<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    
    <script src="ì•„ë°”íƒ€.js"></script>
    <script src="ë ˆë²¨ì—….js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <style>
        :root {
            --bg-color: #222; --text-color: #fff; --primary-color: #FF6B6B; --secondary-color: #4ECDC4;
            --font-main: 'GmarketSans', sans-serif;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; touch-action: none; }
        body { 
            margin: 0; background: var(--bg-color); color: var(--text-color); 
            overflow: hidden; display: flex; flex-direction: column; 
            height: 100%; width: 100%; position: absolute; font-family: var(--font-main); 
        }
        
        /* í—¤ë” */
        #header { 
            flex-shrink: 0; height: 50px; width: 100%; 
            background: rgba(0,0,0,0.9); border-bottom: 1px solid #444; 
            display: flex; align-items: center; justify-content: space-between; 
            padding: 0 10px; z-index: 20; gap: 8px;
        }
        #timer-box { 
            width: 45px; text-align: center; font-size: 1.2em; 
            font-weight: bold; color: #fab1a0; background: #333; 
            border-radius: 8px; padding: 4px 0; border: 1px solid #555;
            flex-shrink: 0;
        }
        #timer-box.danger { color: #ff4757; animation: pulse 0.5s infinite; }
        
        #score-board { 
            flex: 1; display: flex; justify-content: flex-start; align-items: center; 
            overflow: hidden; min-width: 0; 
        }
        .score-pill {
            background: #333; padding: 4px 8px; border-radius: 15px;
            font-size: 0.8em; border: 2px solid #555; 
            display: flex; align-items: center; gap: 5px;
            max-width: 130px; overflow: hidden;
        }
        .score-pill span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
        .score-pill.my-score { border-color: var(--primary-color); background: #442222; }
        .score-pill img { width: 20px; height: 20px; object-fit: cover; border-radius: 50%; flex-shrink: 0; }
        
        #lives-container { 
            font-size: 1.0em; letter-spacing: 1px; 
            flex-shrink: 0; text-align: right; white-space: nowrap;
        }

        /* ê²Œì„ ì˜ì—­ */
        #game-container { 
            flex: 1; width: 100%; height: 100%; 
            display: flex; flex-direction: column; 
            padding: 10px; gap: 10px; 
            justify-content: center; align-items: center; background: #111; 
        }
        /* í˜„ì¬ CSSì—ì„œ ì´ ë¶€ë¶„ì´ ì¤‘ìš”í•©ë‹ˆë‹¤ */
/* [ìˆ˜ì •] ìº”ë²„ìŠ¤ë¥¼ ê°ì‹¸ëŠ” í‹€ */
.canvas-wrapper { 
    position: relative; 
    border: 2px solid #555; 
    border-radius: 8px; 
    overflow: hidden;
    background: #000; /* ê²€ì€ ë°°ê²½ */
    width: 100%; 
    height: 100%;
    display: flex;       
    justify-content: center;
    align-items: center;
}

/* [ìˆ˜ì •] ìº”ë²„ìŠ¤ê°€ í‹€ì„ ê°€ë“ ì±„ìš°ê²Œ í•¨ (ë¹„ìœ¨ì€ JSë¡œ ë§ì¶¤) */
canvas { 
    display: block;
    width: 100%;
    height: 100%;
}

        @media (min-aspect-ratio: 1/1) { #game-container { flex-direction: row; } }

        /* ì˜¤ë²„ë ˆì´ */
        .overlay { 
            position: fixed; inset: 0; background: rgba(0,0,0,0.85); 
            z-index: 100; display: none; 
            flex-direction: column; justify-content: center; align-items: center; 
            backdrop-filter: blur(5px); 
        }
        .overlay.active { display: flex; }

        .modal-content { 
            background: #fff; color: #333; 
            width: 85%; max-width: 380px; border-radius: 20px; 
            border: 4px solid #574141; overflow: hidden; 
        }
        .modal-header { 
            background: var(--primary-color); color: white; padding: 12px; 
            font-size: 1.2em; font-weight: bold; text-align: center; position: relative;
        }
        .modal-body { padding: 15px; text-align: center; position: relative; }
        .modal-footer { 
            padding: 12px; background: #FFFAE0; display: flex; gap: 8px; 
            border-top: 3px solid #F0EAD2; 
        }
        .menu-btn { 
            flex: 1; padding: 12px; border: none; border-radius: 10px; 
            font-weight: bold; cursor: pointer; color: white; 
            font-family: var(--font-main); font-size: 1.0em; 
            border-bottom: 4px solid rgba(0,0,0,0.2); 
        }
        .menu-btn:active { transform: translateY(2px); border-bottom-width: 2px; }
        .btn-primary { background: var(--primary-color); }
        .btn-secondary { background: var(--secondary-color); }

        /* ë§ˆì»¤ (í¼ì„¼íŠ¸ ì¢Œí‘œ ì‚¬ìš©) */
        .mark { 
            position: absolute; 
            width: 8%; padding-bottom: 8%; /* ì›í˜• ìœ ì§€ */
            border: 3px solid #ff0000; 
            border-radius: 50%; 
            transform: translate(-50%, -50%); 
            box-shadow: 0 0 10px #ff0000, inset 0 0 5px #ff0000; 
            pointer-events: none; 
            animation: pop 0.2s; 
            z-index: 10; 
        }
        .wrong-mark { 
            position: absolute; 
            width: 8%; padding-bottom: 8%;
            pointer-events: none; 
            transform: translate(-50%, -50%); 
            animation: fadeOut 0.5s forwards; 
            z-index: 50; 
        }
        .wrong-mark::before, .wrong-mark::after { 
            content: ''; position: absolute; width: 100%; height: 3px; background: #ff4757; top: 50%; left: 0; border-radius: 2px; 
        }
        .wrong-mark::before { transform: rotate(45deg); } 
        .wrong-mark::after { transform: rotate(-45deg); }

        @keyframes pop { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }
        @keyframes fadeOut { from { opacity: 1; transform: translate(-50%, -50%) scale(1); } to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        .spinner { width: 40px; height: 40px; border: 4px solid #fff; border-top-color: var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }

/* [ìˆ˜ì •] ê²°ê³¼ì°½ ë¦¬ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ (ì• ë‹ˆíŒ¡ ìŠ¤íƒ€ì¼) */
        #rematch-status-list { 
            text-align: left; 
            background: #FFF; 
            border: 2px solid #ddd;
            border-radius: 10px; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
            max-height: 150px;
            overflow-y: auto;
        }
        .rematch-row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            font-weight: bold; 
            font-size: 0.95em; 
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .rematch-row:last-child { border-bottom: none; }
        .rematch-row.me { color: var(--primary-color); }
        .ready-status { font-weight: 900; font-size: 0.9em; }
        .ready-status.ready { color: #28a745; }
        .ready-status.waiting { color: #ccc; }        .rematch-row { display: flex; justify-content: space-between; font-weight: bold; font-size: 0.9em; }
        
        #countdown-text { font-size: 5em; font-weight: 900; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.8); }

        /* ì±„íŒ… ìŠ¤íƒ€ì¼ */
        #rematch-chat-messages {
            height: 100px; overflow-y: scroll; background: #FFF; 
            border: 2px solid #F0EAD2; border-radius: 10px; padding: 10px; 
            margin-top: 10px; text-align: left; font-size: 0.85em; line-height: 1.4;
        }
        .chat-msg { margin-bottom: 4px; word-wrap: break-word; }
        .chat-msg strong { color: var(--primary-color); margin-right: 4px; }
        .chat-msg.my-message strong { color: var(--secondary-color); }
        
        #rematch-chat-input-modal { background: rgba(0,0,0,0.5); align-items: flex-end; justify-content: flex-end; }
        #rematch-chat-input-modal .modal-content {
            width: 100%; max-width: 100%; border-radius: 15px 15px 0 0; 
            margin: 0; border: none; box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
            background: #fff; padding: 10px;
        }
        #rematch-tts-btn {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            background: rgba(0,0,0,0.1); color: white; border: 1px solid rgba(255,255,255,0.5);
            border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 0.8em;
            display: flex; align-items: center; justify-content: center;
        }
    </style>
</head>
<body>

    <div id="header">
        <div id="timer-box">60</div>
        <div id="score-board"></div>
        <div id="lives-container">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
    </div>

    <div id="game-container">
        <div class="canvas-wrapper" id="wrap-l"><canvas id="cvs-l"></canvas></div>
        <div class="canvas-wrapper" id="wrap-r"><canvas id="cvs-r"></canvas></div>
    </div>

    <div id="loading-overlay" class="overlay active">
        <div class="spinner"></div>
        <div id="loading-text" style="font-size: 1.1em; color: white; font-weight: bold;">ì ‘ì† ì¤‘...</div>
    </div>

    <div id="info-overlay" class="overlay">
        <div id="countdown-text"></div>
    </div>

    <div id="game-over-overlay" class="overlay">
        <div class="modal-content">
            <div class="modal-header">
                ğŸ† ìµœì¢… ê²°ê³¼ ğŸ†
                <button id="rematch-tts-btn">ğŸ”Š</button>
            </div>
            <div class="modal-body">
                <h2 id="winner-text" style="color: var(--primary-color); margin-bottom: 10px;">ìŠ¹ë¦¬!</h2>
                <div id="rematch-status-list"></div>
                <div id="rematch-chat-messages"></div>
                <button id="rematch-chat-open-btn" class="menu-btn btn-secondary" style="position: absolute; right: 15px; bottom: 15px; width: 45px; height: 45px; border-radius: 50%; padding: 0; font-size: 1.3em; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 10;">ğŸ’¬</button>
            </div>
            <div class="modal-footer">
                <button id="rematch-btn" class="menu-btn btn-primary">ë‹¤ì‹œí•˜ê¸°</button>
                <button id="lobby-btn" class="menu-btn btn-secondary">ëŒ€ê¸°ì‹¤ë¡œ</button>
            </div>
        </div>
    </div>

    <div id="rematch-chat-input-modal" class="overlay">
        <div class="modal-content">
            <div style="display: flex; gap: 8px;">
                <input type="text" id="rematch-chat-input" placeholder="ë©”ì‹œì§€ ì…ë ¥..." style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1em;">
                <button id="rematch-chat-send-btn" class="menu-btn btn-primary" style="width: 60px; flex: none; padding: 0;">ì „ì†¡</button>
            </div>
        </div>
    </div>

    <div id="toast-container" style="position: fixed; top: 70px; left: 50%; transform: translateX(-50%); z-index: 999; width: 80%; text-align: center;"></div>

    <audio id="snd-correct" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ë²„íŠ¼í´ë¦­.mp3"></audio>
    <audio id="snd-wrong" src="./ìºì¹˜ë§ˆì¸ë“œíš¨ê³¼ìŒ/ìºì¹˜ë§ˆì¸ë“œì˜¤ë‹µ.MP3"></audio>
    <audio id="snd-win" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/win.mp3"></audio>
    <audio id="snd-lose" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/íŒ¨ë°°ì‚¬ìš´ë“œ.mp3"></audio>
    <audio id="snd-start" src="https://raw.githubusercontent.com/bangat/game/main/sound/start.mp3"></audio>
    
<script>
    const TOTAL_IMAGE_COUNT = 12; 
    const GAME_TIME = 60;
    const MAX_LIVES = 5;
    
    const firebaseConfig = {
        apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
        authDomain: "goodluck-7c14b.firebaseapp.com",
        databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
        projectId: "goodluck-7c14b",
        storageBucket: "goodluck-7c14b.appspot.com",
        messagingSenderId: "858281658455",
        appId: "1:858281658455:web:9131280a459be983933b12"
    };

    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    let roomRef, playerRef, statusRef;
    let currentUser, myUid, myNick, myAvatar;
    let isHost = false;
    let currentRoomId = null;
    let currentRoomData = null;
    let roomValueListener = null;
    let chatListenerRef = null;
    let isExiting = false;
    let isGameOverProcessed = false; // [ì‹ ê·œ] ê²°ê³¼ì°½ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
    let timerInterval = null;

    let lives = MAX_LIVES;
    let foundCount = 0;
    let isProcessingClick = false;
    let isGameRunning = false;
    let loadedImageNum = -1;
    let imagesLoadedCount = 0;
    let hasReportedWin = false;

    const TTS_ENABLED_KEY = 'gameLobbyTTSOn';
    let isTTSOn = localStorage.getItem(TTS_ENABLED_KEY) !== 'false';
    const synthesis = window.speechSynthesis;

    const cvsL = document.getElementById('cvs-l');
    const ctxL = cvsL.getContext('2d', { willReadFrequently: true });
    const cvsR = document.getElementById('cvs-r');
    const ctxR = cvsR.getContext('2d', { willReadFrequently: true });
    
    let imgL = new Image(); imgL.crossOrigin = "Anonymous";
    let imgR = new Image(); imgR.crossOrigin = "Anonymous";

    // ------------------------------------
    // ì´ˆê¸°í™”
    // ------------------------------------
    document.addEventListener('DOMContentLoaded', () => {
        auth.onAuthStateChanged(user => {
            if (user) {
                currentUser = user; myUid = user.uid;
                myNick = localStorage.getItem('userNickname') || 'Guest';
                myAvatar = localStorage.getItem('userAvatar') || 'ğŸ˜€';
                const params = new URLSearchParams(location.search);
                currentRoomId = params.get('roomId');
                if (currentRoomId) joinGameRoom(currentRoomId);
                else { alert("ë°© ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤."); window.location.href = 'ëŒ€ê¸°ì‹¤.html'; }
            } else { window.location.href = 'index.html'; }
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ëŒ€ì‘
        cvsL.addEventListener('pointerdown', handleCanvasClick);
        cvsR.addEventListener('pointerdown', handleCanvasClick);
        
        document.getElementById('rematch-btn').addEventListener('click', toggleRematchReady);
        document.getElementById('lobby-btn').addEventListener('click', handleExitButton);
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                document.querySelectorAll('.mark, .wrong-mark').forEach(el => el.remove());
            }, 300);
        });
        
        setupResultScreenUI();
    });

    function joinGameRoom(roomId) {
        roomRef = db.ref(`rooms/${roomId}`);
        playerRef = roomRef.child(`players/${myUid}`);
        statusRef = roomRef.child('status');

        playerRef.update({ nickname: myNick, avatar: myAvatar, score: 0, isReady: false });
        playerRef.onDisconnect().remove();

        roomRef.child('hostId').once('value', snap => {
            isHost = (snap.val() === myUid);
            if (isHost) statusRef.onDisconnect().set('finished');
        });

        if (roomValueListener) roomRef.off('value', roomValueListener);
        roomValueListener = roomRef.on('value', snapshot => {
            if (isExiting) return;
            if (!snapshot.exists()) {
                if (currentRoomData && currentRoomData.nextRoomId) {
                    window.location.replace(`í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°.html?roomId=${currentRoomData.nextRoomId}`);
                } else {
                    alert("ë°©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."); window.location.href = 'ëŒ€ê¸°ì‹¤.html'; 
                }
                return;
            }
            currentRoomData = snapshot.val();
            if (currentRoomData.nextRoomId) {
                window.location.replace(`í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°.html?roomId=${currentRoomData.nextRoomId}`);
                return;
            }
            updateUnifiedState();
        });
        setupChatListener();
    }

   function updateUnifiedState() {
    if (!currentRoomData) return;
    
    updateScoreBoardUI(currentRoomData.players || {});

    const playerIds = Object.keys(currentRoomData.players || {}).sort();
    if (playerIds.length > 0 && (!currentRoomData.hostId || !currentRoomData.players[currentRoomData.hostId])) {
        if (playerIds[0] === myUid) {
            isHost = true;
            roomRef.update({ hostId: myUid });
        }
    }

    const status = currentRoomData.status;
    const gData = currentRoomData.gameData || {};

    // [í•µì‹¬ ìˆ˜ì •] finished ìƒíƒœì¼ ë•Œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (status === 'finished') {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        isGameRunning = false;

        document.getElementById('loading-overlay').classList.remove('active');
        document.getElementById('info-overlay').classList.remove('active');
        
        // [ì¤‘ìš”] í”Œë˜ê·¸ë¡œ ì¤‘ë³µ ì‹¤í–‰ ì°¨ë‹¨
        if (!isGameOverProcessed) {
            isGameOverProcessed = true; // í”Œë˜ê·¸ ì„¤ì •
            showGameOver();
        }
        
        return; 
    }

    // [ìˆ˜ì • 2] waiting ìƒíƒœë¡œ ëŒì•„ì˜¬ ë•Œ í”Œë˜ê·¸ ì´ˆê¸°í™”
    if (status === 'waiting') {
        isGameOverProcessed = false; // í”Œë˜ê·¸ ë¦¬ì…‹
        
        document.getElementById('game-over-overlay').classList.remove('active');
        document.getElementById('info-overlay').classList.remove('active');
        
        updateRematchUI();

        if (playerIds.length >= 2) {
            if (currentRoomData.starting && !isGameRunning) {
                document.getElementById('loading-overlay').classList.remove('active');
                startCountdown();
            } else if (!currentRoomData.starting && isHost) {
                 setTimeout(() => roomRef.update({ starting: true }), 1000);
            } else if (!currentRoomData.starting) {
                document.getElementById('loading-text').innerText = "ê²Œì„ ì‹œì‘ ëŒ€ê¸° ì¤‘...";
            }
        } else {
            document.getElementById('loading-overlay').classList.add('active');
            document.getElementById('loading-text').innerText = "í”Œë ˆì´ì–´ ëŒ€ê¸° ì¤‘...";
            isGameRunning = false;
            if (isHost) roomRef.update({ starting: false });
        }
        return;
    } 
    
    // playing ìƒíƒœ ì²˜ë¦¬ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
    if (status === 'playing') {
        document.getElementById('loading-overlay').classList.remove('active');
        
        // [ë²„ê·¸ ìˆ˜ì •] ì´ë¯¸ ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬ê°€ ëë‚œ ìƒíƒœ(í”Œë˜ê·¸ true)ë¼ë©´, 
        // ë’¤ëŠ¦ê²Œ ë“¤ì–´ì˜¨ playing ìƒíƒœ ì—…ë°ì´íŠ¸ê°€ ê²°ê³¼ì°½ì„ ë‹«ì§€ ëª»í•˜ë„ë¡ ë§‰ìŠµë‹ˆë‹¤.
        if (!isGameOverProcessed) {
            document.getElementById('game-over-overlay').classList.remove('active');
        }
        
        const serverImgNum = gData.imageNum;
        if (!serverImgNum) {
            if (isHost && !isGameRunning) initializeRound();
            return;
        }

        if (loadedImageNum !== serverImgNum) {
            foundCount = 0;
            lives = MAX_LIVES;
            updateLivesUI();
            hasReportedWin = false;
            loadGameImage(serverImgNum);
        }

        if (gData.timer !== undefined) {
            const tBox = document.getElementById('timer-box');
            tBox.innerText = gData.timer;
            if (gData.timer <= 10) tBox.classList.add('danger');
            else tBox.classList.remove('danger');
        }

        if (isHost && !timerInterval && imagesLoadedCount === 2 && gData.timer > 0) {
            runHostTimer();
        } else if (isHost && gData.timer === 0) {
            handleRoundEnd();
        }
    }
}


    // ------------------------------------
    // ê²Œì„ ë¡œì§
    // ------------------------------------
    function startCountdown() {
        if (isGameRunning) return;
        isGameRunning = true;
        
        const info = document.getElementById('info-overlay');
        const text = document.getElementById('countdown-text');
        info.classList.add('active');
        
        let count = 3;
        playSound('snd-start');
        text.innerText = count;

        const interval = setInterval(() => {
            count--;
            if (count > 0) {
                text.innerText = count;
                playSound('snd-start');
            } else {
                clearInterval(interval);
                text.innerText = "GO!";
                playSound('snd-start');
                
                if (isHost) setTimeout(initializeRound, 500);
                setTimeout(() => info.classList.remove('active'), 1000);
            }
        }, 1000);
    }

    function initializeRound() {
        const allImages = [];
        for(let i=1; i<=TOTAL_IMAGE_COUNT; i++) allImages.push(i);
        
        for (let i = allImages.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allImages[i], allImages[j]] = [allImages[j], allImages[i]];
        }
        
        const roundImages = allImages.slice(0, 5);
        const updates = {};
        const players = currentRoomData.players;
        Object.keys(players).forEach(uid => { updates[`players/${uid}/roundWins`] = 0; });
        
        updates['gameData'] = { 
            imageNum: roundImages[0], 
            roundOrder: roundImages,    
            currentRoundIdx: 0,
            timer: GAME_TIME            
        };
        updates['status'] = 'playing';
        updates['starting'] = null; 

        roomRef.update(updates);
    }

    // âœ… ë³€ê²½ ì½”ë“œ
function loadGameImage(num) {
    if (loadedImageNum === num && imagesLoadedCount >= 2) return;
    
    loadedImageNum = num;
    imagesLoadedCount = 0;
    
    document.getElementById('loading-overlay').classList.add('active');
    document.getElementById('loading-text').innerText = "ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...";

    // âœ… ì›ë˜ ê²½ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
const pathOrig = `https://bangat.github.io/game/í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°ì´ë¯¸ì§€/${num}.png`;
const pathDiff = `https://bangat.github.io/game/í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°ì´ë¯¸ì§€/${num}-1.png`;

    document.querySelectorAll('.mark, .wrong-mark').forEach(el => el.remove());

    // âœ… ì´ ë¶€ë¶„ì€ ìœ ì§€ (ê²€ì€ í™”ë©´ ë°©ì§€)
    cvsL.width = cvsL.clientWidth;
    cvsL.height = cvsL.clientHeight;
    cvsR.width = cvsR.clientWidth;
    cvsR.height = cvsR.clientHeight;
    ctxL.fillStyle = '#000';
    ctxL.fillRect(0, 0, cvsL.width, cvsL.height);
    ctxR.fillStyle = '#000';
    ctxR.fillRect(0, 0, cvsR.width, cvsR.height);

    imgL = new Image(); imgL.crossOrigin = "Anonymous";
    imgR = new Image(); imgR.crossOrigin = "Anonymous";
let gameLayout = { scale: 1, offsetX: 0, offsetY: 0, drawW: 0, drawH: 0 };
    imgL.onload = onImageLoaded;
    imgR.onload = onImageLoaded;
    
    imgL.onerror = () => { 
        console.error("Image load fail:", pathOrig);
        showToast(`ì´ë¯¸ì§€ ${num}.pngë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`); 
        imagesLoadedCount=2; 
        document.getElementById('loading-overlay').classList.remove('active'); 
    };
    imgR.onerror = () => { 
        console.error("Image load fail:", pathDiff);
        showToast(`ì´ë¯¸ì§€ ${num}-1.pngë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`); 
        imagesLoadedCount=2; 
        document.getElementById('loading-overlay').classList.remove('active'); 
    };

    imgL.src = pathOrig;
    imgR.src = pathDiff;
}

    function onImageLoaded() {
        imagesLoadedCount++;
        if (imagesLoadedCount === 2) {
            resizeCanvas();
            document.getElementById('loading-overlay').classList.remove('active');
            if (isHost && currentRoomData && currentRoomData.status === 'playing') runHostTimer();
        }
    }

    // [ì‹ ê·œ] í™”ë©´ì— ê·¸ë ¤ì§„ ì´ë¯¸ì§€ì˜ ìœ„ì¹˜/í¬ê¸° ì •ë³´ë¥¼ ì €ì¥í•  ì „ì—­ ë³€ìˆ˜
let gameLayout = { scale: 1, offsetX: 0, offsetY: 0, drawW: 0, drawH: 0 };

// [ìˆ˜ì •] ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ í™”ë©´ì— ë§ì¶”ê³ , ì´ë¯¸ì§€ë¥¼ ì¤‘ì•™ì— ê·¸ë¦¬ëŠ” í•¨ìˆ˜
function resizeCanvas() {
    const wrapL = document.getElementById('wrap-l');
    if (!wrapL || !imgL.naturalWidth) return;

    // 1. ìº”ë²„ìŠ¤ í•´ìƒë„ë¥¼ í™”ë©´ í¬ê¸°(wrapper)ì™€ 1:1ë¡œ ë§ì¶¤ (ì¢Œí‘œ ì˜¤ì°¨ ì›ì²œ ì°¨ë‹¨)
    cvsL.width = wrapL.clientWidth;
    cvsL.height = wrapL.clientHeight;
    cvsR.width = wrapL.clientWidth;
    cvsR.height = wrapL.clientHeight;

    // 2. ì´ë¯¸ì§€ë¥¼ í™”ë©´ ì¤‘ì•™ì— 'ë¹„ìœ¨ ìœ ì§€(Contain)'í•˜ë©° ê·¸ë¦´ í¬ê¸° ê³„ì‚°
    const screenW = cvsL.width;
    const screenH = cvsL.height;
    const imgW = imgL.naturalWidth;
    const imgH = imgL.naturalHeight;

    // ê°€ë¡œ/ì„¸ë¡œ ì¤‘ ë” ê½‰ ì°¨ëŠ” ìª½ ê¸°ì¤€ìœ¼ë¡œ ë¹„ìœ¨ ê³„ì‚°
    const scale = Math.min(screenW / imgW, screenH / imgH);
    const drawW = imgW * scale;
    const drawH = imgH * scale;
    
    // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì—¬ë°± ê³„ì‚°
    const offsetX = (screenW - drawW) / 2;
    const offsetY = (screenH - drawH) / 2;

    // 3. ìœ„ì¹˜ ì •ë³´ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (í´ë¦­í•  ë•Œ ì‚¬ìš©)
    gameLayout = { scale, offsetX, offsetY, drawW, drawH };

    // 4. ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ê²€ì€ ì—¬ë°± í¬í•¨ë¨)
    ctxL.clearRect(0, 0, cvsL.width, cvsL.height);
    ctxR.clearRect(0, 0, cvsR.width, cvsR.height);
    
    // í”½ì…€ ì•„íŠ¸ì²˜ëŸ¼ ì„ ëª…í•˜ê²Œ ì²˜ë¦¬ (ì„ íƒì‚¬í•­)
    ctxL.imageSmoothingEnabled = false;
    ctxR.imageSmoothingEnabled = false;

    ctxL.drawImage(imgL, offsetX, offsetY, drawW, drawH);
    ctxR.drawImage(imgR, offsetX, offsetY, drawW, drawH);
}

    function runHostTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            if (currentRoomData.status !== 'playing') {
                clearInterval(timerInterval); timerInterval = null; return;
            }
            roomRef.child('gameData/timer').transaction(current => {
                return (current || 0) > 0 ? current - 1 : 0;
            }, (err, committed, snap) => {
                if (committed && snap.val() === 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    handleRoundEnd();
                }
            });
        }, 1000);
    }

  // [ì‹ ê·œ] í”½ì…€ ë¹„êµë¥¼ ìœ„í•œ ì„ì‹œ ìº”ë²„ìŠ¤ (ì„±ëŠ¥ ìµœì í™”)
const diffCvs = document.createElement('canvas');
const diffCtx = diffCvs.getContext('2d');
diffCvs.width = 1; diffCvs.height = 1;

// [ìˆ˜ì •] í´ë¦­ í•¸ë“¤ëŸ¬
// [ìˆ˜ì •] ìƒ‰ìƒ ë³€ê²½ë„ ì˜ ì¡ëŠ” 'ì£¼ë³€ í”½ì…€ ìŠ¤ìº”' ë°©ì‹ì˜ í´ë¦­ í•¸ë“¤ëŸ¬
function handleCanvasClick(e) {
    if (currentRoomData.status !== 'playing' || lives <= 0 || isProcessingClick || imagesLoadedCount < 2) return;
    e.preventDefault();

    // 1. í™”ë©´ ì¢Œí‘œ ê³„ì‚°
    const rect = e.target.getBoundingClientRect();
    let clientX = e.clientX;
    let clientY = e.clientY;
    if(e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    }
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    // 2. ê²€ì€ ì—¬ë°± í´ë¦­ ë¬´ì‹œ
    const { scale, offsetX, offsetY, drawW, drawH } = gameLayout;
    if (x < offsetX || x > offsetX + drawW || y < offsetY || y > offsetY + drawH) {
        return;
    }

    isProcessingClick = true;

    try {
        // 3. í´ë¦­í•œ ìœ„ì¹˜ë¥¼ ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ë³€í™˜
        const imgCenterX = Math.floor((x - offsetX) / scale);
        const imgCenterY = Math.floor((y - offsetY) / scale);

        // 4. [í•µì‹¬ ìˆ˜ì •] ì£¼ë³€ í”½ì…€ ìŠ¤ìº” (Area Scanning)
        // ë”± 1í”½ì…€ë§Œ ë³´ì§€ ì•Šê³ , í´ë¦­í•œ ê³³ ì£¼ë³€ 10x10 ì˜ì—­ì„ í›‘ì–´ì„œ
        // ë¯¸ì„¸í•œ ìƒ‰ìƒ ë³€í™”ë¼ë„ ìˆìœ¼ë©´ ì •ë‹µìœ¼ë¡œ ì¸ì •í•©ë‹ˆë‹¤.
        
        const scanRange = 5; // ë°˜ê²½ 5px (ì´ 10x10px ì˜ì—­ ê²€ì‚¬)
        const scanW = scanRange * 2;
        const scanH = scanRange * 2;

        // ì™¼ìª½ ì´ë¯¸ì§€ ì˜ì—­ ì¶”ì¶œ
        diffCtx.canvas.width = scanW; // ìº”ë²„ìŠ¤ í¬ê¸° ì„ì‹œ ì¡°ì •
        diffCtx.canvas.height = scanH;
        diffCtx.clearRect(0, 0, scanW, scanH);
        diffCtx.drawImage(imgL, imgCenterX - scanRange, imgCenterY - scanRange, scanW, scanH, 0, 0, scanW, scanH);
        const dataL = diffCtx.getImageData(0, 0, scanW, scanH).data;

        // ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ ì˜ì—­ ì¶”ì¶œ
        diffCtx.clearRect(0, 0, scanW, scanH);
        diffCtx.drawImage(imgR, imgCenterX - scanRange, imgCenterY - scanRange, scanW, scanH, 0, 0, scanW, scanH);
        const dataR = diffCtx.getImageData(0, 0, scanW, scanH).data;

        let isDiffFound = false;
        
        // í”½ì…€ ì „ìˆ˜ ì¡°ì‚¬
        for (let i = 0; i < dataL.length; i += 4) {
            const diff = Math.abs(dataL[i] - dataR[i]) +     // R ì°¨ì´
                         Math.abs(dataL[i+1] - dataR[i+1]) + // G ì°¨ì´
                         Math.abs(dataL[i+2] - dataR[i+2]);  // B ì°¨ì´
            
            // [í•µì‹¬] ë¯¼ê°ë„ ì™„í™” (50 -> 30)
            // 30 ì´ìƒ ì°¨ì´ë‚˜ëŠ” í”½ì…€ì´ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì •ë‹µ!
            if (diff > 30) { 
                isDiffFound = true;
                break; // í•˜ë‚˜ ì°¾ì•˜ìœ¼ë©´ ë£¨í”„ ì¢…ë£Œ
            }
        }

        if (isDiffFound) {
            handleCorrect(x, y);
        } else {
            handleWrong(x, y, e.target.parentNode);
        }

    } catch (err) {
        console.error(err);
    }
    
    // ì„ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ë³µêµ¬ (í˜¹ì‹œ ëª¨ë¥¼ ì‚¬ì´ë“œì´í™íŠ¸ ë°©ì§€)
    diffCtx.canvas.width = 1; 
    diffCtx.canvas.height = 1;
    
    setTimeout(() => isProcessingClick = false, 300);
}

    function handleCorrect(x, y) {
        createMark(x, y, 'wrap-l'); 
        createMark(x, y, 'wrap-r');
        playSound('snd-correct');
        foundCount++;

        if (foundCount >= 5 && !hasReportedWin) {
            hasReportedWin = true;
            foundCount = 999; 
            showToast("ë¼ìš´ë“œ ìŠ¹ë¦¬! ë‹¤ìŒ ë¼ìš´ë“œë¡œ ì´ë™í•©ë‹ˆë‹¤.");
            
            playerRef.child('roundWins').transaction(w => (w || 0) + 1);
            roomRef.child('gameData/timer').transaction(() => 0); 
        }
    }

    // [ìˆ˜ì •] ì˜¤ë‹µ ì²˜ë¦¬ í•¨ìˆ˜ (ì¢Œí‘œ ì˜¤ë¥˜ ìˆ˜ì •ë¨)
function handleWrong(x, y, wrapper) {
    // 1. ì—¬ê¸°ì„œ wrapperëŠ” ì´ë¯¸ 'canvas-wrapper' divì…ë‹ˆë‹¤.
    // ê¸°ì¡´ ì½”ë“œì—ì„œ wrapper.parentNodeë¥¼ í•´ë²„ë ¤ì„œ ì¢Œí‘œê°€ í‹€ì–´ì¡Œë˜ ê²ƒì„ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.
    createWrongMark(x, y, wrapper); 
    
    playSound('snd-wrong');
    lives--;
    updateLivesUI();

    if (lives <= 0) {
        showToast("í•˜íŠ¸ ì†Œì§„! ë‹¤ìŒ ë¼ìš´ë“œë¡œ...");
        foundCount = 999;
        // í•˜íŠ¸ ì†Œì§„ ì‹œ ì¦‰ì‹œ ë‹¤ìŒ ë¼ìš´ë“œë¡œ ë„˜ê¹€
        roomRef.child('gameData/timer').transaction(() => 0);
    }
}

    // [ìˆ˜ì •] 5ë¼ìš´ë“œ ì¢…ë£Œ ì‹œ -1ì´ˆ ë©ˆì¶¤ ì—†ì´ ì¦‰ì‹œ ì¢…ë£Œí•˜ëŠ” í•¨ìˆ˜
// [ìˆ˜ì •] 5ë¼ìš´ë“œ ì¢…ë£Œ ì²˜ë¦¬ ë° ìƒíƒœ ë³€ê²½
    function handleRoundEnd() {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        
        roomRef.child('gameData').transaction(gData => {
            if (!gData) return gData;
            
            const nextIdx = (gData.currentRoundIdx || 0) + 1;
            
            // ë‹¤ìŒ ë¼ìš´ë“œê°€ ë‚¨ì•„ìˆëŠ”ì§€ í™•ì¸
            if (gData.roundOrder && nextIdx < gData.roundOrder.length) {
                // ë‹¤ìŒ ë¼ìš´ë“œ ì§„í–‰
                gData.currentRoundIdx = nextIdx;
                gData.imageNum = gData.roundOrder[nextIdx];
                gData.timer = GAME_TIME;
                return gData;
            } else {
                // [í•µì‹¬] ëª¨ë“  ë¼ìš´ë“œ ì¢…ë£Œ! í”Œë˜ê·¸ ì„¤ì •
                gData.timer = 0; 
                gData.isGameComplete = true; 
                return gData;
            }

        }, (err, committed, snap) => {
            // íŠ¸ëœì­ì…˜ ì„±ê³µ í›„, ì¢…ë£Œ í”Œë˜ê·¸ê°€ í™•ì¸ë˜ë©´ ë°© ìƒíƒœë¥¼ 'finished'ë¡œ ë³€ê²½
            if (committed && snap.val() && snap.val().isGameComplete) {
                roomRef.update({ status: 'finished' });
            }
        });
    }

// [ìˆ˜ì •] ì •ë‹µ ë§ˆì»¤ (í™”ë©´ ì¢Œí‘œ px ê·¸ëŒ€ë¡œ ì‚¬ìš©)
function createMark(x, y, wrapId) {
    const wrap = document.getElementById(wrapId);
    const el = document.createElement('div');
    el.className = 'mark';
    // % ëŒ€ì‹  pxë¡œ ì •í™•í•˜ê²Œ ì°ìŒ
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    // ë§ˆì»¤ í¬ê¸° ê³ ì • (í™”ë©´ í¬ê¸°ì— ë”°ë¼ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šê²Œ)
    el.style.width = '40px';
    el.style.paddingBottom = '40px'; 
    wrap.appendChild(el);
}

    // [ìˆ˜ì •] ì˜¤ë‹µ ë§ˆì»¤
function createWrongMark(x, y, wrap) {
    const el = document.createElement('div');
    el.className = 'wrong-mark';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.width = '30px';
    el.style.paddingBottom = '30px';
    wrap.appendChild(el);
    setTimeout(() => el.remove(), 500);
}

    function updateScoreBoardUI(players) {
        const board = document.getElementById('score-board');
        board.innerHTML = '';
        const sorted = Object.keys(players).sort((a,b) => players[b].score - players[a].score);
        sorted.forEach(uid => {
            const p = players[uid];
            const div = document.createElement('div');
            div.className = `score-pill ${uid === myUid ? 'my-score' : ''}`;
            
            let avatarHtml = '';
            if (typeof AVATAR_SETS !== 'undefined' && AVATAR_SETS[p.avatar]) {
                avatarHtml = `<img src="${AVATAR_SETS[p.avatar].front}">`;
            } else if (p.avatar && (p.avatar.startsWith('http') || p.avatar.includes('/') || p.avatar.includes('.') || p.avatar.startsWith('data:'))) {
                avatarHtml = `<img src="${p.avatar}" onerror="this.style.display='none'">`;
            } else {
                avatarHtml = `<span style="font-size:1.0em;">${p.avatar || 'ğŸ˜€'}</span>`;
            }
            div.innerHTML = `${avatarHtml} <span>${p.nickname}: ${p.roundWins || 0}ìŠ¹</span>`;
            board.appendChild(div);
        });
    }

    function updateLivesUI() {
        const container = document.getElementById('lives-container');
        if (window.innerWidth < 360) container.innerText = `â¤ï¸x${lives}`;
        else {
            let str = ''; for(let i=0; i<lives; i++) str += 'â¤ï¸';
            container.innerText = str;
        }
    }

    function showToast(msg) {
        const t = document.createElement('div');
        t.style.background = 'rgba(0,0,0,0.8)'; t.style.color = 'white';
        t.style.padding = '8px 16px'; t.style.borderRadius = '20px';
        t.innerText = msg; t.style.marginTop = '5px'; t.style.display='inline-block';
        document.getElementById('toast-container').appendChild(t);
        setTimeout(() => t.remove(), 2000);
    }

    function playSound(id) {
        const audio = document.getElementById(id);
        if (audio) { audio.currentTime = 0; audio.play().catch(()=>{}); }
    }

    function showGameOver() {
        const modal = document.getElementById('game-over-overlay');
        
        // [í•µì‹¬] ì´ë¯¸ ëª¨ë‹¬ì´ ë– ìˆë‹¤ë©´, ì¤€ë¹„ ìƒíƒœ(ë¦¬ìŠ¤íŠ¸)ë§Œ ê°±ì‹ í•˜ê³  ë¦¬í„´
        // ì´ë ‡ê²Œ í•´ì•¼ ê¹œë¹¡ì„(í´ë˜ìŠ¤ ì œê±°/ì¶”ê°€ ë°˜ë³µ)ì„ ë§‰ì„ ìˆ˜ ìˆìŒ
        if (modal.classList.contains('active')) {
            updateRematchUI();
            return; 
        }
        
        // --- ìµœì´ˆ 1íšŒ ì‹¤í–‰ ë¡œì§ ---
        isGameRunning = false;
        modal.classList.add('active'); // ëª¨ë‹¬ ë„ìš°ê¸°
        
        const players = currentRoomData.players || {};
        // ìŠ¹ìˆ˜(roundWins) ê¸°ì¤€ ì •ë ¬
        const sorted = Object.entries(players).sort(([,a], [,b]) => (b.roundWins || 0) - (a.roundWins || 0));
        
        // 1ë“± ì°¾ê¸° (ë™ì ì ì²˜ë¦¬ í¬í•¨: ìŠ¹ìˆ˜ê°€ ê°™ìœ¼ë©´ ê³µë™ 1ë“±)
        const maxWins = sorted.length > 0 ? (sorted[0][1].roundWins || 0) : 0;
        const myData = players[myUid];
        const myWins = myData ? (myData.roundWins || 0) : 0;
        
        const winnerText = document.getElementById('winner-text');
        
        // ë‚´ê°€ ìµœê³  ìŠ¹ìˆ˜ì™€ ê°™ë‹¤ë©´ ìŠ¹ë¦¬ (ê³µë™ ìš°ìŠ¹ í¬í•¨)
        if (myWins === maxWins && maxWins > 0) {
        winnerText.innerText = "ğŸ† ìŠ¹ë¦¬! ì¶•í•˜í•©ë‹ˆë‹¤!";
        winnerText.style.color = "var(--primary-color)";
        playSound('snd-win');
        // [ì•ˆì „ì¥ì¹˜] ë ˆë²¨ì—… í•¨ìˆ˜ ì˜¤ë¥˜ê°€ ìˆì–´ë„ ëª¨ë‹¬ì€ ëœ¨ë„ë¡ try-catch ì ìš©
        try { applyExpAndPoints(db, myUid, 100, 50); } catch(e) { console.error(e); }
    } else {
        const myRank = sorted.findIndex(([uid]) => uid === myUid) + 1;
        winnerText.innerText = `${myRank}ìœ„... ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!`;
        winnerText.style.color = "#555";
        playSound('snd-lose');
        // [ì•ˆì „ì¥ì¹˜] ë ˆë²¨ì—… í•¨ìˆ˜ ì˜¤ë¥˜ê°€ ìˆì–´ë„ ëª¨ë‹¬ì€ ëœ¨ë„ë¡ try-catch ì ìš©
        try { applyExpAndPoints(db, myUid, 30, 10); } catch(e) { console.error(e); }
    }
        
        updateRematchUI();
        setupResultScreenUI(); 
    }

   function updateRematchUI() {
        const list = document.getElementById('rematch-status-list');
        if (!list) return; // ì•ˆì „ì¥ì¹˜
        
        list.innerHTML = '';
        
        if (!currentRoomData || !currentRoomData.players) return; // ë°ì´í„° ì—†ìŒ ë°©ì§€

        const players = currentRoomData.players;
        const requests = currentRoomData.rematchRequests || {};
        
        const sorted = Object.entries(players).sort(([,a], [,b]) => (b.roundWins || 0) - (a.roundWins || 0));

        // ë¦¬ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        sorted.forEach(([uid, p], idx) => {
            const isReady = !!requests[uid];
            const div = document.createElement('div');
            div.className = `rematch-row ${uid === myUid ? 'me' : ''}`;
            
            div.innerHTML = `
                <div>${idx+1}ìœ„. ${escapeHTML(p.nickname)} <span style="font-size:0.8em; color:#666;">(${p.roundWins || 0}ìŠ¹)</span></div>
                <div class="ready-status ${isReady ? 'ready' : 'waiting'}">
                    ${isReady ? 'ì¤€ë¹„ì™„ë£Œ' : 'ëŒ€ê¸°ì¤‘...'}
                </div>
            `;
            list.appendChild(div);
        });

        // ë‚´ ë²„íŠ¼ ìƒíƒœ
        const btn = document.getElementById('rematch-btn');
        if (requests[myUid]) {
            btn.innerText = "ì¤€ë¹„ ì·¨ì†Œ"; 
            btn.classList.remove('btn-primary'); 
            btn.classList.add('btn-secondary');
        } else {
            btn.innerText = "ë‹¤ì‹œ í•˜ê¸°"; 
            btn.classList.add('btn-primary'); 
            btn.classList.remove('btn-secondary');
        }

        // [í˜¸ìŠ¤íŠ¸] ì „ì› ì¤€ë¹„ ì‹œ ìë™ ì‹œì‘
        if (isHost) {
            const playerIds = Object.keys(players);
            const totalPlayers = playerIds.length;
            const readyCount = playerIds.filter(uid => requests[uid]).length;

            if (totalPlayers >= 2 && readyCount === totalPlayers) {
                setTimeout(() => {
                    const updates = {};
                    updates['status'] = 'playing';
                    updates['rematchRequests'] = null;
                    
                    const allImages = [];
                    for(let i=1; i<=TOTAL_IMAGE_COUNT; i++) allImages.push(i);
                    for (let i = allImages.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allImages[i], allImages[j]] = [allImages[j], allImages[i]];
                    }
                    const roundImages = allImages.slice(0, 5);
                    
                    playerIds.forEach(uid => { updates[`players/${uid}/roundWins`] = 0; });

                    updates['gameData'] = { 
                        imageNum: roundImages[0], 
                        roundOrder: roundImages,    
                        currentRoundIdx: 0,
                        timer: GAME_TIME            
                    };
                    
                    roomRef.update(updates);
                }, 1000);
            }
        }
    }

    function toggleRematchReady() {
        const isReady = currentRoomData.rematchRequests && currentRoomData.rematchRequests[myUid];
        if (isReady) {
            roomRef.child(`rematchRequests/${myUid}`).remove();
        } else {
            roomRef.child(`rematchRequests/${myUid}`).set(true);
        }
        // ë²„íŠ¼ í´ë¦­ íš¨ê³¼ìŒ
        playSound('snd-correct'); 
    }

    async function handleExitButton() {
        isExiting = true;
        cleanupListeners();
        if (isHost) {
            const newRoomRef = db.ref('rooms').push();
            const newRoomId = newRoomRef.key;
            const newRoomData = {
                roomName: `${myNick}ì˜ ë°©`, hostId: myUid, gameType: 'í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°', status: 'waiting',
                players: { [myUid]: { nickname: myNick, avatar: myAvatar, isHost: true } }
            };
            try {
                await newRoomRef.set(newRoomData);
                await roomRef.update({ nextRoomId: newRoomId, status: 'finished' });
                await roomRef.remove(); 
                window.location.replace(`í‹€ë¦°ê·¸ë¦¼ì°¾ê¸°.html?roomId=${newRoomId}`);
            } catch(e) { location.href = 'ëŒ€ê¸°ì‹¤.html'; }
        } else {
            if(roomRef) await roomRef.child(`players/${myUid}`).remove();
            location.href = 'ëŒ€ê¸°ì‹¤.html';
        }
    }

    function cleanupListeners() {
        if (roomValueListener && roomRef) { roomRef.off('value', roomValueListener); roomValueListener = null; }
        if (chatListenerRef) { chatListenerRef.off(); chatListenerRef = null; }
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    }

    function setupChatListener() {
        if (chatListenerRef) chatListenerRef.off();
        chatListenerRef = roomRef.child('chat');
        chatListenerRef.on('child_added', snap => {
            const val = snap.val();
            if (!val) return;
            renderChatMessage(val);
            if (isTTSOn && val.sender !== myNick && synthesis) {
                const ut = new SpeechSynthesisUtterance(val.msg);
                ut.lang = 'ko-KR'; synthesis.speak(ut);
            }
        });
    }

    function renderChatMessage(data) {
        const container = document.getElementById('rematch-chat-messages');
        if (!container) return;
        const div = document.createElement('div');
        div.className = `chat-msg ${data.sender === myNick ? 'my-message' : ''}`;
        div.innerHTML = `<strong>${data.sender}:</strong> ${data.msg}`;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function setupResultScreenUI() {
        const openBtn = document.getElementById('rematch-chat-open-btn');
        if(openBtn) {
             openBtn.onclick = () => {
                document.getElementById('rematch-chat-input-modal').classList.add('active');
                document.getElementById('rematch-chat-input').focus();
            };
        }
        
        const modal = document.getElementById('rematch-chat-input-modal');
        if(modal) {
            modal.onclick = (e) => {
                if(e.target === modal) modal.classList.remove('active');
            };
        }

        const sendBtn = document.getElementById('rematch-chat-send-btn');
        if(sendBtn) sendBtn.onclick = sendChatMessageModal;
        
        const ttsBtn = document.getElementById('rematch-tts-btn');
        if(ttsBtn) {
            ttsBtn.innerText = isTTSOn ? 'ğŸ”Š' : 'ğŸ”‡';
            ttsBtn.onclick = () => {
                isTTSOn = !isTTSOn;
                localStorage.setItem(TTS_ENABLED_KEY, isTTSOn);
                ttsBtn.innerText = isTTSOn ? 'ğŸ”Š' : 'ğŸ”‡';
                if(!isTTSOn) synthesis.cancel();
            };
        }
    }

    function sendChatMessageModal() {
        const input = document.getElementById('rematch-chat-input');
        const msg = input.value.trim();
        if (msg) {
            roomRef.child('chat').push({ sender: myNick, msg: msg });
            input.value = '';
            document.getElementById('rematch-chat-input-modal').classList.remove('active');
        }
    }

    // ------------------------------------
    // [í…ŒìŠ¤íŠ¸ìš©] ì¹˜íŠ¸í‚¤ ì„¤ì •
    // ------------------------------------
    document.addEventListener('keydown', (e) => {
        // ê²Œì„ ì§„í–‰ ì¤‘ì¼ ë•Œ 'e' ë˜ëŠ” 'E' í‚¤ë¥¼ ëˆ„ë¥´ë©´
        if ((e.key === 'e' || e.key === 'E') && isGameRunning) {
            console.log("ğŸ›‘ [TEST] Eí‚¤ ê°ì§€: ê°•ì œ ê²Œì„ ì¢…ë£Œ ì‹¤í–‰");
            
            // Firebase ìƒíƒœë¥¼ 'finished'ë¡œ ê°•ì œ ë³€ê²½
            // -> updateUnifiedStateê°€ ê°ì§€ -> showGameOver ì‹¤í–‰ -> ëª¨ë‹¬ í‘œì‹œ
            if (roomRef) {
                roomRef.update({ status: 'finished' });
            }
        }
    });
</script>
</body>
</html>