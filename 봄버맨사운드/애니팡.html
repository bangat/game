<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ì• ë‹ˆíŒ¡</title> 
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    
    <script src="ë ˆë²¨ì—….js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f438.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f425.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f9a7.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f437.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f43b-200d-2744-fe0f.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f308.svg"> <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f4a3.svg"> 
    <link rel="preload" as="image" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f9ca.svg">
    <style>
        /* ------------------------- */
        /* == 1. ì•± ê³µí†µ í…Œë§ˆ == */
        /* ------------------------- */
        :root {
            --bg-color: #FFFBEB;
            --primary-color: #FF6B6B;
            --secondary-color: #4ECDC4;
            --accent-color: #FFD93D;
            --text-color-dark: #574141;
            --text-color-light: #ffffff;
            --danger-color: #F76363;
            --panel-bg: #FFFFFF;
            --panel-border: #F0EAD2;
            --panel-shadow: #E4DCCF;
            --font-main: 'GmarketSans', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color-dark);
            display: flex; flex-direction: column;
            /* [ìˆ˜ì •] ë ˆì´ì•„ì›ƒ ì¤‘ì•™ ì •ë ¬ */
            justify-content: flex-start; /* [ìˆ˜ì •] center -> flex-start (ìƒë‹¨ ì •ë ¬) */
            align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
            /* [ìˆ˜ì •] bodyì˜ íŒ¨ë”©ì„ #game-wrapperë¡œ ì´ë™ */
            /* padding: 10px; */ 
        }

        /* ------------------------- */
        /* == 2. [ìˆ˜ì •] ê²Œì„ ë ˆì´ì•„ì›ƒ (í†µí•© í”„ë ˆì„) == */
        /* ------------------------- */
        #game-wrapper { 
            width: 100%; 
            /* height: 100%; [ì œê±°] */
            flex-grow: 1; /* [í•µì‹¬ ìˆ˜ì •] bodyì˜ ë‚¨ì€ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ (ì‚¬ì²œì„± ë°©ì‹) */
            min-height: 0; /* [ì¶”ê°€] flex-growê°€ 100% ë†’ì´ì˜ ë¶€ëª¨ì—ì„œ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ê¸° ìœ„í•œ ìµœì†Œ ë†’ì´ */
            
            display: flex; flex-direction: column; 
            justify-content: flex-start; /* [ìœ ì§€] ìƒë‹¨ ì •ë ¬ */
            align-items: center; /* [ìœ ì§€] ìˆ˜í‰ ì¤‘ì•™ ì •ë ¬ */
            
            /* [ìˆ˜ì •] bodyì˜ paddingì„ wrapperë¡œ ì´ë™ ë° safe-areaì™€ ê²°í•© */
            padding-top: calc(10px + env(safe-area-inset-top));
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            padding-left: 10px;
            padding-right: 10px;
            
            position: relative; 
        }

        /* [ì‹ ê·œ] ëª¨ë“  ê²ƒì„ ê°ì‹¸ëŠ” ë‹¨ì¼ í”„ë ˆì„ */
        #game-area-frame {
            display: flex;
            flex-direction: column;
            background: var(--panel-bg);
            /* [ìˆ˜ì •] ë³´ë”ì™€ ì‰ë„ìš°ë¥¼ ì´ í”„ë ˆì„ìœ¼ë¡œ ì´ë™ */
            border: 4px solid var(--panel-border); 
            box-shadow: 6px 6px 0px 0px var(--panel-shadow);
            border-radius: 20px;
            width: 100%;
            max-width: 430px;
            /* [ìˆ˜ì •] height: 100% ëŒ€ì‹  flex-grow: 1 ì‚¬ìš© (ì‚¬ì²œì„±ê³¼ ë™ì¼ ë°©ì‹) */
            flex-grow: 1; /* [í•µì‹¬ ìˆ˜ì •] */
            /* height: 100%; (ì œê±°) */
            /* max-height: 800px; (ì œê±°) */
            padding: 10px;
            overflow: hidden; /* ë‚´ë¶€ ìš”ì†Œê°€ ë‘¥ê·¼ ëª¨ì„œë¦¬ë¥¼ ë„˜ì§€ ì•Šë„ë¡ */
            
            /* [ì¶”ê°€] flex-growê°€ 100% ë†’ì´ì˜ ë¶€ëª¨ì—ì„œ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ê¸° ìœ„í•œ ìµœì†Œ ë†’ì´ */
            min-height: 0; 
        }
        
        /* [ì‹ ê·œ] í”„ë ˆì„ ë‚´ë¶€ì˜ ìƒˆ í—¤ë” (ìŠ¤ì½”ì–´ë³´ë“œìš©) */
        #game-stats-header {
            flex-shrink: 0;
            padding-bottom: 8px;
            border-bottom: 3px solid var(--panel-border);
        }

        /* [ìˆ˜ì •] ìŠ¤ì½”ì–´ë³´ë“œ (ê°„ê²©/í°íŠ¸ ì¡°ì ˆ) */
        #multiplayer-scoreboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px; /* [ìˆ˜ì •] ê°„ê²© ì¶•ì†Œ */
            width: 100%;
        }

        /* [ìˆ˜ì •] ìŠ¤íƒ¯ ë°•ìŠ¤ (ì»´íŒ©íŠ¸í•˜ê²Œ) */
        .stat-box {
            background-color: #fff;
            border: 2px solid var(--panel-border);
            border-radius: 10px;
            padding: 2px 5px; /* [ìˆ˜ì •] íŒ¨ë”© ì¶•ì†Œ */
            text-align: center;
            font-weight: 900;
            transition: all 0.2s ease;
            overflow: hidden;
        }
        .stat-box.my-score {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            transform: scale(1.02); /* [ìˆ˜ì •] ìŠ¤ì¼€ì¼ ì‚´ì§ ì¤„ì„ */
        }
        .stat-box .label {
            font-size: 0.7em; /* [ìˆ˜ì •] í°íŠ¸ ì¶•ì†Œ */
            color: #9A6A3A;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 4px;
        }
        .stat-box .value {
            font-size: 1.2em; /* [ìˆ˜ì •] í°íŠ¸ ì¶•ì†Œ */
            color: var(--primary-color);
        }

        /* [ì‹ ê·œ] í”„ë ˆì„ ë‚´ë¶€ì˜ ìƒˆ í‘¸í„° (íƒ€ì´ë¨¸/ê²Œì´ì§€ìš©) */
        #game-stats-footer {
            flex-shrink: 0;
            display: flex;
            gap: 10px;
            align-items: center;
            padding-top: 8px;
            border-top: 3px solid var(--panel-border);
        }

        /* [ìˆ˜ì •] íƒ€ì´ë¨¸ (í•˜ë‹¨ìœ¼ë¡œ ì´ë™, ì»´íŒ©íŠ¸í•˜ê²Œ) */
        #timer-container {
            flex-shrink: 0; /* í¬ê¸° ê³ ì • */
            width: 100px; /* [ìˆ˜ì •] ë„ˆë¹„ ê³ ì • */
            text-align: center;
            font-weight: 900;
            background-color: #fff;
            border: 2px solid var(--panel-border);
            border-radius: 10px;
            padding: 2px 5px; /* [ìˆ˜ì •] íŒ¨ë”© ì¶•ì†Œ */
            margin: 0; /* [ìˆ˜ì •] ìë™ ë§ˆì§„ ì œê±° */
        }
        #timer-container .label { font-size: 0.8em; color: #9A6A3A; } /* [ìˆ˜ì •] í°íŠ¸ ì¶•ì†Œ */
        #timer-container .value {
            font-size: 1.6em; /* [ìˆ˜ì •] í°íŠ¸ ì¶•ì†Œ */
            color: var(--primary-color);
            transition: color 0.3s ease;
        }
        #timer-container .value.danger-time {
            color: var(--danger-color);
            animation: throb 1.2s infinite ease-in-out;
        }
        @keyframes throb {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* [ìˆ˜ì •] í”¼ë²„ ê²Œì´ì§€ (í•˜ë‹¨ìœ¼ë¡œ ì´ë™, flex-grow) */
        #fever-gauge-container {
            flex-grow: 1; /* [ìˆ˜ì •] ë‚¨ì€ ê³µê°„ ëª¨ë‘ ì°¨ì§€ */
            width: auto; /* [ìˆ˜ì •] ìë™ ë„ˆë¹„ */
            max-width: none; /* [ìˆ˜ì •] ìµœëŒ€ ë„ˆë¹„ ì œê±° */
            height: 22px;
            background-color: #fff;
            border: 2px solid var(--panel-border);
            border-radius: 20px;
            margin: 0; /* [ìˆ˜ì •] ìë™ ë§ˆì§„ ì œê±° */
            position: relative;
            overflow: hidden;
            box-shadow: inset 2px 2px 4px rgba(87, 65, 65, 0.1);
        }
        #fever-gauge-fill {
            height: 100%;
            width: 0%; 
            background: linear-gradient(90deg, var(--secondary-color), var(--primary-color));
            border-radius: 20px;
            transition: width 0.3s ease-out;
        }
        #fever-gauge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
            font-weight: 900;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        /* [ìˆ˜ì •] ê²Œì„ ì»¨í…Œì´ë„ˆ (í”„ë ˆì„ ë‚´ë¶€ë¡œ ì´ë™) */
        #game-container {
            width: 100%; 
            flex-grow: 1; /* [ìˆ˜ì •] í•µì‹¬: ë‚¨ì€ ìˆ˜ì§ ê³µê°„ ëª¨ë‘ ì°¨ì§€ */
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; 
            padding: 5px 0; /* [ìˆ˜ì •] ë³´ë“œ ìƒí•˜ ì—¬ë°± 10px -> 5pxë¡œ ì¶•ì†Œ */
        }
        
        /* [ìˆ˜ì •] ê²Œì„ ë³´ë“œ (ì‹œê°ì  ìš”ì†Œ ì œê±°) */
        #game-board {
    position: relative; 
    background-color: #FFFEF5;
    border: 2px solid var(--panel-border);
    border-radius: 12px;
    display: grid; 
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 2px;
    padding: 4px;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}

        /* ------------------------- */
        /* == 3. íƒ€ì¼ ìŠ¤íƒ€ì¼ (ìœ ì§€) == */
        /* ------------------------- */
        .tile {
    background-color: #FFFEF5; 
    border-radius: 10px; 
    display: flex; 
    justify-content: center; 
    align-items: center;
    cursor: pointer;
    border: 1px solid var(--panel-border);
    box-shadow: inset 2px 2px 4px rgba(87, 65, 65, 0.15), 
                inset -2px -2px 4px rgba(255, 255, 255, 0.7);
    text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), 
                opacity 0.2s ease,
                box-shadow 0.2s ease;
    flex-shrink: 0;
    
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
}

.tile:active {
    box-shadow: inset 1px 1px 2px rgba(87, 65, 65, 0.2), 
                inset -1px -1px 2px rgba(255, 255, 255, 0.7);
    transform: scale(0.95) translateZ(0); /* [ìˆ˜ì •] translateZ ìœ ì§€ */
}

.tile.pop { animation: pop 0.2s ease-out forwards; }
@keyframes pop {
    0% { transform: scale(1) translateZ(0); opacity: 1; }
    50% { transform: scale(1.3) translateZ(0); opacity: 0.5; }
    100% { transform: scale(0.1) translateZ(0); opacity: 0; }
}

.tile.fall {
    /* [í•µì‹¬ ìˆ˜ì •] 
       1. ì‹œê°„: 0.3ì´ˆ -> 0.5ì´ˆ (ë” ê¸¸ê²Œ)
       2. ê³¡ì„ : 'EaseOutBack' (ëª©í‘œ ì§€ì ì„ ì‚´ì§ ì§€ë‚˜ì³¤ë‹¤ê°€ íŠ•ê²¨ ëŒì•„ì˜¤ëŠ” ë°”ìš´ìŠ¤ íš¨ê³¼)
    */
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
}

.tile.new-tile-anim { animation: new-tile 0.2s ease-out; }
@keyframes new-tile {
    from { transform: scale(0.5) translateZ(0); opacity: 0; }
    to { transform: scale(1) translateZ(0); opacity: 1; }
}

.tile.swap { 
    transition: transform 0.2s ease-in-out; 
    z-index: 10; 
}
.tile.invalid { animation: shake 0.4s ease-in-out; }
@keyframes shake {
    0%, 100% { transform: translateX(0) translateZ(0); }
    25% { transform: translateX(-5px) translateZ(0); }
    50% { transform: translateX(5px) translateZ(0); }
    75% { transform: translateX(-5px) translateZ(0); }
}

        /* ------------------------- */
        /* == 4. ëª¨ë‹¬ (ìœ ì§€) == */
        /* ------------------------- */
        .overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            display: none; 
            flex-direction: column; justify-content: center; align-items: center; 
            z-index: 200; text-align: center; 
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        .overlay.active { display: flex; }

        .modal-content { 
            background: var(--panel-bg); 
            color: var(--text-color-dark); 
            padding: 0; 
            border-radius: 24px;
            width: 90%; max-width: 400px; 
            box-shadow: 8px 8px 0px 0px var(--text-color-dark);
            overflow: hidden; 
            border: 4px solid var(--text-color-dark);
        }
        .modal-header { 
            background-color: var(--primary-color);
            color: white; 
            padding: 15px; 
            border-bottom: 4px solid #C04A4A; 
        }
        .modal-header h2 { font-size: 1.6em; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); }
        .modal-body { padding: 25px; }
        .modal-footer {
            display: flex; gap: 10px;
            padding: 20px;
            border-top: 3px solid var(--panel-border);
            background-color: #FFFAE0;
        }

        .spinner { border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #countdown-number { font-size: 7em; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.7); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #final-score {
            font-size: 2.0em;
            font-weight: 900;
            color: var(--primary-color);
            margin-bottom: 0px;
        }
        #final-ranking-list {
            text-align: left;
            margin-bottom: 15px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        /* ------------------------- */
        /* == 5. ì•„ì¼€ì´ë“œ ë²„íŠ¼ (ìœ ì§€) == */
        /* ------------------------- */
        .menu-btn { 
            width: 100%; padding: 15px; font-size: 1.1em; font-weight: 900; 
            font-family: var(--font-main);
            border-radius: 16px; border: none; cursor: pointer; 
            transition: all 0.1s ease-out;
            border-bottom: 5px solid;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
            margin: 5px 0; 
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        .menu-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        .menu-btn.primary { 
            background-color: var(--primary-color);
            color: white; 
            border-bottom-color: #C04A4A;
        }
        .menu-btn.secondary { 
            background-color: var(--secondary-color);
            color: white; 
            border-bottom-color: #379A93;
        }
        
        /* ------------------------- */
        /* == 6. ì½¤ë³´ í…ìŠ¤íŠ¸/ì ìˆ˜ (ìœ ì§€) == */
        /* ------------------------- */
        .combo-text {
            position: absolute;
            font-size: 2.5em;
            font-weight: 900;
            color: rgb(243, 41, 41);
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 100;
            pointer-events: none;
            animation: combo-pop 0.8s ease-out forwards;
        }
        
        .combo-score {
            position: absolute;
            font-size: 1.8em;
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            z-index: 101;
            pointer-events: none;
            animation: combo-pop 0.8s ease-out forwards;
        }

        @keyframes combo-pop {
            0% { transform: scale(0.8); opacity: 1; }
            20% { transform: scale(1.3); }
            40% { transform: scale(1); }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* ------------------------- */
        /* == 7. í”¼ë²„ ê²Œì´ì§€ UI (ìˆ˜ì •ë¨) == */
        /* ------------------------- */
        /* #fever-gauge-container ìŠ¤íƒ€ì¼ì€ 2ë²ˆ ì„¹ì…˜ìœ¼ë¡œ ì´ë™/í†µí•©ë¨ */
        
        /* í”¼ë²„ ëª¨ë“œ í™œì„±í™” ì‹œ UI */
        /* [ìˆ˜ì •] ê²Œì„ ë³´ë“œ (ê²©ìíŒ)ì˜ í…Œë‘ë¦¬ íš¨ê³¼ ê°•í™” */
        #game-board.fever-active {
            animation: fever-pulse 0.7s infinite alternate;
        }
        @keyframes fever-pulse {
            from { 
                box-shadow: 0 0 10px rgba(200, 200, 200, 0.5); 
                border-color: var(--panel-border); 
            }
            to { 
                /* [ìˆ˜ì •] ê·¸ë¦¼ìë¥¼ ë” í¬ê³  ë¶‰ê²Œ, í…Œë‘ë¦¬ë„ ì„ ëª…í•˜ê²Œ */
                box-shadow: 0 0 30px 10px rgba(255, 107, 107, 0.7); 
                border-color: #FF0000; 
            }
        }

        /* [ì‹ ê·œ] ê²Œì„ í”„ë ˆì„ (í°ìƒ‰ íŒ¨ë„)ì˜ ë°°ê²½ ê¹œë¹¡ì„ íš¨ê³¼ */
        #game-area-frame.fever-active {
            animation: fever-frame-pulse 0.7s infinite alternate;
        }
        @keyframes fever-frame-pulse {
            from { 
                background-color: var(--panel-bg); /* ê¸°ë³¸ í°ìƒ‰ */
            }
            to { 
                background-color: #FFF6F6; /* ë¶‰ì€ ê¸°ìš´ì´ ë„ëŠ” ë°°ê²½ìƒ‰ */
                border-color: var(--primary-color);
            }
        }

        @keyframes laser-beam {
    0% {
        height: 0;
        width: 2px; /* ì–‡ê²Œ ì‹œì‘ */
        opacity: 0;
        box-shadow: 0 0 5px 2px #FFD700;
    }
    30% {
        height: 200%; /* ìµœëŒ€ ê¸¸ì´ ë„ë‹¬ */
        width: 8px; /* ìµœëŒ€ ë‘ê»˜ */
        opacity: 1;
        box-shadow: 0 0 20px 10px #FFD700; /* ìµœëŒ€ ê´‘ì› */
    }
    80% {
        height: 200%;
        width: 4px; /* ê°€ëŠ˜ì–´ì§ */
        opacity: 1;
        box-shadow: 0 0 10px 5px #FFD700;
    }
    100% {
        height: 200%;
        width: 2px;
        opacity: 0; /* ì‚¬ë¼ì§ */
        box-shadow: 0 0 5px 2px #FFD700;
    }
}

@keyframes center-burst {
    0% { 
        transform: translate(-50%, -50%) scale(0); 
        opacity: 1; 
    }
    50% { 
        transform: translate(-50%, -50%) scale(3); 
        opacity: 0.8; 
    }
    100% { 
        transform: translate(-50%, -50%) scale(5); 
        opacity: 0; 
    }
}

/* ê¸°ì¡´ @keyframes center-burst ë‹¤ìŒì— ì¶”ê°€ */

@keyframes rainbow-burst {
    0% { 
        transform: translate(-50%, -50%) scale(0) rotate(0deg); 
        opacity: 1; 
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.5) rotate(180deg); 
        opacity: 0.8; 
    }
    100% { 
        transform: translate(-50%, -50%) scale(0) rotate(360deg); 
        opacity: 0; 
    }
}
/* [ì‹ ê·œ] ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œ í”„ë¡¬í”„íŠ¸ */
        #audio-unlock-prompt {
            position: absolute;
            top: 60%; /* ìˆ«ì(3)ë³´ë‹¤ ì•„ë˜ì— ìœ„ì¹˜ */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em; /* í°íŠ¸ í¬ê¸° */
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            /* ëŠë¦° ì ë©¸ ì• ë‹ˆë©”ì´ì…˜ */
            animation: slow-blink 2.2s infinite ease-in-out;
            pointer-events: none; /* í…ìŠ¤íŠ¸ê°€ í„°ì¹˜ë¥¼ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
        }

        /* [ì‹ ê·œ] ëŠë¦° ì ë©¸ @keyframes */
        @keyframes slow-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; } /* 0.3ê¹Œì§€ íë ¤ì§ */
        }


/* [ìˆ˜ì •] 'ë‹¤ì‹œí•˜ê¸°' ìƒíƒœ ëª©ë¡ ìŠ¤íƒ€ì¼ (ìˆœìœ„/ì ìˆ˜ í†µí•©) */
        #rematch-status-list {
            text-align: left;
            margin-top: 10px;
            padding: 10px;
            background-color: #FFFAE0;
            border-radius: 10px;
            border: 2px solid var(--panel-border);
            font-size: 1.0em; /* í°íŠ¸ í¬ê¸° ì‚´ì§ ì¡°ì • */
            line-height: 1.8;
            display: flex;
            flex-direction: column;
            gap: 8px; /* ì¤„ ê°„ê²© */
        }
        .rematch-player-row {
            display: flex;
            justify-content: space-between; /* ì–‘ìª½ ì •ë ¬ */
            align-items: center;
        }
        .rematch-player-row .player-info {
            /* [ìˆ˜ì •] flex ì œê±°, ë‹‰ë„¤ì„/ì ìˆ˜ ì¤„ë°”ê¿ˆì„ ìœ„í•´ ê¸°ë³¸ê°’(block) ì‚¬ìš© */
            font-weight: 900;
        }
        .rematch-player-row .player-info-topline { /* [ì‹ ê·œ] 1ë²ˆì§¸ ì¤„ (ë“±ìˆ˜ + ë‹‰ë„¤ì„) */
            display: flex;
            align-items: baseline; /* í…ìŠ¤íŠ¸ ë² ì´ìŠ¤ë¼ì¸ ì •ë ¬ */
            gap: 8px;
        }
        .rematch-player-row .player-rank {
            color: var(--primary-color);
            min-width: 25px; /* '1ìœ„' '2ìœ„' ìë¦¬ ë§ì¶¤ */
        }
        .rematch-player-row .player-name {
            color: var(--text-color-dark);
        }
        /* [ì‹ ê·œ] ë‚´ ë‹‰ë„¤ì„ë§Œ ê°•ì¡° */
        .rematch-player-row.my-row .player-name { 
            color: var(--primary-color);
            text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
        }
        .rematch-player-row .player-score {
            font-size: 0.9em;
            color: #9A6A3A;
            /* [ìˆ˜ì •] ë“±ìˆ˜(25px) + ê°­(8px) = 33px ë“¤ì—¬ì“°ê¸° */
            padding-left: 33px; 
        }
        /* [ì œê±°] .rematch-player-row .player-you ìŠ¤íƒ€ì¼ ì œê±° */

        #rematch-status-list .status-text {
            font-weight: 900;
            color: #ccc; /* ê¸°ë³¸ 'ëŒ€ê¸°' ìƒ‰ìƒ (ì•ˆë³´ì´ê²Œ) */
            transition: all 0.3s ease;
            font-size: 1.1em;
            min-width: 50px; /* 'Ready' ê³µê°„ í™•ë³´ */
            text-align: right;
        }
        #rematch-status-list .status-text.ready {
            color: #28a745; /* 'Ready' ì´ˆë¡ìƒ‰ */
            text-shadow: 0 0 5px rgba(40, 167, 69, 0.5);
        }

        /* [ì‹ ê·œ] íŒíŠ¸ ë°˜ì§ì„ íš¨ê³¼ */
        .tile.hint {
            animation: hint-sparkle 1.2s infinite ease-in-out;
        }
        @keyframes hint-sparkle {
            0%, 100% { 
                transform: scale(1);
                border-color: var(--panel-border); /* [ìˆ˜ì •] ê¸°ë³¸ í…Œë‘ë¦¬ ìƒ‰ìƒ */
                border-width: 1px; /* [ìˆ˜ì •] ê¸°ë³¸ ë‘ê»˜ */
                box-shadow: inset 2px 2px 4px rgba(87, 65, 65, 0.15), 
                            inset -2px -2px 4px rgba(255, 255, 255, 0.7);
            }
            50% { 
                transform: scale(1.05);
                border-color: #007BFF; /* [ìˆ˜ì •] ì„ ëª…í•œ íŒŒë€ìƒ‰ í…Œë‘ë¦¬ */
                border-width: 3px; /* [ìˆ˜ì •] 3pxë¡œ ë‘ê»ê²Œ */
                box-shadow: inset 2px 2px 4px rgba(87, 65, 65, 0.15), 
                            inset -2px -2px 4px rgba(255, 255, 255, 0.7),
                            0 0 15px 5px #00BFFF; /* [ìˆ˜ì •] íŒŒë€ìƒ‰ ê¸€ë¡œìš° (DeepSkyBlue) */
            }
        }
/* [ì‹ ê·œ] í”¼ë²„ ëª¨ë“œ ì‹œ ê²Œì„ ë³´ë“œ ë’·ë°°ê²½ (ì—¬ë°±) ìƒ‰ìƒ ë³€ê²½ */
        #game-container.fever-active {
            background-color: #FF6B6B; /* Primary color */
            animation: fever-bg-pulse 0.7s infinite alternate;
            border-radius: 10px; /* [ì¶”ê°€] ë³´ë“œì™€ ì—¬ë°± ì‚¬ì´ì˜ ëª¨ì„œë¦¬ë¥¼ ë¶€ë“œëŸ½ê²Œ */
        }
        @keyframes fever-bg-pulse {
            from { background-color: var(--accent-color); } /* ë…¸ë€ìƒ‰ */
            to { background-color: var(--primary-color); } /* ë¶‰ì€ìƒ‰ */
        }

        /* [ì‹ ê·œ] ìŠ¤í¬ë¦° ì‰ì´í¬ íš¨ê³¼ */
        @keyframes screen-shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-3px); }
            40%, 80% { transform: translateX(3px); }
        }
        .shake-effect {
            animation: screen-shake 0.3s ease-in-out;
        }

        /* [ì‹ ê·œ] Twemoji CDNì„ ì‚¬ìš©í•´ í…ìŠ¤íŠ¸ ì´ëª¨ì§€ ëŒ€ì‹  ì´ë¯¸ì§€ ë°°ê²½ ì„¤ì • */
        .tile {
            /* í…ìŠ¤íŠ¸(ğŸ¸)ëŠ” ìˆ¨ê¸°ê³ , ì´ë¯¸ì§€ë§Œ ë³´ì´ê²Œ í•©ë‹ˆë‹¤ */
            font-size: 0; /* [ì¤‘ìš”] í…ìŠ¤íŠ¸ ìˆ¨ê¸°ê¸° */
            background-size: 85%; /* ì´ëª¨ì§€ì™€ ë¹„ìŠ·í•œ í¬ê¸° */
            background-repeat: no-repeat;
            background-position: center;
        }
        
        /* 5ë§ˆë¦¬ ë™ë¬¼ (Twemoji CDN) */
        .tile.frog { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f438.svg'); }
        .tile.chick { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f425.svg'); }
        .tile.monkey { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f9a7.svg'); }
        .tile.pig { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f437.svg'); }
        .tile.bear { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f43b-200d-2744-fe0f.svg'); }

        /* íŠ¹ìˆ˜ íƒ€ì¼ (í­íƒ„, ë ˆì¸ë³´ìš°) - (Twemoji CDN) */
        .tile.rainbow { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f308.svg'); }
        .tile.bomb { background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f4a3.svg'); }
.tile.junk { 
            background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f9ca.svg'); /* ğŸ§Š ì–¼ìŒ */
            background-color: #E0F7FA; /* ì—°í•œ í•˜ëŠ˜ìƒ‰ ë°°ê²½ */
            border: 2px solid #4DD0E1; /* ì²­ë¡ìƒ‰ í…Œë‘ë¦¬ */
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.7), 
                        inset -2px -2px 5px rgba(0, 0, 0, 0.1);
        }
        .tile.star { 
    background-image: url('https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f31f.svg'); 
    background-color: #FFF8E1; /* [ì‹ ê·œ] ì—°í•œ ë…¸ë€ìƒ‰ ë°°ê²½ ì¶”ê°€ */
    border: 3px solid var(--danger-color); /* [ì‹ ê·œ] 3px ë‘ê»˜ì˜ ë¹¨ê°„ìƒ‰ í…Œë‘ë¦¬ */
}
@keyframes mega-rainbow {
    0% { 
        transform: translate(-50%, -50%) scale(0); 
        opacity: 0; 
    }
    20% { 
        transform: translate(-50%, -50%) scale(1.5); 
        opacity: 1; 
    }
    80% { 
        transform: translate(-50%, -50%) scale(1.5); 
        opacity: 1; 
    }
    100% { 
        transform: translate(-50%, -50%) scale(3); 
        opacity: 0; 
    }
}

/* [ì‹ ê·œ] â­ï¸ ë³„ íŒ¡ì´ 3x3 ì¶©ê²©íŒŒ ì• ë‹ˆë©”ì´ì…˜ */
@keyframes shockwave-burst {
    0% { 
        transform: translate(-50%, -50%) scale(0); 
        opacity: 1; 
        box-shadow: 0 0 10px 10px rgba(255, 215, 0, 0.7); /* ê¸ˆìƒ‰(ë³„) ê·¸ë¦¼ì */
        border: 4px solid rgba(255, 215, 0, 1);
    }
    70% { 
        opacity: 0.5; 
    }
    100% { 
        transform: translate(-50%, -50%) scale(2.5); /* 3x3 ëŠë‚Œìœ¼ë¡œ í¬ê²Œ í¼ì§ */
        opacity: 0; 
        box-shadow: 0 0 30px 20px rgba(255, 215, 0, 0);
        border: 2px solid rgba(255, 215, 0, 0.5);
    }

    
}
/* --- [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ ë§ˆì´í¬ ë²„íŠ¼ --- */
        #rematch-mic-btn {
            position: absolute;
            right: 10px; /* ì˜¤ë¥¸ìª½ ëì—ì„œ 10px */
            top: 50%;
            transform: translateY(-50%);
            
            font-size: 1.4em; /* ì»´íŒ©íŠ¸í•œ í¬ê¸° */
            background-color: rgba(0,0,0,0.1); /* í—¤ë”ë³´ë‹¤ ì‚´ì§ ì–´ë‘¡ê²Œ */
            color: white;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            padding: 0;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
        }
        #rematch-mic-btn:active {
            background-color: rgba(0,0,0,0.3);
            transform: translateY(-50%) scale(0.9);
        }
        #rematch-mic-btn.recording {
            background-color: rgba(255, 255, 255, 0.9); /* ë°ì€ í°ìƒ‰ */
            color: var(--primary-color);
            animation: pulse-red-simple 1.5s infinite;
        }
        @keyframes pulse-red-simple {
            0% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.05); }
            100% { transform: translateY(-50%) scale(1); }
        }

        /* [ì‹ ê·œ] í† ìŠ¤íŠ¸ ì•Œë¦¼ (ê²Œì„ë°©.html ìŠ¤íƒ€ì¼) */
        #toast-container {
            position: fixed;
            top: 20px; /* ìƒë‹¨ì—ì„œ 20px ì•„ë˜ */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none; /* í´ë¦­ ë°©ì§€ */
        }
        .toast-notification {
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            animation: toast-fade-in 0.5s forwards, toast-fade-out 0.5s 2.5s forwards;
            white-space: nowrap; /* ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }
        @keyframes toast-fade-in {
            from { opacity: 0; transform: translateY(-20px); } /* ìœ„ì—ì„œ ì•„ë˜ë¡œ */
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toast-fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }

        /* [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ ì±„íŒ…ì°½ ë§í’ì„  ìŠ¤íƒ€ì¼ */
#rematch-chat-messages .chat-msg {
    margin-bottom: 5px;
    word-wrap: break-word;
}
#rematch-chat-messages .chat-msg strong {
    color: var(--primary-color);
    margin-right: 5px;
}
#rematch-chat-messages .chat-msg.my-message strong {
    color: var(--secondary-color);
}
#rematch-chat-messages .system-message {
    font-style: italic;
    color: #888;
    text-align: center;
    font-size: 0.9em;
    margin: 5px 0;
}
/* [ì‹ ê·œ] STT ë…¹ìŒ ì¤‘ ë²„íŠ¼ íš¨ê³¼ */
#rematch-chat-stt-btn.recording {
    background-color: var(--primary-color);
    color: white;
    animation: pulse-red-simple 1.5s infinite;
}
@keyframes pulse-red-simple {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

    </style>
</head>
<body>
    <div id="game-wrapper">

        <div id="game-area-frame">

            <div id="game-stats-header">
                <div id="multiplayer-scoreboard">
                    <div class="stat-box"><div class="label">í”Œë ˆì´ì–´ 1</div><div class="value">0</div></div>
                    <div class="stat-box"><div class="label">í”Œë ˆì´ì–´ 2</div><div class="value">0</div></div>
                    <div class="stat-box"><div class="label">í”Œë ˆì´ì–´ 3</div><div class="value">0</div></div>
                    <div class="stat-box"><div class="label">í”Œë ˆì´ì–´ 4</div><div class="value">0</div></div>
                </div>
            </div>

            <div id="game-container">
                <div id="combo-score-display" style="position: absolute; top: 10px; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 101;"></div>
                <div id="game-board">
                    </div>
            </div>

            <div id="game-stats-footer">
                <div id="fever-gauge-container">
                    <div id="fever-gauge-fill"></div>
                    <span id="fever-gauge-text">BOOM</span>
                </div>
                <div id="timer-container">
                    <div class="label">ì‹œê°„</div>
                    <div class="value" id="timer-value">60</div>
                </div>
            </div>

        </div> </div> <div id="loading-overlay" class="overlay active">
        <div class="spinner"></div>
        <p style="color: white; font-size: 1.2em;">ë°©ì— ì ‘ì† ì¤‘ì…ë‹ˆë‹¤...</p>
    </div>

    <div id="info-overlay" class="overlay"> <div id="countdown-number">3</div>
    </div>

   <div id="game-over-overlay" class="overlay">
     <div class="modal-content">
         <div class="modal-header" style="display: flex; align-items: center; justify-content: center; position: relative;">
             <h2 style="flex-grow: 1; margin: 0; padding-left: 30px;">ğŸ†ìµœì¢… ìˆœìœ„ğŸ†</h2>
             <button id="rematch-tts-btn" class="rematch-mic">ğŸ”Š</button>
         </div>
         <div class="modal-body" style="position: relative;">
            <div id="rematch-status-list">
                </div>
            
            <div id="rematch-chat-messages" style="height: 100px; overflow-y: scroll; background: #FFFAE0; border: 2px solid var(--panel-border); border-radius: 10px; padding: 10px; margin-top: 5px; text-align: left; font-size: 0.9em; line-height: 1.5;">
                </div>
            
            <button id="rematch-chat-open-btn" class="menu-btn secondary" style="position: absolute; right: 15px; bottom: 15px; width: 50px; height: 50px; border-radius: 50%; padding: 0; font-size: 1.5em; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">ğŸ’¬</button>

         </div>
         <div class="modal-footer">
             <button id="rematch-btn" class="menu-btn primary">ë‹¤ì‹œí•˜ê¸°</button>
             <button id="lobby-btn" class="menu-btn secondary">ëŒ€ê¸°ì‹¤ë¡œ</button>
         </div>
     </div>
</div>


    <div id="vfx-flash-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 199;"></div>
<div id="toast-container"></div>
    
    <audio id="countdown-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/321go.mp3" preload="auto"></audio>
    
    <audio id="match-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì• ë‹ˆíŒ¡ì½¤ë³´.mp3" preload="auto"></audio>
    <audio id="gameover-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/íŒ¨ë°°ì‚¬ìš´ë“œ.mp3" preload="auto"></audio>
    <audio id="victory-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ìŠ¹ë¦¬.mp3" preload="auto"></audio>
    <audio id="bgm-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì• ë‹ˆíŒ¡ë°°ê²½ìŒì•….mp3" preload="auto" loop volume="0.3"></audio>
    <audio id="rainbow-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ë¬´ì§€ê°œíš¨ê³¼ìŒ.mp3" preload="auto"></audio>
<audio id="bomb-create-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/íŒ¡ì´ìƒì„±.mp3" preload="auto"></audio>
    <audio id="bomb-explode-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/í­íƒ„íš¨ê³¼ìŒ.mp3" preload="auto"></audio>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // [ì‹ ê·œ] iOS í•€ì¹˜ ì¤Œ(Pinch-zoom) ë°©ì§€
            document.addEventListener('touchmove', function(event) {
                if (event.touches.length > 1) {
                    // ë‘ ì†ê°€ë½ ì´ìƒì´ í™”ë©´ì— ë‹¿ìœ¼ë©´ (í•€ì¹˜ ì¤Œ ì‹œë„)
                    event.preventDefault(); // ê¸°ë³¸ ë™ì‘(ì¤Œ)ì„ ë§‰ìŠµë‹ˆë‹¤.
                }
            }, { passive: false }); // preventDefault()ë¥¼ í—ˆìš©í•˜ê¸° ìœ„í•´ passive: false ì„¤ì •


            // [ì‹ ê·œ] ê³µìš© í† ìŠ¤íŠ¸ ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜
            function showToast(message) {
                const toastContainer = document.getElementById('toast-container');
                if (!toastContainer) return;

                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                
                toastContainer.appendChild(toast);

                // 3ì´ˆ í›„ DOMì—ì„œ ì œê±°
                setTimeout(() => {
                    toast.remove();
                }, 3000);
            }

            // [ì‹ ê·œ] HTML íƒˆì¶œ(escape) í•¨ìˆ˜
            function escapeHTML(str) {
                if (typeof str !== 'string') return '';
                const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
                return str.replace(/[&<>"']/g, m => map[m]);
            }

            // [ì‹ ê·œ] iOS í•€ì¹˜ ì¤Œ(Pinch-zoom) ë°©ì§€
            document.addEventListener('touchmove', function(event) {
                if (event.touches.length > 1) {
                    // ë‘ ì†ê°€ë½ ì´ìƒì´ í™”ë©´ì— ë‹¿ìœ¼ë©´ (í•€ì¹˜ ì¤Œ ì‹œë„)
                    event.preventDefault(); // ê¸°ë³¸ ë™ì‘(ì¤Œ)ì„ ë§‰ìŠµë‹ˆë‹¤.
                }
            }, { passive: false }); // preventDefault()ë¥¼ í—ˆìš©í•˜ê¸° ìœ„í•´ passive: false ì„¤ì •
            // ------------------------------------
            // 1. DOM ìš”ì†Œ ë° ê¸°ë³¸ ì„¤ì •
            // ------------------------------------

            const gameBoard = document.getElementById('game-board');
            const timerValue = document.getElementById('timer-value');
            const infoOverlay = document.getElementById('info-overlay');
            const countdownNumber = document.getElementById('countdown-number');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const finalScoreEl = document.getElementById('final-score');
            const restartBtn = document.getElementById('restart-btn');
            const gameContainer = document.getElementById('game-container'); 
            const loadingOverlay = document.getElementById('loading-overlay');
            const multiplayerScoreboard = document.getElementById('multiplayer-scoreboard');
            const finalRankingList = document.getElementById('final-ranking-list');
            const timerDisplay = document.getElementById('timer-container').querySelector('.value');
            const gameWrapper = document.getElementById('game-wrapper'); 
            const gameAreaFrameEl = document.getElementById('game-area-frame'); // [ì‹ ê·œ] ì „ì²´ í”„ë ˆì„ ì°¸ì¡°
            const comboScoreDisplay = document.getElementById('combo-score-display'); 
         // DOMContentLoaded ìµœìƒë‹¨ì— ì¶”ê°€
const rematchChatInputModal = document.getElementById('rematch-chat-input-modal');
const rematchChatInput = document.getElementById('rematch-chat-input');
const rematchChatSendBtn = document.getElementById('rematch-chat-send-btn');
const rematchChatSttBtn = document.getElementById('rematch-chat-stt-btn');
const rematchChatOpenBtn = document.getElementById('rematch-chat-open-btn'); // ğŸ‘ˆ ì´ë ‡ê²Œ ë³€ê²½
const rematchChatMessages = document.getElementById('rematch-chat-messages');

            // [ì• ë‹ˆíŒ¡.html] ìœ„ ì½”ë“œë¥¼ ì•„ë˜ ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš”
            const sounds = {
                swap: document.getElementById('swap-sound'),
                match: document.getElementById('match-sound'),
                gameOver: document.getElementById('gameover-sound'),
                victory: document.getElementById('victory-sound'),
                bgm: document.getElementById('bgm-sound'), // [ì‹ ê·œ] ë°°ê²½ìŒì•…
                rainbow: document.getElementById('rainbow-sound'), // [ì‹ ê·œ] ë ˆì¸ë³´ìš° íš¨ê³¼ìŒ
                countdown: document.getElementById('countdown-sound') // [ì‹ ê·œ] 321GO
            };

            // [ìˆ˜ì •] íƒ€ì¼ ìˆ˜ (8x6 = 48ê°œ)
            const ROWS = 8;
            const COLS = 6;
            // [ìˆ˜ì •] ì´ëª¨ì§€ -> ì´ë¯¸ì§€ ì´ë¦„ (ì˜ì–´)
            const TILE_EMOJIS = ['frog', 'chick', 'monkey', 'pig', 'bear']; 
            const JUNK_TILE = 'junk'; // [ğŸ§± ë°©í•´ íƒ€ì¼]
            const MULTI_MATCH_BONUS = 2000; // [ğŸ§  ë©€í‹°-ë§¤ì¹˜ ë³´ë„ˆìŠ¤]
            const GAME_TIME = 60; // [ìˆ˜ì •] 5ì´ˆ -> 60ì´ˆ (ì›ë˜ëŒ€ë¡œ)
const PERFECT_PLAY_BONUS = 500; // [ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ë³´ë„ˆìŠ¤]
            const PERFECT_PLAY_COUNT = 10; // [ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ë‹¬ì„± íšŸìˆ˜]

            // [ì‹ ê·œ] 5-Match ì‹­ìê°€ í­ë°œìš© ë³€ìˆ˜
const CROSS_EXPLOSION_BONUS = 500; // ì‹­ìê°€ í­ë°œ ë³´ë„ˆìŠ¤ ì ìˆ˜
const RAINBOW_TILE = 'ğŸŒˆ'; // ë ˆì¸ë³´ìš° íƒ€ì¼ ì´ëª¨ì§€
const RAINBOW_BONUS = 2000; // ë ˆì¸ë³´ìš° í­ë°œ ë³´ë„ˆìŠ¤ ì ìˆ˜

            let board = []; 
            let tileElements = []; 
            let score = 0;
            let timer = GAME_TIME;
            let timerId = null;
            let isProcessing = true;
            let currentCombo = 0;
let hintTimerId = null; // [ì‹ ê·œ] íŒíŠ¸ íƒ€ì´ë¨¸
            let dragStartTile = null;
            let comboTimerId = null; // [ì‹ ê·œ] ì½¤ë³´ ìœ ì§€ íƒ€ì´ë¨¸
            let perfectPlayCount = 0; // [ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ì¹´ìš´í„°]
            let dragStartX = 0;
            let dragStartY = 0;
            // --- âœ¨ [ì‹ ê·œ] í”¼ë²„ ì‹œìŠ¤í…œ ë³€ìˆ˜ ---
            let feverGauge = 0;
            let isCascading = false; // [ì‹ ê·œ] ì—°ì‡„ ì½¤ë³´ ì²˜ë¦¬ ì ê¸ˆ í”Œë˜ê·¸
            const MAX_FEVER_GAUGE = 100; // (ê²Œì´ì§€ ìµœëŒ€ì¹˜, 100ìœ¼ë¡œ ì„¤ì •)
            let isFeverMode = false;
            const FEVER_DURATION = 7000; // [ìˆ˜ì •] 7ì´ˆ
            let feverTimerId = null;
            // --- í”¼ë²„ ì‹œìŠ¤í…œ ë ---

            // [ì‹ ê·œ] iOS ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œìš© ë³€ìˆ˜
            let isAudioUnlocked = false;
            let didGameStart = false; // [ìˆ˜ì •] 'GO!'ê°€ ì§€ë‚¬ëŠ”ì§€ ì²´í¬í•˜ëŠ” í”Œë˜ê·¸

            // [ìˆ˜ì •] iOS ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œìš© í•¨ìˆ˜ (BGM ì¬ìƒ ë¡œì§ ì¶”ê°€)
            function unlockAudioOnFirstTap() {
                if (isAudioUnlocked) return; // í•œ ë²ˆë§Œ ì‹¤í–‰
                isAudioUnlocked = true;
                console.log("iOS ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œ ì‹œë„...");

                let allSounds = document.querySelectorAll('audio');
                let bgmSound = sounds['bgm'];
                
                // 1. ëª¨ë“  'íš¨ê³¼ìŒ' í™œì„±í™” (play/pause íŠ¸ë¦­)
                allSounds.forEach((sound) => {
                    // BGMì€ ì•„ë˜ì—ì„œ ë”°ë¡œ ì²˜ë¦¬
                    if (sound.id === 'bgm-sound') return; 
                    
                    sound.play().then(() => {
                        sound.pause();
                        sound.currentTime = 0;
                    }).catch(e => {});
                });

                // 2. [í•µì‹¬] BGM í™œì„±í™” ë° ì¬ìƒ
                if (bgmSound && bgmSound.paused) {
                    // ë§Œì•½ 'GO!'ê°€ ì§€ë‚œ í›„(didGameStart=true)ì— ì²« íƒ­ì´ ë°œìƒí–ˆë‹¤ë©´,
                    // (ì¦‰, BGM ì¬ìƒì„ ë†“ì³¤ë‹¤ë©´) ì—¬ê¸°ì„œ BGMì„ ê°•ì œë¡œ ì¬ìƒ
                    if (didGameStart) {
                        console.log("ê²Œì„ì´ ì´ë¯¸ ì‹œì‘ë¨. BGM ê°•ì œ ì¬ìƒ.");
                        bgmSound.play().catch(e => {});
                    } else {
                        // 'GO!'ê°€ ì§€ë‚˜ê¸° ì „(ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘)ì— íƒ­í–ˆë‹¤ë©´, 
                        // BGMì„ 'ì¤€ë¹„'ë§Œ ì‹œí‚´ (play/pause íŠ¸ë¦­)
                        bgmSound.play().then(() => {
                            bgmSound.pause();
                            bgmSound.currentTime = 0;
                        }).catch(e => {});
                    }
                }
                
                console.log("ì˜¤ë””ì˜¤ í™œì„±í™” ì™„ë£Œ.");
            }

            // ------------------------------------
            // 2. Firebase (ë©€í‹°í”Œë ˆì´)
            // ------------------------------------
            
            let db, auth;
            let currentRoomId = null;
            let currentUser = null;
            let playerUid = null;
            let playerRef = null;
            let roomRef = null;
            let rematchPlayerList = null; // [### ì‹ ê·œ ###] ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ ì „ìš© í”Œë ˆì´ì–´ ëª©ë¡
            let allPlayersRef = null;
            let statusRef = null; // [ì‹ ê·œ] status ë¦¬ìŠ¤ë„ˆ ì „ìš© ì°¸ì¡°
            let isHost = false; 
            let hostStatusDisconnectRef = null; // [ì‹ ê·œ] í˜¸ìŠ¤íŠ¸ ì „ìš© onDisconnect í•¸ë“¤ëŸ¬

            // [ìˆ˜ì •] 'ì‚¬ì²œì„±' ë°©ì‹ì˜ ë‹¨ì¼ ë¦¬ìŠ¤ë„ˆë¥¼ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
                      let currentRoomData = null; // ë£¸ ì „ì²´ ë°ì´í„°
            let isExiting = false; // ê°•ì œ ì¢…ë£Œ í”Œë˜ê·¸
            let gameOverFlag = false; // ê²Œì„ì˜¤ë²„ ì¤‘ë³µ ë°©ì§€
            let countdownStarted = false; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ë³µ ë°©ì§€
            let roomValueListener = null; // [ì‹ ê·œ] ë£¸ ë¦¬ìŠ¤ë„ˆ ì°¸ì¡°
            let rematchListener = null; // [ì‹ ê·œ] ë¦¬ë§¤ì¹˜ ë¦¬ìŠ¤ë„ˆ ì°¸ì¡°

            // --- [ì‹ ê·œ] STT/TTS (ê²Œì„ë°©.htmlê³¼ ë™ì¼) ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = SpeechRecognition ? new SpeechRecognition() : null;
            const synthesis = window.speechSynthesis;
            const TTS_VOICE_KEY = 'gameLobbyVoiceURI'; // (ê²Œì„ë°©ê³¼ ë™ì¼í•œ í‚¤ ì‚¬ìš©)
            const TTS_ENABLED_KEY = 'gameLobbyTTSOn'; // (ê²Œì„ë°©ê³¼ ë™ì¼í•œ í‚¤ ì‚¬ìš©)
            // 'false'ì¼ ë•Œë§Œ êº¼ì§€ê³ , null(ìµœì´ˆ)ì´ê±°ë‚˜ 'true'ë©´ ì¼œì§ (ê¸°ë³¸ê°’: ON)
            let isTTSOn = localStorage.getItem(TTS_ENABLED_KEY) !== 'false';
            let voiceList = []; // ìŒì„± ëª©ë¡ ìºì‹œ
            let chatListenerRef = null; // [ì‹ ê·œ] ì±„íŒ… ë¦¬ìŠ¤ë„ˆ ì°¸ì¡°
            // --- [ì‹ ê·œ] STT/TTS ë ---

            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.appspot.com",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.database();
                auth = firebase.auth();
            } catch (e) {
                loadingOverlay.innerHTML = "<p style='color: white;'>Firebase ì—°ê²° ì‹¤íŒ¨!</p>";
                return;
            }

            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    playerUid = user.uid;
                    setupGlobalNotificationListeners(playerUid); // [ì‹ ê·œ] ì „ì—­ ì•Œë¦¼(ì´ˆëŒ€/ìª½ì§€) ë¦¬ìŠ¤ë„ˆ ì‹œì‘
                    const urlParams = new URLSearchParams(window.location.search);
                    const roomId = urlParams.get('roomId');
                    
                   if (roomId) {
                        // [ìˆ˜ì •] "rooms" ê²½ë¡œ ì‚¬ìš©
                        roomRef = db.ref('rooms').child(roomId); 
                        roomRef.child('hostId').once('value', (snapshot) => {
                            isHost = (snapshot.val() === playerUid);
                            console.log("ë°©ì¥ ì—¬ë¶€:", isHost);
                            joinGameRoom(roomId);
                        });
                    } else {
                        loadingOverlay.innerHTML = "<p style='color: white;'>ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤. (ë°© ID ì—†ìŒ)</p>";
                    }
                } else {
                    window.location.href = 'index.html';
                }
            });

            // [ìˆ˜ì •] "ê²ŒìŠ¤íŠ¸ ë©ˆì¶¤" ë²„ê·¸ í•´ê²°ì„ ìœ„í•œ ë¦¬ìŠ¤ë„ˆ ë¶„ë¦¬
            function joinGameRoom(roomId) {
                currentRoomId = roomId;
                allPlayersRef = roomRef.child('players');
                playerRef = allPlayersRef.child(playerUid);
                statusRef = roomRef.child('status'); // [ì‹ ê·œ] status ë¦¬ìŠ¤ë„ˆ ë¶„ë¦¬

                // [ë²„ê·¸ ìˆ˜ì •] .set()ì€ ì•„ë°”íƒ€/ë‹‰ë„¤ì„ì„ ë®ì–´ì“°ë¯€ë¡œ .update() ì‚¬ìš©
                // ë˜í•œ, ë°© ìƒíƒœê°€ 'playing'ì´ ì•„ë‹ ë•Œë§Œ ì´ˆê¸°í™”í•˜ì—¬,
                // ê²Œì„ ì¢…ë£Œ í›„ ì¬ì ‘ì† ì‹œ isFinishedê°€ ë®ì–´ì¨ì§€ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.
                roomRef.child('status').once('value', (statusSnapshot) => {
                    if (statusSnapshot.val() !== 'playing') {
                        playerRef.update({
                            score: 0,
                            isFinished: false
                        });
                        console.log("í”Œë ˆì´ì–´ ìƒíƒœ 'waiting'ìœ¼ë¡œ ì´ˆê¸°í™” ì™„ë£Œ.");
                    } else {
                        console.log("ê²Œì„ì´ ì´ë¯¸ 'playing' ìƒíƒœì´ë¯€ë¡œ, ì ìˆ˜/ìƒíƒœë¥¼ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                    }
                });
                
                playerRef.onDisconnect().remove();
                // [ë²„ê·¸ ìˆ˜ì •] í˜¸ìŠ¤íŠ¸ê°€ ê²Œì„ ì¤‘ ë‚˜ê°€ë©´, ë°© ìƒíƒœë¥¼ 'finished'ë¡œ ê°•ì œ ë³€ê²½
                if (isHost) {
                    hostStatusDisconnectRef = statusRef.onDisconnect();
                    hostStatusDisconnectRef.set('finished');
                    console.log("í˜¸ìŠ¤íŠ¸ onDisconnect í•¸ë“¤ëŸ¬ ì„¤ì •: ë¹„ì •ìƒ ì¢…ë£Œ ì‹œ statusë¥¼ 'finished'ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.");
                }

                             // ê¸°ì¡´ ìœ„ì¹˜ (joinGameRoom í•¨ìˆ˜ ë‚´ë¶€, playerRef.onDisconnect() ë‹¤ìŒ)

// [í•µì‹¬ ìˆ˜ì •] ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±° í›„ ìƒˆë¡œ ë“±ë¡
if (roomValueListener) {
    roomRef.off('value', roomValueListener);
}

roomValueListener = (snapshot) => {
    if (isExiting) return;
    if (!snapshot.exists()) {
        // [ìˆ˜ì •] 3. ë°©ì´ ì‚¬ë¼ì¡Œì„ ë•Œ, ê²ŒìŠ¤íŠ¸ê°€ ìƒˆ ë°©ì„ ì¶”ì í•˜ëŠ” ë¡œì§
        // (ë°©ì´ ì‚­ì œë˜ê¸° ì§ì „ì˜ ë°ì´í„°ëŠ” currentRoomDataì— ë‚¨ì•„ìˆìŒ)
        if (currentRoomData && currentRoomData.nextRoomId) {
            console.log(`ë°©ì¥ì´ ìƒˆ ë°©ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ${currentRoomData.nextRoomId} ë°©ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.`);
            window.location.replace(`ê²Œì„ë°©.html?roomId=${currentRoomData.nextRoomId}`);
        } else {
            // ë°©ì¥ì´ ê·¸ëƒ¥ ë‚˜ê°”ê±°ë‚˜, ì¶”ì í•  ë°©ì´ ì—†ëŠ” ê²½ìš°
            if (!gameOverOverlay.classList.contains('active')) {
                alert("ë°©ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.");
            }
            cleanupAndExit(); // ê²ŒìŠ¤íŠ¸ëŠ” ëŒ€ê¸°ì‹¤ë¡œ ì´ë™
        }
        return;
    }
    
    currentRoomData = snapshot.val(); // [í•µì‹¬] í•­ìƒ ìµœì‹  ë°ì´í„° ìœ ì§€
    
    // 1. (ê³µí†µ) í”Œë ˆì´ì–´ UI ê°±ì‹  (ìŠ¤ì½”ì–´íŒ)
    if (currentRoomData.players) {
        updateScoreboardUI(currentRoomData.players);
    } else {
        return;
    }

    // 2. (ê³µí†µ) í˜¸ìŠ¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜
    const playerIds = Object.keys(currentRoomData.players || {});
    if (playerIds.length > 0 && (!currentRoomData.hostId || !currentRoomData.players[currentRoomData.hostId])) {
        const newHostId = playerIds.sort()[0];
        isHost = (newHostId === playerUid);
        if (isHost) {
            console.log(`[í˜¸ìŠ¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜] ë‚´ê°€ ìƒˆ í˜¸ìŠ¤íŠ¸(${playerUid})ê°€ ë¨.`);
            roomRef.update({ 'hostId': newHostId });
        }
    }
    
    // 3. (ê³µí†µ) 1ëª…ë§Œ ë‚¨ì•˜ì„ ë•Œ
    if (currentRoomData.status === 'playing' && playerIds.length === 1) {
        if (playerIds[0] === playerUid && !gameOverFlag) {
            console.log("[ê²Œì„ ì¢…ë£Œ] ìƒëŒ€ë°© ì´íƒˆë¡œ ìŠ¹ë¦¬.");
            gameOverFlag = true;
            if (playerRef) playerRef.child('isFinished').set(true);
            forceGameOver();
        }
        return; 
    }
    
    // 4. (ê³µí†µ) ë‚´ê°€ ë°©ì—ì„œ ì œì™¸ë¨
    if (!currentRoomData.players || !currentRoomData.players[playerUid]) {
        if (!gameOverOverlay.classList.contains('active')) {
            alert("ë°©ì—ì„œ í‡´ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
        cleanupAndExit();
        return;
    }

    // 5. ìƒíƒœë³„ ë¶„ê¸°
    const status = currentRoomData.status;
    console.log("ë°© ìƒíƒœ ë³€ê²½:", status);

    if (status === 'playing') {
       if (!timerId && !countdownStarted) {
            countdownStarted = true; 
            loadingOverlay.classList.remove('active');
            infoOverlay.classList.remove('active');
            startCountdown();
        }
    } else if (status === 'finished') {
        forceGameOver();
    } else if (status === 'waiting') {
        if (gameOverOverlay.classList.contains('active')) {
            console.log("[Rematch] 'waiting' ìƒíƒœ ê°ì§€. ê²Œì„ ì¬ì‹œì‘ ì¤€ë¹„...");
            gameOverOverlay.classList.remove('active');
            gameOverFlag = false;
            countdownStarted = false; 
            isProcessing = true; 
            
            if (roomRef && playerUid) {
                roomRef.child('readyPlayers/' + playerUid).set(true);
            }
            infoOverlay.classList.add('active');
        }
        
        const readyPlayers = currentRoomData.readyPlayers || {};
        const totalPlayers = Object.keys(currentRoomData.players).length;
        const readyCount = Object.keys(readyPlayers).length;
        
        if (infoOverlay.classList.contains('active')) {
            infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">ìƒëŒ€ë°© ê¸°ë‹¤ë¦¬ëŠ” ì¤‘ (${readyCount}/${totalPlayers})...</p>`;
        }

        if (isHost && totalPlayers >= 2 && readyCount === totalPlayers) {
            roomRef.update({
                status: 'playing',
                gameStarted: false,
                readyPlayers: null
            });
        }
        } else if (status === 'lobby') {
                // [ì‹ ê·œ] ë°©ì¥ì´ 'ê²Œì„ë°©'ìœ¼ë¡œ ë³µê·€í•˜ì—¬, 'lobby' ìƒíƒœë¡œ ë³€ê²½í•¨
                // ëª¨ë“  ì¸ì›ì„ ê²Œì„ë°©.htmlë¡œ ì´ë™ì‹œí‚µë‹ˆë‹¤.
                console.log("[ê²Œì„ ì¢…ë£Œ] 'lobby' ìƒíƒœ ê°ì§€. ê²Œì„ë°©.htmlë¡œ ë³µê·€í•©ë‹ˆë‹¤.");
                isExiting = true;
                stopSound('bgm');
                if (timerId) clearInterval(timerId);
                if (feverTimerId) clearTimeout(feverTimerId);

                // ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                if (roomRef) roomRef.off();
                if (chatListenerRef) chatListenerRef.off();

                window.location.replace(`ê²Œì„ë°©.html?roomId=${currentRoomId}`);
                return; // [ì‹ ê·œ]

    } else if (status === null && !gameOverOverlay.classList.contains('active')) {
        console.warn("ë°© ìƒíƒœê°€ 'null'ì…ë‹ˆë‹¤. í˜¸ìŠ¤íŠ¸ê°€ ë°©ì„ ì‚­ì œí•œ ê²ƒ ê°™ìŠµë‹ˆë‹¤.");
        forceGameOver();
    }
};

// [í•µì‹¬] ë¦¬ìŠ¤ë„ˆ ë“±ë¡
roomRef.on('value', roomValueListener);

loadingOverlay.querySelector('p').textContent = "ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";

// --- [ì‹ ê·œ] TTS ì—”ì§„ ê¹¨ìš°ê¸° ë° ëª©ì†Œë¦¬ ë¡œë“œ (ê²Œì„ë°©.html ë¡œì§) ---
                if (synthesis) {
                    if (synthesis.onvoiceschanged !== undefined) {
                        synthesis.onvoiceschanged = populateVoiceList;
                    }
                    populateVoiceList(); // ë¡œë“œ ì‹œë„
                }

                // --- [ì‹ ê·œ] ì±„íŒ… ìˆ˜ì‹ (TTS) ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ---
                if (chatListenerRef) chatListenerRef.off(); // ë§Œì•½ì„ ëŒ€ë¹„í•´ ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±°
                chatListenerRef = roomRef.child('chat');
                
                chatListenerRef.on('child_added', snapshot => {
    const msg = snapshot.val();
    if (!msg) return;
    
    // [ì‹ ê·œ] 1. ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ì´ ì—´ë ¤ìˆìœ¼ë©´ ì±„íŒ…ì°½ì— ë Œë”ë§
    if (gameOverOverlay.classList.contains('active')) {
        renderRematchChatMessage(msg);
    }

    // [ìœ ì§€] 2. TTS ì¬ìƒ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
    if (msg && !msg.isSystem && msg.senderId !== currentUser.uid && synthesis && isTTSOn) {
        try {
            if (synthesis.speaking) synthesis.cancel(); 
            
            const processedText = preprocessTextForTTS(msg.content);
            const utterance = new SpeechSynthesisUtterance(processedText);
            
            const savedVoiceURI = localStorage.getItem(TTS_VOICE_KEY);
            if (savedVoiceURI) {
                const savedVoice = voiceList.find(v => v.voiceURI === savedVoiceURI);
                if (savedVoice) utterance.voice = savedVoice;
            }
            
            utterance.lang = 'ko-KR';
            utterance.rate = 1.1;
            synthesis.speak(utterance);
        } catch (e) {
            console.error("TTS ì‹¤í–‰ ì˜¤ë¥˜:", e);
        }
    }
});
                // --- [ì‹ ê·œ] TTS ìˆ˜ì‹  ë¡œì§ ë ---
                // --- [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ ê³µê²© ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ ---
                // (ì°¸ê³ : setupGlobalNotificationListenersì™€ ë‹¬ë¦¬, ì´ ë¦¬ìŠ¤ë„ˆëŠ” ê²Œì„ ë°©ì—ë§Œ í•´ë‹¹ë¨)
                const attackListenerRef = roomRef.child('attacks/' + playerUid).orderByChild('timestamp').startAt(Date.now());
                
                attackListenerRef.on('child_added', (snapshot) => {
                    const attack = snapshot.val();
                    if (attack && attack.count > 0) {
                        console.log(`ğŸ§Š ${attack.count}ê°œì˜ ì–¼ìŒ íƒ€ì¼ ê³µê²© ìˆ˜ì‹ !`);
                        // [ì‹ ê·œ] ì‚¬ìš´ë“œ ì¶”ê°€ (ê¸°ì¡´ ì‚¬ìš´ë“œ ì¬í™œìš©)
                        playSound('bomb-create-sound'); 
                        // [ì‹ ê·œ] ë³´ë“œì— ì–¼ìŒ íƒ€ì¼ ì¶”ê°€
                        addJunkTilesToBoard(attack.count); 
                    }
                    snapshot.ref.remove(); // ìˆ˜ì‹  ì™„ë£Œ í›„ ì¦‰ì‹œ ì œê±°
                });
                // --- [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ ë¡œì§ ë ---

            }

            function updateScoreboardUI(players) {
                multiplayerScoreboard.innerHTML = '';
                // playerNicknames.clear(); // [ì‚­ì œ] ë‹‰ë„¤ì„ ë§µ ë¶ˆí•„ìš”

                for (const uid in players) {
                    const player = players[uid];
                    const nickname = player.nickname || 'Unknown';
                    const score = player.score || 0;
                    
                    // playerNicknames.set(uid, nickname); // [ì‚­ì œ]

                    const statBox = document.createElement('div');
                    statBox.className = 'stat-box';
                    statBox.dataset.uid = uid;

                    if (uid === playerUid) {
                        statBox.classList.add('my-score');
                    }

                    statBox.innerHTML = `
                        <div class="label">${nickname}</div>
                        <div class="value" id="score-value-${uid}">${score.toLocaleString()}</div>
                    `;
                    multiplayerScoreboard.appendChild(statBox);
                }
            }

// [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ ëª¨ë‹¬ ì±„íŒ…ì°½ ë Œë”ë§ í•¨ìˆ˜
function renderRematchChatMessage(msg) {
    if (!rematchChatMessages) return; 

    const msgEl = document.createElement('div');
    
    if (msg.isSystem) {
        msgEl.className = 'system-message';
        msgEl.textContent = msg.content;
    } 
    // [### ë²„ê·¸ ìˆ˜ì • ###] currentRoomData.players -> rematchPlayerList
    else if (rematchPlayerList && rematchPlayerList[msg.senderId]) { 
        const senderInfo = rematchPlayerList[msg.senderId]; // <-- ì—¬ê¸°ì„œ ìˆ˜ì •ë¨
        const isMe = msg.senderId === playerUid;
        
        msgEl.className = 'chat-msg';
        if (isMe) msgEl.classList.add('my-message');
        
        msgEl.innerHTML = `<strong>${escapeHTML(senderInfo.nickname)}:</strong> ${escapeHTML(msg.content)}`;
    } else {
        // í”Œë ˆì´ì–´ ì •ë³´ë¥¼ ëª» ì°¾ì•˜ì„ ë•Œ (ë°©ì–´ ì½”ë“œ)
        msgEl.className = 'system-message';
        msgEl.textContent = `[...]: ${escapeHTML(msg.content)}`;
    }
    
    rematchChatMessages.appendChild(msgEl);
    rematchChatMessages.scrollTop = rematchChatMessages.scrollHeight; 
}

            // ------------------------------------
            // 3. ê²Œì„ ì´ˆê¸°í™”
            // ------------------------------------

            function initGame() {
                score = 0;
                timer = GAME_TIME;
                currentCombo = 0;
                isProcessing = true; 

                // --- âœ¨ [ì‹ ê·œ] í”¼ë²„ ê²Œì´ì§€ ì´ˆê¸°í™” ---
                if (feverTimerId) clearTimeout(feverTimerId); // ì´ì „ íƒ€ì´ë¨¸ ì œê±°
                feverGauge = 0;
                isFeverMode = false;
                feverTimerId = null;
                updateFeverGaugeUI(); // UI 0%ë¡œ ë¦¬ì…‹
                gameBoard.classList.remove('fever-active'); // ì´í™íŠ¸ ì œê±°
                // --- í”¼ë²„ ì´ˆê¸°í™” ë ---
gameAreaFrameEl.classList.remove('fever-active'); // [ì‹ ê·œ] í”„ë ˆì„ ì´í™íŠ¸ ì œê±°
                gameContainer.classList.remove('fever-active'); // [ì‹ ê·œ] ë’·ë°°ê²½ ì´í™íŠ¸ ì œê±°
                timerValue.textContent = GAME_TIME;
                timerDisplay.classList.remove('danger-time');
                gameOverOverlay.classList.remove('active');
                
                if (playerRef) {
                    playerRef.child('score').set(0);
                    playerRef.child('isFinished').set(false);
                }

                createBoardData();
                renderBoard();
            }

          function createBoardData() {
    board = [];
    for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
            let newEmoji;
            do {
                newEmoji = getRandomEmoji();
            } while (
                (c >= 2 && newEmoji === row[c - 1] && newEmoji === row[c - 2]) ||
                (r >= 2 && newEmoji === board[r - 1][c] && newEmoji === board[r - 2][c])
            );
            row.push(newEmoji);
        }
        board.push(row);
    }
    const initialMatchData = findAllMatches();
    if (initialMatchData.matches.size > 0) {
        createBoardData(); 
    }
}


            function getRandomEmoji() {
                return TILE_EMOJIS[Math.floor(Math.random() * TILE_EMOJIS.length)];
            }

          // [ìˆ˜ì •] "íƒ€ì¼ ì•ˆë§ìŒ" ë²„ê·¸ í•´ê²° (JS ë¡œì§ì€ ìˆ˜ì • ì—†ì´ ê·¸ëŒ€ë¡œ ì‘ë™)
            function renderBoard() {
    gameBoard.innerHTML = '';
    tileElements = [];
    
    const gameContainerStyles = window.getComputedStyle(gameContainer);
    const containerW = gameContainer.clientWidth;
    const containerH = gameContainer.clientHeight;
    
    console.log("ğŸ® ë Œë”ë§ ì‹œì‘:", { containerW, containerH });
    
    if (containerW <= 0 || containerH <= 0) { 
        console.warn("ì»¨í…Œì´ë„ˆ í¬ê¸° ì˜¤ë¥˜", containerW, containerH);
        setTimeout(renderBoard, 100);
        return; 
    }

    const maxBoardW = containerW;
    const maxBoardH = containerH;
    let boardSizeW, boardSizeH;
    
    const cellAspectRatio = 1;
    const boardAspectRatio = (COLS * cellAspectRatio) / ROWS;
    
    if ((maxBoardW / boardAspectRatio) <= maxBoardH) {
        boardSizeW = maxBoardW;
        boardSizeH = maxBoardW / boardAspectRatio;
    } else {
        boardSizeH = maxBoardH;
        boardSizeW = maxBoardH * boardAspectRatio;
    }
    
    boardSizeW = Math.floor(boardSizeW);
    boardSizeH = Math.floor(boardSizeH);

    gameBoard.style.width = `${boardSizeW}px`;
    gameBoard.style.height = `${boardSizeH}px`; 

    const boardPadding = parseFloat(window.getComputedStyle(gameBoard).paddingLeft) || 4;
    const boardBorder = parseFloat(window.getComputedStyle(gameBoard).borderLeftWidth) || 2;
    const gap = parseFloat(window.getComputedStyle(gameBoard).gap) || 2;

    const currentTileSize = Math.floor((boardSizeW - (boardPadding * 2) - (boardBorder * 2) - (COLS - 1) * gap) / COLS);
    const iconSize = Math.floor(currentTileSize * 0.7);

    console.log("ğŸ“ íƒ€ì¼ í¬ê¸°:", { 
        boardSizeW, 
        boardSizeH, 
        currentTileSize, 
        iconSize,
        boardPadding,
        boardBorder,
        gap
    });

   for (let r = 0; r < ROWS; r++) {
    const rowElements = [];
    for (let c = 0; c < COLS; c++) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.row = r;
        tile.dataset.col = c;
        setTileAppearance(tile, board[r][c]); // [ìˆ˜ì •]
        
        // [ê¸´ê¸‰ ìˆ˜ì •] font-sizeë¥¼ ë” í¬ê²Œ
        const safeFontSize = Math.max(iconSize, 24); // ìµœì†Œ 24px ë³´ì¥
        tile.style.fontSize = `${safeFontSize}px`;
        
        console.log(`íƒ€ì¼[${r},${c}]: "${board[r][c]}", fontSize: ${safeFontSize}px`); // ë””ë²„ê¹…
        
        gameBoard.appendChild(tile);
        rowElements.push(tile);
        tile.addEventListener('pointerdown', handleDragStart);
    }
    tileElements.push(rowElements);
}
    
    console.log("âœ… íƒ€ì¼ ìƒì„± ì™„ë£Œ, ì´ ê°œìˆ˜:", tileElements.flat().length);
}

// [ì‹ ê·œ] ì´ëª¨ì§€/ë°ì´í„°ë¥¼ CSS í´ë˜ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
            function setTileAppearance(tile, emoji) {
                if (!tile) return;
                
                // 1. í…ìŠ¤íŠ¸(ì´ëª¨ì§€) ì‚­ì œ
                tile.textContent = ''; 
                
                // 2. [í•µì‹¬ ìˆ˜ì •] ëª¨ë“  ë™ë¬¼ ë° ìƒíƒœ í´ë˜ìŠ¤ ì œê±° (ì´ˆê¸°í™”)
            // .pop, .fall, .hint ë“± ëª¨ë“  í´ë˜ìŠ¤ë¥¼ ì œê±°í•˜ê³  'tile'ë§Œ ë‚¨ê¹ë‹ˆë‹¤.
            tile.className = 'tile';

                // 3. [ìˆ˜ì •] ìƒˆ ë°ì´í„°ì— ë§ëŠ” í´ë˜ìŠ¤ ì¶”ê°€
                switch (emoji) {
                    // 5ë§ˆë¦¬ ë™ë¬¼
                    case JUNK_TILE: tile.classList.add('junk'); break; // [ğŸ§± ë°©í•´ íƒ€ì¼]
                    case 'frog': tile.classList.add('frog'); break;
                    case 'chick': tile.classList.add('chick'); break;
                    case 'monkey': tile.classList.add('monkey'); break;
                    case 'pig': tile.classList.add('pig'); break;
                    case 'bear': tile.classList.add('bear'); break;
                    
                    // íŠ¹ìˆ˜ íƒ€ì¼ (ì´ëª¨ì§€ í‚¤ ìœ ì§€)
                    case 'ğŸŒˆ': tile.classList.add('rainbow'); break;
                    case 'star': tile.classList.add('star'); break; // [ì‹ ê·œ] ë³„ íŒ¡ì´
                    default:
                        // í˜¹ì‹œ ëª¨ë¥¼ ì˜ˆì™¸
                        tile.textContent = emoji; 
                }
            }

            // ------------------------------------
            // 4. ê²Œì„ ì‹œì‘/ì¢…ë£Œ (ìˆ˜ì •)
            // ------------------------------------

function startCountdown() {
    console.log("ğŸ¬ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘!");
    
    infoOverlay.classList.add('active');
    // [1/2 ìˆ˜ì •] ì ë©¸ í…ìŠ¤íŠ¸ë¥¼ í•¨ê»˜ ì¶”ê°€í•©ë‹ˆë‹¤.
    infoOverlay.innerHTML = `
        <div id="countdown-number" style="font-size: 7em; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.7);">3</div>
        <div id="audio-unlock-prompt">í™”ë©´ì„ í„°ì¹˜í•˜ë©´ ì†Œë¦¬ê°€ ì¬ìƒë©ë‹ˆë‹¤.</div>
    `;

    playSound('countdown');
    
    const countdownNumberEl = document.getElementById('countdown-number');
    // [ì‹ ê·œ] âš ï¸ ë¹ ì§„ ì½”ë“œ: ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œë¥¼ ìœ„í•œ 'íƒ­' ë¦¬ìŠ¤ë„ˆ
    infoOverlay.addEventListener('pointerdown', unlockAudioOnFirstTap, { once: true });
    let count = 3;
    
    const interval = setInterval(() => {
        count--;
        if (count > 0) {
            if (countdownNumberEl) countdownNumberEl.textContent = count;
            if (countdownNumberEl) {
                countdownNumberEl.style.animation = 'none';
                countdownNumberEl.offsetHeight; 
                countdownNumberEl.style.animation = 'countdown-pop 1s';
            }
        } else if (count === 0) {
            if (countdownNumberEl) countdownNumberEl.textContent = 'GO!';
            if (countdownNumberEl) {
                countdownNumberEl.style.animation = 'none';

                // [ìˆ˜ì •] BGM ì¬ìƒ ë¡œì§ (iOS í˜¸í™˜)
                if (isAudioUnlocked) {
                    // ìœ ì €ê°€ ì¹´ìš´íŠ¸ë‹¤ìš´ì„ íƒ­í•´ì„œ ì˜¤ë””ì˜¤ê°€ ì´ë¯¸ í’€ë ¸ë‹¤ë©´ BGM ì¬ìƒ
                    console.log("BGM ì¬ìƒ (ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œë¨)");
                    playSound('bgm');
                } else {
                    // ìœ ì €ê°€ íƒ­í•˜ì§€ ì•ŠìŒ. BGMì€ (ì•„ì§) ì¬ìƒ ë¶ˆê°€
                    console.log("BGM ì¬ìƒ ì‹¤íŒ¨ (ì˜¤ë””ì˜¤ ì ê¹€). ì²« ë“œë˜ê·¸ ì‹œ ì¬ìƒë©ë‹ˆë‹¤.");
                }

                countdownNumberEl.offsetHeight; 
                countdownNumberEl.style.animation = 'countdown-pop 1s';
            }
        } else {
            clearInterval(interval);
            infoOverlay.innerHTML = '';
            infoOverlay.classList.remove('active');

            // [ì‹ ê·œ] 'GO!'ê°€ ì§€ë‚¬ìŒì„ í”Œë˜ê·¸ì— í‘œì‹œ
            didGameStart = true;
            
            console.log("ğŸ® ê²Œì„ ì‹œì‘ ì¤€ë¹„ ì¤‘...");
            
            function runGame() {
                console.log(`ğŸ“ ì»¨í…Œì´ë„ˆ ì²´í¬: W=${gameContainer.clientWidth}, H=${gameContainer.clientHeight}`);
                
                if (gameContainer.clientWidth > 0 && gameContainer.clientHeight > 0) {
                    console.log("âœ… ë ˆì´ì•„ì›ƒ ê³„ì‚° ì™„ë£Œ. ê²Œì„ ì‹œì‘.");
                    initGame();
                    startGame();
                } else {
                    console.log(`â³ ë ˆì´ì•„ì›ƒ ëŒ€ê¸° ì¤‘... W:${gameContainer.clientWidth} H:${gameContainer.clientHeight}`);
                    requestAnimationFrame(runGame);
                }
            }
            
            requestAnimationFrame(runGame);
        }
    }, 1000);
}

            function startGame() {
                // [ìˆ˜ì •] ë³´ë“œ ë Œë”ë§ì´ ì•ˆëì„ ê²½ìš°ë¥¼ ëŒ€ë¹„
                if (tileElements.length === 0) { 
                    console.log("ë Œë”ë§ ì¬ì‹œë„...");
                    renderBoard(); 
                }
                if (tileElements.length === 0) { 
                    console.error("ë³´ë“œ ë Œë”ë§ ì‹¤íŒ¨. ì‹œì‘ ë¶ˆê°€.");
                    return; 
                }
                
                isProcessing = false;
                timerId = setInterval(() => {
                    timer--;
                    timerValue.textContent = timer;
                    if (timer <= 10) {
                        timerDisplay.classList.add('danger-time');
                    }
         if (timer <= 0) {
            gameOver();
        }
    }, 1000);
    
    // ğŸ® ì¹˜íŠ¸í‚¤ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    setupCheatKeys();
    startHintTimer(); // [ì‹ ê·œ] ê²Œì„ ì‹œì‘ê³¼ ë™ì‹œì— íŒíŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
}

// ğŸ® ì¹˜íŠ¸í‚¤ ì‹œìŠ¤í…œ
function setupCheatKeys() {
    // ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì¤‘ë³µ ë°©ì§€
    if (window.cheatKeysEnabled) return;
    window.cheatKeysEnabled = true;
    
    document.addEventListener('keydown', (e) => {
        // ê²Œì„ ì¤‘ì´ ì•„ë‹ˆë©´ ë¬´ì‹œ
        if (!timerId || isProcessing) return;
        
        switch(e.key.toLowerCase()) {
            case 'c': // Cí‚¤: ì‹­ìê°€ í­ë°œ í…ŒìŠ¤íŠ¸
                createCrossExplosionTest();
                break;
            case 'r': // Rí‚¤: ë ˆì¸ë³´ìš° íƒ€ì¼ í…ŒìŠ¤íŠ¸
                createRainbowTest();
                break;
            case 'd': // Dí‚¤: ë”ë¸” ë ˆì¸ë³´ìš° í…ŒìŠ¤íŠ¸
                createDoubleRainbowTest();
                break;
            case 'f': // Fí‚¤: í”¼ë²„ëª¨ë“œ ê°•ì œ ë°œë™
                if (!isFeverMode) {
                    feverGauge = MAX_FEVER_GAUGE;
                    updateFeverGaugeUI();
                    startFeverMode();
                }
                break;
            case 's': // Sí‚¤: ë³´ë“œ ì…”í”Œ
                handleNoMoreMoves();
                break;
            case 't': // Tí‚¤: ì‹œê°„ +10ì´ˆ
                timer = Math.min(GAME_TIME, timer + 10);
                timerValue.textContent = timer;
                break;
                case 'b': // Bí‚¤: ë³„ íŒ¡ì´ í­ë°œ í…ŒìŠ¤íŠ¸
                createStarPangiTest(); // [ì‹ ê·œ]
                break;
            case 'p': // Pí‚¤: ì ìˆ˜ +1000ì 
                score += 1000;
                updateScoreUI();
                if (playerRef) playerRef.child('score').set(score);
                break;
                case 'e': // Eí‚¤: ê²Œì„ ê°•ì œ ì¢…ë£Œ (End)
                    console.log('ğŸ® ì¹˜íŠ¸í‚¤: ê²Œì„ ê°•ì œ ì¢…ë£Œ (E)');
                    gameOver(); // ê²Œì„ ì¢…ë£Œ í•¨ìˆ˜ í˜¸ì¶œ
                    break;
        }
    });
    
    console.log('ğŸ® ì¹˜íŠ¸í‚¤ í™œì„±í™”!');
    console.log('C: ì‹­ìê°€ | R: ë ˆì¸ë³´ìš° | D: ë”ë¸” ë ˆì¸ë³´ìš° | B: ë³„ íŒ¡ì´'); // [ìˆ˜ì •]
    console.log('F: í”¼ë²„ëª¨ë“œ | S: ì…”í”Œ | T: ì‹œê°„+10ì´ˆ | P: ì ìˆ˜+1000');
}

// Cí‚¤: ì‹­ìê°€ í­ë°œ í…ŒìŠ¤íŠ¸ (5ê°œ ì¼ì§ì„  ìƒì„±)
async function createCrossExplosionTest() {
    console.log('ğŸ”¥ ì‹­ìê°€ í­ë°œ í…ŒìŠ¤íŠ¸ ìƒì„±!');
    isProcessing = true;
    
    // ì¤‘ì•™ ë¶€ê·¼ì— ê°€ë¡œ 5ì¤„ ìƒì„±
    const testRow = Math.floor(ROWS / 2);
    const startCol = 1;
    const testEmoji = TILE_EMOJIS[0]; // ì²« ë²ˆì§¸ ì´ëª¨ì§€ ì‚¬ìš©
    
    // ë³´ë“œ ë°ì´í„° ë³€ê²½
    for (let c = startCol; c < startCol + 5; c++) {
        board[testRow][c] = testEmoji;
    }
    
    // DOM ì—…ë°ì´íŠ¸
    for (let c = startCol; c < startCol + 5; c++) {
        if (tileElements[testRow][c]) {
            setTileAppearance(tileElements[testRow][c], testEmoji); // [ìˆ˜ì •] textContent -> setTileAppearance
            tileElements[testRow][c].classList.add('new-tile-anim');
        }
    }
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì œê±°
    for (let c = startCol; c < startCol + 5; c++) {
        if (tileElements[testRow][c]) {
            tileElements[testRow][c].classList.remove('new-tile-anim');
        }
    }
    
    // ë§¤ì¹­ ê°ì§€ ë° ì²˜ë¦¬
    const matchData = findAllMatches();
    if (matchData.matches.size > 0) {
        await processMatchesAndCascade(matchData);
    }
    
    isProcessing = false;
}

// Rí‚¤: ë ˆì¸ë³´ìš° íƒ€ì¼ í…ŒìŠ¤íŠ¸ (6ê°œ ì¼ì§ì„  ìƒì„±)
async function createRainbowTest() {
    console.log('ğŸŒˆ ë ˆì¸ë³´ìš° íƒ€ì¼ í…ŒìŠ¤íŠ¸ ìƒì„±!');
    isProcessing = true;
    
    // ì¤‘ì•™ ë¶€ê·¼ì— ê°€ë¡œ 6ì¤„ ìƒì„±
    const testRow = Math.floor(ROWS / 2);
    const startCol = 0;
    const testEmoji = TILE_EMOJIS[1]; // ë‘ ë²ˆì§¸ ì´ëª¨ì§€ ì‚¬ìš©
    
    // ë³´ë“œ ë°ì´í„° ë³€ê²½
    for (let c = startCol; c < startCol + 6; c++) {
        board[testRow][c] = testEmoji;
    }
    
    // DOM ì—…ë°ì´íŠ¸
    for (let c = startCol; c < startCol + 6; c++) {
        if (tileElements[testRow][c]) {
            setTileAppearance(tileElements[testRow][c], testEmoji); // [ìˆ˜ì •] textContent -> setTileAppearance
            tileElements[testRow][c].classList.add('new-tile-anim');
        }
    }
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì œê±°
    for (let c = startCol; c < startCol + 6; c++) {
        if (tileElements[testRow][c]) {
            tileElements[testRow][c].classList.remove('new-tile-anim');
        }
    }
    
    // ë§¤ì¹­ ê°ì§€ ë° ì²˜ë¦¬
    const matchData = findAllMatches();
    if (matchData.matches.size > 0) {
        await processMatchesAndCascade(matchData);
    }
    
    isProcessing = false;
}

// Dí‚¤: ë”ë¸” ë ˆì¸ë³´ìš° í…ŒìŠ¤íŠ¸ (ë ˆì¸ë³´ìš° 2ê°œ ìƒì„±)
async function createDoubleRainbowTest() {
    console.log('ğŸŒˆğŸŒˆ ë”ë¸” ë ˆì¸ë³´ìš° í…ŒìŠ¤íŠ¸!');
    isProcessing = true;
    
    // ì¤‘ì•™ ê·¼ì²˜ì— ë ˆì¸ë³´ìš° 2ê°œ ë°°ì¹˜
    const testRow = Math.floor(ROWS / 2);
    const col1 = 2;
    const col2 = 3;
    
    // ë³´ë“œ ë°ì´í„° ë³€ê²½
    board[testRow][col1] = RAINBOW_TILE;
    board[testRow][col2] = RAINBOW_TILE;
    
    // DOM ì—…ë°ì´íŠ¸
    if (tileElements[testRow][col1]) {
        setTileAppearance(tileElements[testRow][col1], RAINBOW_TILE); // [ìˆ˜ì •] textContent -> setTileAppearance
        tileElements[testRow][col1].classList.add('new-tile-anim');
    }
    if (tileElements[testRow][col2]) {
        setTileAppearance(tileElements[testRow][col2], RAINBOW_TILE); // [ìˆ˜ì •] textContent -> setTileAppearance
        tileElements[testRow][col2].classList.add('new-tile-anim');
    }
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì œê±°
    if (tileElements[testRow][col1]) {
        tileElements[testRow][col1].classList.remove('new-tile-anim');
    }
    if (tileElements[testRow][col2]) {
        tileElements[testRow][col2].classList.remove('new-tile-anim');
    }
    
    isProcessing = false;
    console.log('ğŸ’¡ ë ˆì¸ë³´ìš° íƒ€ì¼ 2ê°œë¥¼ ë“œë˜ê·¸ë¡œ êµí™˜í•˜ì„¸ìš”!');
}
    // í…ŒìŠ¤íŠ¸ë

    // [ì‹ ê·œ] Bí‚¤: ë³„ íŒ¡ì´ í­ë°œ í…ŒìŠ¤íŠ¸ (ë³„ 1ê°œ + ì¼ë°˜ 1ê°œ ìƒì„±)
async function createStarPangiTest() {
    console.log('â­ï¸ ë³„ íŒ¡ì´ í­ë°œ í…ŒìŠ¤íŠ¸ ìƒì„±!');
    if (isProcessing) return; // [ìˆ˜ì •] ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    isProcessing = true;
    
    // ì¤‘ì•™ ê·¼ì²˜ì— ë³„ íŒ¡ì´ 1ê°œ, ê°œêµ¬ë¦¬ 1ê°œ ë°°ì¹˜
    const testRow = Math.floor(ROWS / 2);
    const col1 = 2;
    const col2 = 3;
    const testEmoji = TILE_EMOJIS[0]; // 'frog'
    
    // ë³´ë“œ ë°ì´í„° ë³€ê²½
    board[testRow][col1] = 'star';
    board[testRow][col2] = testEmoji;
    
    // DOM ì—…ë°ì´íŠ¸
    if (tileElements[testRow][col1]) {
        setTileAppearance(tileElements[testRow][col1], 'star');
        tileElements[testRow][col1].classList.add('new-tile-anim');
    }
    if (tileElements[testRow][col2]) {
        setTileAppearance(tileElements[testRow][col2], testEmoji);
        tileElements[testRow][col2].classList.add('new-tile-anim');
    }
    
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì œê±°
    if (tileElements[testRow][col1]) {
        tileElements[testRow][col1].classList.remove('new-tile-anim');
    }
    if (tileElements[testRow][col2]) {
        tileElements[testRow][col2].classList.remove('new-tile-anim');
    }
    
    isProcessing = false;
    console.log('ğŸ’¡ â­ï¸(ë³„)ê³¼ ğŸ¸(ê°œêµ¬ë¦¬)ë¥¼ ìŠ¤ì™‘í•˜ì„¸ìš”!');
}


        function gameOver() {
            if (isProcessing) return; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            isProcessing = true; 
            stopSound('bgm'); // [ì‹ ê·œ] BGM ì •ì§€
            clearInterval(timerId);
            timerId = null;
        
            if (feverTimerId) {
                clearTimeout(feverTimerId);
                feverTimerId = null;
                isFeverMode = false;
                gameBoard.classList.remove('fever-active');
            }
            timerDisplay.classList.remove('danger-time'); 
            timerValue.textContent = '0';
            // playSound('gameOver'); // [ì œê±°] (ì‚¬ìš´ë“œ ì¬ìƒì„ forceGameOver í•¨ìˆ˜ë¡œ ì´ë™)
            
            // [ìˆ˜ì •] (Tetris/ShisenSho ë°©ì‹ ì ìš©)
            // 1. ë¨¼ì € ë³¸ì¸ì˜ isFinishedë¥¼ trueë¡œ ì„¤ì •
            if (playerRef) {
                playerRef.child('isFinished').set(true).then(() => {
                    console.log(`[${isHost ? 'Host' : 'Guest'}] isFinished = true ì„¤ì • ì™„ë£Œ.`);
                    
                    // 2. (ì‹ ê·œ) í˜¸ìŠ¤íŠ¸/ê²ŒìŠ¤íŠ¸ êµ¬ë¶„ ì—†ì´ "ì¦‰ì‹œ" ê³µìš© ì²´í¬ í•¨ìˆ˜ í˜¸ì¶œ
                    //    (Firebase ì „íŒŒ ì‹œê°„ì„ ê³ ë ¤í•´ 500ms ë”œë ˆì´)
                    setTimeout(checkGameOverCondition, 500); 

                }).catch(err => {
                    // [ì‹ ê·œ] set ì‹¤íŒ¨ ì‹œì—ë„ 500ms í›„ ì²´í¬ ì‹œë„ (ë°©ì–´ ì½”ë“œ)
                    console.error("isFinished ì„¤ì • ì‹¤íŒ¨:", err);
                    setTimeout(checkGameOverCondition, 500);
                });
            } else {
                // playerRefê°€ ì—†ëŠ” ë¹„ì •ìƒì  ìƒí™©
                setTimeout(checkGameOverCondition, 500);
            }
            
            // 3. ê²°ê³¼ ì§‘ê³„ì¤‘ UI í‘œì‹œ
            loadingOverlay.classList.add('active');
            loadingOverlay.querySelector('p').textContent = "ê²°ê³¼ ì§‘ê³„ ì¤‘...";
        }



       // [ìˆ˜ì •] ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì¦ê°€ ë° ê°„ê²© ë‹¨ì¶•
// [ìˆ˜ì •] (Tetris/ShisenSho ë°©ì‹ ì ìš©)
        // checkAttempts ë³€ìˆ˜ ë° ê´€ë ¨ ìƒìˆ˜ëŠ” ì´ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©
        let checkGameOverAttempts = 0;
        const MAX_CHECK_ATTEMPTS = 20; // 10ì´ˆ (500ms * 20)
        const CHECK_INTERVAL = 500;

        // [ìˆ˜ì •] í•¨ìˆ˜ ì´ë¦„ì„ ë³€ê²½í•˜ê³  (checkAllPlayersFinished -> checkGameOverCondition)
        // í˜¸ìŠ¤íŠ¸/ê²ŒìŠ¤íŠ¸ ê³µìš© í•¨ìˆ˜ë¡œ ë³€ê²½
        function checkGameOverCondition() {
            // 1. ì´ë¯¸ ê²°ê³¼ì°½ì´ ë–´ìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            if (gameOverOverlay.classList.contains('active')) {
                return;
            }
            
            // 2. allPlayersRefê°€ ì—†ìœ¼ë©´ (ë°©ì´ í„°ì¡Œìœ¼ë©´) ê°•ì œ ì¢…ë£Œ
            if (!allPlayersRef) {
                console.warn("[CheckGameOver] allPlayersRefê°€ ì—†ìŠµë‹ˆë‹¤. ê°•ì œ ì¢…ë£Œ.");
                forceGameOver(); // (ê²°ê³¼: ë°©ì´ ì¢…ë£Œë¨)
                return;
            }

            checkGameOverAttempts++;
            console.log(`[CheckGameOver] (ê³µìš©) í”Œë ˆì´ì–´ ì¢…ë£Œ ì²´í¬ (${checkGameOverAttempts}/${MAX_CHECK_ATTEMPTS})`);

            // 3. (ì‹ ê·œ) í˜¸ìŠ¤íŠ¸/ê²ŒìŠ¤íŠ¸ êµ¬ë¶„ ì—†ì´ "ì¦‰ì‹œ" allPlayersRefë¥¼ í™•ì¸
            allPlayersRef.once('value', (snapshot) => {
                const players = snapshot.val();
                if (!players) {
                    console.warn("[CheckGameOver] players ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ê°•ì œ ì¢…ë£Œ.");
                    forceGameOver(); // (ê²°ê³¼: ë°©ì´ ì¢…ë£Œë¨)
                    return;
                }

                const playerArray = Object.values(players);
                const allFinished = playerArray.length > 0 && playerArray.every(p => p.isFinished === true);

                // 4. (ì‹ ê·œ) "ëª¨ë‘ ì¢…ë£Œ"ê°€ í™•ì¸ë˜ë©´, ì¦‰ì‹œ ë¡œì»¬ì—ì„œ forceGameOver() í˜¸ì¶œ
                if (allFinished) {
                    console.log("[CheckGameOver] ëª¨ë“  í”Œë ˆì´ì–´ ì¢…ë£Œ í™•ì¸! ì¦‰ì‹œ ê²°ê³¼ í‘œì‹œ.");
                    
                    // (ì„ íƒì ) í˜¸ìŠ¤íŠ¸ê°€ status: 'finished'ë¥¼ ì´ì„œ, 
                    // ì²´í¬ê°€ ëŠ¦ëŠ” ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ ì‹ í˜¸ë¥¼ ì¤„ ìˆ˜ ìˆìŒ (ì•ˆì „ì¥ì¹˜)
                    if (isHost) {
                        statusRef.set('finished');
                    }
                    
                    forceGameOver(); // "ì¦‰ì‹œ" ë¡œì»¬ì—ì„œ ê²°ê³¼ì°½ í‘œì‹œ
                    checkGameOverAttempts = 0; // ì´ˆê¸°í™”
                }
                // 5. (ì‹ ê·œ) ì•„ì§ "ëª¨ë‘ ì¢…ë£Œ"ê°€ ì•„ë‹ˆë©´, ì¬ì‹œë„ (ì•ˆì „ì¥ì¹˜)
                else if (checkGameOverAttempts < MAX_CHECK_ATTEMPTS) {
                    console.log(`[CheckGameOver] ì•„ì§ ëª¨ë‘ ì¢…ë£Œë˜ì§€ ì•ŠìŒ. ${CHECK_INTERVAL}ms í›„ ì¬ì‹œë„...`);
                    setTimeout(checkGameOverCondition, CHECK_INTERVAL);
                }
                // 6. (ì‹ ê·œ) ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ (ì•ˆì „ì¥ì¹˜)
                else {
                    console.warn("[CheckGameOver] ìµœëŒ€ ì²´í¬ íšŸìˆ˜ ì´ˆê³¼. ê°•ì œë¡œ ê²°ê³¼ í‘œì‹œ.");
                    
                    // (ì„ íƒì ) í˜¸ìŠ¤íŠ¸ê°€ ê°•ì œë¡œ status: 'finished' ì„¤ì •
                    if (isHost) {
                        statusRef.set('finished');
                    }
                    
                    forceGameOver();
                    checkGameOverAttempts = 0;
                }
            });
        }

       // [ìˆ˜ì •] "ê²ŒìŠ¤íŠ¸ ë©ˆì¶¤" ë²„ê·¸ í•´ê²° (ë¦¬ìŠ¤ë„ˆ ì •ë¦¬)
function forceGameOver() {
    if (gameOverOverlay.classList.contains('active')) return;

    gameOverOverlay.classList.add('active'); // ì¤‘ë³µ ë°©ì§€

    // [ì‹ ê·œ] 2. ì±„íŒ… ì…ë ¥ ëª¨ë‹¬ ë¡œì§
    // (ì±„íŒ… ì „ì†¡ í•¨ìˆ˜)
    function sendRematchChat() {
        const message = rematchChatInput.value.trim();
        
        // [### ë²„ê·¸ ìˆ˜ì • ###]
        // rematchPlayerListì—ì„œ ë‚´ ë‹‰ë„¤ì„ì„ ì°¾ì•„ì„œ sendMessageì— ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤.
        if (message && rematchPlayerList && rematchPlayerList[playerUid]) {
            const myNickname = rematchPlayerList[playerUid].nickname;
            sendMessage(message, myNickname); // ìˆ˜ì •ëœ í•¨ìˆ˜ í˜¸ì¶œ
        } else if (message) {
            // ì˜ˆì™¸ ì²˜ë¦¬: ë‹‰ë„¤ì„ì„ ëª»ì°¾ìœ¼ë©´ ì „ì†¡ ì‹¤íŒ¨
            console.error("sendRematchChat: ë‹‰ë„¤ì„ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", rematchPlayerList, playerUid);
            showToast("ì±„íŒ… ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ì •ë³´ ì—†ìŒ)");
        }
        // [### ìˆ˜ì • ë ###]
        
        rematchChatInput.value = '';
        rematchChatInputModal.classList.remove('active'); // ì „ì†¡ í›„ ëª¨ë‹¬ ë‹«ê¸°
    }
    
    // [### ìˆ˜ì • ###] ëª¨ë‹¬ ë‚´ë¶€ í”Œë¡œíŒ… ë²„íŠ¼ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
    rematchChatOpenBtn.onclick = () => { 
        rematchChatInputModal.classList.add('active');
        rematchChatInput.focus();
    };
    
    // (ì „ì†¡ ë²„íŠ¼)
    rematchChatSendBtn.onclick = sendRematchChat;
    // (ì—”í„°í‚¤)
    rematchChatInput.onkeydown = (e) => {
        if (e.key === 'Enter' && !e.isComposing) {
            e.preventDefault();
            sendRematchChat();
        }
    };
    // (ë°”íƒ• í´ë¦­ ì‹œ ë‹«ê¸°)
    rematchChatInputModal.onclick = (e) => {
        if (e.target === rematchChatInputModal) {
            rematchChatInputModal.classList.remove('active');
        }
    };

    // [ì‹ ê·œ] 3. STT(ë§ˆì´í¬) ë²„íŠ¼ ë¡œì§ (ì…ë ¥ ëª¨ë‹¬ ì•ˆì˜ ë²„íŠ¼)
    if (recognition && rematchChatSttBtn) {
        recognition.onresult = (event) => {
            const text = event.results[0][0].transcript;
            rematchChatInput.value = text; // [ìˆ˜ì •] ì…ë ¥ì°½ì— í…ìŠ¤íŠ¸ ì‚½ì…
            rematchChatSttBtn.classList.remove('recording');
            rematchChatSttBtn.disabled = false;
            rematchChatInput.focus();
        };
        recognition.onend = () => {
            rematchChatSttBtn.classList.remove('recording');
            rematchChatSttBtn.disabled = false;
        };
        recognition.onerror = (event) => {
            console.error('STT ì—ëŸ¬:', event.error);
            rematchChatSttBtn.classList.remove('recording');
            rematchChatSttBtn.disabled = false;
        };
        rematchChatSttBtn.onclick = (e) => {
            e.stopPropagation();
            if (rematchChatSttBtn.classList.contains('recording')) {
                recognition.stop();
            } else {
                try {
                    recognition.start();
                    rematchChatSttBtn.classList.add('recording');
                    rematchChatSttBtn.disabled = true;
                } catch(e) { console.error("STT ì‹œì‘ ì—ëŸ¬", e); }
            }
        };
    } else if (rematchChatSttBtn) {
        rematchChatSttBtn.style.display = 'none';
    }

    // [ì‹ ê·œ] 4. TTS(ìŒì„±ë“£ê¸°) í† ê¸€ ë²„íŠ¼ ë¡œì§
    const rematchTtsBtn = document.getElementById('rematch-tts-btn');
    if (rematchTtsBtn) {
        rematchTtsBtn.textContent = isTTSOn ? 'ğŸ”Š' : 'ğŸ”‡'; // í˜„ì¬ ìƒíƒœ ì•„ì´ì½˜
        rematchTtsBtn.onclick = (e) => {
            e.stopPropagation();
            isTTSOn = !isTTSOn; // ì „ì—­ ìƒíƒœ í† ê¸€
            localStorage.setItem(TTS_ENABLED_KEY, isTTSOn); // ìƒíƒœ ì €ì¥
            rematchTtsBtn.textContent = isTTSOn ? 'ğŸ”Š' : 'ğŸ”‡'; // ì•„ì´ì½˜ ë³€ê²½
            showToast(isTTSOn ? 'ì±„íŒ… ìŒì„± ë“£ê¸° ON' : 'ì±„íŒ… ìŒì„± ë“£ê¸° OFF');
            if (!isTTSOn) synthesis.cancel(); // ë„ë©´ í˜„ì¬ TTS ì¤‘ì§€
        };
    }

    // --- (ì´í•˜ëŠ” ê¸°ì¡´ forceGameOver ë¡œì§) ---
    stopSound('bgm'); 

    if (isHost && hostStatusDisconnectRef) {
        try {
            hostStatusDisconnectRef.cancel();
            hostStatusDisconnectRef = null;
            console.log("ê²Œì„ ì •ìƒ ì¢…ë£Œ: í˜¸ìŠ¤íŠ¸ onDisconnect í•¸ë“¤ëŸ¬ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.");
        } catch (e) {
            console.warn("í˜¸ìŠ¤íŠ¸ onDisconnect í•¸ë“¤ëŸ¬ ì·¨ì†Œ ì‹¤íŒ¨:", e);
        }
    }

    if (timerId) {
        clearInterval(timerId);
        timerId = null;
    }
    isProcessing = true; 
    loadingOverlay.classList.remove('active');
    
    if (!allPlayersRef) {
        finalRankingList.innerHTML = '<p style="text-align: center;">ë°© ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤.</p>';
        // finalScoreEl.textContent = `${score.toLocaleString()} ì `; // finalScoreElì´ ì—†ìœ¼ë¯€ë¡œ ì œê±°
        return;
    }
    
    allPlayersRef.once('value', (snapshot) => {
        if (allPlayersRef) {
            allPlayersRef.off();
            console.log("ê²°ê³¼ ëª¨ë‹¬ í‘œì‹œ ì™„ë£Œ. allPlayersRef ë¦¬ìŠ¤ë„ˆë¥¼ ë•ë‹ˆë‹¤.");
        }
        if (statusRef) {
            statusRef.off();
            console.log("statusRef ë¦¬ìŠ¤ë„ˆë¥¼ ë•ë‹ˆë‹¤.");
        }
        
        const players = snapshot.val();
        if (!players) {
            finalRankingList.innerHTML = '<p style="text-align: center;">ë°©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</p>';
            return;
        }

        // [### ë²„ê·¸ ìˆ˜ì • ###]
        // 1. ì´ ì‹œì ì˜ í”Œë ˆì´ì–´ ëª©ë¡ì„ ì±„íŒ…ë°© ì „ìš© ë³€ìˆ˜ì— í™•ì •í•©ë‹ˆë‹¤.
        rematchPlayerList = players; 

        // 2. ì´ì œ í”Œë ˆì´ì–´ ëª©ë¡ì´ í™•ì •ë˜ì—ˆìœ¼ë‹ˆ, ì±„íŒ… ë‚´ì—­ì„ ë¡œë“œí•©ë‹ˆë‹¤.
        if (rematchChatMessages) {
            rematchChatMessages.innerHTML = '<div class="spinner" style="margin: auto; width: 20px; height: 20px;"></div>';
            roomRef.child('chat').limitToLast(10).once('value', chatSnapshot => { 
                if (rematchChatMessages) rematchChatMessages.innerHTML = ''; 
                if (chatSnapshot.exists()) {
                    chatSnapshot.forEach(childSnap => {
                        renderRematchChatMessage(childSnap.val()); // ì´ì œ rematchPlayerListë¥¼ ì‚¬ìš©í•¨
                    });
                }
            });
        }
        // [### ë²„ê·¸ ìˆ˜ì • ë ###]

        const sortedPlayers = Object.entries(players)
            .map(([uid, data]) => ({ uid, ...data }))
            .sort((a, b) => (b.score || 0) - (a.score || 0));

        let myFinalRank = -1;
        let myFinalScore = 0;
        
        sortedPlayers.forEach((player, index) => {
            if (player.uid === playerUid) {
                myFinalRank = index + 1;
                myFinalScore = player.score || 0;
            }
        });

        const didIWin = (myFinalRank === 1);
        
        if (didIWin) {
            playSound('victory');
        } else {
            playSound('gameOver');
        }
        updatePlayerStats(didIWin, myFinalScore, myFinalRank);

        const rematchStatusList = document.getElementById('rematch-status-list');
        rematchStatusList.innerHTML = ''; 

        sortedPlayers.forEach((player, index) => {
            const rank = index + 1;
            const nickname = player.nickname || 'Unknown';
            const scoreVal = player.score || 0;
            const scoreText = `(${scoreVal.toLocaleString()}ì )`;
            const isMe = (player.uid === playerUid);

            const row = document.createElement('div');
            row.className = 'rematch-player-row';
            if (isMe) {
                row.classList.add('my-row');
            }

            let playerInfoHTML = `
                <span class="player-info">
                    <span class="player-info-topline"> <span class="player-rank">${rank}ìœ„</span>
                        <span class="player-name">${nickname}</span>
                    </span>
                    <span class="player-score">${scoreText}</span> </span>
            `;
            
            let statusHTML = `<span class="status-text" data-uid="${player.uid}"></span>`;

            row.innerHTML = playerInfoHTML + statusHTML;
            rematchStatusList.appendChild(row);
        });
        
        const rematchBtn = document.getElementById('rematch-btn');
        const lobbyBtn = document.getElementById('lobby-btn');
        
        rematchBtn.textContent = 'ë‹¤ì‹œí•˜ê¸°';
        rematchBtn.disabled = false;
        
        const newRematchBtn = rematchBtn.cloneNode(true);
        rematchBtn.parentNode.replaceChild(newRematchBtn, rematchBtn);
        
        const newLobbyBtn = lobbyBtn.cloneNode(true);
        lobbyBtn.parentNode.replaceChild(newLobbyBtn, lobbyBtn);
        
        const gameType = currentRoomData.gameType; 
        const maxPlayers = currentRoomData.maxPlayers || 4; 

         if (isHost) {
           newLobbyBtn.addEventListener('click', () => hostReturnToGameLobby(players, gameType));
        } else {
           newLobbyBtn.addEventListener('click', () => guestHandleReturn(players));
        }
        
        newRematchBtn.addEventListener('click', () => {
            if (roomRef && playerUid) {
                if (amIReadyForRematch) { 
                    roomRef.child('rematchRequests/' + playerUid).remove();
                } else { 
                    roomRef.child('rematchRequests/' + playerUid).set(true);
                }
            }
        });
        
        listenForRematch();
    });
}

            // [ì‹ ê·œ] 'ë‹¤ì‹œí•˜ê¸°' ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ (Tetris/ShisenSho ë°©ì‹)
            
            // [ìˆ˜ì •] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ ë¦¬ìŠ¤ë„ˆ ì°¸ì¡°ë¥¼ ì™¸ë¶€ë¡œ ì´ë™
            let rematchRef = null; 
            let amIReadyForRematch = false; // [ì‹ ê·œ] 'ì¤€ë¹„ì™„ë£Œ' ìƒíƒœ ì¶”ì 
            
            function listenForRematch() {
                 if (!roomRef) return;

                 // [ìˆ˜ì •] ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆê°€ ìˆë‹¤ë©´ ì œê±° (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
                 if (rematchRef) {
                    rematchRef.off();
                 }
                 rematchRef = roomRef.child('rematchRequests');
                 
                 rematchRef.on('value', snapshot => {
                      const requests = snapshot.val() || {}; // [ìˆ˜ì •] nullì¼ ê²½ìš° ë¹ˆ ê°ì²´
                      amIReadyForRematch = requests.hasOwnProperty(playerUid); // [ì‹ ê·œ] ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸

                      // [ì‹ ê·œ] í˜„ì¬ ë°©ì— ë‚¨ì•„ìˆëŠ” í”Œë ˆì´ì–´ ëª©ë¡ (ì¤‘ìš”)
                      const playersInRoom = Object.keys(currentRoomData.players || {});
                      
                      // [ì‹ ê·œ] 'ë‹¤ì‹œí•˜ê¸°' ìƒíƒœ ëª©ë¡ UI ì—…ë°ì´íŠ¸
                      const allStatusSpans = document.querySelectorAll('#rematch-status-list .status-text');
                      
                      allStatusSpans.forEach(span => {
                          const uid = span.dataset.uid;
                          
                          if (!playersInRoom.includes(uid)) {
                              // [ì‹ ê·œ] 1. ë°©ì— ì—†ëŠ” ìœ ì € (ë‚˜ê°„ ì‚¬ëŒ)
                              span.textContent = 'í‡´ì¥';
                              span.classList.remove('ready');
                              span.style.color = 'var(--danger-color)'; // ë¹¨ê°„ìƒ‰
                              span.style.textShadow = 'none';

                          } else if (requests.hasOwnProperty(uid)) {
                              // 2. ë°©ì— ìˆê³ , ì¤€ë¹„ ì™„ë£Œí•œ ìœ ì €
                              span.textContent = 'ì¤€ë¹„ì™„ë£Œ!';
                              span.classList.add('ready');
                              span.style.color = '#28a745'; // ì´ˆë¡ìƒ‰ (ì›ë˜ëŒ€ë¡œ)
                              span.style.textShadow = '0 0 5px rgba(40, 167, 69, 0.5)';
                          
                          } else {
                              // 3. ë°©ì— ìˆì§€ë§Œ, ì•„ì§ ì¤€ë¹„ ì•ˆ í•œ ìœ ì €
                              span.textContent = ''; // 'ëŒ€ê¸°ì¤‘' (ì•„ë¬´ê²ƒë„ í‘œì‹œ ì•ˆ í•¨)
                              span.classList.remove('ready');
                              span.style.color = '#ccc'; // (ì›ë˜ëŒ€ë¡œ)
                              span.style.textShadow = 'none';
                          }
                      });
                      
                      // [ì‹ ê·œ] ë‚´ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì¬ì ‘ì† ì‹œ ë˜ëŠ” ë¦¬ì…‹ ì‹œ)
                      const myRematchBtn = document.getElementById('rematch-btn');
                      if (myRematchBtn) { // ë²„íŠ¼ì´ ì¡´ì¬í•  ë•Œë§Œ
                          if (amIReadyForRematch) { // [ìˆ˜ì •]
                              myRematchBtn.disabled = false; // [ìˆ˜ì •] í•­ìƒ í™œì„±í™”
                              myRematchBtn.textContent = 'ì¤€ë¹„ì™„ë£Œ! âœ“';
                          } else {
                              myRematchBtn.disabled = false;
                              myRematchBtn.textContent = 'ë‹¤ì‹œí•˜ê¸°';
                          }
                      }
                      
                      // [ìˆ˜ì •] ëª¨ë‹¬ì´ ë‹«í˜€ìˆê±°ë‚˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¦¬ìŠ¤ë„ˆ ë¡œì§ ì¤‘ì§€
                      if (!snapshot.exists() || !currentRoomData || !currentRoomData.players || !gameOverOverlay.classList.contains('active')) {
                        return;
                      }

                      // (ê¸°ì¡´ ë¡œì§) ëª¨ë“  í”Œë ˆì´ì–´ê°€ ë™ì˜í–ˆëŠ”ì§€ ì²´í¬
                      const requestCount = Object.keys(requests).length;
                      
                      // [ìˆ˜ì •] ì „ì²´ í”Œë ˆì´ì–´ ìˆ˜ -> "ë°©ì— ë‚¨ì•„ìˆëŠ”" í”Œë ˆì´ì–´ ìˆ˜
                      const playerCountInRoom = playersInRoom.length;

                      // [ìˆ˜ì •] "ë°©ì— ë‚¨ì•„ìˆëŠ”" ëª¨ë“  í”Œë ˆì´ì–´ê°€ ë™ì˜í–ˆê³ , ë‚´ê°€ í˜¸ìŠ¤íŠ¸ë¼ë©´
                      if (playerCountInRoom >= 2 && requestCount === playerCountInRoom && isHost) {
                            if (rematchRef) rematchRef.off(); // [ìˆ˜ì •] ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                            rematchRef = null;
                            
                            // [ìˆ˜ì •] 'ì• ë‹ˆíŒ¡' ê²Œì„ ì¬ì‹œì‘ì„ ìœ„í•œ ìƒíƒœê°’ ì´ˆê¸°í™”
                            roomRef.update({
                                rematchRequests: null,
                                status: 'waiting',      // ë°© ìƒíƒœë¥¼ 'ëŒ€ê¸°'ë¡œ
                                // 'playing' ìƒíƒœì—ì„œ ìƒì„±ëœ ê²Œì„ ë°ì´í„° ì´ˆê¸°í™”
                                gameStarted: false, 
                                // (readyPlayersëŠ” 'waiting' ìƒíƒœì—ì„œ ë‹¤ì‹œ ì±„ì›Œì§)
                                readyPlayers: null     
                            });
                      }
                 });
            }

            // ------------------------------------
            // 5. [ì‹ ê·œ] í”¼ë²„ ì‹œìŠ¤í…œ í•¨ìˆ˜
            // ------------------------------------
            
            function updateFeverGaugeUI() {
                const fill = document.getElementById('fever-gauge-fill');
                if (fill) {
                    const percent = Math.min(100, (feverGauge / MAX_FEVER_GAUGE) * 100);
                    fill.style.width = `${percent}%`;
                }
            }

            function startFeverMode() {
                // [ìˆ˜ì •] í”¼ë²„ ëª¨ë“œ ëŒ€ì‹  'íŒ¡ì´' ìƒì„± ë¡œì§ìœ¼ë¡œ ë³€ê²½
                // if (isProcessing) return; // [ì œê±°] ì´ ë¼ì¸ì´ íŒ¡ì´ ìƒì„±ì„ ë§‰ê³  ìˆì—ˆìŒ
                
                console.log("ğŸ’£ 'íŒ¡ì´' ê²Œì´ì§€ ì™„ë£Œ! íŒ¡ì´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.");
                playSound('bomb-create-sound'); // [ì‹ ê·œ] íŒ¡ì´ ìƒì„± íš¨ê³¼ìŒ
                feverGauge = 0; // ê²Œì´ì§€ ì´ˆê¸°í™”
                updateFeverGaugeUI();

                // 1. ë³´ë“œì—ì„œ ë¹„ì–´ìˆì§€ ì•Šì€ ëœë¤í•œ íƒ€ì¼ ì°¾ê¸°
                const availableTiles = [];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        // ë ˆì¸ë³´ìš°ë‚˜ íŒ¡ì´ê°€ ì•„ë‹Œ ì¼ë°˜ íƒ€ì¼ë§Œ ëŒ€ìƒìœ¼ë¡œ í•¨
                        if (board[r][c] && board[r][c] !== RAINBOW_TILE && board[r][c] !== 'ğŸ’£') {
                            availableTiles.push({ r, c });
                        }
                    }
                }

                if (availableTiles.length === 0) return; // ìƒì„±í•  ê³³ ì—†ìŒ

                // 2. ëœë¤ íƒ€ì¼ í•˜ë‚˜ë¥¼ 'íŒ¡ì´'ë¡œ ë³€ê²½
                const target = availableTiles[Math.floor(Math.random() * availableTiles.length)];
                board[target.r][target.c] = 'ğŸ’£'; // íŒ¡ì´ ì´ëª¨ì§€ (ë°ì´í„° ë³€ê²½)
                
                const tileElement = tileElements[target.r][target.c];
                setTileAppearance(tileElement, 'ğŸ’£'); // [ìˆ˜ì •]
                tileElement.classList.add('new-tile-anim'); // ìƒì„± ì• ë‹ˆë©”ì´ì…˜

                // 3. "íŒ¡ì´ ìƒì„±!" í…ìŠ¤íŠ¸ í‘œì‹œ
                const pangiText = document.createElement('div');
                pangiText.className = 'combo-text'; // [ìˆ˜ì •] feverText -> pangiText
                pangiText.textContent = 'ğŸ’£ íŒ¡ì´ ìƒì„±! ğŸ’£'; // [ìˆ˜ì •] í…ìŠ¤íŠ¸ ë³€ê²½
                pangiText.style.top = '50%';
                pangiText.style.left = '50%';
                pangiText.style.transform = 'translate(-50%, -50%)';
                gameWrapper.appendChild(pangiText); // [ìˆ˜ì •] feverText -> pangiText
                setTimeout(() => pangiText.remove(), 1000); // [ìˆ˜ì •] feverText -> pangiText

            }

            // [ì‹ ê·œ] 15ì½¤ë³´ ë‹¬ì„± ì‹œ "ì§„ì§œ" í”¼ë²„ ëª¨ë“œë¥¼ ë°œë™ì‹œí‚¤ëŠ” í•¨ìˆ˜
            function triggerActualFeverMode() {
                if (isFeverMode) return; // ì¤‘ë³µ ë°©ì§€

                console.log("ğŸ”¥ 15ì½¤ë³´ ë‹¬ì„±! í”¼ë²„ ëª¨ë“œ ë°œë™!");
                isFeverMode = true;
                gameBoard.classList.add('fever-active');
                gameAreaFrameEl.classList.add('fever-active');
                gameContainer.classList.add('fever-active'); // [ì‹ ê·œ] ê²Œì„ ì»¨í…Œì´ë„ˆ(ë’·ë°°ê²½) í™œì„±í™”

                // "FEVER!" í…ìŠ¤íŠ¸ í‘œì‹œ
                const feverText = document.createElement('div');
                feverText.className = 'combo-text';
                feverText.textContent = 'ğŸ”¥ FEVER! ğŸ”¥';
                feverText.style.top = '50%';
                feverText.style.left = '50%';
                feverText.style.transform = 'translate(-50%, -50%)';
                gameWrapper.appendChild(feverText);
                setTimeout(() => feverText.remove(), 1000); // 1ì´ˆ ë’¤ ì œê±°

                // [ì¤‘ìš”] 5ì´ˆ ë’¤ì— í”¼ë²„ ì¢…ë£Œ
                if (feverTimerId) clearTimeout(feverTimerId); // í˜¹ì‹œ ëª¨ë¥¼ íƒ€ì´ë¨¸ ì œê±°
                feverTimerId = setTimeout(endFeverMode, FEVER_DURATION);
            }


            function endFeverMode() {
                console.log("...í”¼ë²„ ëª¨ë“œ ì¢…ë£Œ.");
                isFeverMode = false;
                feverTimerId = null;
                gameBoard.classList.remove('fever-active');
                gameAreaFrameEl.classList.remove('fever-active'); // [ì‹ ê·œ] ê²Œì„ í”„ë ˆì„ ì´í™íŠ¸ ì œê±°
                gameContainer.classList.remove('fever-active'); // [ì‹ ê·œ] ê²Œì„ ì»¨í…Œì´ë„ˆ(ë’·ë°°ê²½) ë¹„í™œì„±í™”
                // (í•„ìš”ì‹œ) "FEVER END" í…ìŠ¤íŠ¸
            }
            // ------------------------------------
            // 5. ì»¨íŠ¸ë¡¤ (ë“œë˜ê·¸) (ìˆ˜ì •)
            // ------------------------------------

            function handleDragStart(e) {
                if (isProcessing) return;
                unlockAudioOnFirstTap();
                stopHintTimer(); // [ì‹ ê·œ] íŒíŠ¸ íƒ€ì´ë¨¸ ì¦‰ì‹œ ì¤‘ì§€
                // [ìˆ˜ì •] "ê³ ìŠ¤íŠ¸ í„°ì¹˜" í•´ê²°: e.currentTarget ëŒ€ì‹  datasetìœ¼ë¡œ ì¢Œí‘œ ì°¾ê¸°
                const row = parseInt(e.currentTarget.dataset.row, 10);
                const col = parseInt(e.currentTarget.dataset.col, 10);

                // [ìˆ˜ì •] tileElementsì—ì„œ DOM ìš”ì†Œë¥¼ ë‹¤ì‹œ ì°¸ì¡°
                const tile = tileElements[row][col]; 
                
                if (!tile) {
                    console.error("ê³ ìŠ¤íŠ¸ í„°ì¹˜ ë°©ì§€: íƒ€ì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ", row, col);
                    return;
                }

                dragStartTile = { row: row, col: col, el: tile };
                dragStartX = e.clientX || (e.touches && e.touches[0].clientX);
                dragStartY = e.clientY || (e.touches && e.touches[0].clientY);
                window.addEventListener('pointerup', handleDragEnd, { once: true });
                window.addEventListener('pointercancel', handleDragEnd, { once: true });
            }

            function handleDragEnd(e) {
                if (!dragStartTile) return;
                const dragEndX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
                const dragEndY = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
                const deltaX = dragEndX - dragStartX;
                const deltaY = dragEndY - dragStartY;
                const threshold = dragStartTile.el.clientWidth / 3; 
                let targetRow = dragStartTile.row;
                let targetCol = dragStartTile.col;

                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {
                    targetCol += (deltaX > 0) ? 1 : -1;
                } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > threshold) {
                    targetRow += (deltaY > 0) ? 1 : -1;
                } else {
                    dragStartTile = null; return;
                }
                if (targetRow < 0 || targetRow >= ROWS || targetCol < 0 || targetCol >= COLS) {
                    dragStartTile = null; return;
                }
                attemptSwap(dragStartTile.row, dragStartTile.col, targetRow, targetCol);
                dragStartTile = null;
            }

            // ------------------------------------
            // 6. ê²Œì„ ë¡œì§ (ìˆ˜ì •)
            // ------------------------------------
            
         async function attemptSwap(r1, c1, r2, c2) {
    if (isProcessing) return;
    isProcessing = true;

    playSound('swap'); // [ìˆ˜ì •] í•œê¸€ 'ìŠ¤ì™‘' -> ì˜ì–´ 'swap' (íŒŒì¼ ì›ë¬¸ ê¸°ì¤€)
    
    // [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ (ì–¼ìŒ) ìŠ¤ì™‘ ë°©ì§€
    if (board[r1][c1] === JUNK_TILE || board[r2][c2] === JUNK_TILE) {
        // [ë²„ê·¸ ìˆ˜ì •] animateInvalidSwapì„ í˜¸ì¶œí•˜ë©´ ë°ì´í„°(board)ê°€ ê¼¬ì„.
        // ë°ì´í„°/DOM ìŠ¤ì™‘ ì—†ì´ 'í”ë“¤ë¦¼' ì• ë‹ˆë©”ì´ì…˜ë§Œ ì‹¤í–‰í•©ë‹ˆë‹¤.
        if (!isFeverMode) { // í”¼ë²„ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ í”ë“¤ë¦¼
            const tile1 = tileElements[r1][c1]; 
            const tile2 = tileElements[r2][c2]; 
            tile1.classList.add('invalid');
            tile2.classList.add('invalid');
            await new Promise(resolve => setTimeout(resolve, 400)); // 400ms ëŒ€ê¸°
            tile1.classList.remove('invalid');
            tile2.classList.remove('invalid');
        }
        
        startHintTimer(); // [ì¶”ê°€] íŒíŠ¸ íƒ€ì´ë¨¸ ë‹¤ì‹œ ì‹œì‘
        isProcessing = false;
        return;
    }
    // [ì‹ ê·œ] 1. íŠ¹ìˆ˜ íƒ€ì¼ ìŠ¤ì™‘ì„ ëª¨ë‘ ì—¬ê¸°ì„œ ë¨¼ì € í™•ì¸
    const tile1 = board[r1][c1];
    const tile2 = board[r2][c2];
    
    // 1a. ğŸ’£ íŒ¡ì´(í­íƒ„) + íŒ¡ì´(í­íƒ„) ìŠ¤ì™‘ [ğŸ”¥ ì‹ ê·œ ë¡œì§]
    if (tile1 === 'ğŸ’£' && tile2 === 'ğŸ’£') {
        await handleDoublePangiExplosion(r1, c1, r2, c2);
        isProcessing = false;
        return;
    }
    
    // 1b. â­ï¸ ë³„ íŒ¡ì´ + ë³„ íŒ¡ì´ ìŠ¤ì™‘ [ğŸ”¥ ì‹ ê·œ ë¡œì§]
    if (tile1 === 'star' && tile2 === 'star') {
        await handleDoubleStarPangiExplosion(r1, c1, r2, c2);
        isProcessing = false;
        return;
    }
    
    // 1c. íŒ¡ì´(í­íƒ„) ìŠ¤ì™‘ (ì¼ë°˜ íƒ€ì¼ê³¼ì˜ ìŠ¤ì™‘, ê¸°ì¡´ ë¡œì§)
    if (tile1 === 'ğŸ’£') {
        await handlePangiExplosion(r1, c1);
        isProcessing = false;
        return;
    }
    if (tile2 === 'ğŸ’£') {
        await handlePangiExplosion(r2, c2);
        isProcessing = false;
        return;
    }

    // 1d. ë³„ íŒ¡ì´ ìŠ¤ì™‘ (ì¼ë°˜ íƒ€ì¼ê³¼ì˜ ìŠ¤ì™‘, ê¸°ì¡´ ë¡œì§)
    if (tile1 === 'star') {
        await handleStarPangiExplosion(r1, c1);
        isProcessing = false;
        return;
    }
    if (tile2 === 'star') {
        await handleStarPangiExplosion(r2, c2);
        isProcessing = false;
        return;
    }
    
    // 1e. ë ˆì¸ë³´ìš° + ì¼ë°˜ ìŠ¤ì™‘ (ê¸°ì¡´ ë¡œì§)
    if (tile1 === RAINBOW_TILE && tile2 !== RAINBOW_TILE) {
        await handleRainbowSwap(r1, c1, tile2);
        isProcessing = false;
        return;
    }
    if (tile2 === RAINBOW_TILE && tile1 !== RAINBOW_TILE) {
        await handleRainbowSwap(r2, c2, tile1);
        isProcessing = false;
        return;
    }
    
    // 1f. ë ˆì¸ë³´ìš° + ë ˆì¸ë³´ìš° ìŠ¤ì™‘ (ê¸°ì¡´ ë¡œì§)
    if (tile1 === RAINBOW_TILE && tile2 === RAINBOW_TILE) {
        await handleDoubleRainbow(r1, c1, r2, c2);
        isProcessing = false;
        return;
    }
    
// 2. ì¼ë°˜ ìŠ¤ì™‘ ë¡œì§
    swapData(r1, c1, r2, c2);
    await animateSwap(r1, c1, r2, c2);
    // [ì‹ ê·œ] ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ì¹´ìš´íŠ¸ ì¦ê°€
    perfectPlayCount++;
    console.log(`í¼í™íŠ¸ í”Œë ˆì´ ì¹´ìš´íŠ¸: ${perfectPlayCount}/${PERFECT_PLAY_COUNT}`);
    if (perfectPlayCount >= PERFECT_PLAY_COUNT) {
        console.log("ğŸ¯ PERPECT PLAY! +", PERFECT_PLAY_BONUS);
        score += PERFECT_PLAY_BONUS;
        playSound('bomb-create-sound'); // [ìš”ì²­] 'íŒ¡ì´ ìƒì„±' ì‚¬ìš´ë“œ ì¬í™œìš©
        showPerfectPlayText(PERFECT_PLAY_BONUS);
        perfectPlayCount = 0; // ë³´ë„ˆìŠ¤ ë°›ê³  ì´ˆê¸°í™”
    }
    // [ì‹ ê·œ] ğŸ§  ë©€í‹°-ë§¤ì¹˜ ë³´ë„ˆìŠ¤
    // (ë°©í•´ íƒ€ì¼ íŒì • 'ì „ì—' ë©€í‹°-ë§¤ì¹˜ ë³´ë„ˆìŠ¤ë¥¼ ë¨¼ì € ê²€ì‚¬)
    if (checkMultiMatch(r1, c1, r2, c2)) {
        console.log("ğŸ§  MULTI-MATCH! +", MULTI_MATCH_BONUS);
        score += MULTI_MATCH_BONUS;
        playSound('rainbow-sound'); // [ìš”ì²­] 'ë¬´ì§€ê°œ' ì‚¬ìš´ë“œ ì¬í™œìš©
        showMultiMatchText(r1, c1, MULTI_MATCH_BONUS); // ìƒˆ í…ìŠ¤íŠ¸ í•¨ìˆ˜
    }
    // [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ (ê³µê²© íŒì •)
    // (findAllMatchesë³´ë‹¤ ë¨¼ì €, ìŠ¤ì™‘ ì§í›„ì˜ ë³´ë“œë¥¼ ê²€ì‚¬í•´ì•¼ í•¨)
    const attackCount = checkPlayerAttack(r1, c1, r2, c2);
    if (attackCount > 0) {
        sendJunkAttack(attackCount); // ìƒëŒ€ì—ê²Œ ê³µê²© ì „ì†¡
    }
    const matchData = findAllMatches();
            
    if (matchData.matches.size > 0) {
        // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
                if (comboTimerId) {
                    // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
                    clearTimeout(comboTimerId);
                    comboTimerId = null;
                    // ì½¤ë³´ëŠ” ìœ ì§€ë©ë‹ˆë‹¤. (1ë²ˆì—ì„œ ì¶”ê°€í•œ processMatchesAndCascadeì˜ currentCombo++ê°€ 1 ì˜¬ë ¤ì¤Œ)
                    console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
                } else {
                    // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
                    currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (processMatchesAndCascadeê°€ 1ë¡œ ë§Œë“¦)
                }
        if (isFeverMode) {
            // í”¼ë²„ ëª¨ë“œ
            console.log("ğŸ”¥ í”¼ë²„ ëª¨ë“œ: ì½¤ë³´ ì¦‰ì‹œ í•´ì œ!");
            runCascade(matchData);
            isProcessing = false;
        } else {
            // ì¼ë°˜ ëª¨ë“œ
            await runCascade(matchData);
            isProcessing = false;
        }
    } else {
        // ë§¤ì¹­ ì‹¤íŒ¨
        // [ì‹ ê·œ] ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ì´ˆê¸°í™”
        if (perfectPlayCount > 0) {
            console.log("ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ì‹¤íŒ¨. ì¹´ìš´íŠ¸ 0ìœ¼ë¡œ ì´ˆê¸°í™”.");
            perfectPlayCount = 0;
        }
        await animateInvalidSwap(r1, c1, r2, c2); 
        isProcessing = false;
    }
}

// [ì‹ ê·œ] í˜¸ìŠ¤íŠ¸ê°€ "ëŒ€ê¸°ì‹¤ë¡œ"ë¥¼ ëˆ„ë¥¼ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
async function hostReturnToGameLobby(playersData, gameType) {
    if (!isHost || !playersData || !gameType || !playerUid || !roomRef) {
        console.error("hostReturnToGameLobby: í•„ìˆ˜ ë°ì´í„° ëˆ„ë½");
        cleanupAndExit();
        return;
    }

    console.log("ë°©ì¥ì´ ê²Œì„ë°©.htmlë¡œ ë³µê·€í•©ë‹ˆë‹¤. ëª¨ë“  ì¸ì›ì´ í•¨ê»˜ ì´ë™í•©ë‹ˆë‹¤...");
    isExiting = true;
    stopSound('bgm');
    if (timerId) clearInterval(timerId);
    if (feverTimerId) clearTimeout(feverTimerId);

    try {
        // 1. ë°© ìƒíƒœë¥¼ 'lobby'ë¡œ ë³€ê²½ (ê²Œì„ë°©.htmlì—ì„œ ìë™ ì •ë¦¬)
        await roomRef.update({
            status: 'lobby',
            // ê²Œì„ ê´€ë ¨ ë°ì´í„° ì´ˆê¸°í™”
            gameStarted: false,
            readyPlayers: null,
            rematchRequests: null,
            attacks: null
        });

        console.log("ë°© ìƒíƒœë¥¼ 'lobby'ë¡œ ë³€ê²½ ì™„ë£Œ. ê²Œì„ë°©.htmlë¡œ ì´ë™.");
        
        // [### 1. onDisconnect í•¸ë“¤ëŸ¬ ìˆ˜ë™ ì·¨ì†Œ (í•µì‹¬) ###]
        if (isHost && hostStatusDisconnectRef) {
            try {
                hostStatusDisconnectRef.cancel();
                hostStatusDisconnectRef = null;
                console.log("Host onDisconnect.cancel() í˜¸ì¶œë¨.");
            } catch (e) { console.warn("Host onDisconnect.cancel() ì‹¤íŒ¨:", e); }
        }

        // [### 2. ë¦¬ìŠ¤ë„ˆ ë„ê¸° ###]
        // [ìˆ˜ì •] ì •í™•í•œ ë¦¬ìŠ¤ë„ˆ ì°¸ì¡°ë¡œ ë„ê¸°
        if (roomRef) roomRef.off('value', roomValueListener); 
        if (chatListenerRef) chatListenerRef.off();
        if (rematchRef) rematchRef.off(); // 'ë‹¤ì‹œí•˜ê¸°' ë¦¬ìŠ¤ë„ˆë„ ì¢…ë£Œ

        // [### 3. URL ë²„ê·¸ ìˆ˜ì • (newRoomId -> roomRef.key) ###]
        // ğŸš¨ hostCleanupAndCreateNewRoom í•¨ìˆ˜ì—ì„œ newRoomIdë¥¼ ì°¸ì¡°í•˜ë˜ ë²„ê·¸ ìˆ˜ì •
        window.location.replace(`ê²Œì„ë°©.html?roomId=${roomRef.key}`);

    } catch (error) {
        console.error("ë°© ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:", error);
        cleanupAndExit(); // ì‹¤íŒ¨ ì‹œ ì¼ë°˜ ë‚˜ê°€ê¸°
    }
}

// [ì‹ ê·œ] ê²ŒìŠ¤íŠ¸ê°€ "ëŒ€ê¸°ì‹¤ë¡œ"ë¥¼ ëˆ„ë¥¼ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
async function guestHandleReturn(playersData) { // [ìˆ˜ì •] async ì¶”ê°€
    if (!playersData || !roomRef || !playerUid) {
        console.error("guestHandleReturn: í•„ìˆ˜ ë°ì´í„° ëˆ„ë½");
        cleanupAndExit(); // Fallback
        return;
    }

    const totalPlayers = Object.keys(playersData).length;

   if (totalPlayers === 2) {
        // 2ëª… ë°©: ê²ŒìŠ¤íŠ¸ë„ ê²Œì„ë°©.htmlë¡œ ì´ë™ (ë°©ì¥ê³¼ í•¨ê»˜)
        console.log("2ëª… ë°©: ê²ŒìŠ¤íŠ¸ë„ ê²Œì„ë°©.htmlë¡œ ì´ë™í•©ë‹ˆë‹¤. (Hostë„ ì´ë™í•˜ë„ë¡ status: 'lobby' ì„¤ì •)");

        try {
            // [ì‹ ê·œ] ë°©ì¥ë„ ì´ë™ì‹œí‚¤ê¸° ìœ„í•´ status: 'lobby'ë¡œ ë³€ê²½
            await roomRef.update({
                status: 'lobby',
                gameStarted: false,
                readyPlayers: null,
                rematchRequests: null,
                attacks: null
            });
        } catch (error) {
            console.error("2ëª… ë°©(Guest) 'lobby' ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:", error);
        }

        isExiting = true;
        stopSound('bgm');
        if (timerId) clearInterval(timerId);
        if (feverTimerId) clearTimeout(feverTimerId);
        
        // [### 1. onDisconnect í•¸ë“¤ëŸ¬ ìˆ˜ë™ ì·¨ì†Œ (í•µì‹¬) ###]
        if (playerRef) { // (playerRefëŠ” ì „ì—­ì— ì„ ì–¸ë˜ì–´ ìˆìŒ)
            try {
                playerRef.onDisconnect().cancel();
                console.log("Guest (2p) onDisconnect.cancel() í˜¸ì¶œë¨.");
            } catch (e) { console.warn("Guest (2p) onDisconnect.cancel() ì‹¤íŒ¨:", e); }
        }

        // [### 2. ë¦¬ìŠ¤ë„ˆ ë„ê¸° ###]
        if (roomRef) roomRef.off('value', roomValueListener);
        if (chatListenerRef) chatListenerRef.off();
        if (rematchRef) rematchRef.off(); // 'ë‹¤ì‹œí•˜ê¸°' ë¦¬ìŠ¤ë„ˆë„ ì¢…ë£Œ
        
        // [### 3. ê²Œì„ë°©.htmlë¡œ ì´ë™ ###]
        window.location.replace(`ê²Œì„ë°©.html?roomId=${roomRef.key}`);
    
    } else {
        // 3~4ëª… ë°©: ê²ŒìŠ¤íŠ¸ ë³¸ì¸ë§Œ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ í›„ "ê²Œì„ë°©.html"ë¡œ ë‚˜ê°
        console.log(`${totalPlayers}ëª… ë°©: ê²ŒìŠ¤íŠ¸ë§Œ ê²Œì„ë°©.htmlë¡œ ë‚˜ê°‘ë‹ˆë‹¤. (ë‚˜ë¨¸ì§€ ì¸ì› ìœ ì§€)`);
        
        isExiting = true; 
        stopSound('bgm'); 
        if (timerId) clearInterval(timerId);
        if (feverTimerId) clearTimeout(feverTimerId);
        
        // [ìˆ˜ì •] playerRefê°€ ìˆëŠ”ì§€ í™•ì¸
        if (playerRef) {
            const playerOnDisconnect = playerRef.onDisconnect();
            if (playerOnDisconnect) { 
                try { playerOnDisconnect.cancel(); } catch(e) { console.warn("Player onDisconnect cancel failed:", e); } 
            }
        }

        let removePromise = Promise.resolve(); 

        if (roomRef && playerUid) {
            // [ìˆ˜ì •] ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
            if (roomRef) roomRef.off('value', roomValueListener);
            if (chatListenerRef) chatListenerRef.off();
            if (rematchRef) rematchRef.off();

            // 'players' ëª©ë¡ì—ì„œ ë³¸ì¸ë§Œ ì œê±°
            console.log("Guest (3-4p) removing self from players...");
            removePromise = roomRef.child('players/' + playerUid).remove();
        }

        // Firebaseì—ì„œ ì œê±°ê°€ ì™„ë£Œë˜ë©´ ë¦¬ë””ë ‰ì…˜
        removePromise
            .catch(e => console.error("Firebase 'players' ë…¸ë“œ ì œê±° ì‹¤íŒ¨:", e))
            .finally(() => {
                // ëŒ€ê¸°ì‹¤.htmlì´ ì•„ë‹Œ ê²Œì„ë°©.htmlë¡œ ë¦¬ë””ë ‰ì…˜
                console.log(`Redirecting to ê²Œì„ë°©.html?roomId=${currentRoomId}`); 
                window.location.replace(`ê²Œì„ë°©.html?roomId=${currentRoomId}`);
            });
    }
}


// ë ˆì¸ë³´ìš° íƒ€ì¼ê³¼ ì¼ë°˜ íƒ€ì¼ êµí™˜ (í•´ë‹¹ ìƒ‰ìƒ ì „ì²´ ì œê±°)
async function handleRainbowSwap(rainbowRow, rainbowCol, targetColor) {
   // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
    playExplosionVFX(); // [ì‹ ê·œ] ìŠ¤í¬ë¦° ì‰ì´í¬ + í”Œë˜ì‹œ
    const matchingTiles = new Set();
    
    // ë³´ë“œì—ì„œ targetColorì™€ ê°™ì€ ìƒ‰ìƒì˜ ëª¨ë“  íƒ€ì¼ ì°¾ê¸°
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (board[r][c] === targetColor) {
                matchingTiles.add(`${r}-${c}`);
            }
        }
    }
    
    // ë ˆì¸ë³´ìš° íƒ€ì¼ë„ ì œê±°
    matchingTiles.add(`${rainbowRow}-${rainbowCol}`);
    
    const scoreMultiplier = isFeverMode ? 1.5 : 1.0;
    const baseScore = matchingTiles.size * 50;
    const comboBonus = currentCombo * 20;
    const turnScore = Math.round((baseScore + comboBonus + RAINBOW_BONUS) * scoreMultiplier);
    
    score += turnScore;
    
    showRainbowExplosion(rainbowRow, rainbowCol, targetColor);
    showComboText(currentCombo, matchingTiles);
    showComboScore(turnScore);
    
    // [ìˆ˜ì •] ì´ ë¶€ë¶„ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.
    if (!isFeverMode) {
        const gaugeGain = matchingTiles.size * 1.5;
        feverGauge = Math.min(MAX_FEVER_GAUGE, feverGauge + gaugeGain);
        updateFeverGaugeUI();
        if (feverGauge >= MAX_FEVER_GAUGE) {
            startFeverMode();
        }
    }
    
    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    playComboSound(currentCombo);
    
    await animatePop(matchingTiles);
    removeMatches(matchingTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();
    
    // [í•µì‹¬ ìˆ˜ì •] ì´ ë¶€ë¶„ì´ í”¼ë²„ëª¨ë“œ/ì¼ë°˜ëª¨ë“œë¡œ ë¶„ê¸°ë©ë‹ˆë‹¤.
    if (isFeverMode) {
        // í”¼ë²„ ëª¨ë“œ: ì• ë‹ˆë©”ì´ì…˜/ì½¤ë³´ë¥¼ 'ì‹œì‘'ë§Œ ì‹œí‚´ (await ì•ˆí•¨)
        animateDrops(droppedTilesMap, newTilesMap); // [ìˆ˜ì •] await ì œê±°
        
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            runCascade(newMatchData); // [ìˆ˜ì •] await ì œê±°, ë˜í¼ í•¨ìˆ˜ ì‚¬ìš©
        } else {
            currentCombo = 0;
            if (!checkForPossibleMoves()) {
                handleNoMoreMoves(); // (await ì—†ìŒ)
            }
        }
    } else {
        // ì¼ë°˜ ëª¨ë“œ: (ê¸°ì¡´ ë¡œì§)
        await animateDrops(droppedTilesMap, newTilesMap);
        
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
            await runCascade(newMatchData); // [ìˆ˜ì •] ë˜í¼ í•¨ìˆ˜ ì‚¬ìš©
        } else {
            currentCombo = 0;
            if (!checkForPossibleMoves()) {
                await handleNoMoreMoves();
            }
        }
    }
}

// [ì‹ ê·œ] â­ï¸ ë³„ íŒ¡ì´ 2ê°œ êµí™˜ (ë³´ë“œ ì „ì²´ ì œê±°)
async function handleDoubleStarPangiExplosion(r1, c1, r2, c2) {
    // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
    playExplosionVFX(); 
    playSound('victory'); // ìŠ¹ë¦¬ ì‚¬ìš´ë“œì™€ ë¹„ìŠ·í•œ ê°•ë ¥í•œ íš¨ê³¼ìŒ ì‚¬ìš©
    
    const allTiles = new Set();
    
    // ë³´ë“œì˜ ëª¨ë“  íƒ€ì¼ ì œê±°
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (board[r][c]) {
                allTiles.add(`${r}-${c}`);
            }
        }
    }
    
    const DOUBLE_STAR_BONUS = 5000; // [ì‹ ê·œ] ë³´ë„ˆìŠ¤ 5000ì 
    const scoreMultiplier = 1.0; 
    const baseScore = allTiles.size * 100;
    const turnScore = Math.round((baseScore + DOUBLE_STAR_BONUS) * scoreMultiplier);
    
    score += turnScore;
    
    // [ì‹ ê·œ] ë”ë¸” ë ˆì¸ë³´ìš° ì´í™íŠ¸ ì¬í™œìš©
    showDoubleRainbowEffect(r1, c1, r2, c2); 
    showComboScore(turnScore);
    
    // [ì‹ ê·œ] í”¼ë²„ ê²Œì´ì§€ ê°•ì œ ë°œë™ ë¡œì§ ì œê±° (ë”ë¸” ìŠ¤íƒ€ëŠ” í•œ ë²ˆì— ê²Œì„ ì˜¤ë²„ê¸‰)
    // feverGauge = MAX_FEVER_GAUGE;
    // updateFeverGaugeUI();
    // startFeverMode();

    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    
    await animatePop(allTiles);
    removeMatches(allTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();
    
    // í›„ì²˜ë¦¬ ë¡œì§ (ë”ë¸” ë ˆì¸ë³´ìš° ë¡œì§ ì¬í™œìš©)
    if (isFeverMode) {
        animateDrops(droppedTilesMap, newTilesMap);
        currentCombo = 0;
        if (!checkForPossibleMoves()) { handleNoMoreMoves(); }
    } else {
        await animateDrops(droppedTilesMap, newTilesMap);
        currentCombo = 0;
        if (!checkForPossibleMoves()) { await handleNoMoreMoves(); }
    }
}

// ë ˆì¸ë³´ìš° íƒ€ì¼ 2ê°œ êµí™˜ (ë³´ë“œ ì „ì²´ ì œê±°)
async function handleDoubleRainbow(r1, c1, r2, c2) {

    // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
    playExplosionVFX(); // [ì‹ ê·œ] ìŠ¤í¬ë¦° ì‰ì´í¬ + í”Œë˜ì‹œ
    const allTiles = new Set();
    
    // ë³´ë“œì˜ ëª¨ë“  íƒ€ì¼ ì œê±°
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (board[r][c]) {
                allTiles.add(`${r}-${c}`);
            }
        }
    }
    
    const scoreMultiplier = isFeverMode ? 1.5 : 1.0;
    const baseScore = allTiles.size * 100;
    const turnScore = Math.round((baseScore + RAINBOW_BONUS * 3) * scoreMultiplier);
    
    score += turnScore;
    
    showDoubleRainbowEffect(r1, c1, r2, c2);
    showComboScore(turnScore);
    
    if (!isFeverMode) {
        feverGauge = MAX_FEVER_GAUGE;
        updateFeverGaugeUI();
        startFeverMode();
    }
    
    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    
    await animatePop(allTiles);
    removeMatches(allTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();
    
    if (isFeverMode) {
        // í”¼ë²„ ëª¨ë“œ: (await ì•ˆí•¨)
        animateDrops(droppedTilesMap, newTilesMap); // [ìˆ˜ì •] await ì œê±°
        currentCombo = 0;
        if (!checkForPossibleMoves()) {
            handleNoMoreMoves(); // [ìˆ˜ì •] await ì œê±°
        }
    } else {
        // ì¼ë°˜ ëª¨ë“œ: (ê¸°ì¡´ ë¡œì§)
        await animateDrops(droppedTilesMap, newTilesMap);
        currentCombo = 0;
        if (!checkForPossibleMoves()) {
            await handleNoMoreMoves();
        }
    }
}

// ë ˆì¸ë³´ìš° íƒ€ì¼ ìƒì„± ì‹œ íš¨ê³¼
function showRainbowEffect(rainbowTiles) {
    rainbowTiles.forEach(({ row, col }) => {
        if (!tileElements[row] || !tileElements[row][col]) return;
        
        const tile = tileElements[row][col];
        const rect = tile.getBoundingClientRect();
        const boardRect = gameBoard.getBoundingClientRect();
        const wrapperRect = gameWrapper.getBoundingClientRect();
        
        const centerTop = (rect.top - boardRect.top) + (rect.height / 2) + boardRect.top - wrapperRect.top;
        const centerLeft = (rect.left - boardRect.left) + (rect.width / 2) + boardRect.left - wrapperRect.left;
        
        // ë¬´ì§€ê°œ ë¹› íš¨ê³¼
        const rainbow = document.createElement('div');
        rainbow.style.position = 'absolute';
        rainbow.style.top = `${centerTop}px`;
        rainbow.style.left = `${centerLeft}px`;
        rainbow.style.width = '60px';
        rainbow.style.height = '60px';
        rainbow.style.borderRadius = '50%';
        rainbow.style.background = 'conic-gradient(from 0deg, red, orange, yellow, green, blue, indigo, violet, red)';
        rainbow.style.transform = 'translate(-50%, -50%) scale(0)';
        rainbow.style.pointerEvents = 'none';
        rainbow.style.zIndex = '150';
        rainbow.style.animation = 'rainbow-burst 0.6s ease-out forwards';
        rainbow.style.boxShadow = '0 0 30px rgba(255,255,255,0.8)';
        
        gameWrapper.appendChild(rainbow);
        setTimeout(() => rainbow.remove(), 600);
        
        const rainbowText = document.createElement('div');
        rainbowText.className = 'combo-text';
        rainbowText.textContent = 'ë ˆì¸ë³´ìš°ğŸŒˆ ';
        rainbowText.style.top = `${centerTop}px`;
        rainbowText.style.left = `${centerLeft}px`;
        rainbowText.style.transform = 'translate(-50%, -50%)';
        rainbowText.style.fontSize = '2.5em';
        rainbowText.style.background = 'linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet)';
        rainbowText.style.webkitBackgroundClip = 'text';
        rainbowText.style.webkitTextFillColor = 'transparent';
        
        gameWrapper.appendChild(rainbowText);
        setTimeout(() => rainbowText.remove(), 800);
    });
}

// ë ˆì¸ë³´ìš° íƒ€ì¼ ì‚¬ìš© ì‹œ ìƒ‰ìƒ ì œê±° íš¨ê³¼
function showRainbowExplosion(rainbowRow, rainbowCol, targetColor) {
    const tile = tileElements[rainbowRow][rainbowCol];
    if (!tile) return;
    
    const rect = tile.getBoundingClientRect();
    const boardRect = gameBoard.getBoundingClientRect();
    const wrapperRect = gameWrapper.getBoundingClientRect();
    
    const centerTop = (rect.top - boardRect.top) + (rect.height / 2) + boardRect.top - wrapperRect.top;
    const centerLeft = (rect.left - boardRect.left) + (rect.width / 2) + boardRect.left - wrapperRect.left;
    
    // ë¬´ì§€ê°œì—ì„œ í¼ì ¸ë‚˜ê°€ëŠ” íš¨ê³¼
    for (let i = 0; i < 20; i++) {
        setTimeout(() => {
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.top = `${centerTop}px`;
            particle.style.left = `${centerLeft}px`;
            particle.style.fontSize = '2em';
            particle.textContent = targetColor;
            particle.style.pointerEvents = 'none';
            particle.style.zIndex = '150';
            
            const angle = (Math.PI * 2 * i) / 20;
            const distance = 200;
            const targetX = Math.cos(angle) * distance;
            const targetY = Math.sin(angle) * distance;
            
            particle.style.animation = `particle-explode-${i} 0.8s ease-out forwards`;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes particle-explode-${i} {
                    0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    100% { transform: translate(calc(-50% + ${targetX}px), calc(-50% + ${targetY}px)) scale(0); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            gameWrapper.appendChild(particle);
            setTimeout(() => {
                particle.remove();
                style.remove();
            }, 800);
        }, i * 20);
    }
}
// [ì‹ ê·œ] ğŸ’£ íŒ¡ì´(í­íƒ„) 2ê°œ ìŠ¤ì™‘ ì²˜ë¦¬ í•¨ìˆ˜
async function handleDoublePangiExplosion(r1, c1, r2, c2) {
    // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
    playExplosionVFX();
    playSound('bomb-explode-sound'); // íŒ¡ì´ í­ë°œ íš¨ê³¼ìŒ

    const matchingTiles = new Set();
    
    // 1. ìŠ¤ì™‘ëœ ë‘ íŒ¡ì´ì˜ 2x2 ì˜ì—­ ê³„ì‚° (r_min, r_max, c_min, c_max)
    const r_min = Math.min(r1, r2);
    const r_max = Math.max(r1, r2);
    const c_min = Math.min(c1, c2);
    const c_max = Math.max(c1, c2);

    // 2. ê°€ë¡œ 2ì¤„ ëª¨ë‘ ì¶”ê°€ (r_min í–‰, r_max í–‰)
    for (let c = 0; c < COLS; c++) {
        if (board[r_min][c]) matchingTiles.add(`${r_min}-${c}`);
        if (board[r_max][c]) matchingTiles.add(`${r_max}-${c}`);
    }

    // 3. ì„¸ë¡œ 2ì¤„ ëª¨ë‘ ì¶”ê°€ (c_min ì—´, c_max ì—´)
    for (let r = 0; r < ROWS; r++) {
        if (board[r][c_min]) matchingTiles.add(`${r}-${c_min}`);
        if (board[r][c_max]) matchingTiles.add(`${r}-${c_max}`);
    }
    
    // 4. [ì‹ ê·œ] ë³´ë„ˆìŠ¤ ì ìˆ˜ ê³„ì‚°
    const DOUBLE_PANGI_BONUS = 3000;
    const scoreMultiplier = 1.0;
    const baseScore = matchingTiles.size * 50;
    const comboBonus = currentCombo * 20;
    const turnScore = Math.round((baseScore + comboBonus + DOUBLE_PANGI_BONUS) * scoreMultiplier);
    
    score += turnScore;
    
    showCrossExplosion([{ row: r1, col: c1 }, { row: r2, col: c2 }]); // ì´í™íŠ¸ ì¬í™œìš©
    showComboText(currentCombo, matchingTiles);
    showComboScore(turnScore);
    
    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    playComboSound(currentCombo);
    
    await animatePop(matchingTiles);
    removeMatches(matchingTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();

    // 5. í›„ì²˜ë¦¬ ë¡œì§ (í”¼ë²„/ì¼ë°˜ ëª¨ë“œ ë¶„ê¸°)
    if (isFeverMode) {
        animateDrops(droppedTilesMap, newTilesMap);
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) { runCascade(newMatchData); }
        else {
            const gracePeriod = getComboGracePeriod(currentCombo);
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => { currentCombo = 0; comboTimerId = null; }, gracePeriod); 
            startHintTimer(); 
            if (!checkForPossibleMoves()) { handleNoMoreMoves(); }
        }
    } else {
        await animateDrops(droppedTilesMap, newTilesMap);
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
            await runCascade(newMatchData);
        } else {
            const gracePeriod = getComboGracePeriod(currentCombo);
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => { currentCombo = 0; comboTimerId = null; }, gracePeriod); 
            startHintTimer(); 
            if (!checkForPossibleMoves()) { await handleNoMoreMoves(); }
        }
    }
}

// ë ˆì¸ë³´ìš° íƒ€ì¼ 2ê°œ êµí™˜ ì‹œ íš¨ê³¼
function showDoubleRainbowEffect(r1, c1, r2, c2) {
    const explosionText = document.createElement('div');
    explosionText.className = 'combo-text';
    explosionText.textContent = 'ë”ë¸”íŒ¡!!';
    explosionText.style.top = '50%';
    explosionText.style.left = '50%';
    explosionText.style.transform = 'translate(-50%, -50%)';
    explosionText.style.fontSize = '3em';
    explosionText.style.background = 'linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet)';
    explosionText.style.webkitBackgroundClip = 'text';
    explosionText.style.webkitTextFillColor = 'transparent';
    explosionText.style.animation = 'mega-rainbow 1s ease-out';
    
    gameWrapper.appendChild(explosionText);
    setTimeout(() => explosionText.remove(), 1000);
}

// [ì‹ ê·œ] ğŸ’£ íŒ¡ì´(í­íƒ„) í­ë°œ ì²˜ë¦¬ í•¨ìˆ˜
async function handlePangiExplosion(row, col) {
    // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
playSound('bomb-explode-sound'); // [ì‹ ê·œ] íŒ¡ì´ í­ë°œ íš¨ê³¼ìŒ
    const matchingTiles = new Set();
    const bottomRow = ROWS - 1; // ë§¨ ì•„ë«ì¤„

    // 1. íŒ¡ì´ ìì‹  ì¶”ê°€
    matchingTiles.add(`${row}-${col}`);

    // 2. íŒ¡ì´ì™€ ê°™ì€ "ì„¸ë¡œ ì¤„" ëª¨ë‘ ì¶”ê°€
    for (let r = 0; r < ROWS; r++) {
        if (board[r][col]) matchingTiles.add(`${r}-${col}`);
    }

    // 3. [ì‹ ê·œ] íŒ¡ì´ì™€ ê°™ì€ "ê°€ë¡œ ì¤„" ëª¨ë‘ ì¶”ê°€
    for (let c = 0; c < COLS; c++) {
        if (board[row][c]) matchingTiles.add(`${row}-${c}`);
    }

    // 4. "ë§¨ ì•„ë«ì¤„" ëª¨ë‘ ì¶”ê°€
    for (let c = 0; c < COLS; c++) {
        if (board[bottomRow][c]) matchingTiles.add(`${bottomRow}-${c}`);
    }
    
    // (ì ìˆ˜ ê³„ì‚°ì€ ë ˆì¸ë³´ìš°ì™€ ë¹„ìŠ·í•˜ê²Œ ì²˜ë¦¬)
    const scoreMultiplier = 1.0; // íŒ¡ì´ëŠ” í”¼ë²„ ëª¨ë“œì™€ ë¬´ê´€
    const baseScore = matchingTiles.size * 50;
    const comboBonus = currentCombo * 20;
    const turnScore = Math.round((baseScore + comboBonus + 1000) * scoreMultiplier); // íŒ¡ì´ ë³´ë„ˆìŠ¤ 1000ì 
    
    score += turnScore;
    
    // (ì´í™íŠ¸ëŠ” ì‹­ìê°€ í­ë°œ ì´í™íŠ¸ ì¬í™œìš©)
    // [ìˆ˜ì •] íŒ¡ì´ ìœ„ì¹˜ + ë§¨ ì•„ë«ì¤„ (íŒ¡ì´ì™€ ê°™ì€ col)ì— ì´í™íŠ¸ ë™ì‹œ í‘œì‹œ
    showCrossExplosion([{ row: row, col: col }, { row: bottomRow, col: col }]);
    showComboText(currentCombo, matchingTiles);
    showComboScore(turnScore);
    
    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    playComboSound(currentCombo);
    
    await animatePop(matchingTiles);
    removeMatches(matchingTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();
    // [í•µì‹¬ ìˆ˜ì •] ì´ ë¶€ë¶„ì´ í”¼ë²„ëª¨ë“œ/ì¼ë°˜ëª¨ë“œë¡œ ë¶„ê¸°ë©ë‹ˆë‹¤.
    if (isFeverMode) {
        // í”¼ë²„ ëª¨ë“œ: (await ì•ˆí•¨)
        animateDrops(droppedTilesMap, newTilesMap); // [ìˆ˜ì •] await ì œê±°
        
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            runCascade(newMatchData); // [ìˆ˜ì •] await ì œê±°, ë˜í¼ í•¨ìˆ˜ ì‚¬ìš©
        } else {
            // [ìˆ˜ì •] (ê¸°ì¡´ ì½¤ë³´ ë¦¬ì…‹ ë¡œì§) + await ì œê±°
            const gracePeriod = getComboGracePeriod(currentCombo);
            console.log(`ì½¤ë³´ ${currentCombo} ì¢…ë£Œ. ${gracePeriod}msê°„ ìœ ì§€...`);
            
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => {
                console.log("ì½¤ë³´ ìœ ì§€ì‹œê°„ ì¢…ë£Œ. ì½¤ë³´ ë¦¬ì…‹.");
                currentCombo = 0;
                comboTimerId = null;
            }, gracePeriod); 
            
            startHintTimer(); 
            
            if (!checkForPossibleMoves()) {
                handleNoMoreMoves(); // (await ì—†ìŒ)
            }
        }
    } else {
        // ì¼ë°˜ ëª¨ë“œ: (ê¸°ì¡´ ë¡œì§)
        await animateDrops(droppedTilesMap, newTilesMap);
        
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
            await runCascade(newMatchData); // [ìˆ˜ì •] ë˜í¼ í•¨ìˆ˜ ì‚¬ìš©
        } else {
            // [ìˆ˜ì •] (ê¸°ì¡´ ì½¤ë³´ ë¦¬ì…‹ ë¡œì§) + await ìœ ì§€
            const gracePeriod = getComboGracePeriod(currentCombo);
            console.log(`ì½¤ë³´ ${currentCombo} ì¢…ë£Œ. ${gracePeriod}msê°„ ìœ ì§€...`);
            
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => {
                console.log("ì½¤ë³´ ìœ ì§€ì‹œê°„ ì¢…ë£Œ. ì½¤ë³´ ë¦¬ì…‹.");
                currentCombo = 0;
                comboTimerId = null;
            }, gracePeriod); 
            
            startHintTimer(); 
            
            if (!checkForPossibleMoves()) {
                await handleNoMoreMoves(); // (await ìœ ì§€)
            }
        }
    }
}


// [ì‹ ê·œ] â­ï¸ ë³„ íŒ¡ì´ (3x3) í­ë°œ ì²˜ë¦¬ í•¨ìˆ˜
async function handleStarPangiExplosion(row, col) {
    // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
    if (comboTimerId) {
        // 2ì´ˆ íƒ€ì´ë¨¸ í™œì„± ì¤‘ -> ìŠ¤í”¼ë“œ ì½¤ë³´ ì„±ê³µ
        clearTimeout(comboTimerId);
        comboTimerId = null;
        console.log(`âš¡ SPEED COMBO! (í˜„ì¬ ${currentCombo}x)`);
    } else {
        // 2ì´ˆ íƒ€ì´ë¨¸ ë§Œë£Œ -> ìƒˆ ì½¤ë³´ ì‹œì‘
        currentCombo = 0; // 0ìœ¼ë¡œ ë¦¬ì…‹ (ì•„ë˜ currentCombo++ê°€ 1ë¡œ ë§Œë“¦)
    }
    currentCombo++; // [ì¤‘ìš”] íŠ¹ìˆ˜ íƒ€ì¼ ë°œë™ ì‹œ ì½¤ë³´ 1 ì¦ê°€
playSound('bomb-explode-sound'); // [ì‹ ê·œ] ë³„ íŒ¡ì´ í­ë°œ íš¨ê³¼ìŒ (ë™ì¼)
    const matchingTiles = new Set();
    
    // 1. [ìˆ˜ì •] (row, col)ì„ ì¤‘ì‹¬ìœ¼ë¡œ 5x5 ëŒ€í˜• í­ë°œ
    for (let r = row - 2; r <= row + 2; r++) {
        for (let c = col - 2; c <= col + 2; c++) {
            // ë³´ë“œ ë²”ìœ„ ì²´í¬
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                if (board[r][c]) { // nullì´ ì•„ë‹Œ íƒ€ì¼ë§Œ
                    matchingTiles.add(`${r}-${c}`);
                }
            }
        }
    }
    
    const scoreMultiplier = 1.0; // í”¼ë²„ì™€ ë¬´ê´€
    const baseScore = matchingTiles.size * 50; // 3x3 = 9 * 50 = 450
    const comboBonus = currentCombo * 20;
    const turnScore = Math.round((baseScore + comboBonus + 1500) * scoreMultiplier); // ë³„ íŒ¡ì´ ë³´ë„ˆìŠ¤ 1500ì 
    
    score += turnScore;
    
    // ì´í™íŠ¸ (ë³„ íŒ¡ì´ ì „ìš© ì¶©ê²©íŒŒ ì´í™íŠ¸ë¡œ ë³€ê²½)
    showStarExplosionVFX(row, col); // [ìˆ˜ì •] ì‹­ìê°€ -> ë³„ íŒ¡ì´ ì „ìš© ì´í™íŠ¸
    showComboText(currentCombo, matchingTiles);
    showComboScore(turnScore);
    
    updateScoreUI();
    if (playerRef) { playerRef.child('score').set(score); }
    playComboSound(currentCombo);
    
    await animatePop(matchingTiles);
    removeMatches(matchingTiles);
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();

    // [ìˆ˜ì •] í”¼ë²„/ì¼ë°˜ ëª¨ë“œ ë¶„ê¸° (íŒ¡ì´ ë¡œì§ê³¼ ë™ì¼)
    if (isFeverMode) {
        animateDrops(droppedTilesMap, newTilesMap);
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            runCascade(newMatchData);
        } else {
            const gracePeriod = getComboGracePeriod(currentCombo);
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => { currentCombo = 0; comboTimerId = null; }, gracePeriod); 
            startHintTimer(); 
            if (!checkForPossibleMoves()) { handleNoMoreMoves(); }
        }
    } else {
        await animateDrops(droppedTilesMap, newTilesMap);
        const newMatchData = findAllMatches();
        if (newMatchData.matches.size > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
            await runCascade(newMatchData);
        } else {
            const gracePeriod = getComboGracePeriod(currentCombo);
            if (comboTimerId) clearTimeout(comboTimerId);
            comboTimerId = setTimeout(() => { currentCombo = 0; comboTimerId = null; }, gracePeriod); 
            startHintTimer(); 
            if (!checkForPossibleMoves()) { await handleNoMoreMoves(); }
        }
    }
}

            function swapData(r1, c1, r2, c2) {
                const temp = board[r1][c1];
                board[r1][c1] = board[r2][c2];
                board[r2][c2] = temp;
            }
            // [ìˆ˜ì •] "ê³ ìŠ¤íŠ¸ í„°ì¹˜" í•´ê²°ì˜ í•µì‹¬ í•¨ìˆ˜
            // [ìˆ˜ì •] "ê³ ìŠ¤íŠ¸ í„°ì¹˜" ë° "ì˜ëª»ëœ ìŠ¤ì™‘" ë²„ê·¸ ìµœì¢… ìˆ˜ì •
            function swapDOMElements(r1, c1, r2, c2) {
                const tile1 = tileElements[r1][c1]; // (ì˜ˆ: El_A)
                const tile2 = tileElements[r2][c2]; // (ì˜ˆ: El_B)

                // 1. [í•µì‹¬ ìˆ˜ì •] ë‘ íƒ€ì¼ì˜ "ë™ë¬¼ í´ë˜ìŠ¤"ë¥¼ ì§ì ‘ êµí™˜í•©ë‹ˆë‹¤.
                // setTileAppearanceë¥¼ ì‚¬ìš©í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.
                
                // (1-1) tile1(El_A)ì—ì„œ ëª¨ë“  ë™ë¬¼ í´ë˜ìŠ¤ë¥¼ ì°¾ì•„ tile2(El_B)ì— ì¤ë‹ˆë‹¤.
                const tile1Classes = [];
                tile1.classList.forEach(c => {
                    // [ë²„ê·¸ ìˆ˜ì •] 'star', JUNK_TILE(junk) í´ë˜ìŠ¤ë„ êµí™˜ ëŒ€ìƒì— í¬í•¨
                    if (TILE_EMOJIS.includes(c) || c === 'rainbow' || c === 'bomb' || c === 'star' || c === JUNK_TILE) {
                        tile1Classes.push(c);
                    }
                });
                
                // (1-2) tile2(El_B)ì—ì„œ ëª¨ë“  ë™ë¬¼ í´ë˜ìŠ¤ë¥¼ ì°¾ì•„ tile1(El_A)ì— ì¤ë‹ˆë‹¤.
                const tile2Classes = [];
                tile2.classList.forEach(c => {
                    // [ë²„ê·¸ ìˆ˜ì •] 'star', JUNK_TILE(junk) í´ë˜ìŠ¤ë„ êµí™˜ ëŒ€ìƒì— í¬í•¨
                    if (TILE_EMOJIS.includes(c) || c === 'rainbow' || c === 'bomb' || c === 'star' || c === JUNK_TILE) {
                        tile2Classes.push(c);
                    }
                });

                // (1-3) í´ë˜ìŠ¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ì„œë¡œ êµì²´í•©ë‹ˆë‹¤.
                tile1.classList.remove(...tile1Classes);
                tile1.classList.add(...tile2Classes);
                
                tile2.classList.remove(...tile2Classes);
                tile2.classList.add(...tile1Classes);

                // 2. [í•µì‹¬ ìˆ˜ì •] DOM dataset ìŠ¤ì™‘ (ì´ì „ ìˆ˜ì •ì•ˆ ìœ ì§€)
                // tile1(El_A)ì€ (r2,c2)ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ datasetì„ (r2,c2)ë¡œ ì„¤ì •
                tile1.dataset.row = r2;
                tile1.dataset.col = c2;
                // tile2(El_B)ëŠ” (r1,c1)ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ datasetì„ (r1,c1)ë¡œ ì„¤ì •
                tile2.dataset.row = r1;
                tile2.dataset.col = c1;

                // 3. JS ë°°ì—´ ìŠ¤ì™‘ (íƒ€ì¼ ì°¸ì¡° ìŠ¤ì™‘)
                tileElements[r1][c1] = tile2;
                tileElements[r2][c2] = tile1;
            }
            function animateSwap(r1, c1, r2, c2) {
                const tile1 = tileElements[r1][c1];
                const tile2 = tileElements[r2][c2];
                tile1.classList.add('swap');
                tile2.classList.add('swap');
                const rect1 = tile1.getBoundingClientRect();
                const rect2 = tile2.getBoundingClientRect();
                const deltaX = rect1.left - rect2.left;
                const deltaY = rect1.top - rect2.top;
                tile1.style.transform = `translate(${-deltaX}px, ${-deltaY}px)`;
                tile2.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                return new Promise(resolve => {
                    setTimeout(() => {
                        tile1.style.transform = '';
                        tile2.style.transform = '';
                        tile1.classList.remove('swap');
                        tile2.classList.remove('swap');
                        swapDOMElements(r1, c1, r2, c2); // DOM, dataset, JSë°°ì—´ ë™ê¸°í™”
                        resolve();
                    }, 200); 
                });
            }
            async function animateInvalidSwap(r1, c1, r2, c2) {
                // [ì‹ ê·œ] í”¼ë²„ ëª¨ë“œê°€ "ì•„ë‹" ë•Œë§Œ í”ë“¤ë¦¼(shake) ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
                if (!isFeverMode) {
                    const tile1 = tileElements[r2][c2]; 
                    const tile2 = tileElements[r1][c1]; 
                    tile1.classList.add('invalid');
                    tile2.classList.add('invalid');
                    await new Promise(resolve => setTimeout(resolve, 400)); // 400ms ëŒ€ê¸°
                    tile1.classList.remove('invalid');
                    tile2.classList.remove('invalid');
                }
                
                swapData(r1, c1, r2, c2); // ë°ì´í„° ì›ìœ„ì¹˜
                await animateSwap(r2, c2, r1, c1); // DOM ì›ìœ„ì¹˜ (ë¹ ë¥¸ ë³µê·€)
                startHintTimer(); // [ì‹ ê·œ] íŒíŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
            }
          
         function findAllMatches() {
    // 1. [ì‹ ê·œ] ê°€ë¡œ/ì„¸ë¡œ ë§¤ì¹­ ì¢Œí‘œë¥¼ ë³„ë„ë¡œ ìˆ˜ì§‘
    const hMatchCoords = new Set();
    const vMatchCoords = new Set();
    
    // 1-1. ê°€ë¡œ ë°©í–¥ ë§¤ì¹­ (ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼)
    for (let r = 0; r < ROWS; r++) {
        let matchStart = 0;
        for (let c = 1; c < COLS; c++) {
            if (board[r][c] && board[r][c] === board[r][matchStart] && board[r][matchStart] !== RAINBOW_TILE && board[r][matchStart] !== JUNK_TILE) {
                continue;
            }
            const matchLength = c - matchStart;
            if (matchLength >= 3) {
                for (let i = matchStart; i < c; i++) {
                    hMatchCoords.add(`${r}-${i}`); // [ìˆ˜ì •] hMatchCoordsì— ì €ì¥
                }
            }
            matchStart = c;
        }
        const matchLength = COLS - matchStart;
        if (matchLength >= 3) {
            for (let i = matchStart; i < COLS; i++) {
                hMatchCoords.add(`${r}-${i}`); // [ìˆ˜ì •] hMatchCoordsì— ì €ì¥
            }
        }
    }
    
    // 1-2. ì„¸ë¡œ ë°©í–¥ ë§¤ì¹­ (ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼)
    for (let c = 0; c < COLS; c++) {
        let matchStart = 0;
        for (let r = 1; r < ROWS; r++) {
           if (board[r][c] && board[r][c] === board[matchStart][c] && board[matchStart][c] !== RAINBOW_TILE && board[matchStart][c] !== JUNK_TILE) {
                continue;
            }
            const matchLength = r - matchStart;
            if (matchLength >= 3) {
                for (let i = matchStart; i < r; i++) {
                    vMatchCoords.add(`${i}-${c}`); // [ìˆ˜ì •] vMatchCoordsì— ì €ì¥
                }
            }
            matchStart = r;
        }
        const matchLength = ROWS - matchStart;
        if (matchLength >= 3) {
            for (let i = matchStart; i < ROWS; i++) {
                vMatchCoords.add(`${i}-${c}`); // [ìˆ˜ì •] vMatchCoordsì— ì €ì¥
            }
        }
    }

    // --- [ì‹ ê·œ] 2. íŠ¹ìˆ˜ íƒ€ì¼ ìƒì„± ë¡œì§ (L/Tì, 5, 6ì¤„) ---
    
    // 2-1. (L/Tì) êµì°¨ì (ë³„ íŒ¡ì´) ì°¾ê¸°
    const starTiles = new Set();
    hMatchCoords.forEach(key => {
        if (vMatchCoords.has(key)) {
            starTiles.add(key); // êµì°¨í•˜ëŠ” íƒ€ì¼ = 'ë³„ íŒ¡ì´'
        }
    });
    
    // 2-2. (5/6ì¤„) ì§ì„  ë§¤ì¹­ ë‹¤ì‹œ í™•ì¸ (êµì°¨ì  ì œì™¸)
    // [ìˆ˜ì •] ê¸°ì¡´ ë¡œì§ì„ ì´ìª½ìœ¼ë¡œ ì´ë™í•˜ê³ , starTilesë¥¼ ê³ ë ¤í•˜ë„ë¡ ìˆ˜ì •
    const matches = new Set([...hMatchCoords, ...vMatchCoords]); // ëª¨ë“  ë§¤ì¹­ íƒ€ì¼
    const crossExplosions = []; // 5ì¤„
    const rainbowTiles = [];    // 6ì¤„

    // ê°€ë¡œ 5/6ì¤„ (êµì°¨ì ì´ ì•„ë‹Œ ê³³)
    for (let r = 0; r < ROWS; r++) {
        let matchStart = 0;
        for (let c = 1; c < COLS; c++) {
            if (board[r][c] && board[r][c] === board[r][matchStart] && board[r][matchStart] !== RAINBOW_TILE) {
                continue;
            }
            const matchLength = c - matchStart;
            const centerCol = matchStart + Math.floor(matchLength / 2);
            const centerKey = `${r}-${centerCol}`;
            
            if (matchLength >= 6 && !starTiles.has(centerKey)) { // 6ì¤„ì´ê³  êµì°¨ì  ì•„ë‹ˆë©´
                rainbowTiles.push({ row: r, col: centerCol });
            } else if (matchLength >= 5 && !starTiles.has(centerKey)) { // 5ì¤„ì´ê³  êµì°¨ì  ì•„ë‹ˆë©´
                crossExplosions.push({ row: r, col: centerCol });
            }
            matchStart = c;
        }
        // (ê°€ë¡œ ë§ˆì§€ë§‰ ì¤„)
        const matchLength = COLS - matchStart;
        const centerCol = matchStart + Math.floor(matchLength / 2);
        const centerKey = `${r}-${centerCol}`;
        if (matchLength >= 6 && !starTiles.has(centerKey)) {
            rainbowTiles.push({ row: r, col: centerCol });
        } else if (matchLength >= 5 && !starTiles.has(centerKey)) {
            crossExplosions.push({ row: r, col: centerCol });
        }
    }
    // ì„¸ë¡œ 5/6ì¤„ (êµì°¨ì ì´ ì•„ë‹Œ ê³³)
    for (let c = 0; c < COLS; c++) {
        let matchStart = 0;
        for (let r = 1; r < ROWS; r++) {
            if (board[r][c] && board[r][c] === board[matchStart][c] && board[matchStart][c] !== RAINBOW_TILE) {
                continue;
            }
            const matchLength = r - matchStart;
            const centerRow = matchStart + Math.floor(matchLength / 2);
            const centerKey = `${centerRow}-${c}`;

            if (matchLength >= 6 && !starTiles.has(centerKey)) {
                rainbowTiles.push({ row: centerRow, col: c });
            } else if (matchLength >= 5 && !starTiles.has(centerKey)) {
                crossExplosions.push({ row: centerRow, col: c });
            }
            matchStart = r;
        }
        // (ì„¸ë¡œ ë§ˆì§€ë§‰ ì¤„)
        const matchLength = ROWS - matchStart;
        const centerRow = matchStart + Math.floor(matchLength / 2);
        const centerKey = `${centerRow}-${c}`;
        if (matchLength >= 6 && !starTiles.has(centerKey)) {
            rainbowTiles.push({ row: centerRow, col: c });
        } else if (matchLength >= 5 && !starTiles.has(centerKey)) {
            crossExplosions.push({ row: centerRow, col: c });
        }
    }
    
    // 2-3. ì‹­ìê°€ í­ë°œ ì²˜ë¦¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    crossExplosions.forEach(({ row, col }) => {
        for (let c = 0; c < COLS; c++) {
            if (board[row][c]) matches.add(`${row}-${c}`);
        }
        for (let r = 0; r < ROWS; r++) {
            if (board[r][col]) matches.add(`${r}-${col}`);
        }
    });
    
    // [ì‹ ê·œ] 3. 'ë³„ íŒ¡ì´'ê°€ ë  êµì°¨ì  ì¢Œí‘œë¥¼ Setìœ¼ë¡œ ë°˜í™˜
    const starPangiTiles = new Set();
    starTiles.forEach(key => starPangiTiles.add(key));

    return { matches, crossExplosions, rainbowTiles, starPangiTiles }; // [ìˆ˜ì •] starPangiTiles ì¶”ê°€
}
            
          async function processMatchesAndCascade(matchData) {
    // [ì‹ ê·œ] ì½¤ë³´ ìœ ì§€ íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì¦‰ì‹œ ì·¨ì†Œ (ì½¤ë³´ê°€ ì´ì–´ì§)
    if (comboTimerId) {
        clearTimeout(comboTimerId);
        comboTimerId = null;
    }

    const matches = matchData.matches || matchData;
    const crossExplosions = matchData.crossExplosions || [];
    const rainbowTiles = matchData.rainbowTiles || [];
    currentCombo++; // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´] ì—°ì‡„ í­ë°œ ì½¤ë³´ ì¹´ìš´íŠ¸
 const starPangiTiles = matchData.starPangiTiles || new Set(); // [ì‹ ê·œ] ë³„ íŒ¡ì´ ì¢Œí‘œ
    // [ì‹ ê·œ] ğŸ”¥ í”¼ë²„ ëª¨ë“œ ì‹­ì í­ë°œ ë¡œì§
    if (isFeverMode && matches.size > 0) {
        console.log("ğŸ”¥ í”¼ë²„ ëª¨ë“œ: ì‹­ì í­ë°œ ì ìš©!");
        const neighborsToAdd = new Set();
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // ìƒ, í•˜, ì¢Œ, ìš°

        matches.forEach(key => {
            const [r, c] = key.split('-').map(Number);
            
            directions.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                // ë³´ë“œ ë²”ìœ„ ì²´í¬ ë° ë¹ˆ ì¹¸(null)ì´ ì•„ë‹Œì§€ í™•ì¸
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc]) {
                    neighborsToAdd.add(`${nr}-${nc}`);
                }
            });
        });

        // ì›ë³¸ matches ì„¸íŠ¸ì— ì´ì›ƒë“¤ì„ ì¶”ê°€ (ì¤‘ë³µ ìë™ ì œê±°ë¨)
        neighborsToAdd.forEach(key => matches.add(key));
    }

// [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ (ì¸ì ‘ ì œê±° ë¡œì§)
    const junkToRemove = new Set();
    const directions = [
        [-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]
    ]; // 8ë°©í–¥

    matches.forEach(key => {
        const [r, c] = key.split('-').map(Number);
        
        directions.forEach(([dr, dc]) => {
            const nr = r + dr;
            const nc = c + dc;
            // ë³´ë“œ ë²”ìœ„ ì²´í¬
            if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                // ì¸ì ‘í•œ íƒ€ì¼ì´ 'ì–¼ìŒ'ì´ë©´
                if (board[nr][nc] === JUNK_TILE) {
                    junkToRemove.add(`${nr}-${nc}`);
                }
            }
        });
    });

    // ì œê±° ëª©ë¡(junkToRemove)ì— ìˆëŠ” ì–¼ìŒì„ ë©”ì¸ í­ë°œ ëª©ë¡(matches)ì— ì¶”ê°€
    junkToRemove.forEach(key => matches.add(key));
    currentCombo++;

    // [ì‹ ê·œ] 15ì½¤ë³´ ë‹¬ì„± ì‹œ í”¼ë²„ ëª¨ë“œ ë°œë™
    if (currentCombo === 10 && !isFeverMode) {
        triggerActualFeverMode();
    }

    const scoreMultiplier = isFeverMode ? 1.5 : 1.0;

    const baseScore = matches.size * 10;
    const comboBonus = currentCombo * 20;
    const crossBonus = crossExplosions.length * CROSS_EXPLOSION_BONUS;
    const rainbowBonus = rainbowTiles.length * RAINBOW_BONUS;
    
    const turnScore = Math.round((baseScore + comboBonus + crossBonus + rainbowBonus) * scoreMultiplier);
    score += turnScore;
    
    if (crossExplosions.length > 0) {
        playSound('rainbow'); // [ì‹ ê·œ] 5-Match(ì‹­ìê°€) íš¨ê³¼ìŒ ì¬ìƒ
        showCrossExplosion(crossExplosions);
    }
    
    if (rainbowTiles.length > 0) {
        showRainbowEffect(rainbowTiles);
    }
    
    showComboText(currentCombo, matches);
    showComboScore(turnScore);

    if (!isFeverMode) {
        const gaugeGain = (matches.size * 0.5) + (currentCombo * 1.5) + (rainbowTiles.length * 10);
        feverGauge = Math.min(MAX_FEVER_GAUGE, feverGauge + gaugeGain);
        updateFeverGaugeUI();

        if (feverGauge >= MAX_FEVER_GAUGE) {
            startFeverMode();
        }
    }

    updateScoreUI(); 
    if (playerRef) { playerRef.child('score').set(score); }
    playComboSound(currentCombo);
    // [ì‹ ê·œ] 'ë³„ íŒ¡ì´'ê°€ ë  íƒ€ì¼ì€ matches ì„¸íŠ¸ì—ì„œ ì œê±° (í„°ì§€ì§€ ì•Šë„ë¡)
    starPangiTiles.forEach(key => {
        matches.delete(key);
    });
    await animatePop(matches);
    removeMatches(matches);
    
    // ë ˆì¸ë³´ìš° íƒ€ì¼ ìƒì„±
    rainbowTiles.forEach(({ row, col }) => {
        board[row][col] = RAINBOW_TILE;
    });

    // [ì‹ ê·œ] ë³„ íŒ¡ì´ â­ï¸ ìƒì„±
    starPangiTiles.forEach(key => {
        const [r, c] = key.split('-').map(Number);
        board[r][c] = 'star'; // [ì‹ ê·œ] ë°ì´í„° ë³€ê²½
        if(tileElements[r][c]) {
            setTileAppearance(tileElements[r][c], 'star'); // [ì‹ ê·œ] CSS ë³€ê²½
            tileElements[r][c].classList.add('new-tile-anim'); // ìƒì„± ì• ë‹ˆë©”ì´ì…˜
        }
    });
    
    const { droppedTilesMap } = dropTiles();
    const newTilesMap = fillTopTiles();
    
    await animateDrops(droppedTilesMap, newTilesMap);
    
    const newMatchData = findAllMatches();
    if (newMatchData.matches.size > 0) {
        await new Promise(resolve => setTimeout(resolve, 100)); 
        await processMatchesAndCascade(newMatchData);
   } else {
                // [âš¡ í•˜ì´ë¸Œë¦¬ë“œ ì½¤ë³´ ìˆ˜ì •]
                // ëª¨ë“  ì—°ì‡„ í­ë°œì´ ì¢…ë£Œë¨. ìŠ¤í”¼ë“œ ì½¤ë³´ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
                
                const gracePeriod = getComboGracePeriod(currentCombo); // ì½¤ë³´ë³„ ìœ ì§€ì‹œê°„
                console.log(`â±ï¸ ìŠ¤í”¼ë“œ ì½¤ë³´ ${currentCombo}x ìœ ì§€! ${gracePeriod}ms íƒ€ì´ë¨¸ ì‹œì‘...`);
                
                if (comboTimerId) clearTimeout(comboTimerId); // ì´ì „ íƒ€ì´ë¨¸ ì •ë¦¬
                comboTimerId = setTimeout(() => {
                    // íƒ€ì´ë¨¸ê°€ ë§Œë£Œë˜ë©´ ì½¤ë³´ ì´ˆê¸°í™”
                    console.log("...ìŠ¤í”¼ë“œ ì½¤ë³´ ì‹œê°„ ì´ˆê³¼. ì½¤ë³´ ë¦¬ì…‹.");
                    currentCombo = 0;
                    comboTimerId = null;
                }, gracePeriod); 

                startHintTimer(); // íŒíŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
                if (!checkForPossibleMoves()) {
                    await handleNoMoreMoves();
                }
            }
}

// [ì‹ ê·œ] ì—°ì‡„ ì½¤ë³´(Cascade) ì‹¤í–‰ì„ ê´€ë¦¬í•˜ëŠ” ë˜í¼ í•¨ìˆ˜
            // (í”¼ë²„ ëª¨ë“œì—ì„œ ì½¤ë³´ê°€ ì¤‘ì²© ì‹¤í–‰ë˜ì–´ ì¶©ëŒí•˜ëŠ” ê²ƒì„ ë°©ì§€)
            async function runCascade(matchData) {
                // 1. ì´ë¯¸ ë‹¤ë¥¸ ì½¤ë³´ê°€ ì²˜ë¦¬ ì¤‘ì´ë©´(isCascading=true) ì¦‰ì‹œ ë°˜í™˜
                if (isCascading) {
                    console.log("CASCADE: ì½¤ë³´ ì¤‘ì²© ë°©ì§€. ì‹¤í–‰ ì·¨ì†Œ.");
                    return; 
                }
                
                // 2. ì½¤ë³´ ì²˜ë¦¬ ì‹œì‘ (ì ê¸ˆ)
                isCascading = true;
                console.log("CASCADE: ì½¤ë³´ ì²˜ë¦¬ ì‹œì‘ (ì ê¸ˆ).");

                // 3. (await) ëª¨ë“  ì—°ì‡„ ë°˜ì‘ì´ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
                try {
                    await processMatchesAndCascade(matchData);
                } catch (e) {
                    console.error("Cascade ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
                }

                // 4. ì½¤ë³´ ì²˜ë¦¬ ì™„ë£Œ (ì ê¸ˆ í•´ì œ)
                console.log("CASCADE: ì½¤ë³´ ì²˜ë¦¬ ì™„ë£Œ (ì ê¸ˆ í•´ì œ).");
                isCascading = false;
            }

            // [ì‹ ê·œ] TTSê°€ ì½ê¸° ì „ì— í…ìŠ¤íŠ¸ë¥¼ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
            function preprocessTextForTTS(text) {
                let processedText = text.replace(/ã…‹{2,}/g, 'í¬í¬í¬'); 
                processedText = processedText.replace(/ã…{2,}/g, 'ííí');
                if (processedText === 'ã…ã…‡') return 'í•˜ì´';
                if (processedText === 'ã…‡ã…‡') return 'ì‘ì‘';
                if (processedText === 'ã„±ã„±') return 'ê³ ê³ ';
                if (processedText === 'ã„´ã„´') return 'ë…¸ë…¸';
                if (processedText === 'ã…ˆã……') return 'ì£„ì†¡';
                return processedText;
            }

            // [ì‹ ê·œ] TTS ì—”ì§„ì„ "ê¹¨ìš°ëŠ”" (Prime) í•¨ìˆ˜
            function primeTTSEngine() {
                if (!synthesis) return;
                const emptyUtterance = new SpeechSynthesisUtterance('');
                emptyUtterance.lang = 'ko-KR';
                try {
                    synthesis.pause();
                    synthesis.resume();
                    synthesis.speak(emptyUtterance);
                } catch (e) {}
            }
            
            // [ì‹ ê·œ] TTS ëª©ì†Œë¦¬ ëª©ë¡ ë¡œë“œ (ì„ íƒ UIëŠ” ì—†ì§€ë§Œ, ì €ì¥ëœ ëª©ì†Œë¦¬ë¥¼ ì°¾ê¸° ìœ„í•´ í•„ìš”)
            let voiceLoadAttempts = 0;
            function populateVoiceList() {
                if (!synthesis) return;
                voiceList = synthesis.getVoices();
                const koreanVoices = voiceList.filter(voice => voice.lang === 'ko-KR' || voice.lang.startsWith('ko-'));

                if (koreanVoices.length === 0 && voiceLoadAttempts < 5) {
                    voiceLoadAttempts++;
                    setTimeout(primeTTSEngine, 100); 
                    setTimeout(populateVoiceList, 500); 
                    return;
                }
                
                if (koreanVoices.length > 0) {
                     console.log(`TTS: í•œêµ­ì–´ ëª©ì†Œë¦¬ ${koreanVoices.length}ê°œ ë¡œë“œ ì™„ë£Œ.`);
                }
            }
            
            function updateScoreUI() {
                const myScoreValueEl = multiplayerScoreboard.querySelector('.my-score .value');
                if (myScoreValueEl) {
                    myScoreValueEl.textContent = score.toLocaleString();
                }
            }

            // [ì‹ ê·œ] BGM ì •ì§€ë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
            function stopSound(id) {
                try {
                    const sound = sounds[id];
                    if(sound) {
                        sound.pause();
                        sound.currentTime = 0;
                    }
                } catch(e) {}
            }


            function playSound(id) {
                try {
                    const sound = sounds[id];
                    if(sound) {
                        sound.currentTime = 0;
                        sound.play().catch(e => {});
                    }
                } catch(e) {}
            }
// [ì‹ ê·œ] ì½¤ë³´ ìˆ˜ì— ë”°ë¼ ì½¤ë³´ ìœ ì§€ ì‹œê°„(ms)ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
            function getComboGracePeriod(combo) {
                if (combo <= 10) {
                    return 2000; // 1~10ì½¤ë³´: 2ì´ˆ (ê¸°ë³¸)
                }
                
                // 11ì½¤ë³´(1850ms) ~ 19ì½¤ë³´(650ms)ê¹Œì§€ ì ì°¨ ê°ì†Œ
                // 20ì½¤ë³´ë¶€í„°ëŠ” 500ms (0.5ì´ˆ)ë¡œ ê³ ì •
                return Math.max(500, 2000 - 150 * (combo - 10));
            }


           function playComboSound(combo) {
    // ğŸµ ì¥ìŒê³„ ê¸°ë°˜ í”¼ì¹˜ ì‹œìŠ¤í…œ
    const semitone = Math.pow(2, 1/12);
    const pitchMap = [0, 2, 4, 5, 7, 9, 11, 12, 14, 16];
    const comboIndex = Math.min(combo - 1, pitchMap.length - 1);
    const semitonesUp = pitchMap[comboIndex];
    const finalRate = Math.pow(semitone, semitonesUp);
    const clampedRate = Math.max(1.0, Math.min(finalRate, 4.0));
    
    // ë³¼ë¥¨ ì¡°ì ˆ (0.6 â†’ 0.9)
    const volumeBoost = Math.min(0.6 + (combo * 0.03), 0.9);
    
    try {
        const sound = sounds['match'];
        if(sound) {
            sound.currentTime = 0;
            sound.playbackRate = clampedRate;
            sound.volume = volumeBoost;
            sound.play().catch(e => {});
        }
    } catch(e) {}
    
   
    console.log(`ğŸµ ${combo}ì½¤ë³´: +${semitonesUp}ë°˜ìŒ (${clampedRate.toFixed(2)}x, Vol:${volumeBoost.toFixed(2)})`);
}


            function animatePop(matches) {
    const matchArray = Array.from(matches);
    const batchSize = 8; // iOS ìµœì í™”
    
    for (let i = 0; i < matchArray.length; i += batchSize) {
        setTimeout(() => {
            matchArray.slice(i, i + batchSize).forEach(key => {
                const [r, c] = key.split('-').map(Number);
                if (tileElements[r] && tileElements[r][c]) {
                    tileElements[r][c].classList.add('pop');
                }
            });
        }, i * 10);
    }
    
    const maxI = (Math.floor((matchArray.length - 1) / batchSize)) * batchSize;
                const maxDelay = maxI * 10;
                

                return new Promise(resolve => setTimeout(resolve, maxDelay + 200));
            }


            function removeMatches(matches) {
                matches.forEach(key => {
                    const [r, c] = key.split('-').map(Number);
                    if (board[r]) {
                        board[r][c] = null; 
                    }
                });
            }
            function dropTiles() {
                const droppedTilesMap = new Map(); 
                for (let c = 0; c < COLS; c++) {
                    let emptyRow = ROWS - 1; 
                    for (let r = ROWS - 1; r >= 0; r--) {
                        if (board[r][c] !== null) {
                            if (r !== emptyRow) {
                                board[emptyRow][c] = board[r][c];
                                board[r][c] = null;
                                droppedTilesMap.set(`${emptyRow}-${c}`, r); // { endKey: startRow }
                            }
                            emptyRow--;
                        }
                    }
                }
                return { droppedTilesMap };
            }
            function fillTopTiles() {
                const newTilesMap = new Map(); 
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] === null) {
                            const newEmoji = getRandomEmoji();
                            board[r][c] = newEmoji;
                            newTilesMap.set(`${r}-${c}`, newEmoji);
                        }
                    }
                }
                return newTilesMap;
            }
          
          // [ìˆ˜ì •] "ê³ ìŠ¤íŠ¸ í„°ì¹˜" "ì…ë ¥ ì˜¤ë¥˜" "ë²„ë²…ì„" ëª¨ë‘ í•´ê²°í•œ ìµœì¢… í•¨ìˆ˜ (v2)
            async function animateDrops(droppedTilesMap, newTilesMap) {
                const fallPromises = [];
                // [ë²„ê·¸ ìˆ˜ì •] tileElements[0][0]ì´ nullì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ í¬ê¸° ê³„ì‚°
                const firstTile = gameBoard.querySelector('.tile') || {};
                const tileSize = (firstTile.clientHeight || 50) + 2; // 2ëŠ” ê°­(gap)

                // 1. DOM/ë°ì´í„°/ë°°ì—´ ì—…ë°ì´íŠ¸
                // (ë°ì´í„° `board` ë°°ì—´ì€ ì´ë¯¸ ìµœì‹  ìƒíƒœ)
                // `tileElements` ë°°ì—´ì„ `board` ë°ì´í„° ê¸°ì¤€ìœ¼ë¡œ ì¬ì •ë ¬
                
                const newTileElements = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                
                // [ìˆ˜ì •] 1a. ëª¨ë“  íƒ€ì¼ DOM ìš”ì†Œë¥¼ 1D ë°°ì—´ë¡œ ìˆ˜ì§‘ (ì¬ì‚¬ìš© í)
                const allOldTiles = [];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (tileElements[r][c]) {
                            allOldTiles.push(tileElements[r][c]);
                        }
                    }
                }

                // 1b. `board` ë°ì´í„° ê¸°ì¤€ìœ¼ë¡œ `tileElements` ë°°ì—´ì„ 'ì™„ì „íˆ ìƒˆë¡œ' ë§Œë“¦
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const key = `${r}-${c}`;
                        const tileData = board[r][c];
                        
                        // [ìˆ˜ì •] ì¬ì‚¬ìš© íì—ì„œ íƒ€ì¼ì„ í•˜ë‚˜ êº¼ëƒ„
                        const tile = allOldTiles.pop(); // DOM ìš”ì†Œ
                        if (!tile) {
                             console.error("Tile reuse queue empty! This should not happen.");
                             continue; 
                        }

                        setTileAppearance(tile, tileData); // [ìˆ˜ì •]
                        tile.dataset.row = r; // [ìˆ˜ì •] dataset ê°•ì œ ì¼ì¹˜
                        tile.dataset.col = c; // [ìˆ˜ì •] dataset ê°•ì œ ì¼ì¹˜
                        newTileElements[r][c] = tile; // ìƒˆ 2D ë°°ì—´ì— í• ë‹¹

                       if (newTilesMap.has(key)) {
                            // 'ìƒˆë¡œ ìƒê¸´ íƒ€ì¼'
                            // [ë²„ê·¸ ìˆ˜ì •] .className = -> .classList.add()
                            tile.classList.add('fall', 'new-tile-anim');
                            const startY = -(r + 2) * tileSize;
                            tile.style.transform = `translateY(${startY}px)`;

                      } else if (droppedTilesMap.has(key)) {
                            // 'ë–¨ì–´ì§„ íƒ€ì¼'
                            const startRow = droppedTilesMap.get(key); // ë°ì´í„°ê°€ ìˆë˜ 'í–‰'
                            // [ë²„ê·¸ ìˆ˜ì •] .className = -> .classList.add()
                            tile.classList.add('fall');
                            // (r=5, startRow=2) -> 3ì¹¸ ì´ë™


                            // (r=5, startRow=2) -> 3ì¹¸ ì´ë™
                            const dropDistance = (r - startRow) * tileSize;
                            // [ìˆ˜ì •] ë²„ê·¸ ë°©ì§€: ë–¨ì–´ì§€ëŠ” ê±°ë¦¬ê°€ 0ì¼ ìˆ˜ ì—†ìŒ (ë¡œì§ìƒ)
                            // startRowê°€ rê³¼ ê°™ìœ¼ë©´ `droppedTilesMap`ì— ì—†ì–´ì•¼ í•¨.
                            // ë§Œì•½ì˜ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ 0ì´ ì•„ë‹Œ ê°’ë§Œ transform
                            if (dropDistance !== 0) {
                                // [ë²„ê·¸ ìˆ˜ì •] translateY(${dropDistance}px) -> translateY(${-dropDistance}px)
                                tile.style.transform = `translateY(${-dropDistance}px)`;
                            } else {
                                // ì´ íƒ€ì¼ì€ ì‹¤ì œë¡œëŠ” ì›€ì§ì´ì§€ ì•Šì€ íƒ€ì¼ì„
                                tile.className = 'tile';
                                tile.style.transform = '';
                            }
                            
                       } else {
                            // 'ê°€ë§Œíˆ ìˆëŠ” íƒ€ì¼'
                            // [ë²„ê·¸ ìˆ˜ì •] tile.className = 'tile'; <-- ì´ ì¤„ì„ ì‚­ì œí•©ë‹ˆë‹¤.
                            tile.style.transform = ''; // [ìˆ˜ì •] transform ì´ˆê¸°í™”
                        }
                    }
                }
                
                // 2. ì „ì—­ `tileElements` ë°°ì—´ êµì²´ (DOM/ë°ì´í„°/ë°°ì—´ ë…¼ë¦¬ì  ì‹±í¬ ì™„ë£Œ)
                tileElements = newTileElements;
                
                // 3. ê°•ì œ ë¦¬í˜ì¸íŠ¸ (ì¤‘ìš”)
                gameBoard.offsetHeight; 

                // 4. [ìˆ˜ì •] ëª¨ë“  'fall' íƒ€ì¼ì„ í•œ ë²ˆì— ì²˜ë¦¬ (ë¦¬í”Œë¡œìš° ìµœì†Œí™”)
const fallTiles = [];
for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
        const tile = tileElements[r][c];
        if (tile && tile.classList.contains('fall')) {
            fallTiles.push(tile);
        }
    }
}

// [í•µì‹¬ ìˆ˜ì •] í•œ ë²ˆì˜ rAFì—ì„œ ëª¨ë“  íƒ€ì¼ transform ë³€ê²½ (ë°°ì¹˜ ì²˜ë¦¬ + iOS ìµœì í™”)
if (fallTiles.length > 0) {
    // iOSì—ì„œëŠ” í•œ í”„ë ˆì„ì— ë„ˆë¬´ ë§ì€ DOM ë³€ê²½ì´ ìˆìœ¼ë©´ ë²„ë²…ì„
    // íƒ€ì¼ì„ ì†Œê·œëª¨ ë°°ì¹˜ë¡œ ë‚˜ëˆ ì„œ ì²˜ë¦¬
    const batchSize = 12; // iOSì— ìµœì í™”ëœ ë°°ì¹˜ í¬ê¸°
    let batchIndex = 0;
    
    const processBatch = () => {
        const start = batchIndex * batchSize;
        const end = Math.min(start + batchSize, fallTiles.length);
        
        for (let i = start; i < end; i++) {
            const tile = fallTiles[i];
            tile.style.transform = 'translateY(0)';
            fallPromises.push(new Promise(resolve => {
                tile.addEventListener('transitionend', resolve, { once: true });
            }));
        }
        
        batchIndex++;
        if (end < fallTiles.length) {
            requestAnimationFrame(processBatch);
        }
    };
    
    requestAnimationFrame(processBatch);
}

                // 5. ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ëŒ€ê¸° (transition 0.3s + ì˜ˆë¹„ 0.3s)
                const timeoutPromise = new Promise(resolve => setTimeout(resolve, 600)); 
                await Promise.race([Promise.all(fallPromises), timeoutPromise]);

                // 6. DOM ìˆœì„œ ì¬ì •ë ¬ ë° ìŠ¤íƒ€ì¼ ì´ˆê¸°í™” (ë²„ë²…ì„ í•´ê²°)
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                       if (tileElements[r][c]) {
                            const tile = tileElements[r][c];
                            // [í•µì‹¬ ë²„ê·¸ ìˆ˜ì •]
                        // .pop (íˆ¬ëª…) í´ë˜ìŠ¤ê°€ ë‚¨ì•„ì„œ íƒ€ì¼ì´ ì‚¬ë¼ì§€ëŠ” ë²„ê·¸ í•´ê²°
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì‹œ .pop, .fall, .new-tile-anim ì„ ëª¨ë‘ ì œê±°
                        tile.classList.remove('fall', 'new-tile-anim', 'pop');
                        tile.style.transform = '';
                            gameBoard.appendChild(tile); // DOM ì´ë™ (ë¹ ë¦„)
                        }
                    }
                }
                
            }

            // ------------------------------------
            // 7. [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸/ì ìˆ˜
            // ------------------------------------
            
            function showComboText(combo, matches) {
                if (combo < 2) return; 

                let totalTop = 0;
                let totalLeft = 0;
                let count = 0;
                const boardRect = gameBoard.getBoundingClientRect();

                matches.forEach(key => {
                    const [r, c] = key.split('-').map(Number);
                    if (tileElements[r] && tileElements[r][c]) {
                        const rect = tileElements[r][c].getBoundingClientRect();
                        totalTop += (rect.top - boardRect.top) + (rect.height / 2);
                        totalLeft += (rect.left - boardRect.left) + (rect.width / 2);
                        count++;
                    }
                });
                
                if (count === 0) return;
                const avgTop = totalTop / count;
                const avgLeft = totalLeft / count;

                const comboEl = document.createElement('div');
                comboEl.className = 'combo-text';
                comboEl.textContent = `${combo} ì½¤ë³´!`;
                
                const wrapperRect = gameWrapper.getBoundingClientRect();
                comboEl.style.top = `${avgTop + boardRect.top - wrapperRect.top}px`;
                comboEl.style.left = `${avgLeft + boardRect.left - wrapperRect.left}px`;
                comboEl.style.transform = 'translate(-50%, -50%)'; 

                gameWrapper.appendChild(comboEl);

                setTimeout(() => {
                    comboEl.remove();
                }, 800);
            }

            function showComboScore(turnScore) {
                const scoreEl = document.createElement('div');
                scoreEl.className = 'combo-score';
                scoreEl.textContent = `+${turnScore}`;
                
                comboScoreDisplay.innerHTML = ''; 
                comboScoreDisplay.appendChild(scoreEl);

                setTimeout(() => {
                    scoreEl.remove();
                }, 800);
            }

            // [ì‹ ê·œ] ë©€í‹°-ë§¤ì¹˜ ì „ìš© í…ìŠ¤íŠ¸
            function showMultiMatchText(r, c, bonusScore) {
                const tile = tileElements[r][c];
                if (!tile) return;
                
                const rect = tile.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();
                const wrapperRect = gameWrapper.getBoundingClientRect();

                // íƒ€ì¼ ì¤‘ì‹¬ ì¢Œí‘œ
                const avgTop = (rect.top - boardRect.top) + (rect.height / 2) + boardRect.top - wrapperRect.top;
                const avgLeft = (rect.left - boardRect.left) + (rect.width / 2) + boardRect.left - wrapperRect.left;

                // 1. "ë©€í‹°-ë§¤ì¹˜!" í…ìŠ¤íŠ¸
                const comboEl = document.createElement('div');
                comboEl.className = 'combo-text';
                comboEl.textContent = 'ğŸ§  ë©€í‹°-ë§¤ì¹˜!';
                comboEl.style.color = 'var(--secondary-color)'; // í‹¸(teal)ìƒ‰
                comboEl.style.top = `${avgTop - 20}px`; // ì ìˆ˜ë³´ë‹¤ ì‚´ì§ ìœ„ì—
                comboEl.style.left = `${avgLeft}px`;
                comboEl.style.transform = 'translate(-50%, -50%)'; 
                gameWrapper.appendChild(comboEl);
                setTimeout(() => comboEl.remove(), 1000); // 1ì´ˆê°„ í‘œì‹œ

                // 2. ë³´ë„ˆìŠ¤ ì ìˆ˜ í…ìŠ¤íŠ¸
                const scoreEl = document.createElement('div');
                scoreEl.className = 'combo-score';
                scoreEl.textContent = `+${bonusScore}`;
                scoreEl.style.top = `${avgTop + 20}px`; // ì½¤ë³´ í…ìŠ¤íŠ¸ë³´ë‹¤ ì‚´ì§ ì•„ë˜ì—
                scoreEl.style.left = `${avgLeft}px`;
                scoreEl.style.transform = 'translate(-50%, -50%)'; 
                scoreEl.style.fontSize = '2.2em'; // ì ìˆ˜ë¥¼ ë” í¬ê²Œ
                scoreEl.style.animationDuration = '1s'; // 1ì´ˆê°„ í‘œì‹œ
                gameWrapper.appendChild(scoreEl);
                setTimeout(() => scoreEl.remove(), 1000);
            }

            // [ì‹ ê·œ] ğŸ¯ í¼í™íŠ¸ í”Œë ˆì´ ì „ìš© í…ìŠ¤íŠ¸
            function showPerfectPlayText(bonusScore) {
                // í™”ë©´ ì¤‘ì•™ ìƒë‹¨ì— í‘œì‹œ
                const avgTop = gameWrapper.clientHeight * 0.25;
                const avgLeft = gameWrapper.clientWidth * 0.5;

                // 1. "í¼í™íŠ¸ í”Œë ˆì´!" í…ìŠ¤íŠ¸
                const comboEl = document.createElement('div');
                comboEl.className = 'combo-text';
                comboEl.textContent = `ğŸ¯í¼í™íŠ¸ ${PERFECT_PLAY_COUNT}!`;
                comboEl.style.color = '#007BFF'; // íŒŒë€ìƒ‰
                comboEl.style.top = `${avgTop}px`;
                comboEl.style.left = `${avgLeft}px`;
                comboEl.style.transform = 'translate(-50%, -50%)'; 
                gameWrapper.appendChild(comboEl);
                setTimeout(() => comboEl.remove(), 1000); // 1ì´ˆê°„ í‘œì‹œ

                // 2. ë³´ë„ˆìŠ¤ ì ìˆ˜ í…ìŠ¤íŠ¸
                const scoreEl = document.createElement('div');
                scoreEl.className = 'combo-score';
                scoreEl.textContent = `+${bonusScore}`;
                scoreEl.style.top = `${avgTop + 40}px`; // ì½¤ë³´ í…ìŠ¤íŠ¸ë³´ë‹¤ ì‚´ì§ ì•„ë˜ì—
                scoreEl.style.left = `${avgLeft}px`;
                scoreEl.style.transform = 'translate(-50%, -50%)'; 
                scoreEl.style.fontSize = '2.0em';
                scoreEl.style.color = '#007BFF'; // íŒŒë€ìƒ‰
                scoreEl.style.animationDuration = '1s'; // 1ì´ˆê°„ í‘œì‹œ
                gameWrapper.appendChild(scoreEl);
                setTimeout(() => scoreEl.remove(), 1000);
            }
            // [ì‹ ê·œ] ê°•ë ¥í•œ í­ë°œ ì´í™íŠ¸ (ìŠ¤í¬ë¦° ì‰ì´í¬ + í”Œë˜ì‹œ)
            function playExplosionVFX() {
                // 1. ìŠ¤í¬ë¦° ì‰ì´í¬
                gameAreaFrameEl.classList.add('shake-effect');
                setTimeout(() => gameAreaFrameEl.classList.remove('shake-effect'), 300);

                // 2. í”Œë˜ì‹œ
                const flashOverlay = document.getElementById('vfx-flash-overlay');
                if (flashOverlay) {
                    flashOverlay.style.transition = 'none';
                    flashOverlay.style.opacity = '0.7'; // í•˜ì–—ê²Œ ë²ˆì©
                    setTimeout(() => {
                        flashOverlay.style.transition = 'opacity 0.4s ease-out';
                        flashOverlay.style.opacity = '0'; // ì„œì„œíˆ íˆ¬ëª…í•˜ê²Œ
                    }, 50); // 0.05ì´ˆê°„ ë²ˆì©ì„
                }
            }

            // [ì‹ ê·œ] ì‹­ìê°€ í­ë°œ ì´í™íŠ¸
function showCrossExplosion(crossExplosions) {
    playExplosionVFX(); // [ì‹ ê·œ] ìŠ¤í¬ë¦° ì‰ì´í¬ + í”Œë˜ì‹œ
    
    crossExplosions.forEach(({ row, col }) => {
        if (!tileElements[row] || !tileElements[row][col]) return;
        
        const centerTile = tileElements[row][col];
        const rect = centerTile.getBoundingClientRect();
        const boardRect = gameBoard.getBoundingClientRect();
        const wrapperRect = gameWrapper.getBoundingClientRect();
        
        // ì¤‘ì‹¬ ì¢Œí‘œ ê³„ì‚°
        const centerTop = (rect.top - boardRect.top) + (rect.height / 2) + boardRect.top - wrapperRect.top;
        const centerLeft = (rect.left - boardRect.left) + (rect.width / 2) + boardRect.left - wrapperRect.left;
        
        // ì‹­ìê°€ 4ë°©í–¥ í­ë°œ ë¼ì¸
        const directions = [
            { angle: 0, length: '200%' },    // ì˜¤ë¥¸ìª½
            { angle: 90, length: '200%' },   // ì•„ë˜
            { angle: 180, length: '200%' },  // ì™¼ìª½
            { angle: 270, length: '200%' }   // ìœ„
        ];
        
        directions.forEach(({ angle, length }) => {
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.top = `${centerTop}px`;
                line.style.left = `${centerLeft}px`;
                
                // [ìˆ˜ì •] ì´ˆê¸° width/heightëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ì œì–´
                // line.style.width = '4px'; 
                // line.style.height = length;
                
                // [ìˆ˜ì •] ë ˆì´ì € ë¹” ìŠ¤íƒ€ì¼ (ì¤‘ì•™ì— í°ìƒ‰ ì½”ì–´ ì¶”ê°€)
                line.style.background = 'linear-gradient(180deg, rgba(255, 255, 255, 0.8), #FFD700, #FF6B6B, transparent)';
                line.style.borderRadius = '4px'; // ë ˆì´ì € ëì„ ë‘¥ê¸€ê²Œ

                line.style.transformOrigin = 'top center';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.opacity = '0'; // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ì€ 0
                line.style.pointerEvents = 'none';
                line.style.zIndex = '150';
                
                // [ìˆ˜ì •] ìƒˆ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
                line.style.animation = 'laser-beam 0.4s ease-out forwards'; // 0.5ì´ˆ -> 0.4ì´ˆë¡œ ì†ë„ê° ì¦ê°€
                
                // [ìˆ˜ì •] box-shadowëŠ” CSS ì• ë‹ˆë©”ì´ì…˜ì´ ì œì–´
                // line.style.boxShadow = '0 0 10px #FFD700';
                
                gameWrapper.appendChild(line);
                setTimeout(() => line.remove(), 400); // 0.5ì´ˆ -> 0.4ì´ˆ
            });
        
        // ì¤‘ì‹¬ í­ë°œ ì´í™íŠ¸
        const centerBurst = document.createElement('div');
        centerBurst.style.position = 'absolute';
        centerBurst.style.top = `${centerTop}px`;
        centerBurst.style.left = `${centerLeft}px`;
        centerBurst.style.width = '20px';
        centerBurst.style.height = '20px';
        centerBurst.style.borderRadius = '50%';
        centerBurst.style.background = 'radial-gradient(circle, #FFD700, #FF6B6B)';
        centerBurst.style.transform = 'translate(-50%, -50%) scale(0)';
        centerBurst.style.pointerEvents = 'none';
        centerBurst.style.zIndex = '151';
        centerBurst.style.animation = 'center-burst 0.5s ease-out forwards';
        centerBurst.style.boxShadow = '0 0 20px #FFD700';
        
        gameWrapper.appendChild(centerBurst);
        setTimeout(() => centerBurst.remove(), 500);
        
        // "CROSS!" í…ìŠ¤íŠ¸
        const crossText = document.createElement('div');
        crossText.className = 'combo-text';
        crossText.textContent = 'ğŸ’¥ CROSS! ğŸ’¥';
        crossText.style.top = `${centerTop}px`;
        crossText.style.left = `${centerLeft}px`;
        crossText.style.transform = 'translate(-50%, -50%)';
        crossText.style.fontSize = '2em';
        crossText.style.color = '#FFD700';
        crossText.style.textShadow = '2px 2px 8px rgba(255,107,107,0.8)';
        
        gameWrapper.appendChild(crossText);
        setTimeout(() => crossText.remove(), 800);
    });
}

// [ì‹ ê·œ] â­ï¸ ë³„ íŒ¡ì´ (3x3) ì „ìš© í­ë°œ ì´í™íŠ¸
function showStarExplosionVFX(row, col) {
    playExplosionVFX(); // ìŠ¤í¬ë¦° ì‰ì´í¬/í”Œë˜ì‹œ ì¬í™œìš©

    if (!tileElements[row] || !tileElements[row][col]) return;
    
    const centerTile = tileElements[row][col];
    const rect = centerTile.getBoundingClientRect();
    const boardRect = gameBoard.getBoundingClientRect();
    const wrapperRect = gameWrapper.getBoundingClientRect();
    
    // ì¤‘ì‹¬ ì¢Œí‘œ
    const centerTop = (rect.top - boardRect.top) + (rect.height / 2) + boardRect.top - wrapperRect.top;
    const centerLeft = (rect.left - boardRect.left) + (rect.width / 2) + boardRect.left - wrapperRect.left;

    // 1. ì¶©ê²©íŒŒ (Shockwave) ì´í™íŠ¸
    const shockwave = document.createElement('div');
    shockwave.style.position = 'absolute';
    shockwave.style.top = `${centerTop}px`;
    shockwave.style.left = `${centerLeft}px`;
shockwave.style.width = `${rect.width * 3}px`; // [ìˆ˜ì •] íƒ€ì¼ 3ë°° í¬ê¸° (5x5 ëŠë‚Œ)
    shockwave.style.height = `${rect.height * 3}px`; // [ìˆ˜ì •] íƒ€ì¼ 3ë°° í¬ê¸° (5x5 ëŠë‚Œ)
    shockwave.style.borderRadius = '50%';
    shockwave.style.background = 'transparent';
    shockwave.style.transformOrigin = 'center center';
    shockwave.style.pointerEvents = 'none';
    shockwave.style.zIndex = '151';
    shockwave.style.animation = 'shockwave-burst 0.5s ease-out forwards'; // 1ë‹¨ê³„ì—ì„œ ë§Œë“  ì• ë‹ˆë©”ì´ì…˜
    
    gameWrapper.appendChild(shockwave);
    setTimeout(() => shockwave.remove(), 500);

    // 2. "STAR!" í…ìŠ¤íŠ¸ (ê¸°ì¡´ Cross í…ìŠ¤íŠ¸ ì¬í™œìš©)
    const starText = document.createElement('div');
    starText.className = 'combo-text';
    starText.textContent = 'â­ï¸ STAR! â­ï¸';
    starText.style.top = `${centerTop}px`;
    starText.style.left = `${centerLeft}px`;
    starText.style.transform = 'translate(-50%, -50%)';
    starText.style.fontSize = '2em';
    starText.style.color = '#FFD700'; // ê¸ˆìƒ‰
    starText.style.textShadow = '2px 2px 8px rgba(255, 215, 0, 0.8)';
    
    gameWrapper.appendChild(starText);
    setTimeout(() => starText.remove(), 800);
}
// [ì‹ ê·œ] íŒíŠ¸ë¥¼ ìœ„í•œ "ê°€ëŠ¥í•œ ì§" 1ê°œ ì°¾ê¸° í•¨ìˆ˜
            function findA_PossibleMove() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        // ê°€ë¡œë¡œ ì¸ì ‘í•œ ì§ ê²€ì‚¬ (ì˜¤ë¥¸ìª½)
                        if (c < COLS - 1) {
                            if (checkMove(r, c, r, c + 1)) {
                                return [tileElements[r][c], tileElements[r][c + 1]];
                            }
                        }
                        // ì„¸ë¡œë¡œ ì¸ì ‘í•œ ì§ ê²€ì‚¬ (ì•„ë˜ìª½)
                        if (r < ROWS - 1) {
                            if (checkMove(r, c, r + 1, c)) {
                                return [tileElements[r][c], tileElements[r + 1][c]];
                            }
                        }
                    }
                }
                return null; // ê°€ëŠ¥í•œ ì§ ì—†ìŒ
            }

// [ì‹ ê·œ] íŒíŠ¸ íƒ€ì´ë¨¸ ì¤‘ì§€ ë° ë°˜ì§ì„ ì œê±°
            function stopHintTimer() {
                if (hintTimerId) {
                    clearTimeout(hintTimerId);
                    hintTimerId = null;
                }
                // ëª¨ë“  íƒ€ì¼ì—ì„œ .hint í´ë˜ìŠ¤ ì¦‰ì‹œ ì œê±°
                const hintedTiles = gameBoard.querySelectorAll('.tile.hint');
                hintedTiles.forEach(tile => tile.classList.remove('hint'));
            }

            // [ì‹ ê·œ] íŒíŠ¸ íƒ€ì´ë¨¸ ì‹œì‘ (4ì´ˆ)
            function startHintTimer() {
                stopHintTimer(); // ê¸°ì¡´ íŒíŠ¸ íƒ€ì´ë¨¸/íš¨ê³¼ ì œê±°
                
                // [ìˆ˜ì •] 4ì´ˆ "í›„ì—" isProcessing ìƒíƒœë¥¼ ì²´í¬í•˜ë„ë¡ ë³€ê²½
                hintTimerId = setTimeout(() => {
                    if (isProcessing) return; // 4ì´ˆê°€ ì§€ë‚¬ì–´ë„ ì²˜ë¦¬ ì¤‘ì´ë©´ íŒíŠ¸ ì•ˆí•¨
                    showHint();
                }, 3000); // 3ì´ˆ
            }

            // [ì‹ ê·œ] íŒíŠ¸ í‘œì‹œ
            function showHint() {
                const hintTiles = findA_PossibleMove();
                if (hintTiles) {
                    console.log("ğŸ’¡ íŒíŠ¸ í‘œì‹œ:", hintTiles);
                    hintTiles[0].classList.add('hint');
                    hintTiles[1].classList.add('hint');
                }
            }

            // ------------------------------------
            // 8. ì…”í”Œ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
            // ------------------------------------
            function checkForPossibleMoves() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (c < COLS - 1) {
                            if (checkMove(r, c, r, c + 1)) return true;
                        }
                        if (r < ROWS - 1) {
                            if (checkMove(r, c, r + 1, c)) return true;
                        }
                    }
                }
                return false; 
            }
            function checkMove(r1, c1, r2, c2) {
    swapData(r1, c1, r2, c2);
    const matchData = findAllMatches();
    swapData(r1, c1, r2, c2); 
    return matchData.matches.size > 0;
}
            async function handleNoMoreMoves() {
    console.log("ë” ì´ìƒ ì›€ì§ì¼ ìˆ˜ ì—†ìŒ! ì…”í”Œí•©ë‹ˆë‹¤.");
    
    const shuffleText = document.createElement('div');
    shuffleText.className = 'combo-text';
    shuffleText.textContent = 'SHUFFLE!';
    shuffleText.style.top = '50%';
    shuffleText.style.left = '50%';
    shuffleText.style.transform = 'translate(-50%, -50%)';
    gameWrapper.appendChild(shuffleText);
    setTimeout(() => shuffleText.remove(), 800);
    
    await new Promise(resolve => setTimeout(resolve, 300));

    shuffleBoard(); 

    for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if(tileElements[r][c]) {
                        setTileAppearance(tileElements[r][c], board[r][c]); // [ìˆ˜ì •]
                        
                        // [í•µì‹¬ ìˆ˜ì •] .className= (êµì²´)ê°€ ì•„ë‹Œ .classList.add() (ì¶”ê°€)ë¥¼ ì‚¬ìš©í•´ì•¼
                        // setTileAppearanceë¡œ ì„¤ì •ëœ ë™ë¬¼ í´ë˜ìŠ¤(ì˜ˆ: .frog)ê°€ ìœ ì§€ë©ë‹ˆë‹¤.
                        tileElements[r][c].classList.add('new-tile-anim');

                        tileElements[r][c].dataset.row = r;
                        tileElements[r][c].dataset.col = c;
                    }
                }
            }
    await new Promise(resolve => setTimeout(resolve, 300));

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if(tileElements[r][c]) {
                // [í•µì‹¬ ìˆ˜ì •] .className = 'tile' (êµì²´)ì€ ë™ë¬¼ í´ë˜ìŠ¤ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
                // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ë§Œ ì œê±°í•´ì•¼ í•©ë‹ˆë‹¤.
                tileElements[r][c].classList.remove('new-tile-anim');
            }
        }
    }
    
    const matchData = findAllMatches();
    if (matchData.matches.size > 0) {
        await processMatchesAndCascade(matchData);
    }
}

            function shuffleBoard() {
                console.log("ë³´ë“œ ë°ì´í„° ì…”í”Œ ì¤‘...");
                createBoardData(); 
            }

            // [ì‹ ê·œ] STTê°€ ì‚¬ìš©í•  ì±„íŒ… ì „ì†¡ í•¨ìˆ˜ (ê²Œì„ë°©.htmlê³¼ ë™ì¼)
            function sendMessage(content, nickname) { // [### 1. nickname ì¸ì ì¶”ê°€ ###]
                const message = content.trim();
                if (message && roomRef && currentUser && nickname) { // [### 2. nickname ì²´í¬ ì¶”ê°€ ###]
                    roomRef.child('chat').push({
                        senderId: currentUser.uid, 
                        senderNickname: nickname, // [### 3. senderNickname ì¶”ê°€ (ë²„ê·¸ ìˆ˜ì •) ###]
                        content: message, 
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            }

            // [ì‹ ê·œ] ê²Œì„ ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (í…ŒíŠ¸ë¦¬ìŠ¤.htmlì—ì„œ ê°€ì ¸ì™€ ìˆ˜ì •)
            function updatePlayerStats(didIWin, finalScore, finalRank) { // [ìˆ˜ì •] finalRank ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
                if (!playerUid || playerUid.startsWith('guest_')) return;
                
                // 'win', 'loss', 'draw' ì¤‘ í•˜ë‚˜
                const result = (didIWin === null) ? 'draws' : (didIWin ? 'wins' : 'losses');
                
                // 1. (ê²Œì„ íŒŒì¼ì˜ ì±…ì„) 'candysoap' ì „ìš© ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
                const userStatsRef = db.ref('users').child(playerUid).child('gameStats/candysoap');

                userStatsRef.transaction(currentStats => {
                    if (currentStats === null) {
                        // [ì‹ ê·œ] ë­í‚¹ í•„ë“œ ì´ˆê¸°í™”
                        currentStats = { 
                            wins: 0, losses: 0, draws: 0, plays: 0, highscore: 0,
                            rank1: 0, rank2: 0, rank3: 0, rank4: 0
                        };
                    }

                    // [ì‹ ê·œ] ê¸°ì¡´ ìœ ì €ê°€ ìƒˆ í•„ë“œ(rank1~4)ê°€ ì—†ì„ ê²½ìš° ëŒ€ë¹„
                    currentStats.rank1 = (currentStats.rank1 || 0);
                    currentStats.rank2 = (currentStats.rank2 || 0);
                    currentStats.rank3 = (currentStats.rank3 || 0);
                    currentStats.rank4 = (currentStats.rank4 || 0);

                    // ê¸°ì¡´ ë¡œì§
                    currentStats.plays = (currentStats.plays || 0) + 1;
                    currentStats.highscore = Math.max(currentStats.highscore || 0, finalScore); 
                    
                    // [ì‹ ê·œ] ìµœì¢… ìˆœìœ„(finalRank)ì— ë”°ë¼ í•´ë‹¹ ë­í‚¹ íšŸìˆ˜ ì¦ê°€
                    if (finalRank === 1) {
                        currentStats.rank1 += 1;
                        currentStats.wins = (currentStats.wins || 0) + 1; // 1ìœ„ = ìŠ¹ë¦¬ (ê¸°ì¡´ ë¡œì§ í˜¸í™˜)
                    } else if (finalRank === 2) {
                        currentStats.rank2 += 1;
                        currentStats.losses = (currentStats.losses || 0) + 1; // 2~4ìœ„ = íŒ¨ë°° (ê¸°ì¡´ ë¡œì§ í˜¸í™˜)
                    } else if (finalRank === 3) {
                        currentStats.rank3 += 1;
                        currentStats.losses = (currentStats.losses || 0) + 1;
                    } else if (finalRank === 4) {
                        currentStats.rank4 += 1;
                        currentStats.losses = (currentStats.losses || 0) + 1;
                    } else {
                        // 1ì¸ ì†”ë¡œ í”Œë ˆì´ ë˜ëŠ” ì˜ˆì™¸ ì²˜ë¦¬ (ê¸°ì¡´ ìŠ¹/íŒ¨ ë¡œì§ ì‚¬ìš©)
                        currentStats[result] = (currentStats[result] || 0) + 1;
                    }

                    return currentStats;
                });
                
                // 2. (ê²Œì„ íŒŒì¼ì˜ ì±…ì„) 'ì• ë‹ˆíŒ¡' ë³´ìƒ ê³„ì‚°
                let expGained = 50, pointsGained = 50;
                if(didIWin === true) { expGained = 150; pointsGained = 100; } // 1ë“±
                else if (didIWin === null) { expGained = 75; pointsGained = 75; } // ë¬´ìŠ¹ë¶€
                // 2~4ë“±ì€ ê¸°ë³¸ ì ìˆ˜
                
                // 3. (ë ˆë²¨ì—….jsì˜ ì±…ì„) ì¤‘ì•™ ë ˆë²¨ì—… í•¨ìˆ˜ í˜¸ì¶œ
                // (db, playerUid, expGained, pointsGained)
                applyExpAndPoints(db, playerUid, expGained, pointsGained);
            }

            // [ìˆ˜ì •] 1. ë°©ì¥ì´ 'ëŒ€ê¸°ì‹¤ë¡œ'ë¥¼ ëˆ„ë¥¼ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
            async function hostCleanupAndCreateNewRoom(playersData, gameType) { // [ìˆ˜ì •] ì¸ì ë°›ê¸°
                // [ìˆ˜ì •] currentRoomData ëŒ€ì‹  ì „ë‹¬ë°›ì€ ë°ì´í„°ë¡œ ìœ íš¨ì„± ê²€ì‚¬
                if (!isHost || !playersData || !gameType || !playerUid) {
                    console.error("hostCleanupAndCreateNewRoom: í•„ìˆ˜ ë°ì´í„° ëˆ„ë½", isHost, playersData, gameType, playerUid);
                    cleanupAndExit(); // ì‹¤íŒ¨ ì‹œ ì¼ë°˜ ë‚˜ê°€ê¸°
                    return;
                }

                console.log("ë°©ì¥ì´ ìƒˆ ë°©ì„ ìƒì„±í•©ë‹ˆë‹¤...");
                isExiting = true;
                stopSound('bgm');
                if (timerId) clearInterval(timerId);
                if (feverTimerId) clearTimeout(feverTimerId);

                const oldRoomRef = roomRef; // ì´ì „ ë°© ì°¸ì¡° ì €ì¥
                
                // 1. [ìˆ˜ì •] currentRoomData -> playersData
                const hostProfile = playersData[playerUid];
                if (!hostProfile) {
                    console.error("í˜¸ìŠ¤íŠ¸ í”„ë¡œí•„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (playersDataì— UID ì—†ìŒ)");
                    cleanupAndExit(); // ì‹¤íŒ¨ ì‹œ ì¼ë°˜ ë‚˜ê°€ê¸°
                    return;
                }

                // 2. ìƒˆë¡œìš´ ë°© ìƒì„± (ëŒ€ê¸°ì‹¤ ë¡œì§ê³¼ ìœ ì‚¬)
                const newRoomRef = db.ref('rooms').push(); // ìƒˆ ë°© ID ìƒì„±
                const newRoomData = {
                    roomName: `${hostProfile.nickname}ì˜ ë°©`,
                    hostId: playerUid,
                    gameType: gameType, // [ìˆ˜ì •] currentRoomData.gameType -> gameType
                    status: 'waiting',
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    maxPlayers: currentRoomData.maxPlayers || 4, // [ì‹ ê·œ] ìµœëŒ€ ì¸ì› ìˆ˜ (ì—†ìœ¼ë©´ 4ëª…)
                    players: {
                        [playerUid]: {
                            nickname: hostProfile.nickname,
                            avatar: hostProfile.avatar,
                            isHost: true
                        }
                    }
                };

                try {
                    // 3. ìƒˆ ë°© ì •ë³´ Firebaseì— ë“±ë¡
                    await newRoomRef.set(newRoomData);
                    const newRoomId = newRoomRef.key;
                    console.log(`ìƒˆ ë°© ìƒì„± ì™„ë£Œ: ${newRoomId}`);

                    // 4. [í•µì‹¬] "ì´ì „ ë°©"ì— "ë‹¤ìŒ ë°© ID"ë¥¼ ë‚¨ê¸°ê¸° (ê²ŒìŠ¤íŠ¸ ì¶”ì ìš©)
                    await oldRoomRef.update({
                        nextRoomId: newRoomId,
                        status: 'finished' // ê²ŒìŠ¤íŠ¸ë“¤ì˜ ë¦¬ìŠ¤ë„ˆë¥¼ í™•ì‹¤íˆ ì¢…ë£Œ
                    });
                    
                    // 5. ì´ì „ ë°© ì‚­ì œ
                    await oldRoomRef.remove();

                    // 6. í˜¸ìŠ¤íŠ¸ëŠ” ìƒˆ ë°©ìœ¼ë¡œ ì´ë™
                    window.location.replace(`ê²Œì„ë°©.html?roomId=${newRoomId}`);

                } catch (error) {
                    console.error("ìƒˆ ë°© ìƒì„± ë˜ëŠ” ì´ì „ ë°© ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
                    cleanupAndExit(); // ì‹¤íŒ¨ ì‹œ ì¼ë°˜ ë‚˜ê°€ê¸°
                }
            }

          // [ìˆ˜ì •] 2. ê²ŒìŠ¤íŠ¸ê°€ 'ëŒ€ê¸°ì‹¤ë¡œ'ë¥¼ ëˆ„ë¥´ê±°ë‚˜, ì—ëŸ¬ ë°œìƒ ì‹œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜
            function cleanupAndExit() {
                console.log("Cleanup and Exit called (Guest or Fallback)");
                isExiting = true; 
                stopSound('bgm'); 
                if (timerId) clearInterval(timerId);
                if (feverTimerId) clearTimeout(feverTimerId);

                // onDisconnect í•¸ë“¤ëŸ¬ ì·¨ì†Œ ì‹œë„
                if (hostStatusDisconnectRef) { try { hostStatusDisconnectRef.cancel(); } catch(e) {} }
                
                let removePromise = Promise.resolve(); 

                if (roomRef && playerUid) {
                    roomRef.off(); 
                    if (chatListenerRef) chatListenerRef.off(); 

                    // [ìˆ˜ì •] ì´ í•¨ìˆ˜ëŠ” ì´ì œ ê²ŒìŠ¤íŠ¸ ì „ìš©ì´ë¯€ë¡œ, 'isHost' ì²´í¬ ì—†ì´ ìì‹ ë§Œ ì œê±°
                    if (!isHost) {
                        console.log("Guest removing self from players...");
                        removePromise = roomRef.child('players/' + playerUid).remove();
                    } else {
                        // ë°©ì¥ì´ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí–ˆë‹¤ë©´ (ì˜ˆ: hostCleanupAndCreateNewRoom ì‹¤íŒ¨ ì‹œ)
                        // ë°©ì„ ê·¸ëƒ¥ ì‚­ì œ (Fallback)
                        console.warn("Host fallback: removing room...");
                        removePromise = roomRef.remove();
                    }
                }

                removePromise
                    .catch(e => console.error("Firebase remove operation failed:", e))
                    .finally(() => {
                        console.log("Redirecting to ëŒ€ê¸°ì‹¤.html");
                        window.location.replace('ëŒ€ê¸°ì‹¤.html');
                    });
            }

            // --- [ì‹ ê·œ] ğŸ§± ë°©í•´ íƒ€ì¼ í—¬í¼ í•¨ìˆ˜ 3ê°œ ---

            /**
             * 1. (ë„¤íŠ¸ì›Œí¬) ìƒëŒ€ë°© ì „ì›ì—ê²Œ ë°©í•´ íƒ€ì¼ ê³µê²©ì„ ì „ì†¡í•©ë‹ˆë‹¤.
             */
            function sendJunkAttack(attackCount) {
                if (!currentRoomData || !currentRoomData.players || !roomRef || !playerUid) return;

                console.log(`ğŸ§Š ${attackCount}ê°œ ì–¼ìŒ íƒ€ì¼ ê³µê²© ì „ì†¡!`);
                const attackData = {
                    count: attackCount,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };

                // ë‚˜ë¥¼ ì œì™¸í•œ ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ì „ì†¡
                Object.keys(currentRoomData.players).forEach(uid => {
                    if (uid !== playerUid) {
                        roomRef.child('attacks/' + uid).push(attackData);
                    }
                });
            }

            /**
             * 2. (ìˆ˜ì‹ ) ê³µê²©ë°›ì€ ì–¼ìŒ íƒ€ì¼ì„ ë³´ë“œì— ë¬´ì‘ìœ„ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
             */
            function addJunkTilesToBoard(count) {
                if (isProcessing) return; // ì…”í”Œ ì¤‘ì´ê±°ë‚˜ í•˜ë©´ ë°©ì§€

                const availableTiles = [];
                // 1. ì¼ë°˜ ë™ë¬¼ íƒ€ì¼ë§Œ ìˆ˜ì§‘
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const tileData = board[r][c];
                        if (tileData && TILE_EMOJIS.includes(tileData)) {
                            availableTiles.push({ r, c });
                        }
                    }
                }

                if (availableTiles.length === 0) return;

                // 2. íƒ€ì¼ì„ ì„ì–´ì„œ count ë§Œí¼ ì–¼ìŒìœ¼ë¡œ ë³€ê²½
                availableTiles.sort(() => 0.5 - Math.random());
                const tilesToFreeze = availableTiles.slice(0, count);

                tilesToFreeze.forEach(({ r, c }) => {
                    board[r][c] = JUNK_TILE; // ë°ì´í„° ë³€ê²½
                    const tileEl = tileElements[r][c];
                    if (tileEl) {
                        setTileAppearance(tileEl, JUNK_TILE); // ê²‰ëª¨ìŠµ ë³€ê²½
                        tileEl.classList.add('new-tile-anim'); // ìƒì„± ì• ë‹ˆë©”ì´ì…˜
                    }
                });
            }

            /**
             * 3. (ê³µê²© íŒì •) í”Œë ˆì´ì–´ì˜ ìŠ¤ì™‘ì´ 4/5ë§¤ì¹˜ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
             */
            function checkPlayerAttack(r1, c1, r2, c2) {
                let attackCount = 0;
                // ìŠ¤ì™‘í•œ ë‘ ìœ„ì¹˜ (r1,c1), (r2,c2)ë§Œ ê²€ì‚¬
                const coordsToTest = [[r1, c1], [r2, c2]];
                const checkedTiles = new Set(); // ì¤‘ë³µ ê²€ì‚¬ ë°©ì§€

                coordsToTest.forEach(([r, c]) => {
                    const tile = board[r][c];
                    if (!tile || !TILE_EMOJIS.includes(tile) || checkedTiles.has(`${r}-${c}`)) return;

                    // ê°€ë¡œ ê²€ì‚¬
                    let hCount = 1;
                    let cLeft = c - 1;
                    while (cLeft >= 0 && board[r][cLeft] === tile) { hCount++; checkedTiles.add(`${r}-${cLeft--}`); }
                    let cRight = c + 1;
                    while (cRight < COLS && board[r][cRight] === tile) { hCount++; checkedTiles.add(`${r}-${cRight++}`); }
                    
                    if (hCount === 5) attackCount += 3;
                    else if (hCount === 4) attackCount += 1;

                    // ì„¸ë¡œ ê²€ì‚¬
                    let vCount = 1;
                    let rUp = r - 1;
                    while (rUp >= 0 && board[rUp][c] === tile) { vCount++; checkedTiles.add(`${rUp--}-${c}`); }
                    let rDown = r + 1;
                    while (rDown < ROWS && board[rDown][c] === tile) { vCount++; checkedTiles.add(`${rDown++}-${c}`); }
                    
                    if (vCount === 5) attackCount += 3;
                    else if (vCount === 4) attackCount += 1;
                });

return attackCount;
            }

            /**
             * 4. (ë©€í‹°-ë§¤ì¹˜ íŒì •) í”Œë ˆì´ì–´ì˜ ìŠ¤ì™‘ì´ 2ê°œ ì´ìƒì˜ ë§¤ì¹˜ë¥¼ 'ë™ì‹œì—' ë§Œë“¤ì—ˆëŠ”ì§€ í™•ì¸
             */
            function checkMultiMatch(r1, c1, r2, c2) {
                // ìŠ¤ì™‘í•œ ë‘ íƒ€ì¼ì´ ê°ìì˜ 'ìƒˆ ìœ„ì¹˜'ì—ì„œ 3ë§¤ì¹˜ ì´ìƒì„ ë§Œë“œëŠ”ì§€ ê²€ì‚¬
                const match1 = isTileCreatingMatch(r1, c1);
                const match2 = isTileCreatingMatch(r2, c2);
                
                // ë‘ íƒ€ì¼ ëª¨ë‘ 3ë§¤ì¹˜ ì´ìƒì„ ë§Œë“¤ì—ˆë‹¤ë©´ 'ë©€í‹°-ë§¤ì¹˜'
                return match1 && match2;
            }
            
            // checkMultiMatchì˜ í—¬í¼: íŠ¹ì • íƒ€ì¼ì´ 3ë§¤ì¹˜ ì´ìƒì„ ë§Œë“œëŠ”ì§€ í™•ì¸
            function isTileCreatingMatch(r, c) {
                const tile = board[r][c];
                if (!tile || !TILE_EMOJIS.includes(tile)) return false;

                // ê°€ë¡œ ê²€ì‚¬
                let hCount = 1;
                let cLeft = c - 1;
                while (cLeft >= 0 && board[r][cLeft] === tile) { hCount++; cLeft--; }
                let cRight = c + 1;
                while (cRight < COLS && board[r][cRight] === tile) { hCount++; cRight++; }
                if (hCount >= 3) return true;

                // ì„¸ë¡œ ê²€ì‚¬
                let vCount = 1;
                let rUp = r - 1;
                while (rUp >= 0 && board[rUp][c] === tile) { vCount++; rUp--; }
                let rDown = r + 1;
                while (rDown < ROWS && board[rDown][c] === tile) { vCount++; rDown++; }
                if (vCount >= 3) return true;
                
                return false;
            }

            // [ì‹ ê·œ] í† ìŠ¤íŠ¸ ì•Œë¦¼ (ì´ˆëŒ€/ìª½ì§€/ì¹œêµ¬) ë¦¬ìŠ¤ë„ˆ ì„¤ì • í•¨ìˆ˜
            let globalListenersAttached = false; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
            function setupGlobalNotificationListeners(userId) {
                if (globalListenersAttached || !userId || !db) return;
                globalListenersAttached = true;
                
                console.log("[ì•Œë¦¼] ì „ì—­ ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (ID:", userId, ")");
                
                // ì§€ê¸ˆ ì´ ìˆœê°„ ì´í›„ì˜ ë°ì´í„°ë§Œ ë°›ë„ë¡ ì„¤ì • (í˜ì´ì§€ ë¡œë“œ ì‹œ ê³¼ê±° ì•Œë¦¼ ë°©ì§€)
                const now = Date.now(); // [ë²„ê·¸ ìˆ˜ì •] TIMESTAMP -> Date.now()

                // 1. ë°© ì´ˆëŒ€ ì•Œë¦¼
                const invitesRef = db.ref(`invitations/${userId}`);
                invitesRef.on('child_added', snapshot => {
                    const invite = snapshot.val();
                    if (invite && invite.from_name) {
                        showToast(`ğŸ”” [ë°© ì´ˆëŒ€] ${escapeHTML(invite.from_name)}ë‹˜ì´ '${escapeHTML(invite.game_name)}' ë°©ì— ì´ˆëŒ€í–ˆìŠµë‹ˆë‹¤.`);
                        playSound('swap'); // ê°„ë‹¨í•œ ì•Œë¦¼ìŒ
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });

                // 2. ì¹œêµ¬ ìš”ì²­ ì•Œë¦¼
                const friendReqRef = db.ref(`friend_requests/${userId}`); // [ìˆ˜ì •] ê²½ë¡œ ë³€ê²½
                friendReqRef.on('child_added', snapshot => {
                    const req = snapshot.val();
                    if (req && req.from_name) {
                         showToast(`ğŸ’Œ [ì¹œêµ¬ ìš”ì²­] ${escapeHTML(req.from_name)}ë‹˜ì´ ì¹œêµ¬ë¥¼ ì‹ ì²­í–ˆìŠµë‹ˆë‹¤.`);
                         playSound('swap');
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });

                // 3. ìª½ì§€(ê·“ì†ë§) ì•Œë¦¼
                const whisperRef = db.ref(`user_inboxes/${userId}`); // [ìˆ˜ì •] ê²½ë¡œ ë³€ê²½
                whisperRef.on('child_added', async (snapshot) => { // [ìˆ˜ì •] async ì¶”ê°€
                    const msg = snapshot.val();
                    const senderUid = snapshot.key; // [ìˆ˜ì •] í‚¤ê°€ UIDì„

                    // [ìˆ˜ì •] ë°ì´í„° êµ¬ì¡° ë³€ê²½ (lastMessage)
                    if (msg && msg.lastMessage && senderUid) { 
                        try {
                            // [ì‹ ê·œ] ë³´ë‚¸ ì‚¬ëŒì˜ í”„ë¡œí•„ì„ ê°€ì ¸ì˜´
                            const profileSnap = await db.ref(`users/${senderUid}/profile`).once('value');
                            if (profileSnap.exists()) {
                                const nickname = profileSnap.val().nickname || '...';
                                showToast(`ğŸ’¬ [ìª½ì§€] ${escapeHTML(nickname)}: ${escapeHTML(msg.lastMessage)}`);
                                playSound('swap');
                            }
                        } catch (e) {
                            console.error("ìª½ì§€ ì•Œë¦¼ ë‹‰ë„¤ì„ ë¡œë“œ ì‹¤íŒ¨:", e);
                        }
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });
            }
        }); // DOMContentLoaded End
    </script>

    <div id="rematch-chat-input-modal" class="overlay" style="background-color: transparent; align-items: flex-end;">
    <div class="modal-content" style="max-width: 100%; width: 100%; border-radius: 20px 20px 0 0; margin-bottom: 0; padding: 0; border-bottom: none; box-shadow: 0 -5px 20px rgba(0,0,0,0.3);">
        <div class="modal-body" style="padding: 10px;">
            <div style="display: flex; gap: 8px;">
                <input type="text" id="rematch-chat-input" placeholder="ì±„íŒ… ì…ë ¥..." style="flex-grow: 1; border: 2px solid var(--text-color-dark); border-radius: 12px; padding: 12px; font-size: 1em; font-family: var(--font-main); min-width: 0;">
                <button id="rematch-chat-stt-btn" class="menu-btn secondary" style="width: 50px; padding: 0; font-size: 1.2em; flex-shrink: 0; border-bottom-width: 4px;">ğŸ™ï¸</button>
                <button id="rematch-chat-send-btn" class="menu-btn primary" style="width: 70px; padding: 0; flex-shrink: 0; border-bottom-width: 4px;">ì „ì†¡</button>
            </div>
        </div>
    </div>
</div>

</body>
</html>