<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>사천성 (멀티플레이)</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        /* --- 기본 스타일 (알까기/리버시 참고) --- */
:root {
            --bg-color: #f0f0f0; /* 밝은 배경 */
            --board-bg: #f8f9fa; /* [수정] 보드 배경을 살짝 어둡게 (타일과 분리) */
            --border-color: #cccccc;
            --tile-bg: #ffffff; /* [유지] 타일은 흰색 */
            --tile-bg-hover: #f0f0f0; /* [수정] 호버 색상을 조금 더 진하게 */
            --tile-selected-bg: #FFC84A; /* 강조색 */
            --tile-selected-border: #4A8DFF; /* Primary Color */
            --primary-color: #4A8DFF;
            --accent-color: #FFC84A;
            --text-color-dark: #333D4B;
            --text-color-light: #ffffff;
            --danger-color: #F76363;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: var(--text-color-dark);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
        }

        #game-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #e9eef2; }
        #game-header {
            flex-shrink: 0; display: flex; justify-content: space-around; align-items: center;
            padding: 10px 15px; background-color: rgba(0,0,0,0.05); gap: 15px; border-bottom: 1px solid var(--border-color);
        }
        .player-info {
            display: flex; align-items: center; gap: 8px;
            background-color: rgba(255,255,255,0.7);
            padding: 8px 12px; border-radius: 20px; /* 더 둥글게 */
            transition: all 0.3s ease;
            flex: 1; min-width: 0; /* 내용 넘칠 때 줄어들도록 */
            border: 2px solid transparent;
        }
        .player-info.my-turn {
            border-color: var(--accent-color);
            background-color: var(--accent-color);
            color: var(--text-color-dark);
            transform: scale(1.03);
            box-shadow: 0 0 10px rgba(255, 200, 74, 0.5);
        }
        .player-info .avatar {
            font-size: 1.8em; width: 36px; height: 36px;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; background-color: #eee; border-radius: 50%;
        }
        .player-info .avatar img { width: 100%; height: 100%; object-fit: contain; border-radius: 50%; }
        .player-info .info-text { display: flex; flex-direction: column; min-width: 0; flex-grow: 1;}
        .player-info .nickname { font-weight: 700; font-size: 0.9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-info .score { font-size: 0.8em; color: #555; }
        .player-info.my-turn .score { color: #333; }

        #game-container {
            width: 100%; flex-grow: 1; display: flex; justify-content: center; align-items: center; /* 다시 center로 복구 */
            position: relative; overflow: hidden; padding: 5px; /* 패딩 약간 줄임 */
        }
        #game-board {
            position: relative; background-color: var(--board-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            display: grid; /* JS에서 columns/rows 설정 */
            gap: 1px; /* 타일 간격 (2px -> 1px) */
            padding: 2px; /* 보드 내부 여백 (5px -> 2px) */
            /* 크기는 JS에서 설정 */
            /* 터치 시 확대 방지 */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        

.tile {
            background-color: var(--tile-bg);
            border-radius: 5px; /* 약간 덜 둥글게 */
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8em; /* 아이콘 크기 (JS에서 조절) */
            cursor: pointer;
            transition: background-color 0.15s, transform 0.15s, border-color 0.15s, box-shadow 0.15s; /* [수정] transition에 shadow 추가 */
            border: 1px solid transparent; /* 기본 테두리 투명 (2px -> 1px) */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* [수정] 그림자 강화 (더 떠보이게) */
            aspect-ratio: 1 / 1; /* 정사각형 유지 */
        }
      .tile:hover { 
            background-color: var(--tile-bg-hover); 
            box-shadow: 0 4px 10px rgba(0,0,0,0.12); /* [수정] 호버 시 그림자 더 강조 */
        }
        .tile.selected {
            background-color: var(--tile-selected-bg);
            border-color: var(--tile-selected-border);
            transform: scale(1.08); /* 선택 시 약간 더 크게 */
            box-shadow: 0 0 10px var(--tile-selected-border);
        }
        .tile.hidden { /* 매칭되어 사라질 때 */
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            background-color: transparent !important; /* 배경 투명하게 */
            box-shadow: none;
            cursor: default;
        }
        .tile img { /* 이미지 타일용 */
             width: 75%; height: 75%; object-fit: contain;
             pointer-events: none; /* 이미지 클릭 방지 */
        }

        /* --- 오버레이/모달 스타일 (리버시.html 참고, 약간 수정) --- */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.7); }
        .modal-content { background: var(--panel-bg); color: var(--text-color-dark); padding: 0; border-radius: 16px; width: 90%; max-width: 400px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); overflow: hidden; }
        .modal-header { background-color: var(--primary-color); color: white; padding: 15px; border-radius: 16px 16px 0 0; }
        .modal-header h2 { font-size: 1.6em; }
        .modal-body { padding: 25px; }
        .modal-buttons { display: flex; flex-direction: column; gap: 12px; align-items: center; margin-top: 25px; }
        .spinner { border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #countdown-number { font-size: 7em; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.7); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* 게임 종료 점수판 */
        #score-board { margin: 20px 0; display: flex; flex-direction: column; gap: 8px; }
        .score-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-radius: 8px; font-size: 1.1em; font-weight: 700; }
        .score-row.winner { background-color: var(--accent-color); color: var(--text-color-dark); transform: scale(1.03); }
        .score-row.loser, .score-row.draw { background-color: #e9ecef; color: var(--text-color-dark); }
        .score-avatar { display: inline-flex; align-items: center; gap: 10px; }
        .score-avatar img { width: 32px; height: 32px; object-fit: contain; border-radius: 50%; }

        /* 버튼 스타일 */
        .menu-btn { width: 100%; padding: 15px; font-size: 1.1em; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; margin: 5px 0; }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #e9eff8; color: var(--text-color-dark); }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn:disabled { background-color: #ccc; color: #888; cursor: not-allowed; }

        /* 나가기 확인 모달 스타일 */
       #confirm-exit-modal .modal-content { max-width: 350px; background-color: #fff; }
       #confirm-exit-modal .modal-body { padding: 30px; text-align: center; }
       #confirm-exit-modal .modal-body h3 { font-size: 1.4em; margin-bottom: 15px; color: var(--text-color-dark); }
       #confirm-exit-modal .modal-body p { font-size: 0.9em; color: #666; }
       #confirm-exit-modal .modal-footer { display: flex; gap: 10px; padding: 15px; background-color: #f8f9fa; border-top: 1px solid #eee; }

       #path-canvas {
            position: absolute;
            /* JS에서 top/left/width/height를 보드에 맞춰 설정합니다 */
            pointer-events: none; /* 캔버스 클릭 방지 */
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-header">
            </div>
        <div id="game-container">
            <div id="game-board">
                </div>
            <canvas id="path-canvas"></canvas>
            </div>
    </div>

    <div id="game-over-overlay" class="overlay" style="display: none;">
        </div>
    <div id="info-overlay" class="overlay">
         <div class="spinner"></div>
         <p style="color: white; margin-top: 15px; font-size: 1.1em;">게임 준비 중...</p>
    </div>
    <div id="confirm-exit-modal" class="overlay" style="display: none;">
         <div class="modal-content">
             <div class="modal-body">
                 <h3>게임에서 나가시겠습니까?</h3>
                 <p>게임은 패배 처리됩니다.</p>
             </div>
             <div class="modal-footer">
                 <button id="exit-cancel-btn" class="menu-btn secondary">취소</button>
                 <button id="exit-confirm-btn" class="menu-btn primary" style="background-color: var(--danger-color);">확인</button>
             </div>
         </div>
    </div>

    <audio id="tile-select-sound" src="./sounds/select.mp3" preload="auto"></audio>
    <audio id="tile-match-sound-new" src="./봄버맨사운드/사천성맞춤.mp3" preload="auto"></audio>
    <audio id="win-sound-new" src="./봄버맨사운드/win.mp3" preload="auto"></audio>
    <audio id="loss-sound-new" src="./봄버맨사운드/패배.mp3" preload="auto"></audio>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script>
        // --- HTML Escape 함수 ---
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
            return str.replace(/[&<>"']/g, m => map[m]);
        }

        function getBoardArray(boardData, tileCount) {
            // 항상 TILE_COUNT 길이를 가진 새 배열을 만듭니다.
            const newArray = new Array(tileCount).fill(null);
            
            if (boardData) {
                 // boardData가 Firebase 객체({0: 'a', 2: 'c'})든,
                 // JS의 (희소) 배열이든, for...in은 숫자 인덱스를 순회합니다.
                for (const key in boardData) {
                    const index = parseInt(key, 10);
                    // 키값이 숫자인지, 유효한 인덱스 범위인지 확인
                    if (!isNaN(index) && index >= 0 && index < tileCount) { 
                        newArray[index] = boardData[key];
                    }
                }
            }
            return newArray; // 항상 'null'을 포함한 'dense' 배열을 반환
        }

        // --- [신규] 배열 섞기 헬퍼 ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- [신규] 빈 칸 인덱스 찾기 헬퍼 ---
        function findEmptySpots(boardArray) {
            const emptyIndices = [];
            boardArray.forEach((tile, index) => {
                if (tile === null) {
                    emptyIndices.push(index);
                }
            });
            return emptyIndices;
        }

        document.addEventListener('DOMContentLoaded', () => {
            // --- 개발자 도구 방지 ---
             document.addEventListener('contextmenu', event => event.preventDefault());
             document.addEventListener('keydown', event => {
                 if (event.key === 'F12' ||
                   (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
                    (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                     event.preventDefault();
                 }
             });
             setInterval(() => { try { debugger; } catch (e) {} }, 1000); 

            // --- Firebase 설정 ---
            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.appspot.com",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database();
            const auth = firebase.auth();
            const roomsRef = db.ref('rooms');
            const usersRef = db.ref('users');

            // --- HTML 요소 ---
            const gameBoard = document.getElementById('game-board');
            const gameHeader = document.getElementById('game-header');
            const gameContainer = document.getElementById('game-container');
            const infoOverlay = document.getElementById('info-overlay');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const confirmExitModal = document.getElementById('confirm-exit-modal');
            const exitConfirmBtn = document.getElementById('exit-confirm-btn');
            // ▼▼▼ [신규] 캔버스 요소 추가 ▼▼▼
            const pathCanvas = document.getElementById('path-canvas');
            const ctx = pathCanvas.getContext('2d');
            // ▲▲▲ [신규] 캔버스 요소 추가 ▲▲▲

            // --- 게임 상태 변수 ---
            let myPlayerId, myNickname, myAvatar;
            let roomRef, currentRoomData, isHost;
            let isGameLive = false, gameOverFlag = false, isExiting = false;
            let selectedTileElement = null; // 현재 내가 선택한 타일 DOM 요소
            let firstSelection = null; // Firebase 'selectedTiles'에 저장된 내 첫 선택 정보
            
            // ▼▼▼ [신규] 타일 크기/간격 (캔버스 좌표 계산용) ▼▼▼
            let currentTileSize = 0;
            let currentGapSize = 2; // CSS의 gap 값과 일치
            let currentExtraMargin = 0; // 캔버스 외곽 여백 (외곽선 그리기용)


            // --- 게임 설정 보드판 ---
            const BOARD_ROWS = 8; // 행 (조절 가능)
            const BOARD_COLS = 5; // 열 (조절 가능)
            const TILE_COUNT = BOARD_ROWS * BOARD_COLS;
            // 사용할 타일 아이콘/이미지 경로 (짝수 개수, TILE_COUNT 이상)
            // 아이콘과 이미지 경로를 섞어서 사용할 수 있습니다. 이모지
             const TILE_ICONS = [
                '🐶', '🎴', '🎃', '🐹', '🐰', '🎤', '🐻', '🧸', '🐨', '🐯',
                '🦁', '🍩', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦', '🐤', '🗝️',
                '🍔', '🍕', '🍟', '🌭', '🍿', '🐞', '🥓', '🥚', '🧟‍♂️', '🥞',
                '🎻', '🍋', '🍉', '🍇', '🍓', '🍑', '🥝', '🥥', '⛏️', '👻',
                // 이미지 예시 (경로 확인 필요)
                 './tiles/cake.png', './tiles/candy.png', './tiles/cherry.png', './tiles/donut.png',
                 './tiles/icecream.png', './tiles/lollipop.png', './tiles/pudding.png', './tiles/star.png'
             ]; // TILE_COUNT / 2 개의 *고유한* 아이콘/경로 필요

            // 아바타 세트 정의 (대기실.html 에서 복사)
             const AVATAR_SETS = {
                 'penguin_parka': { front: './아바타폴더/펭귄정면.png' },
                 'puppy_set': { front: './아바타폴더/강아지정면.png' }
             };

            // --- 사운드 재생 함수 ---
            function playSound(id) {
                try {
                    const sound = document.getElementById(id);
                    if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
                } catch(e) { console.warn("Sound play error:", e); }
            }

          // ▼▼▼ [신규] 진동 효과 함수 (틀렸을 때) ▼▼▼
            function playVibrationEffect() {
                if (navigator.vibrate) {
                    // 안드로이드 기기에서 100ms 진동
                    navigator.vibrate(100); 
                }
            }
            // ▲▲▲ [신규] 진동 효과 함수 (틀렸을 때) ▲▲▲

            // --- 초기화 및 방 참가 로직 ---
            function initialize() {
                auth.onAuthStateChanged(user => {
                    if (user) {
                        myPlayerId = user.uid;
                        myNickname = localStorage.getItem('userNickname') || 'Player';
                        myAvatar = localStorage.getItem('userAvatar') || '😊';
                        if (!myNickname) { auth.signOut(); window.location.replace('index.html'); return; }

                        const urlParams = new URLSearchParams(window.location.search);
                        const roomId = urlParams.get('roomId');
                        if (roomId) {
                             // 로딩 오버레이 표시
                            infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">방에 참가하는 중...</p>`;
                            infoOverlay.style.display = 'flex';
                            joinRoom(roomId);
                        } else {
                            alert("잘못된 접근입니다."); window.location.replace('대기실.html');
                        }
                    } else {
                        window.location.replace('index.html');
                    }
                });

                // 뒤로가기 이벤트 처리
                history.pushState(null, '', location.href);
                window.addEventListener('popstate', (e) => {
                     history.pushState(null, '', location.href);
                     confirmExitModal.style.display = 'flex';
                });
                exitConfirmBtn.addEventListener('click', cleanupAndExit);
                exitCancelBtn.addEventListener('click', () => { confirmExitModal.style.display = 'none'; });
            }

            function joinRoom(roomId) {
                roomRef = roomsRef.child(roomId);
                roomRef.once('value', snapshot => {
                    if (!snapshot.exists()) { alert("방을 찾을 수 없습니다."); window.location.replace('대기실.html'); return; }

                    currentRoomData = snapshot.val();
                    isHost = currentRoomData.hostId === myPlayerId;

                    // 방 참가 처리 (플레이어 정보 추가 등 - 게임방.html 참고)
                    const myPlayerData = {
                        nickname: myNickname,
                        avatar: myAvatar,
                        isHost: isHost
                    };

                     // 이미 방에 있고, 상태가 'playing'이면 바로 게임 시작 (재접속 처리)
                     if (currentRoomData.players && currentRoomData.players[myPlayerId] && currentRoomData.status === 'playing') {
                         console.log("재접속 감지됨, 게임 데이터 리스닝 시작");
                         listenToRoomChanges();
                         return; // setupGameLayout 불필요
                     }

                    // onDisconnect 설정
                    if (isHost) { roomRef.onDisconnect().remove(); }
                    else { roomRef.child('players/' + myPlayerId).onDisconnect().remove(); }

                    // 플레이어 정보 업데이트/추가
                   roomRef.child('players/' + myPlayerId).set(myPlayerData).then(() => {
                         listenToRoomChanges();
                         
                         // ✨ [수정] 방장/게스트 상관없이 'waiting' 상태(재시작)이고
                         // board가 없으면 (아직 맵 생성 전) ready 신호를 보냅니다.
                         if (currentRoomData.status === 'waiting' && !currentRoomData.board) {
                             roomRef.child('readyPlayers/' + myPlayerId).set(true);
                         }
                    }).catch(error => {
                        console.error("방 참가 오류:", error);
                        alert("방 입장에 실패했습니다."); window.location.replace('대기실.html');
                    });

                }).catch(error => {
                     console.error("Firebase read error:", error);
                     alert("방 정보를 읽어오는데 실패했습니다."); window.location.replace('대기실.html');
                });
            }

            function listenToRoomChanges() {
                let countdownStarted = false; // 카운트다운 중복 실행 방지 플래그

                roomRef.on('value', snapshot => {
                    if (isExiting) return; // 퇴장 중이면 업데이트 무시
                    if (!snapshot.exists()) {
                         if (!gameOverFlag) alert("방장이 나가 방이 사라졌습니다."); // 게임 종료가 아닐 때만 알림
                         cleanupAndExit();
                         return;
                    }

                    currentRoomData = snapshot.val();

                    // 내가 방에서 제외되었는지 확인
                    if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                         if (!gameOverFlag) alert("방에서 제외되었습니다.");
                         cleanupAndExit();
                         return;
                    }

                 // 게임 상태에 따른 처리
            if (currentRoomData.status === 'playing') {
                
                // ✨ [수정] 방장이 게임판(board)을 생성해야 하는지 확인
                if (isHost && !currentRoomData.board) {
                    // status가 'playing'이지만 board가 없으면, 방장이 지금 생성합니다.
                    // (게임방.html에서 'launching' 신호를 받고 넘어온 직후)
                    
                    // ▼▼▼ [신규] 맵 생성 중... 로딩 표시 ▼▼▼
                    // ✨ [수정] 맵 생성 시도 횟수를 표시하도록 텍스트 변경
                    infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">게임보드 생성중... (1/10)</p>`;
                    infoOverlay.style.display = 'flex';
                    // ▲▲▲ [신규] 맵 생성 중... 로딩 표시 ▲▲▲

                    console.log("방장 감지: board가 없으므로 게임판을 생성합니다.");
                    initializeShisenShoGame();
                    return; // board 생성 후, 다음 on('value') 이벤트를 기다립니다.
                }

                // ▼▼▼ [신규] 게스트가 방장의 맵 생성을 기다리는 상태 ▼▼▼
                if (!isHost && !currentRoomData.board) {
                    infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">게임보드 생성중...</p>`;
                    infoOverlay.style.display = 'flex';
                    return; // 방장이 맵을 만들고 board가 생길 때까지 대기
                }
                // ▲▲▲ [신규] 게스트가 방장의 맵 생성을 기다리는 상태 ▲▲▲

                // 게임판 데이터가 있고, 카운트다운이 시작되지 않았고, 재배열 중이 아니라면 시작
                if (currentRoomData.board && !countdownStarted && !currentRoomData.isShuffling) {
                    countdownStarted = true;
                    startCountdown();
                }
                // 게임이 이미 라이브 상태이면 UI 업데이트
                // ✨ [수정] 재배열 상태 확인을 isGameLive 밖으로 이동
                if (isGameLive) {
                    // ✨ [핵심 수정] isGameLive *내부에서* 재배열 상태를 확인합니다.
                    
                    if (currentRoomData.isShuffling) {
                        // 1. 재배열 중: 오버레이 표시
                        infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">보드를 재배열 합니다...</p>`;
                        infoOverlay.style.display = 'flex';
                    } else {
                        // 2. 재배열 중이 아님: 오버레이 숨기고 게임 UI 업데이트
                        
                        // ✨ [추가] 오버레이가 켜져 있으면 끈다
                        if (infoOverlay.style.display !== 'none') {
                             infoOverlay.style.display = 'none';
                        }

                        // 최신 게임 상태 렌더링
                        updateHeaderUI();
                        renderBoard();
                        updateMySelection(); // 내 선택 상태 UI 반영
                    }
                }
            } else if (currentRoomData.status === 'gameOver' && !gameOverFlag) {
                        gameOverFlag = true; // 게임 종료 플래그 설정
                        infoOverlay.style.display = 'none'; // [추가] 로딩 오버레이 끄기
                        renderBoard(); // 최종 보드 상태 렌더링
                        showGameOverScreen(); // 게임 종료 화면 표시
                   (변경코드)
                    } else if (currentRoomData.status === 'waiting') {
                        gameOverOverlay.style.display = 'none';
                        gameOverFlag = false;
                        countdownStarted = false; 
                        isGameLive = false; 

                        const readyPlayers = currentRoomData.readyPlayers || {};
                        const totalPlayers = Object.keys(currentRoomData.players).length;
                        const readyCount = Object.keys(readyPlayers).length;

                        // ✨ [수정] '준비' 상태가 아니면, 'readyPlayers'에 자신을 등록합니다.
                        if (!readyPlayers[myPlayerId]) {
                            roomRef.child('readyPlayers/' + myPlayerId).set(true);
                            
                            // ✨ [핵심 수정] 
                            // 방금 '준비' 신호를 보냈으므로, stale(오래된) 데이터로 
                            // 게임 시작을 확인하지 말고 즉시 리턴하여 다음 이벤트를 기다립니다.
                            // 대기 화면을 먼저 표시합니다.
                            if (isHost) {
                                infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">상대방 기다리는 중 (${readyCount}/${totalPlayers})...</p>`;
                            } else {
                                infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">게임 시작 대기 중...</p>`;
                            }
                            infoOverlay.style.display = 'flex';
                            return; // ✨ 즉시 리턴
                        }
                        
                        // ✨ [수정] 
                        // 이 코드는 내가 *이미* ready 상태일 때만 실행됩니다.
                        // (즉, 'readyPlayers'에 내가 포함된 이벤트가 다시 들어왔을 때)
                        if (isHost) {
                            if (totalPlayers >= 2 && readyCount === totalPlayers) {
                                // ✨ [핵심 수정] 
                                // 보드를 *바로* 생성하지 않고, '게임방.html'에서 보낸 것과
                                // 동일한 '게임 시작 로딩' 신호를 보냅니다.
                                roomRef.update({
                                    status: 'playing',
                                    gameState: 'launching', // '처음하기'와 동일한 신호
                                    board: null,            // 보드를 비워서 '보드 생성중' 상태 유도
                                    scores: null,
                                    selectedTiles: null,
                                    readyPlayers: null      // '준비' 상태 초기화
                                });
                                // initializeShisenShoGame(); // <--- 이 코드를 위 update로 대체
                            } else {
                                // 아직 모두 준비되지 않음 (상대방 기다리는 중)
                                infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">상대방 기다리는 중 (${readyCount}/${totalPlayers})...</p>`;
                                infoOverlay.style.display = 'flex';
                            }
                        } else {
                            // 게스트는 대기 중
                             infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">게임 시작 대기 중...</p>`;
                            infoOverlay.style.display = 'flex';
                        }
                    }
                });
            }

          // --- [개선] 재귀 백트래킹 헬퍼 함수 ---
function _generateBoardRecursive(board, tilesToPlace, depth = 0) {
    // 깊이 제한 (무한 재귀 방지)
    if (depth > TILE_COUNT * 2) {
        return null;
    }

    // 1. 모든 타일을 배치했으면 성공
    if (tilesToPlace.length === 0) {
        return board;
    }

    // 2. 배치할 타일과 빈 칸 목록 준비
    const tile = tilesToPlace[0];
    const emptyIndices = findEmptySpots(board);

    if (emptyIndices.length < 2) {
        return null;
    }

    // 3. 빈 칸을 섞어서 무작위성 확보
    const shuffledEmptyIndices = shuffleArray([...emptyIndices]);

    // 4. 연결 가능한 빈 칸 쌍 찾기 (최적화: 거리순 정렬)
    const pairs = [];
    for (let i = 0; i < shuffledEmptyIndices.length - 1; i++) {
        const index1 = shuffledEmptyIndices[i];
        const row1 = Math.floor(index1 / BOARD_COLS);
        const col1 = index1 % BOARD_COLS;

        for (let j = i + 1; j < shuffledEmptyIndices.length; j++) {
            const index2 = shuffledEmptyIndices[j];
            const row2 = Math.floor(index2 / BOARD_COLS);
            const col2 = index2 % BOARD_COLS;

            // 거리 계산 (맨해튼 거리)
            const distance = Math.abs(row1 - row2) + Math.abs(col1 - col2);
            
            pairs.push({ index1, index2, distance });
        }
    }

    // 거리순 정렬 (가까운 쌍부터 시도 - 성공률 향상)
    pairs.sort((a, b) => a.distance - b.distance);

    // 5. 각 쌍에 대해 연결 가능 여부 확인 및 배치 시도
    for (const { index1, index2 } of pairs) {
        if (findPath_BFS(board, index1, index2)) {
            // 6. 배치
            board[index1] = tile;
            board[index2] = tile;

            // 7. 재귀 호출
            const remainingTiles = tilesToPlace.slice(1);
            const result = _generateBoardRecursive(board, remainingTiles, depth + 1);

            if (result) {
                return result;
            }

            // 8. 백트래킹
            board[index1] = null;
            board[index2] = null;
        }
    }

    // 10. 모든 쌍 시도했지만 실패
    return null;
}


         function initializeShisenShoGame() { // ✨ retryCount 제거
                 if (!isHost) return;

                 console.log("풀 수 있는 사천성 보드 생성 시작...");

                 // 1. 타일 준비
                 const iconsNeeded = TILE_COUNT / 2;
                 if (TILE_ICONS.length < iconsNeeded) {
                     console.error("타일 아이콘/이미지 개수가 부족합니다!");
                     // ✨ [수정] alert 제거, waiting으로 되돌림 (무한루프 방지)
                     roomRef.update({ status: 'waiting', board: null, readyPlayers: null });
                     return;
                 }

                 // 2. 보드 생성 (✨ 단 한 번만 시도)
                 const board = createSolvableBoard(iconsNeeded);
                 
                 // ✨ createSolvableBoard가 이제 항상 성공하므로 (랜덤 배치)
                 // ✨ !board 체크 로직이 필요 없어졌습니다.

                 console.log("✅ 풀 수 있는 보드 생성 완료!");

                 // 3. 초기 게임 데이터 구성
                 const playerIds = Object.keys(currentRoomData.players);
                 const initialScores = {};
                 playerIds.forEach(id => initialScores[id] = 0);
                 const initialSelectedTiles = {};
                 playerIds.forEach(id => initialSelectedTiles[id] = null);

                 // 4. Firebase 업데이트
                 roomRef.update({
                     status: 'playing',
                     board: board,
                     scores: initialScores,
                     selectedTiles: initialSelectedTiles,
                     readyPlayers: null,
                     isShuffling: false // ✨ [추가] 재배열 상태 초기화
                     
                 }).catch(error => {
                     console.error("게임 시작 데이터 업데이트 실패:", error);
                 });

                 // ✨ 5. [추가] 방장만, 생성된 맵이 혹시 막혔는지 1초 뒤 체크
  
             }

             // --- [신규] 풀이 가능 보드 생성 핵심 함수 ---
             function createSolvableBoard(iconsNeeded) {
                 const board = new Array(TILE_COUNT).fill(null);
                 const selectedIcons = TILE_ICONS.slice(0, iconsNeeded);
                 
                 // 타일 쌍 목록 생성 및 섞기
                 const tilePairs = [];
                 selectedIcons.forEach(icon => {
                     tilePairs.push({ icon, placed: false });
                 });
                 shuffleArray(tilePairs);

                 // 배치 기록 (역순으로 제거할 수 있게)
                 const placementOrder = [];

                 // 각 타일 쌍을 연결 가능한 위치에 배치
                 for (const pair of tilePairs) {
                     const emptySpots = findEmptySpots(board);
                     
                     if (emptySpots.length < 2) {
                         console.error("빈 칸 부족!");
                         return null;
                     }

                     // 연결 가능한 2개 위치 찾기
                     let placed = false;
                     shuffleArray(emptySpots); // 무작위성

                     for (let i = 0; i < emptySpots.length && !placed; i++) {
                         for (let j = i + 1; j < emptySpots.length && !placed; j++) {
                             const pos1 = emptySpots[i];
                             const pos2 = emptySpots[j];

                             // 현재 보드 상태에서 연결 가능한지 확인
                             if (findPath_BFS(board, pos1, pos2)) {
                                 board[pos1] = pair.icon;
                                 board[pos2] = pair.icon;
                                 placementOrder.push({ pos1, pos2, icon: pair.icon });
                                 placed = true;
                             }
                         }
                     }

                     if (!placed) {
                         console.warn("타일 배치 실패, 랜덤 배치로 전환");
                         // 실패 시 그냥 아무 빈 곳에 배치
                         const pos1 = emptySpots[0];
                         const pos2 = emptySpots[1];
                         board[pos1] = pair.icon;
                         board[pos2] = pair.icon;
                     }
                 }

                 console.log(`📊 배치 완료: ${placementOrder.length}개 쌍`);
                 return board;
             }

            function startCountdown() {
                // playSound('game-start-fanfare'); // ✨ 1. 빵빠레 사운드 (주석 해제)
                infoOverlay.style.display = 'flex';
                
                // ✨ 2. "Ready?" 텍스트를 먼저 1초간 표시
                infoOverlay.innerHTML = `<div id="countdown-number" style="font-size: 4.5em; animation: countdown-pop 1s;">Ready?</div>`;

                let count = 3; // 3초 카운트다운
                
                setTimeout(() => { // 1초 뒤에 3부터 시작
                    const el = document.getElementById('countdown-number');
                    if (el) {
                        el.style.fontSize = '7em'; 
                        el.style.animation = 'countdown-pop 1s';
                        el.textContent = count;
                    }

                    // ✨ 4. 1초 간격으로 나머지 카운트다운 진행
                    const interval = setInterval(() => {
                        count--;
                        const el = document.getElementById('countdown-number');
                        if (el) {
                            el.style.animation = 'none';
                            el.offsetHeight; 
                            el.style.animation = 'countdown-pop 1s';
                            el.textContent = count > 0 ? count : 'GO!'; // 2, 1, GO!
                        }

                        if (count <= -1) { // GO! 보여주고 1초 뒤
                            clearInterval(interval);
                            infoOverlay.style.display = 'none';
                            isGameLive = true;
                            updateHeaderUI();
                            renderBoard(); // 게임 보드 렌더링

                            // ✨ [핵심] "GO!"가 끝난 후, 방장만 맵 검사 시작
                            if (isHost) {
                                // 0.5초 딜레이 (UI 렌더링 시간 확보)
                                setTimeout(checkAndShuffleIfNeeded, 500); 
                            }
                        }
                    }, 1000);
                }, 1000); // "Ready?"를 1초간 보여줌
            }

           // --- 게임판 렌더링 ---
            function renderBoard() {
                if (!currentRoomData || !currentRoomData.board) {
                     console.warn("renderBoard 호출되었으나 board 데이터 없음");

                     return;
                 }
                 const boardData = currentRoomData.board;
                 // ▼▼▼ [수정] 헬퍼 함수 사용 ▼▼▼
                 const boardArray = getBoardArray(boardData, TILE_COUNT);
                 // ▲▲▲ [수정] 헬퍼 함수 사용 ▲▲▲

                 // 보드 크기 계산 (화면 크기에 맞게)
                 const containerW = gameContainer.clientWidth;
                 const containerH = gameContainer.clientHeight; // 헤더 제외됨
                 const maxBoardW = containerW * 0.98; // 여백 조금 더 줄임
                 const maxBoardH = containerH * 0.98;

                 let boardSizeW, boardSizeH, tileSize;
                 // 가로/세로 비율 유지하며 최대 크기 계산
                 const cellAspectRatio = 1; // 타일 비율 (정사각형)
                 const boardAspectRatio = (BOARD_COLS * cellAspectRatio) / BOARD_ROWS;

                 if (maxBoardW / boardAspectRatio < maxBoardH) {
                     boardSizeW = maxBoardW;
                     boardSizeH = maxBoardW / boardAspectRatio;
                 } else {
                     boardSizeH = maxBoardH;
                     boardSizeW = maxBoardH * boardAspectRatio;
                 }

                 gameBoard.style.width = `${boardSizeW}px`;
                 gameBoard.style.height = `${boardSizeH}px`;
                 gameBoard.style.gridTemplateColumns = `repeat(${BOARD_COLS}, 1fr)`;
                 gameBoard.style.gridTemplateRows = `repeat(${BOARD_ROWS}, 1fr)`;

                 // 타일 크기에 따른 폰트/이미지 크기 계산 (갭 고려)
                 currentGapSize = 2; // CSS의 gap 값과 일치 (전역 변수 사용)
              currentTileSize = (boardSizeW - (BOARD_COLS - 1) * currentGapSize - 10) / BOARD_COLS; // 10은 padding 값 (5*2)

                 // 기존 타일 유지 및 업데이트 로직 (성능 향상)
                 const existingTiles = new Map();
                 gameBoard.querySelectorAll('.tile').forEach(tile => {
                     existingTiles.set(parseInt(tile.dataset.index, 10), tile);
                 });

                 const fragment = document.createDocumentFragment(); // DocumentFragment 사용

                boardArray.forEach((tileIcon, index) => {
                    let tileEl = existingTiles.get(index);
                    const isEmpty = tileIcon === null;

                    if (!tileEl) { // 새 타일 생성
                        tileEl = document.createElement('div');
                        tileEl.className = 'tile';
                        tileEl.dataset.index = index;
                        fragment.appendChild(tileEl); // 프래그먼트에 추가
                    }

                    // 클래스 업데이트 (hidden)
                    tileEl.classList.toggle('hidden', isEmpty);

                    // 내용 업데이트 (빈 칸 아니면)
                    if (!isEmpty) {
                         // 이미지 경로인지, 이모지인지 확인
                         const isImage = tileIcon.startsWith('.') || tileIcon.startsWith('http') || tileIcon.includes('/');
                         const currentContent = tileEl.firstChild; // 현재 내용 (img 또는 text node)

                         if (isImage) {
                             if (!currentContent || currentContent.tagName !== 'IMG' || currentContent.src !== tileIcon) {
                                 tileEl.innerHTML = `<img src="${escapeHTML(tileIcon)}" alt="tile">`;
                             }
                             // 이미지 크기는 CSS에서 %로 관리하므로 JS 설정 불필요
                         } else {
                             if (!currentContent || currentContent.nodeType !== Node.TEXT_NODE || currentContent.textContent !== tileIcon) {
                                 tileEl.textContent = tileIcon;
                             }
tileEl.style.fontSize = `${currentTileSize * 0.55}px`; // 타일 크기에 비례 (전역 변수 사용)
                         }

                         // ▼▼▼ [수정] 턴 체크 삭제! (실시간) ▼▼▼
                         // 클릭 리스너 추가/제거 (게임 중이면 항상 활성화)
                         if (isGameLive && !tileEl.onclick) {
                             tileEl.onclick = handleTileClick; // 핸들러 직접 할당
                         } else if (!isGameLive && tileEl.onclick) {
                             tileEl.onclick = null; // 핸들러 제거
                         }
                    } else {
                        // 빈 칸이면 내용 지우고 리스너 제거
                        tileEl.innerHTML = '';
                        tileEl.onclick = null;
                    }

                    // 기존 맵에서 제거 (처리된 타일)
                    existingTiles.delete(index);
                });

                 // 사라진 타일 DOM 제거 (이미 매칭된 후 데이터가 null로 바뀐 경우 등)
                 existingTiles.forEach(tile => tile.remove());

                 // 프래그먼트를 실제 DOM에 추가 (한 번의 reflow)
                 // 프래그먼트를 실제 DOM에 추가 (한 번의 reflow)
                 gameBoard.appendChild(fragment);

                // ▼▼▼ [수정] 캔버스를 보드보다 *크게* 만들어 외곽선도 보이도록 조절 ▼▼▼
                 const boardStyle = window.getComputedStyle(gameBoard);
                 const boardPaddingLeft = parseFloat(boardStyle.paddingLeft) || 0;
                 const boardPaddingTop = parseFloat(boardStyle.paddingTop) || 0;
                 const boardBorderLeft = parseFloat(boardStyle.borderLeftWidth) || 0;
                 const boardBorderTop = parseFloat(boardStyle.borderTopWidth) || 0;

                // 1. 외곽선이 그려질 추가 여백 (타일 1개 크기 + 갭)
                currentExtraMargin = currentTileSize + currentGapSize; 

                // 2. 캔버스의 *내부* 영역 크기 (타일이 깔리는 영역)
                const innerWidth = gameBoard.clientWidth - (boardPaddingLeft * 2) - (boardBorderLeft * 2);
                const innerHeight = gameBoard.clientHeight - (boardPaddingTop * 2) - (boardBorderTop * 2);

                // 3. 캔버스의 *전체* 크기 (내부 영역 + 상하좌우 여백)
                const canvasWidth = innerWidth + currentExtraMargin * 2;
                const canvasHeight = innerHeight + currentExtraMargin * 2;

                // 4. 캔버스 위치 설정 (타일 영역 시작점보다 여백만큼 '위' '왼쪽'으로 이동)
                pathCanvas.style.position = 'absolute';
                pathCanvas.style.left = `${gameBoard.offsetLeft + boardBorderLeft + boardPaddingLeft - currentExtraMargin}px`;
                pathCanvas.style.top = `${gameBoard.offsetTop + boardBorderTop + boardPaddingTop - currentExtraMargin}px`;

                // 5. 캔버스 크기 및 해상도 설정
                pathCanvas.width = canvasWidth; 
                pathCanvas.height = canvasHeight;
                pathCanvas.style.width = `${canvasWidth}px`;
                pathCanvas.style.height = `${canvasHeight}px`;
                // ▲▲▲ [수정] 캔버스 크기 및 위치 조절 ▲▲▲
            }

            // --- 타일 클릭 처리 ---
            function handleTileClick(event) {
                // ▼▼▼ [수정] 턴 체크 삭제! (실시간) ▼▼▼
                // ✨ [추가] 게임이 라이브 중이 아니거나, "재배열 중"일 때는 클릭 비활성화
                if (!isGameLive || (currentRoomData && currentRoomData.isShuffling)) return;
                // ▲▲▲ [수정] 턴 체크 삭제! (실시간) ▲▲▲

                const clickedEl = event.currentTarget;
                const clickedIndex = parseInt(clickedEl.dataset.index, 10);
                // ▼▼▼ [수정] 헬퍼 함수 사용 ▼▼▼
                const boardArray = getBoardArray(currentRoomData.board, TILE_COUNT);
                // ▲▲▲ [수정] 헬퍼 함수 사용 ▲▲▲
                const clickedIcon = boardArray[clickedIndex];

                // 이미 hidden 상태거나 아이콘 없으면 무시
                if (clickedIcon === null || clickedEl.classList.contains('hidden')) return;

                playSound('tile-select-sound'); // 선택 사운드

                // 현재 Firebase에 저장된 내 첫 번째 선택 가져오기
                const currentFirstSelection = currentRoomData.selectedTiles ? currentRoomData.selectedTiles[myPlayerId] : null;

                // 이미 선택된 타일 다시 클릭 (선택 취소)
                if (currentFirstSelection && currentFirstSelection.index === clickedIndex) {
                    roomRef.child('selectedTiles').child(myPlayerId).set(null); // Firebase 선택 취소
                    // UI 업데이트는 listenToRoomChanges가 처리
                    return;
                }

                // 첫 번째 타일 선택
                if (!currentFirstSelection) {
                    const selectionData = { index: clickedIndex, icon: clickedIcon };
                    roomRef.child('selectedTiles').child(myPlayerId).set(selectionData);
                    // UI 업데이트는 listenToRoomChanges가 처리
                }
                // 두 번째 타일 선택
                else {
                    // 1. 아이콘이 같은지 확인
                    if (currentFirstSelection.icon === clickedIcon) {
                        // 2. 경로 탐색 (BFS)
                         const path = findPath_BFS(boardArray, currentFirstSelection.index, clickedIndex); // ▼ [수정] 경로 반환 ▼

                        if (path) { // ▼ [수정] path가 있으면 (경로 찾음) ▼
                            
                            // ▼▼▼ [수정] 애니메이션으로 경로 시각화 ▼▼▼
                            drawAnimatedPath(path); // 1. 선 그리기 애니메이션 시작
                            // ▲▲▲ [수정] 애니메이션으로 경로 시각화 ▲▲▲
                            
                            // 2. 매칭 성공! -> Transaction으로 타일 제거 시도 (즉시 실행)
                            attemptTileRemoval(currentFirstSelection.index, clickedIndex);
                     } else {
                        // 4. 경로 없음 -> 두 번째 타일을 새로운 첫 선택으로 변경
                         const newSelectionData = { index: clickedIndex, icon: clickedIcon };
                         roomRef.child('selectedTiles').child(myPlayerId).set(newSelectionData);
                    }
                } else {
                    // 5. 아이콘 다름 -> 두 번째 타일을 새로운 첫 선택으로 변경
                     const newSelectionData = { index: clickedIndex, icon: clickedIcon };
                     roomRef.child('selectedTiles').child(myPlayerId).set(newSelectionData);
                }
            }
        }

            // --- 내 선택 상태 UI 반영 ---
            function updateMySelection() {
                if (!currentRoomData || !currentRoomData.selectedTiles) return;
                firstSelection = currentRoomData.selectedTiles[myPlayerId] || null;

                // 기존 선택 UI 제거
                const previouslySelected = gameBoard.querySelector('.tile.selected');
                if (previouslySelected) {
                    previouslySelected.classList.remove('selected');
                }
                selectedTileElement = null; // 로컬 참조 초기화

                // 새 선택 UI 적용
                if (firstSelection) {
                    const selectedIndex = firstSelection.index;
                    selectedTileElement = gameBoard.querySelector(`.tile[data-index="${selectedIndex}"]`);
                    if (selectedTileElement && !selectedTileElement.classList.contains('hidden')) { // hidden 아닌 타일만
                        selectedTileElement.classList.add('selected');
                    } else {
                        // 선택된 타일이 hidden 상태면 로컬 선택 정보도 초기화
                        firstSelection = null;
                         // Firebase에도 반영 (선택 사항 - 다른 플레이어가 먼저 제거한 경우 등)
                         // roomRef.child('selectedTiles').child(myPlayerId).set(null);
                    }
                }
            }

          

            // --- [대체] 경로 탐색 함수 (BFS) ---
            // 기존 findPath_BFS 함수를 통째로 삭제하고 아래 코드로 교체하세요.
            // (경로를 찾으면 'true' 대신 '경로 배열'을 반환합니다)
            function findPath_BFS(board, startIndex, endIndex) {
                const V_ROWS = BOARD_ROWS + 2;
                const V_COLS = BOARD_COLS + 2;
                const virtualBoard = Array(V_ROWS * V_COLS).fill(null);

                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        const boardIndex = r * BOARD_COLS + c;
                        const virtualIndex = (r + 1) * V_COLS + (c + 1);
                        if (board[boardIndex] !== null) {
                            virtualBoard[virtualIndex] = 1; // 타일 있음
                        }
                    }
                }

                const startR = Math.floor(startIndex / BOARD_COLS) + 1;
                const startC = startIndex % BOARD_COLS + 1;
                const vStartIndex = startR * V_COLS + startC;

                const endR = Math.floor(endIndex / BOARD_COLS) + 1;
                const endC = endIndex % BOARD_COLS + 1;
                const vEndIndex = endR * V_COLS + endC;

                // 큐: { index, turns, dir, parentNode }
                const queue = [{ i: vStartIndex, t: 0, d: 0, p: null }];
                
                // 방문 기록: visited[인덱스] = { turns: 꺾임 횟수, parent: 부모 노드 인덱스 }
                const visited = Array(V_ROWS * V_COLS).fill(null);
                visited[vStartIndex] = { t: 0, p: -1 }; // -1: 시작점

                const directions = [
                    { dr: -1, dc: 0, d: 1 }, // 상
                    { dr: 1, dc: 0, d: 2 },  // 하
                    { dr: 0, dc: -1, d: 3 }, // 좌
                    { dr: 0, dc: 1, d: 4 }   // 우
                ];

                let endNode = null;

                while (queue.length > 0) {
                    const { i, t, d, p } = queue.shift();

                    if (i === vEndIndex) {
                        endNode = { i, t, d, p }; // 목표 도달
                        break;
                    }

                    for (const move of directions) {
                        const nextR = Math.floor(i / V_COLS) + move.dr;
                        const nextC = i % V_COLS + move.dc;
                        const nextIndex = nextR * V_COLS + nextC;

                        if (nextR < 0 || nextR >= V_ROWS || nextC < 0 || nextC >= V_COLS) continue;
                        if (virtualBoard[nextIndex] !== null && nextIndex !== vEndIndex) continue;

                        const nextTurns = (d !== 0 && d !== move.d) ? t + 1 : t;
                        if (nextTurns > 2) continue;

                        if (!visited[nextIndex] || visited[nextIndex].t >= nextTurns) {
                            visited[nextIndex] = { t: nextTurns, p: i };
                            queue.push({ i: nextIndex, t: nextTurns, d: move.d, p: i });
                        }
                    }
                }

                if (endNode) {
                    // 경로 역추적
                    const path = [];
                    let currentIdx = endNode.i;
                    while (currentIdx !== -1 && visited[currentIdx]) {
                        path.push(currentIdx);
                        currentIdx = visited[currentIdx].p;
                    }
                    return path.reverse(); // [시작점 ... 끝점] 순으로 반환
                }

                return null; // 경로 없음
            }

         // 헬퍼: 가상 인덱스 경로 -> 캔버스 픽셀 좌표로 변환
            function _getPathPixelCoords(path) {
                const pixelPath = [];
                for (let i = 0; i < path.length; i++) {
                    const virtualIndex = path[i];
                    
                    // 가상 인덱스 -> 보드 인덱스로 변환
                    const vR = Math.floor(virtualIndex / (BOARD_COLS + 2));
                    const vC = virtualIndex % (BOARD_COLS + 2);
                    const bR = vR - 1; // 보드 Row (0 ~ BOARD_ROWS-1)
                    const bC = vC - 1; // 보드 Col (0 ~ BOARD_COLS-1)

                    // 보드 인덱스 -> 캔버스 픽셀 좌표로 변환 (타일 중앙)
                    // ▼▼▼ [수정] 캔버스가 커졌으므로 currentExtraMargin 만큼 좌표를 더해줌 ▼▼▼
                    const x = bC * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    const y = bR * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    // ▲▲▲ [수정] 캔버스가 커졌으므로 currentExtraMargin 만큼 좌표를 더해줌 ▲▲▲
                    
                    pixelPath.push({ x, y });
                }
                return pixelPath;
            }

            // --- [신규] 재배열(셔플) 헬퍼 함수 1: 가능한 모든 수 확인 ---
            function checkForAvailableMoves(boardArray) {
                const availableTiles = {}; // { '🐶': [idx1, idx2], '🐱': [idx3] }

                // 1. 현재 보드에 남은 타일들을 아이콘별로 그룹화
                boardArray.forEach((icon, index) => {
                    if (icon !== null) {
                        if (!availableTiles[icon]) {
                            availableTiles[icon] = [];
                        }
                        availableTiles[icon].push(index);
                    }
                });

                // 2. 각 아이콘 그룹을 순회
                for (const icon in availableTiles) {
                    const indices = availableTiles[icon];
                    if (indices.length < 2) continue; // 1개만 남은 타일은 무시

                    // 3. 모든 가능한 '쌍'을 만들어 경로 탐색 (조합)
                    for (let i = 0; i < indices.length - 1; i++) {
                        for (let j = i + 1; j < indices.length; j++) {
                            const index1 = indices[i];
                            const index2 = indices[j];
                            
                            // 4. 경로가 하나라도 발견되면 즉시 true 반환
                            if (findPath_BFS(boardArray, index1, index2)) {
                                console.log(`[Move Check] Found: ${icon} at ${index1}, ${index2}`);
                                return true; // 가능한 움직임 발견!
                            }
                        }
                    }
                }

                // 5. 모든 검사가 끝날 때까지 경로를 못 찾으면 false 반환
                console.log("[Move Check] No moves left.");
                return false; // 막힘!
            }

           // --- [개선] 재배열(셔플) 헬퍼 함수 2: 연결 가능하게 재배치 ---
            function shuffleRemainingTiles(boardArray) {
                const remainingTiles = [];
                const occupiedIndices = [];
                
                // 1. 현재 남은 타일 정보 추출
                boardArray.forEach((icon, index) => {
                    if (icon !== null) {
                        remainingTiles.push(icon);
                        occupiedIndices.push(index);
                    }
                });

                if (remainingTiles.length === 0) return boardArray;

                // 2. 재귀 백트래킹으로 연결 가능한 배치 생성
                const newBoard = new Array(TILE_COUNT).fill(null);
                const tilePairs = {};
                
                // 타일을 쌍으로 그룹화
                remainingTiles.forEach(icon => {
                    tilePairs[icon] = (tilePairs[icon] || 0) + 1;
                });
                
                const pairsToPlace = [];
                for (const icon in tilePairs) {
                    const count = Math.floor(tilePairs[icon] / 2);
                    for (let i = 0; i < count; i++) {
                        pairsToPlace.push(icon);
                    }
                }
                
                // 3. 백트래킹으로 배치 시도
                shuffleArray(pairsToPlace);
                const result = _generateBoardRecursive(newBoard, pairsToPlace, occupiedIndices);
                
                if (result) {
                    return result;
                } else {
                    // 실패 시 랜덤 배치 (최후의 수단)
                    console.warn("백트래킹 실패, 랜덤 배치로 폴백");
                    shuffleArray(remainingTiles);
                    occupiedIndices.forEach((index, i) => {
                        newBoard[index] = remainingTiles[i];
                    });
                    return newBoard;
                }
            }
            
            // 백트래킹 헬퍼: 주어진 빈 칸들에만 타일 배치
            function _generateBoardRecursive(board, tilesToPlace, allowedIndices, depth = 0) {
                if (depth > tilesToPlace.length * 10) return null; // 무한 재귀 방지
                
                if (tilesToPlace.length === 0) return board; // 성공
                
                const tile = tilesToPlace[0];
                const emptyIndices = allowedIndices.filter(idx => board[idx] === null);
                
                if (emptyIndices.length < 2) return null;
                
                shuffleArray(emptyIndices);
                
                // 거리순 정렬로 가까운 쌍부터 시도
                const pairs = [];
                for (let i = 0; i < emptyIndices.length - 1; i++) {
                    for (let j = i + 1; j < emptyIndices.length; j++) {
                        const idx1 = emptyIndices[i];
                        const idx2 = emptyIndices[j];
                        const r1 = Math.floor(idx1 / BOARD_COLS);
                        const c1 = idx1 % BOARD_COLS;
                        const r2 = Math.floor(idx2 / BOARD_COLS);
                        const c2 = idx2 % BOARD_COLS;
                        const dist = Math.abs(r1 - r2) + Math.abs(c1 - c2);
                        pairs.push({ idx1, idx2, dist });
                    }
                }
                pairs.sort((a, b) => a.dist - b.dist);
                
                for (const { idx1, idx2 } of pairs) {
                    if (findPath_BFS(board, idx1, idx2)) {
                        board[idx1] = tile;
                        board[idx2] = tile;
                        
                        const result = _generateBoardRecursive(board, tilesToPlace.slice(1), allowedIndices, depth + 1);
                        if (result) return result;
                        
                        board[idx1] = null;
                        board[idx2] = null;
                    }
                }
                
                return null;
            }

            // --- [신규] 재배열(셔플) 메인 함수 (방장만 호출) ---
            let isCheckingOrShuffling = false; // 중복 실행 방지 플래그

           // ✨ [수정] 안정성 강화: try...finally, .catch 추가
            function checkAndShuffleIfNeeded(retryCount = 0) {
                // 중복 실행 방지 및 기본 조건 체크
                if (!isHost || isCheckingOrShuffling || !currentRoomData || currentRoomData.status !== 'playing') {
                    // console.log("[Shuffle Check] Skipped - 조건 미충족"); // 디버깅 시 주석 해제
                    return;
                }

                try { // ✨ [추가] finally 블록을 위해 try 시작
                    isCheckingOrShuffling = true; // 검사/셔플 시작 플래그
                    console.log(`[Shuffle Check] 시작 (Try ${retryCount})...`);

                    const boardArray = getBoardArray(currentRoomData.board, TILE_COUNT);

                    // 1. 가능한 움직임 검사
                    if (checkForAvailableMoves(boardArray)) {
                        console.log("[Shuffle Check] 움직임 가능. 셔플 불필요.");
                        // isCheckingOrShuffling = false; // <-- finally에서 처리
                        return; // 종료
                    }

                    // --- 막혔을 경우 ---
                    console.log("[Shuffle Check] 움직임 없음. 셔플 시도 필요.");

                    // 2. 최대 재시도 횟수 초과 시 게임 종료
                    if (retryCount >= 2) { // ✨ [수정] 1 -> 2 (0, 1 총 2번 시도 후 종료)
                        console.error("[Shuffle Check] 재배열 2회 시도 후에도 막힘. 게임 종료.");
                        roomRef.update({ 
                            status: 'gameOver', 
                            isShuffling: false // ✨ 확실히 false로 설정
                        }).catch(err => console.error("게임 종료 업데이트 실패:", err));
                        // isCheckingOrShuffling = false; // <-- finally에서 처리
                        return; // 종료
                    }

                    // 3. 재배열 시작: Firebase에 isShuffling: true 설정
                    console.log("[Shuffle Check] isShuffling: true 설정 시도...");
                    roomRef.child('isShuffling').set(true).then(() => {
                        console.log("[Shuffle Check] isShuffling: true 설정 완료.");
                        
                        // 4. (UI 표시 시간 2초) 2초 뒤에 실제 셔플 실행
                        setTimeout(() => {
                            // setTimeout 시점에 currentRoomData가 유효한지 다시 확인
                            if (!currentRoomData || currentRoomData.status !== 'playing') {
                                console.warn("[Shuffle Timeout] 게임 상태 변경됨. 셔플 중단.");
                                // 상태가 바뀌었으면 isShuffling을 false로 되돌려야 함
                                roomRef.update({ isShuffling: false }).catch(e => {}); // 오류 무시
                                isCheckingOrShuffling = false; // 플래그도 리셋
                                return;
                            }
                            
                            console.log("[Shuffle Timeout] 실제 셔플 실행...");
                            const boardBeforeShuffle = getBoardArray(currentRoomData.board, TILE_COUNT); // 최신 데이터 사용
                            const newShuffledBoard = shuffleRemainingTiles(boardBeforeShuffle);
                            
                            // 5. 새 보드판 업데이트, isShuffling: false, 선택 해제
                            console.log("[Shuffle Timeout] Firebase 업데이트 시도 (board, isShuffling: false)...");
                            roomRef.update({
                                board: newShuffledBoard,
                                isShuffling: false,
                                selectedTiles: {} 
                            }).then(() => {
                                console.log("[Shuffle Timeout] Firebase 업데이트 성공.");
                                // isCheckingOrShuffling = false; // <-- finally에서 처리
                                
                                // 6. [재귀] 셔플 후 잠시(1초) 뒤에 다시 막혔는지 검사
                                setTimeout(() => {
                                     // ✨ isCheckingOrShuffling 플래그는 재귀 호출 전에 false로 만들어야 함
                                     isCheckingOrShuffling = false; 
                                     checkAndShuffleIfNeeded(retryCount + 1);
                                }, 1000);

                            }).catch(error => { // ✨ [추가] 업데이트 실패 시 처리
                                console.error("[Shuffle Timeout] Firebase 업데이트 실패:", error);
                                // isCheckingOrShuffling = false; // <-- finally에서 처리
                            });

                        }, 2000); // 2초간 "재배열 중" 메시지 표시

                    }).catch(error => { // ✨ [추가] isShuffling: true 설정 실패 시 처리
                        console.error("[Shuffle Check] isShuffling: true 설정 실패:", error);
                        // isCheckingOrShuffling = false; // <-- finally에서 처리
                    });

                } finally { // ✨ [추가] 어떤 경우든 함수 종료 시 플래그 리셋 시도
                    // 주의: setTimeout 내부의 비동기 작업 완료 전에 finally가 실행될 수 있음.
                    // 따라서 setTimeout 내부에서도 실패/성공 시점에 플래그를 false로 설정해야 함.
                    // 여기서는 즉시 반환되는 경우(움직임 가능, 최대 재시도 초과)에 대한 리셋을 보장함.
                    if (isCheckingOrShuffling && !setTimeoutPending) { // setTimeout이 예약되지 않은 경우에만 즉시 리셋
                        // console.log("[Shuffle Check] finally 블록에서 isCheckingOrShuffling 리셋.");
                        isCheckingOrShuffling = false;
                    }
                    // setTimeout이 예약된 경우는 해당 콜백 내부에서 리셋해야 함 (위 코드에 반영됨)
                }
                
                // setTimeout 예약 여부를 추적하기 위한 임시 변수 (finally 블록에서 사용)
                let setTimeoutPending = false;
                if (isCheckingOrShuffling && retryCount < 2 && !checkForAvailableMoves(getBoardArray(currentRoomData.board, TILE_COUNT))) {
                     setTimeoutPending = true;
                }

            } // --- checkAndShuffleIfNeeded 끝 ---

            let currentAnimationId = null; // 중복 애니메이션 방지

            function drawAnimatedPath(path) {
                if (!ctx || !path || path.length < 2) return;

                // 1. 기존 애니메이션이 실행 중이면 취소
                if (currentAnimationId) {
                    cancelAnimationFrame(currentAnimationId);
                }
                
                // 2. 픽셀 좌표로 변환
                const pixelPath = _getPathPixelCoords(path);
                const totalSegments = pixelPath.length - 1;
                if (totalSegments <= 0) return;

                // 3. 애니메이션 설정
                const DURATION = 300; // 0.3초
                const startTime = performance.now();
                const segmentProgress = 1.0 / totalSegments; // 각 선분(segment)이 차지하는 전체 진행도의 비율

                // 4. 라인 스타일 (▼▼▼ [수정] 색상 및 그림자(Glow) 효과 ▼▼▼)
                ctx.strokeStyle = "#4A8DFF"; // 선택 타일 테두리색 (파란색)
                ctx.lineWidth = 6;           // 굵기 (8 -> 6)
                ctx.lineCap = "round";       // 선의 끝부분을 둥글게
                ctx.lineJoin = "round";      // 선이 꺾이는 부분을 둥글게
                ctx.shadowColor = "rgba(74, 141, 255, 0.7)"; // 파란색 Glow
                ctx.shadowBlur = 10;         // Glow 번짐 정도
                // (▲▲▲ [수정] 색상 및 그림자(Glow) 효과 ▲▲▲)

                // 5. 애니메이션 프레임 함수
                function animate(timestamp) {
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / DURATION, 1.0); // 0.0 ~ 1.0

                    // 캔버스 클리어
                    ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                    
                    ctx.beginPath();
                    ctx.moveTo(pixelPath[0].x, pixelPath[0].y);

                    let currentProgress = 0.0; // 현재까지의 진행도

                    // 6. 경로를 따라 그리기
                    for (let i = 1; i < pixelPath.length; i++) {
                        // 현재 선분이 그려져야 하는 비율 (0.0 ~ 1.0)
                        // (현재 전체 진행도 - 이 선분이 시작되기 전까지의 진행도) / 이 선분이 차지하는 진행도
                        const segmentT = Math.min(Math.max(progress - currentProgress, 0) / segmentProgress, 1.0);

                        if (segmentT > 0) {
                            const prev = pixelPath[i - 1];
                            const curr = pixelPath[i];
                            
                            // 선형 보간(Lerp)으로 중간 지점 계산
                            const interpX = prev.x + (curr.x - prev.x) * segmentT;
                            const interpY = prev.y + (curr.y - prev.y) * segmentT;
                            
                            ctx.lineTo(interpX, interpY);
                        }
                        
                        currentProgress += segmentProgress; // 다음 선분을 위해 진행도 누적
                        
                        if (segmentT < 1.0) {
                            // 이 선분을 다 그리지 못했다면, 뒤의 선분은 그릴 필요 없음
                            break; 
                        }
                    }
                    
                    ctx.stroke(); // 계산된 경로 그리기

                    // 7. 애니메이션 반복/종료
                    if (progress < 1.0) {
                        currentAnimationId = requestAnimationFrame(animate);
                    } else {
                        // 애니메이션 완료
                        currentAnimationId = null;
                        // 0.1초 뒤에 선 지우기 (타일 사라지는 시간과 비슷하게)
                        setTimeout(() => {
                            if (ctx) { // 캔버스가 유효할 때만 클리어
                                // ▼▼▼ [수정] 지우기 전 그림자 설정 초기화 ▼▼▼
                                ctx.shadowColor = "transparent"; 
                                ctx.shadowBlur = 0;
                                // ▲▲▲ [수정] 지우기 전 그림자 설정 초기화 ▲▲▲
                                ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                            }
                        }, 100); 
                    }
                }

                // 8. 애니메이션 시작
                currentAnimationId = requestAnimationFrame(animate);
            }

            // --- 타일 제거 시도 (Transaction) ---
            // (이 함수는 위 2번 단계에서 이미 수정했습니다.)
            function attemptTileRemoval(index1, index2) {
                roomRef.transaction(currentRoom => {
                    if (!currentRoom || !currentRoom.board || !currentRoom.selectedTiles) {
                        return; // Abort transaction
                    }

                    // ▼▼▼ [수정] 헬퍼 함수 사용 ▼▼▼
                    const board = getBoardArray(currentRoom.board, TILE_COUNT);
                    // ▲▲▲ [수정] 헬퍼 함수 사용 ▼▼▼
                    const icon1 = board[index1];
                    const icon2 = board[index2];

                    // 트랜잭션 시점 확인:
                    // 1. 두 타일이 여전히 존재하는가 (null이 아닌가)?
                    // 2. 두 타일의 아이콘이 여전히 같은가?
                    if (icon1 === null || icon2 === null || icon1 !== icon2) {
                        // 조건 불일치 -> 내 선택만 초기화하고 트랜잭션 종료
                        if (currentRoom.selectedTiles[myPlayerId] && currentRoom.selectedTiles[myPlayerId].index === index1) {
                             currentRoom.selectedTiles[myPlayerId] = null;
                        }
                        return currentRoom; // 변경된 선택 상태만 반환 (트랜잭션 성공 처리됨)
                    }

                    // 선점 성공: 타일 제거
                    board[index1] = null;
                    board[index2] = null;
                    currentRoom.board = board; // 변경된 board로 업데이트

                    // 점수 획득
                    if (!currentRoom.scores) currentRoom.scores = {}; // scores 객체 없을 경우 대비
                    currentRoom.scores[myPlayerId] = (currentRoom.scores[myPlayerId] || 0) + 1;

                    // 내 선택 초기화
                    currentRoom.selectedTiles[myPlayerId] = null;
                    // 상대방 선택도 초기화 (혹시 같은 타일 노렸을 경우 방지)
                     const playerIds = Object.keys(currentRoom.players);
                     const opponentId = playerIds.find(id => id !== myPlayerId);
                     if (opponentId && currentRoom.selectedTiles[opponentId]) {
                          const oppSelection = currentRoom.selectedTiles[opponentId];
                          if (oppSelection.index === index1 || oppSelection.index === index2) {
                               currentRoom.selectedTiles[opponentId] = null;
                          }
                    }

                    // ▼▼▼ [삭제] 턴 넘기기 로직 (실시간이므로 삭제) ▼▼▼
                    // (턴 관련 코드 4줄 삭제)
                    // ▲▲▲ [삭제] 턴 넘기기 로직 (실시간이므로 삭제) ▲▲▲

                    // 남은 타일 확인 (게임 종료 조건)
                    const remainingTiles = board.filter(tile => tile !== null).length;
                    if (remainingTiles === 0) {
                        currentRoom.status = 'gameOver';
                    }

                    return currentRoom; // 변경된 전체 방 데이터 반환

                }, (error, committed, snapshot) => {
                    if (error) {
                        console.error("타일 제거 Transaction 실패:", error);
                        // 오류 발생 시 사용자에게 알림 등 처리 필요
                    } else if (!committed) {
                        console.log("타일 선점 실패 (다른 유저가 먼저 가져가거나 데이터 변경됨)");
                        // UI 갱신 (선택 해제 등) - listenToRoomChanges가 처리할 것임
                  } else {
                        // 성공 시 사운드 재생
                        playSound('tile-match-sound-new'); // ▼ [수정] 새 사운드 ID ▼
                         // console.log("타일 제거 성공:", snapshot.val()); // 디버깅용
                         
                         // ✨ [추가] 방장만, 타일 제거 후 막혔는지 검사
                         if (isHost) {
                            // 0.5초 딜레이 (트랜잭션 데이터 반영 시간)
                            setTimeout(checkAndShuffleIfNeeded, 500); 
                         }
                    }
                });
            }


            // --- 헤더 UI 업데이트 ---
            function updateHeaderUI() {
                if (!currentRoomData || !currentRoomData.players) return;
                const { players, scores = {}, turn } = currentRoomData;
                // ▼▼▼ [신규] 승리자 하이라이트 로직 ▼▼▼
                let highScore = 0;
                let isTie = true; // 기본값은 무승부(하이라이트 없음)
                
                const allPlayerIds = Object.keys(players);
                const allScores = allPlayerIds.map(id => scores[id] || 0);
                
                if (allScores.length > 0) {
                    highScore = Math.max(...allScores);
                    
                    if (highScore > 0) { // 최고 점수가 0점 초과일 때만 승자 판별
                        const highScorersCount = allScores.filter(s => s === highScore).length;
                        if (highScorersCount === 1) {
                            isTie = false; // 동점자가 없으면, 승자가 있음!
                        }
                    }
                }
                // ▲▲▲ [신규] 승리자 하이라이트 로직 ▲▲▲
                gameHeader.innerHTML = ''; // 헤더 초기화

                // 플레이어 ID 정렬 (예: 방장 우선 또는 ID 순)
                 const playerIds = Object.keys(players).sort((a, b) => {
                     if (a === currentRoomData.hostId) return -1;
                     if (b === currentRoomData.hostId) return 1;
                     return a.localeCompare(b); // ID 문자열 순
                 });

                 playerIds.forEach(playerId => {
                    const player = players[playerId];
                    if (!player) return; // 혹시 모를 데이터 누락 방지

                    const score = scores[playerId] || 0;
                    // ▼▼▼ [수정] 턴 하이라이트 대신 '승자' 하이라이트 적용 ▼▼▼
                    const isWinner = !isTie && score === highScore;
                    // ▲▲▲ [수정] 턴 하이라이트 대신 '승자' 하이라이트 적용 ▲▲▲

                    // 아바타 HTML 생성 (대기실.html 참고)
                     const avatarSet = AVATAR_SETS[player.avatar];
                     let avatarHTML = '';
                     if (avatarSet) {
                         avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                     } else if (player.avatar && (player.avatar.startsWith('http') || player.avatar.includes('.'))) {
                         avatarHTML = `<img src="${escapeHTML(player.avatar)}" alt="avatar">`;
                     } else {
                         avatarHTML = escapeHTML(player.avatar || '❓'); // 기본값 추가
                     }

                    const infoEl = document.createElement('div');
                    // ▼ [수정] isMyTurnNow -> isWinner
                    infoEl.className = `player-info ${isWinner ? 'my-turn' : ''}`; 
                    infoEl.innerHTML = `
                        <div class="avatar">${avatarHTML}</div>
                        <div class="info-text">
                            <div class="nickname">${escapeHTML(player.nickname || 'Unknown')}</div>
                            <div class="score">점수: ${score}</div>
                        </div>
                    `;
                    gameHeader.appendChild(infoEl);
                });
            }

            // --- 게임 종료 처리 ---
            function showGameOverScreen() {
                 if (!currentRoomData) return;
                 const { players, scores = {} } = currentRoomData;
                 const playerIds = Object.keys(players);

                 // 점수 계산 및 승자 판정
                 let winnerId = null;
                 let highScore = -1;
                 let isDraw = false;
                 playerIds.forEach(id => {
                     const score = scores[id] || 0;
                     if (score > highScore) {
                         highScore = score;
                         winnerId = id;
                         isDraw = false;
                     } else if (score === highScore) {
                         isDraw = true;
                     }
                 });
                 if (isDraw) winnerId = null; // 동점이면 무승부

                 const iWon = winnerId === myPlayerId;
                 const resultText = isDraw ? "무승부!" : (iWon ? "🎉 승리!" : "😢 패배...");

                 // 사운드 재생
                 // ▼▼▼ [수정] 새 사운드 ID로 변경 ▼▼▼
                 playSound(isDraw ? 'loss-sound-new' : (iWon ? 'win-sound-new' : 'loss-sound-new'));
                 // ▲▲▲ [수정] 새 사운드 ID로 변경 ▲▲▲
                 // 전적 업데이트
                 if (playerIds.length > 1) { // 혼자하기 모드 제외
                    updatePlayerStats(isDraw ? 'draw' : (iWon ? 'win' : 'loss'));
                 }

                 // 점수판 HTML 생성
                 const scoresHTML = playerIds.map(id => {
                     const player = players[id];
                     const score = scores[id] || 0;
                     const isWinner = !isDraw && id === winnerId;
                     const scoreClass = isDraw ? 'draw' : (isWinner ? 'winner' : 'loser');

                      // 아바타 HTML (updateHeaderUI와 동일 로직)
                      const avatarSet = AVATAR_SETS[player.avatar];
                      let avatarHTML = '';
                      if (avatarSet) avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                      else if (player.avatar && (player.avatar.startsWith('http') || player.avatar.includes('.'))) avatarHTML = `<img src="${escapeHTML(player.avatar)}" alt="avatar">`;
                      else avatarHTML = escapeHTML(player.avatar || '❓');

                     return `<div class="score-row ${scoreClass}">
                                 <span class="score-avatar">${avatarHTML} ${escapeHTML(player.nickname || 'Unknown')}</span>
                                 <span>${score} 점</span>
                             </div>`;
                 }).join('');

                 // 게임 오버 모달 내용 구성 및 표시
                 gameOverOverlay.innerHTML = `
                     <div class="modal-content">
                         <div class="modal-header"><h2>${resultText}</h2></div>
                         <div class="modal-body">
                             <div id="score-board">${scoresHTML}</div>
                             <div class="modal-buttons">
                                 <button id="rematch-btn" class="menu-btn primary">다시 하기</button>
                                 <button id="lobby-btn" class="menu-btn secondary">대기실로</button>
                             </div>
                         </div>
                     </div>`;
                 gameOverOverlay.style.display = 'flex';

                 // 버튼 이벤트 리스너 설정
                 const rematchBtn = document.getElementById('rematch-btn');
                 rematchBtn.addEventListener('click', () => {
                     rematchBtn.textContent = '상대방 기다리는 중...';
                     rematchBtn.disabled = true;
                     roomRef.child('rematchRequests/' + myPlayerId).set(true);
                 });
                 document.getElementById('lobby-btn').addEventListener('click', cleanupAndExit);

                 // 다시하기 요청 리스너 (방장이 게임 재시작 처리)
                 listenForRematch();
            }

            function listenForRematch() {
                 const rematchRef = roomRef.child('rematchRequests');
                 rematchRef.on('value', snapshot => {
                      if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;

                      const requests = snapshot.val();
                      const requestCount = Object.keys(requests).length;
                      const playerCount = Object.keys(currentRoomData.players).length;

                      // 모든 플레이어가 동의하면 방장이 게임 재설정
                      if (requestCount === playerCount && isHost) {
                            rematchRef.off(); // 리스너 제거
                            // 게임 상태 초기화 (새로고침 없이 'waiting' 상태로 변경)
                            roomRef.update({
                                // gameState: 'restarting', // <-- 이 줄을 삭제 (또는 주석 처리)
                                rematchRequests: null,
                                gameOver: null,
                                status: 'waiting', // 대기 상태로 변경
                                board: null, // 게임판 초기화
                                scores: null,
                                selectedTiles: null,
                                turn: null,
                                readyPlayers: null // 준비 상태 초기화
                            });
                      }
                 });

   
            }

            // --- 전적 업데이트 ---
             function updatePlayerStats(result) { // 'win', 'loss', 'draw'
                 if (!myPlayerId || myPlayerId.startsWith('guest_')) return; // 게스트는 제외

                 const userStatsRef = usersRef.child(myPlayerId).child('gameStats/shisenSho'); // 게임 ID 사용

                 userStatsRef.transaction(currentStats => {
                     if (currentStats === null) {
                         currentStats = { wins: 0, losses: 0, draws: 0, plays: 0 };
                     }

                     currentStats.plays = (currentStats.plays || 0) + 1;
                     if (result === 'win') {
                         currentStats.wins = (currentStats.wins || 0) + 1;
                     } else if (result === 'loss') {
                         currentStats.losses = (currentStats.losses || 0) + 1;
                     } else if (result === 'draw') {
                         currentStats.draws = (currentStats.draws || 0) + 1; // 무승부 카운트 추가
                     }
                     return currentStats;
                 }, (error, committed, snapshot) => {
                     if (error) { console.error("전적 업데이트 실패:", error); }
                     else if (committed) { console.log("전적 업데이트 성공:", snapshot.val()); }

                     // 경험치/포인트 업데이트 (알까기.html 참고, 값 조절 필요)
                      if (committed) {
                           let expGained = 0, pointsGained = 0;
                           if (result === 'win') { expGained = 100; pointsGained = 150; }
                           else if (result === 'loss') { expGained = 20; pointsGained = 50; }
                           else { expGained = 40; pointsGained = 75; } // 무승부 보상

                           usersRef.child(myPlayerId).child('profile/exp').transaction(exp => (exp || 0) + expGained);
                           usersRef.child(myPlayerId).child('profile/points').transaction(points => (points || 0) + pointsGained);
                      }
                 });
             }

            // --- 방 나가기 ---
            function cleanupAndExit() {
                isExiting = true; // 퇴장 상태 플래그
                if (roomRef) {
                    roomRef.off(); // 모든 Firebase 리스너 제거
                    if (myPlayerId) {
                         if (isHost) {
                             // 방장이 나가면 방 전체 삭제
                             roomRef.remove().catch(e => console.error("방 삭제 오류", e)).finally(() => {
                                 window.location.replace('대기실.html');
                             });
                         } else {
                             // 게스트가 나가면 플레이어 목록에서 자신만 제거
                             roomRef.child('players/' + myPlayerId).remove().catch(e => console.error("플레이어 제거 오류", e)).finally(() => {
                                 window.location.replace('대기실.html');
                             });
                         }
                    } else {
                         // myPlayerId가 없는 비정상 상태
                         window.location.replace('대기실.html');
                    }
                } else {
                    // roomRef가 없는 경우 (초기화 실패 등)
                    window.location.replace('대기실.html');
                }
            }

            // --- 초기화 함수 호출 ---
            initialize();
        });
    </script>
</body>
</html>