<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ë‰´ ì‚¬ì²œì„±</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        /* ------------------------- */
        /* == 1. ì•± ê³µí†µ í…Œë§ˆ (ëŒ€ê¸°ì‹¤.html ê¸°ë°˜) == */
        /* ------------------------- */
        :root {
            --bg-color: #FFFBEB; /* ë”°ëœ»í•œ í¬ë¦¼ìƒ‰ ë°°ê²½ */
            --primary-color: #FF6B6B; /* í™œê¸°ì°¬ ì½”ë„ìƒ‰ */
            --secondary-color: #4ECDC4; /* ìƒì¾Œí•œ í‹¸(teal)ìƒ‰ */
            --accent-color: #FFD93D; /* ë°ì€ ë…¸ë€ìƒ‰ */
            --text-color-dark: #574141; /* ì–´ë‘ìš´ ê°ˆìƒ‰ */
            --text-color-light: #ffffff;
            --danger-color: #F76363;
            --panel-bg: #FFFFFF;
            --panel-border: #F0EAD2; /* ì—°í•œ ë² ì´ì§€ìƒ‰ í…Œë‘ë¦¬ */
            --panel-shadow: #E4DCCF; /* íŒ¨ë„ ê·¸ë¦¼ì */
            --font-main: 'GmarketSans', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: var(--font-main);
            background-color: var(--bg-color); /* [í…Œë§ˆ] */
            color: var(--text-color-dark); /* [í…Œë§ˆ] */
            display: flex; flex-direction: column;
            justify-content: flex-start; /* [ë³€ê²½] ìƒë‹¨ ì •ë ¬ */
            align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
        }

        /* ------------------------- */
        /* == 2. ê²Œì„ ë ˆì´ì•„ì›ƒ (ì‹ ê·œ) == */
        /* ------------------------- */
        #game-wrapper { 
            width: 100%; height: 100%; 
            display: flex; flex-direction: column; 
            padding-top: env(safe-area-inset-top); /* iOS ìƒë‹¨ ë…¸ì¹˜ ëŒ€ì‘ */
        }
        
        /* [í…Œë§ˆ] ë­í‚¹.html í—¤ë” ìŠ¤íƒ€ì¼ ì ìš© */
        .page-header {
            width: 100%; padding: 10px 12px; flex-shrink: 0;
            background: #FFFAE0;
            border-bottom: 3px solid var(--panel-border);
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            gap: 8px;
        }
        .page-header h1 {
            font-size: 1.3em; margin: 0;
            flex-grow: 1; text-align: center;
        }
        .back-btn {
            background: none; border: none; color: var(--text-color-dark);
            font-size: 2.0em; cursor: pointer; padding: 0 10px;
            text-decoration: none; font-weight: 700; line-height: 1;
        }

        /* [í…Œë§ˆ] í…ŒíŠ¸ë¦¬ìŠ¤.html í—¤ë” ìŠ¤íƒ€ì¼ ì ìš© */
        #game-header {
            flex-shrink: 0; display: flex; 
            justify-content: space-around; align-items: stretch; /* [ìˆ˜ì •] stretch */
            padding: 8px; background-color: #FFFAE0; /* [í…Œë§ˆ] */
            gap: 8px; 
            border-bottom: 3px solid var(--panel-border); /* [í…Œë§ˆ] */
            flex-wrap: wrap; /* [ì¶”ê°€] ì¤„ë°”ê¿ˆ í—ˆìš© */
            padding-bottom: 8px; /* [ì¶”ê°€] 'ë‚´ ì •ë³´'ì™€ ê°„ê²© */
        }
        .player-info {
            display: flex; align-items: center; gap: 5px; /* [ìˆ˜ì •] ê°­ ì¶•ì†Œ */
            background-color: var(--panel-bg); /* [í…Œë§ˆ] */
            padding: 5px; /* [ìˆ˜ì •] íŒ¨ë”© ì¶•ì†Œ */
            border-radius: 12px; /* [ìˆ˜ì •] */
            transition: all 0.3s ease;
            flex: 1 1 30%; /* [ìˆ˜ì •] 3ê°œê°€ í•œ ì¤„ì— ë§ë„ë¡ (í•µì‹¬) */
            min-width: 0; 
            border: 3px solid var(--panel-border); /* [í…Œë§ˆ] */
            box-shadow: 4px 4px 0px 0px var(--panel-shadow); /* [í…Œë§ˆ] */
        }
        .player-info.highlight { /* [ë³€ê²½] my-turn -> highlight */
            border-color: var(--accent-color);
            background-color: #FFF8E1; /* [í…Œë§ˆ] */
            box-shadow: 4px 4px 0px 0px var(--accent-color);
        }
        .player-info .avatar {
            font-size: 1.5em; width: 30px; height: 30px; /* [ìˆ˜ì •] í¬ê¸° ì¶•ì†Œ */
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; 
            background-color: var(--bg-color); /* [í…Œë§ˆ] */
            border-radius: 8px; /* [ìˆ˜ì •] */
            border: 2px solid var(--panel-border); /* [í…Œë§ˆ] */
            overflow: hidden;
        }
        .player-info .avatar img { width: 100%; height: 100%; object-fit: contain; }
        .player-info .info-text { display: flex; flex-direction: column; min-width: 0; flex-grow: 1;}
        .player-info .nickname { 
            font-weight: 700; font-size: 0.8em; /* [ìˆ˜ì •] í°íŠ¸ ì¶•ì†Œ */
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            /* [ì‹ ê·œ] ê²Œì´ì§€ë°”ë¥¼ ìœ„í•œ ê³µê°„ í™•ë³´ */
            margin-bottom: 2px;
        }
        .player-info .score { 
            font-size: 1.0em; font-weight: 900; 
            color: var(--primary-color); /* [í…Œë§ˆ] */
        }
        .player-info.highlight .score {
            transform: scale(1.1);
        }

        /* ê²Œì„ ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        #game-container {
            width: 100%; flex-grow: 1; 
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; 
            padding: 10px; /* ë³´ë“œì™€ í™”ë©´ ê°€ì¥ìë¦¬ ì—¬ë°± */
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* iOS í•˜ë‹¨ í™ˆë°” ëŒ€ì‘ */
        }
        #game-board {
            position: relative; 
            background-color: var(--bg-color); /* [í…Œë§ˆ] */
            border-radius: 12px;
            display: grid; 
            gap: 2px; /* íƒ€ì¼ ê°„ê²© */
            padding: 4px; /* ë³´ë“œ ë‚´ë¶€ ì—¬ë°± */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* ------------------------- */
        /* == 3. íƒ€ì¼ ìŠ¤íƒ€ì¼ (ì‹ ê·œ í…Œë§ˆ) == */
        /* ------------------------- */
        .tile {
            background-color: var(--panel-bg);
            border-radius: 10px; 
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8em; /* ì•„ì´ì½˜ í¬ê¸° (JSì—ì„œ ì¡°ì ˆ) */
            cursor: pointer;
            transition: background-color 0.15s, transform 0.15s, border-color 0.15s, box-shadow 0.15s;
            border: 3px solid var(--panel-border); /* [í…Œë§ˆ] */
            box-shadow: 2px 2px 0px 0px var(--panel-shadow); /* [í…Œë§ˆ] */
            aspect-ratio: 1 / 1;
        }
        .tile:active { 
            /* [í…Œë§ˆ] ì•„ì¼€ì´ë“œ ë²„íŠ¼ì²˜ëŸ¼ ëˆŒë¦¬ëŠ” íš¨ê³¼ */
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0px 0px var(--panel-shadow);
        }
        .tile.selected {
            background-color: #FFF8E1; /* [í…Œë§ˆ] */
            border-color: var(--accent-color); /* [í…Œë§ˆ] */
            transform: scale(1.05); /* [ìœ ì§€] */
            box-shadow: 0 0 10px var(--accent-color); /* [ìœ ì§€] */
        }
        .tile.hidden { /* ë§¤ì¹­ë˜ì–´ ì‚¬ë¼ì§ˆ ë•Œ */
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            background-color: transparent !important;
            border-color: transparent !important;
            box-shadow: none;
            cursor: default;
        }
        .tile img { /* ì´ë¯¸ì§€ íƒ€ì¼ìš© */
             width: 75%; height: 75%; object-fit: contain;
             pointer-events: none; /* ì´ë¯¸ì§€ í´ë¦­ ë°©ì§€ */
        }

        /* ------------------------- */
        /* == 4. ê²½ë¡œ ìº”ë²„ìŠ¤ (ìœ ì§€) == */
        /* ------------------------- */
       #path-canvas {
            position: absolute;
            pointer-events: none; /* ìº”ë²„ìŠ¤ í´ë¦­ ë°©ì§€ */
            z-index: 10;
        }
        
        /* ------------------------- */
        /* == 5. ëª¨ë‹¬ (ëŒ€ê¸°ì‹¤.html ê¸°ë°˜) == */
        /* ------------------------- */
        .overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            display: none; 
            flex-direction: column; justify-content: center; align-items: center; 
            z-index: 200; text-align: center; 
            background-color: rgba(0, 0, 0, 0.6); /* [í…Œë§ˆ] */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding-top: env(safe-area-inset-top); /* [ìˆ˜ì •] ë…¸ì¹˜ ëŒ€ì‘ */
            padding-bottom: env(safe-area-inset-bottom); /* [ìˆ˜ì •] í™ˆë°” ëŒ€ì‘ */
        }
        .overlay.active { display: flex; }
        
        .modal-content { 
            background: var(--panel-bg); 
            color: var(--text-color-dark); 
            padding: 0; 
            border-radius: 24px;
            width: 90%; max-width: 400px; 
            box-shadow: 8px 8px 0px 0px var(--text-color-dark);
            overflow: hidden; 
            border: 4px solid var(--text-color-dark);
        }
        .modal-header { 
            background-color: var(--primary-color);
            color: white; 
            padding: 15px; 
            border-bottom: 4px solid #C04A4A; 
        }
        .modal-header h2 { font-size: 1.6em; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); }
        .modal-body { padding: 25px; }
        .modal-footer {
            display: flex; gap: 10px;
            padding: 20px;
            border-top: 3px solid var(--panel-border);
            background-color: #FFFAE0;
        }
        
        /* ìŠ¤í”¼ë„ˆ/ì¹´ìš´íŠ¸ë‹¤ìš´ (ìœ ì§€) */
        .spinner { border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #countdown-number { font-size: 7em; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.7); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* ì ìˆ˜íŒ (í…Œë§ˆ ì ìš©) */
        #score-board { margin: 20px 0; display: flex; flex-direction: column; gap: 8px; }
        .score-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-radius: 12px; font-size: 1.1em; font-weight: 700; border: 2px solid var(--text-color-dark); }
        .score-row.winner { 
            background-color: var(--accent-color);
            color: var(--text-color-dark); 
            border-color: #D1B030;
        }
        .score-row.loser, .score-row.draw { 
            background-color: var(--panel-border);
            color: var(--text-color-dark); 
        }
        .score-avatar { display: inline-flex; align-items: center; gap: 10px; }
        .score-avatar .avatar { width: 32px; height: 32px; font-size: 1.5em; display:flex; justify-content:center; align-items:center; border-radius: 8px; overflow:hidden; }
        .score-avatar .avatar img { width: 100%; height: 100%; object-fit: contain; }

        /* ìƒí˜¸ ì „ì  (ìœ ì§€) */
        .h2h-stats {
            text-align: center; font-weight: 700; font-size: 1.0em; 
            color: var(--text-color-dark); 
            margin: 0 0 20px 0;
        }
        
        /* ------------------------- */
        /* == 6. ì•„ì¼€ì´ë“œ ë²„íŠ¼ (ëŒ€ê¸°ì‹¤.html) == */
        /* ------------------------- */
        .menu-btn { 
            width: 100%; padding: 15px; font-size: 1.1em; font-weight: 900; 
            font-family: var(--font-main);
            border-radius: 16px; border: none; cursor: pointer; 
            transition: all 0.1s ease-out;
            border-bottom: 5px solid; /* 3D íš¨ê³¼ */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.1);
            margin: 5px 0; 
        }
        .menu-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        .menu-btn.primary { 
            background-color: var(--primary-color);
            color: white; 
            border-bottom-color: #C04A4A;
        }
        .menu-btn.secondary { 
            background-color: var(--secondary-color);
            color: white; 
            border-bottom-color: #379A93;
        }
        .menu-btn:disabled { 
            background-color: #BDBDBD !important; 
            color: #757575 !important;
            border-bottom-color: #8D8D8D !important;
            cursor: not-allowed; 
            transform: none;
        }

        /* ------------------------- */
        /* == 7. ì…”í”Œ ì• ë‹ˆë©”ì´ì…˜ (ì‚¬ì²œì„±.html) == */
        /* ------------------------- */
        @keyframes wipe-down-in {
            from { clip-path: inset(0 0 100% 0); }
            to { clip-path: inset(0 0 0 0); }
        }
        @keyframes wipe-up-out {
            from { clip-path: inset(0 0 0 0); }
            to { clip-path: inset(100% 0 0 0); }
        }
        @keyframes board-shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(3px, 2px); }
            50% { transform: translate(-3px, -2px); }
            75% { transform: translate(2px, -3px); }
        }
        .board-shake {
            animation: board-shake 0.1s linear 20; 
        }
        .wipe-in { animation: wipe-down-in 0.4s ease-out forwards; }
        .wipe-out { animation: wipe-up-out 0.4s ease-in forwards; }
        .wipe-out { animation: wipe-up-out 0.4s ease-in forwards; }

        /* ------------------------- */
        /* == 8. ì‹ ê·œ: ê²Œì´ì§€ ë° ì½¤ë³´ (í—¤ë”) == */
        /* ------------------------- */
        .player-info .info-text {
            display: flex; flex-direction: column; 
            min-width: 0; flex-grow: 1;
            /* [ìˆ˜ì •] ì ìˆ˜ ëŒ€ì‹  ê²Œì´ì§€ê°€ ë“¤ì–´ê°€ë¯€ë¡œ ê°­ ì œê±° */
            gap: 2px; 
        }
        .player-info .nickname {
            font-weight: 700; font-size: 0.9em; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            /* [ì‹ ê·œ] ê²Œì´ì§€ë°”ë¥¼ ìœ„í•œ ê³µê°„ í™•ë³´ */
            margin-bottom: 2px;
        }
        /* [ì‚­ì œ] .player-info .score ìŠ¤íƒ€ì¼ ì œê±° (ê²Œì´ì§€ë¡œ ëŒ€ì²´) */
        /* .player-info .score { ... } */

        /* [ì‹ ê·œ] ê²Œì´ì§€ ë°” (í…Œë‘ë¦¬) */
        .gauge-bar {
            width: 100%;
            height: 12px;
            background-color: rgba(0,0,0,0.5); /* ê²€ì •ìƒ‰ í…Œë‘ë¦¬ ì—­í•  */
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            padding: 1px; /* ë‚´ë¶€ ê²Œì´ì§€ì™€ ê°„ê²© */
        }
        /* [ì‹ ê·œ] ê²Œì´ì§€ ë°” (ì±„ìš°ê¸°) */
        .gauge-fill {
            width: 0%; /* JSì—ì„œ ì¡°ì ˆ */
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
            border-radius: 3px;
            transition: width 0.3s ease-out;
        }

        /* [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ (í—¤ë”) */
        .combo-display {
            position: absolute;
            top: 2px; right: 5px;
            display: none; /* [ìˆ˜ì •] í—¤ë” ì½¤ë³´ í…ìŠ¤íŠ¸ ìˆ¨ê¹€ */
            white-space: nowrap; /* [ìˆ˜ì •] ì½¤ë³´ í…ìŠ¤íŠ¸ ì„¸ë¡œ ì˜¤ë¥˜ ë°©ì§€ */
            font-size: 1.1em;
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 0 0 5px rgba(0,0,0,0.7), 1px 1px 2px rgba(0,0,0,1);
            transition: transform 0.1s ease-out;
        }
        .combo-display.combo-active {
            transform: scale(1.2);
        }

        /* ------------------------- */
        /* == 9. ì‹ ê·œ: ì¸ê²Œì„ ì½¤ë³´/ê³µê²© íš¨ê³¼ == */
        /* ------------------------- */

        /* [ì‹ ê·œ] ë¨¹ë¬¼ ê³µê²© ì˜¤ë²„ë ˆì´ */
        #ink-splatter-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 1;
            pointer-events: none;
            z-index: 150;
            transition: opacity 0.3s ease-out;
        }
        #ink-splatter-overlay.active {
            opacity: 1;
        }

        /* [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ (ì¸ê²Œì„) */
        #combo-text-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        .combo-text-popup {
            position: absolute;
            font-size: 1.5em;
            white-space: nowrap; /* [ìˆ˜ì •] ì½¤ë³´ í…ìŠ¤íŠ¸ ì„¸ë¡œ ì˜¤ë¥˜ ë°©ì§€ */
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: combo-fade-up 2s ease-out forwards;
        }

        /* [ì‹ ê·œ] ê°œë³„ ë¨¹ë¬¼ ì–¼ë£© ìŠ¤íƒ€ì¼ */
        .ink-splat {
            position: absolute;
            width: 150px; /* ì–¼ë£© í¬ê¸° */
            height: 150px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path fill="rgba(0,0,0,0.85)" d="M86.1,61.7C81,73,73.4,80.6,64.2,85.8c-9.2,5.2-20.1,7.9-31.4,7.9c-11.4,0-22.3-2.8-31.4-8C-0.8,80.4-8.4,72.7-13.9,61.4c-5.4-11.3-8.1-23.8-8.1-36.8C-22,11.5-19.3-1.1-13.9-13.1c5.4-12,13.1-19.7,22.2-25.2c9.2-5.4,20-8.1,31.4-8.1c11.4,0,22.3,2.7,31.4,8.1c9.2,5.5,16.9,13.2,22.2,25.2c5.4,12,8.1,24.6,8.1,37.8C100.4,37.9,97.7,50.4,86.1,61.7z" transform="translate(50 50) scale(0.7)"/></svg>') no-repeat center center;
            background-size: contain;
            opacity: 0;
            animation: ink-fade-in 0.2s ease-out forwards, ink-fade-out 0.5s 2.5s ease-in forwards; /* 0.2ì´ˆ ìƒì„±, 2.5ì´ˆ ëŒ€ê¸°, 0.5ì´ˆ ì œê±° = ì´ 3ì´ˆ */
        }
        @keyframes ink-fade-in {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes ink-fade-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.8); }
        }

        @keyframes combo-fade-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* [ì‹ ê·œ] í† ìŠ¤íŠ¸ ì•Œë¦¼ (ì• ë‹ˆíŒ¡.html ìŠ¤íƒ€ì¼) */
        #toast-container {
            position: fixed;
            top: 20px; /* ìƒë‹¨ì—ì„œ 20px ì•„ë˜ */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none; /* í´ë¦­ ë°©ì§€ */
        }
        .toast-notification {
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            animation: toast-fade-in 0.5s forwards, toast-fade-out 0.5s 2.5s forwards;
            white-space: nowrap; /* ì¤„ë°”ê¿ˆ ë°©ì§€ */
        }
        @keyframes toast-fade-in {
            from { opacity: 0; transform: translateY(-20px); } /* ìœ„ì—ì„œ ì•„ë˜ë¡œ */
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toast-fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }

    </style>
</head>
<body>
    <div id="game-wrapper">
        <div class="page-header" id="solo-header" style="display: none;">
            <a href="ëŒ€ê¸°ì‹¤.html" class="back-btn">â€¹</a>
            <h1>ì‚¬ì²œì„± (í˜¼ìí•˜ê¸°)</h1>
            <div style="width: 40px; flex-shrink: 0;"></div>
        </div>
        
        <div id="game-header" style="display: none;">
            </div>
        
        <div id="game-container">
            <div id="game-board">
                </div>
            <canvas id="path-canvas"></canvas>
            <div id="combo-text-overlay"></div>
            <div id="ink-splatter-overlay"></div>
        </div>
    </div>

    <div id="info-overlay" class="overlay active"> <div class="spinner"></div>
         <p style="color: white; margin-top: 15px; font-size: 1.1em;">ê²Œì„ ì¤€ë¹„ ì¤‘...</p>
    </div>
    
    <div id="game-over-overlay" class="overlay">
        </div>
    
    <div id="confirm-exit-modal" class="overlay">
         <div class="modal-content">
             <div class="modal-body">
                 <h3>ê²Œì„ì—ì„œ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?</h3>
                 <p id="exit-modal-subtext">ê²Œì„ì€ íŒ¨ë°° ì²˜ë¦¬ë©ë‹ˆë‹¤.</p>
             </div>
             <div class="modal-footer">
                 <button id="exit-cancel-btn" class="menu-btn secondary">ì·¨ì†Œ</button>
                 <button id="exit-confirm-btn" class="menu-btn primary" style="background-color: var(--danger-color); border-bottom-color: #A94442;">í™•ì¸</button>
             </div>
         </div>
    </div>
<div id="toast-container"></div>
    <audio id="tile-select-sound" src="./sounds/select.mp3" preload="auto"></audio>
    <audio id="tile-match-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì‚¬ì²œì„±ë§ì¶¤.mp3" preload="auto"></audio>
    <audio id="win-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/win.mp3" preload="auto"></audio>
    <audio id="loss-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/íŒ¨ë°°.mp3" preload="auto"></audio>
    <audio id="junk-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì •í¬ë„˜ì–´ì˜¬ë•Œ.mp3" preload="auto"></audio>


    <script src="ì•„ë°”íƒ€.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script>
        // ------------------------------------
        // í—¬í¼ í•¨ìˆ˜
        // ------------------------------------
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
            return str.replace(/[&<>"']/g, m => map[m]);
        }

        // Firebase ê°ì²´/í¬ì†Œë°°ì—´ì„ TILE_COUNT ê¸¸ì´ì˜ ë¹½ë¹½í•œ ë°°ì—´ë¡œ ë³€í™˜
        function getBoardArray(boardData, tileCount) {
            const newArray = new Array(tileCount).fill(null);
            if (boardData) {
                for (const key in boardData) {
                    const index = parseInt(key, 10);
                    if (!isNaN(index) && index >= 0 && index < tileCount) { 
                        newArray[index] = boardData[key];
                    }
                }
            }
            return newArray;
        }

        // ë°°ì—´ ì„ê¸° (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // ë¹ˆ ì¹¸ ì¸ë±ìŠ¤ ì°¾ê¸°
        function findEmptySpots(boardArray) {
            const emptyIndices = [];
            boardArray.forEach((tile, index) => {
                if (tile === null) {
                    emptyIndices.push(index);
                }
            });
            return emptyIndices;
        }

      document.addEventListener('DOMContentLoaded', () => {
            // ------------------------------------
            // 1. Firebase ë° DOM ìš”ì†Œ ì´ˆê¸°í™”
            // ------------------------------------
            // [ì‹ ê·œ] ê³µìš© í† ìŠ¤íŠ¸ ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜
            function showToast(message) {
                const toastContainer = document.getElementById('toast-container');
                if (!toastContainer) return;

                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                
                toastContainer.appendChild(toast);

                // 3ì´ˆ í›„ DOMì—ì„œ ì œê±°
                setTimeout(() => {
                    toast.remove();
                }, 3000);
            }

            // [ì‹ ê·œ] HTML íƒˆì¶œ(escape) í•¨ìˆ˜
            function escapeHTML(str) {
                if (typeof str !== 'string') return '';
                const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'};
                return str.replace(/[&<>"']/g, m => map[m]);
            }
            
            document.addEventListener('contextmenu', event => event.preventDefault());
            // (ë””ë²„ê¹…ì„ ìœ„í•´ F12 ì°¨ë‹¨ ë“±ì€ ì£¼ì„ ì²˜ë¦¬)

            // --- [ì‹ ê·œ] í…ŒìŠ¤íŠ¸ìš© ë‹¨ì¶•í‚¤ (F12, E, S) ---
            document.addEventListener('keydown', event => {
                // F12 ë“± ê°œë°œì ë„êµ¬ ë°©ì§€
                if (event.key === 'F12' ||
                   (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
                    (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                     event.preventDefault();
                }

                // 'E' í‚¤: ê°•ì œ ê²Œì„ ì¢…ë£Œ (í˜„ì¬ ê²Œì´ì§€ ê¸°ì¤€ ìŠ¹íŒ¨ íŒì •)
                if (event.key.toUpperCase() === 'E' && isGameLive) {
                     event.preventDefault();
                     console.log("--- TEST: 'E' í‚¤ë¡œ ê°•ì œ ê²Œì„ ì¢…ë£Œ (ê²Œì´ì§€ ë¹„êµ) ---");
                     isGameLive = false;
                     gameOverFlag = true;

                     if (roomRef && currentRoomData && currentRoomData.playerStates) {
                        const playerStates = currentRoomData.playerStates;
                        const playerIds = Object.keys(playerStates);
                        
                        // 1. ìµœê³  ê²Œì´ì§€ ì°¾ê¸°
                        let maxGauge = -1;
                        let winners = []; // ë™ì ì í¬í•¨
                        
                        playerIds.forEach(id => {
                            const gauge = (playerStates[id] || { gauge: 0 }).gauge;
                            if (gauge > maxGauge) {
                                maxGauge = gauge;
                                winners = [id]; // ìƒˆ ìµœê³ ì ì
                            } else if (gauge === maxGauge) {
                                winners.push(id); // ë™ì ì ì¶”ê°€
                            }
                        });

                        // 2. ë‚´ê°€ ìŠ¹ìì¸ì§€ í™•ì¸ (ë™ì ë„ ìŠ¹ë¦¬ë¡œ ì¹¨)
                        const iWon = winners.includes(myPlayerId);

                        // 3. Firebase ì—…ë°ì´íŠ¸ ì¤€ë¹„ (ìŠ¹ì ì™¸ ëª¨ë‘ isDead: true)
                        const updates = { 'status': 'gameOver' };
                        playerIds.forEach(id => {
                            // ìŠ¹ì ëª©ë¡(winners)ì— í¬í•¨ë˜ì§€ *ì•Šìœ¼ë©´* ì‚¬ë§
                            updates[`playerStates/${id}/isDead`] = !winners.includes(id);
                        });
                        
                        // 4. Firebase ì—…ë°ì´íŠ¸ (ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ì „íŒŒ)
                        roomRef.update(updates);
                        
                        // 5. ë¡œì»¬ ì¦‰ì‹œ ë°˜ì˜
                        // (Firebase on('value')ê°€ ì–´ì°¨í”¼ ì´ê±¸ ë‹¤ì‹œ í˜¸ì¶œí•˜ê² ì§€ë§Œ, ì¦‰ê°ì ì¸ ë°˜ì‘ì„ ìœ„í•´ í•„ìš”)
                        showGameOverScreen(iWon);

                    } else {
                        // ì •ë³´ê°€ ì—†ì„ ë• ê·¸ëƒ¥ ì´ì „ì²˜ëŸ¼ íŒ¨ë°° ì²˜ë¦¬
                        console.log("--- TEST: playerStates ì •ë³´ ì—†ì–´ ê°•ì œ íŒ¨ë°° ì²˜ë¦¬ ---");
                        showGameOverScreen(false);
                    }
                }

                // 'S' í‚¤: ê°•ì œ ë¡œì»¬ í˜ë„í‹° ì…”í”Œ
                if (event.key.toUpperCase() === 'S' && isGameLive && !isShuffling) {
                    event.preventDefault();
                    console.log("--- TEST: 'S' í‚¤ë¡œ ê°•ì œ 'í˜ë„í‹° ì…”í”Œ' ì‹¤í–‰ (ì²´í¬ ë¬´ì‹œ) ---");
                    
                    // [ìˆ˜ì •] checkAndShuffleIfNeeded_Local(0) ëŒ€ì‹ , ì…”í”Œ ë¡œì§ ê°•ì œ ì‹¤í–‰
                    isShuffling = true;

                    // ì¬ë°°ì—´ UI í‘œì‹œ (1ì´ˆ)
                    infoOverlay.innerHTML = `<p style="color: white; font-size: 1.5em; font-weight: 700;">ğŸ² ê°•ì œ ì…”í”Œ ì‹¤í–‰ì¤‘!</p>`;
                    infoOverlay.style.display = 'flex';
                    gameBoard.classList.add('board-shake');
                    playSound('shuffle');
                    playVibrationEffect();

                    // 1ì´ˆ ë’¤ì— ì‹¤ì œ ì…”í”Œ ì‹¤í–‰
                    setTimeout(() => {
                        const newShuffledBoard = shuffleRemainingTiles(myBoard);
                        
                        myBoard = newShuffledBoard; // ë¡œì»¬ ë³´ë“œ êµì²´
                        renderBoard(myBoard); // ìƒˆ ë³´ë“œë¡œ ë Œë”ë§

                        // UI ìˆ¨ê¸°ê¸°
                        gameBoard.classList.remove('board-shake');
                        infoOverlay.style.display = 'none';
                        isShuffling = false; // í”Œë˜ê·¸ í•´ì œ

                        // ì…”í”Œëœ ìƒˆ ë³´ë“œê°€ ë§‰í˜”ëŠ”ì§€ 0.5ì´ˆ ë’¤ ê²€ì‚¬
                        setTimeout(() => checkAndShuffleIfNeeded_Local(0), 500);

                    }, 1000); // 1ì´ˆ í˜ë„í‹°
                }
            });
            // --- í…ŒìŠ¤íŠ¸ìš© ë‹¨ì¶•í‚¤ ë ---

            // Firebase ì„¤ì •
            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.appspot.com",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database();
            const auth = firebase.auth();
            const roomsRef = db.ref('rooms');
            const usersRef = db.ref('users');

            // DOM ìš”ì†Œ
            const gameHeader = document.getElementById('game-header');
            const gameBoard = document.getElementById('game-board');
            const gameContainer = document.getElementById('game-container');
            const pathCanvas = document.getElementById('path-canvas');
            const ctx = pathCanvas.getContext('2d');
            const infoOverlay = document.getElementById('info-overlay');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const confirmExitModal = document.getElementById('confirm-exit-modal');
            const exitCancelBtn = document.getElementById('exit-cancel-btn');
            const exitConfirmBtn = document.getElementById('exit-confirm-btn');
            const soloHeader = document.getElementById('solo-header'); // [ìˆ˜ì •] DOM ë³€ìˆ˜ ì„ ì–¸ ì¶”ê°€

            // [ì‹ ê·œ] ì´í™íŠ¸ DOM
            const comboTextOverlay = document.getElementById('combo-text-overlay');
            const inkSplatterOverlay = document.getElementById('ink-splatter-overlay');
            // ì‚¬ìš´ë“œ ìš”ì†Œ
            const sounds = {
                select: document.getElementById('tile-select-sound'),
                match: document.getElementById('tile-match-sound-new'),
                win: document.getElementById('win-sound-new'),
                lose: document.getElementById('loss-sound-new'),
                shuffle: document.getElementById('junk-sound') // [ìˆ˜ì •] ì…”í”Œìš©ìœ¼ë¡œ ì •í¬ ì‚¬ìš´ë“œ ì¬ì‚¬ìš©
            };

            // ------------------------------------
            // 2. ê²Œì„ ìƒíƒœ ë³€ìˆ˜
            // ------------------------------------
            let myPlayerId, myNickname, myAvatar;
            let roomRef, currentRoomData = null, isHost;
            let isGameLive = false, gameOverFlag = false, isExiting = false;
            let countdownStarted = false;

            // [ì‹ ê·œ] ë¡œì»¬ í”Œë ˆì´ ìƒíƒœ (ë…ë¦½ ë³´ë“œ)
            let myBoard = []; // ë‚´ ë¡œì»¬ ë³´ë“œ
            let selectedTileElement = null; // ë‚´ ë¡œì»¬ ì„ íƒ
            let myScore = 0; // ë‚´ ë¡œì»¬ ì ìˆ˜ (ë§ì¶˜ ìŒ)
            let myCombo = 0;
            let lastMatchTime = 0;
            let isShuffling = false; // ë¡œì»¬ ì…”í”Œ ì¤‘ë³µ ë°©ì§€

            // ìº”ë²„ìŠ¤ ì¢Œí‘œ ê³„ì‚°ìš©
            let currentTileSize = 0, currentGapSize = 2, currentExtraMargin = 0; 
            // [ì‹ ê·œ] ì•„ì´í…œ ìƒíƒœ
            let isFirewallActive = false; // ë°©í™”ë²½ í™œì„±í™” ìƒíƒœ
            
            // ê²Œì„ ì„¤ì • (í”Œë ˆì´ì–´ ìˆ˜ì— ë”°ë¼ JSì—ì„œ ë³€ê²½)
            let BOARD_ROWS = 7;
            let BOARD_COLS = 6;
            let TILE_COUNT = BOARD_ROWS * BOARD_COLS;
            
            const TILE_ICONS = [
                'ğŸ»', 'ğŸ‹', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ•¹ï¸', 'ğŸ¥', 'ğŸ¥¥', 'â›ï¸', 'ğŸ‘»',
                'ğŸ€', 'ğŸ´', 'ğŸ³', 'ğŸŒµ', 'ğŸ„', 'ğŸ¤', 'ğŸ»', 'ğŸ’©', 'ğŸª“', 'ğŸ¯',
                'ğŸ¦', 'ğŸ©', 'ğŸ³', 'ğŸ¸', 'âš¾', 'ğŸŒ»', 'ğŸ­', 'ğŸ§Š', 'ğŸ¤', 'ğŸ—ï¸',
                'ğŸ”', 'ğŸ•', 'ğŸ§®', 'ğŸŒ­', 'ğŸ¿', 'ğŸ', 'ğŸ¥“', 'ğŸ¥š', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ¥',
                'ğŸ¨', 'ğŸ’°', 'ğŸ’£', 'ğŸ’', 'ğŸš€', 'ğŸ›¸', 'ğŸ›°ï¸', 'ğŸª', 'â˜‚ï¸', 'â›±ï¸' 
            ];

            // ------------------------------------
            // 3. í—¬í¼ í•¨ìˆ˜ (ì‚¬ìš´ë“œ, ì§„ë™)
            // ------------------------------------
            function playSound(id) {
                try {
                    const sound = sounds[id];
                    if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
                } catch(e) { console.warn("Sound play error:", e); }
            }
            function playVibrationEffect() {
                if (navigator.vibrate) navigator.vibrate(100); 
            }

            // ------------------------------------
            // 4. ì´ˆê¸°í™” ë° ë°© ì°¸ê°€ ë¡œì§
            // ------------------------------------
            
            // [ì‹ ê·œ] 'í˜¼ìí•˜ê¸°' ëª¨ë“œ ê°ì§€ (íŒŒì¼ ë³‘í•© ëŒ€ë¹„)
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            
            // [ìˆ˜ì •] 'í˜¼ìí•˜ê¸°' ëª¨ë“œëŠ” ì´ íŒŒì¼ì—ì„œ ì§ì ‘ ì²˜ë¦¬ (ì‚¬ì²œì„±í˜¼ìí•˜ê¸°.html ì°¸ì¡°)
            if (urlParams.get('mode') === 'solo') {
                console.log("[ëª¨ë“œ] 'í˜¼ìí•˜ê¸°' ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤.");
                // (ì´ íŒŒì¼ì€ ë©€í‹° ì „ìš©ì´ë¯€ë¡œ, í˜¼ìí•˜ê¸° ë¡œì§ì€ ìƒëµí•˜ê³  ëŒ€ê¸°ì‹¤ë¡œ ë³´ëƒ…ë‹ˆë‹¤.)
                alert("ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤. í˜¼ìí•˜ê¸°ëŠ” ëŒ€ê¸°ì‹¤ì„ í†µí•´ ì ‘ì†í•´ì£¼ì„¸ìš”.");
                window.location.replace('ëŒ€ê¸°ì‹¤.html');
            } else if (roomId) {
                console.log("[ëª¨ë“œ] 'ê°™ì´í•˜ê¸°' ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤.");
                soloHeader.style.display = 'none';
                gameHeader.style.display = 'flex';
                initialize_Multiplayer();
            } else {
                alert("ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.");
                window.location.replace('ëŒ€ê¸°ì‹¤.html');
            }

            // 'ê°™ì´í•˜ê¸°' ëª¨ë“œ ì „ìš© ì´ˆê¸°í™”
            function initialize_Multiplayer() {
                auth.onAuthStateChanged(user => {
                    if (user) {
                        myPlayerId = user.uid;
                        setupGlobalNotificationListeners(myPlayerId); // [ì‹ ê·œ] ì „ì—­ ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì‹œì‘
                        myNickname = localStorage.getItem('userNickname') || 'Player';
                        myAvatar = localStorage.getItem('userAvatar') || 'ğŸ˜Š';
                        if (!myNickname) { auth.signOut(); window.location.replace('index.html'); return; }

                        infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">ë°©ì— ì°¸ê°€í•˜ëŠ” ì¤‘...</p>`;
                        infoOverlay.classList.add('active');
                        joinRoom(roomId); 
                    } else {
                        window.location.replace('index.html');
                    }
                });

                // ë’¤ë¡œê°€ê¸°
                history.pushState(null, '', location.href);
                window.addEventListener('popstate', (e) => {
                    history.pushState(null, '', location.href);
                    confirmExitModal.classList.add('active');
                    document.getElementById('exit-modal-subtext').textContent = isHost ? "ë°©ì¥ì´ ë‚˜ê°€ë©´ ë°©ì´ ì‚¬ë¼ì§‘ë‹ˆë‹¤." : "ê²Œì„ì€ íŒ¨ë°° ì²˜ë¦¬ë©ë‹ˆë‹¤.";
                });
                exitConfirmBtn.addEventListener('click', cleanupAndExit);
                exitCancelBtn.addEventListener('click', () => { confirmExitModal.classList.remove('active'); });
            }

            function joinRoom(roomId) {
                roomRef = roomsRef.child(roomId);
                roomRef.once('value', snapshot => {
                    if (!snapshot.exists()) { alert("ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); window.location.replace('ëŒ€ê¸°ì‹¤.html'); return; }

                    currentRoomData = snapshot.val();
                    isHost = currentRoomData.hostId === myPlayerId;

                    // [ì‹ ê·œ] 'playerStates' ë…¸ë“œ ì´ˆê¸°í™” (ìµœì´ˆ 1íšŒ)
                    const playerStateRef = roomRef.child('playerStates/' + myPlayerId);
                    playerStateRef.set({
                        gauge: 0,
                        combo: 0,
                        isDead: false
                    });
                    
                    // [ì‹ ê·œ] onDisconnect ì‹œ 'playerStates'ì™€ 'players' ëª¨ë‘ ì œê±°
                    playerStateRef.onDisconnect().remove();
                    roomRef.child('players/' + myPlayerId).onDisconnect().remove();

                    // ë¦¬ìŠ¤ë„ˆ ì‹œì‘
                    listenToRoomChanges();

                    // 'ë‹¤ì‹œí•˜ê¸°'ë¡œ 'waiting' ìƒíƒœì¼ ë•Œ 'ì¤€ë¹„' ì‹ í˜¸
                    if (currentRoomData.status === 'waiting') {
                        roomRef.child('readyPlayers/' + myPlayerId).set(true);
                    }

                }).catch(error => {
                     console.error("Firebase read error:", error);
                     alert("ë°© ì •ë³´ë¥¼ ì½ì–´ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); window.location.replace('ëŒ€ê¸°ì‹¤.html');
                });
            }

            // ------------------------------------
            // 5. Firebase ë¦¬ìŠ¤ë„ˆ (ì‹ ê·œ ë¡œì§)
            // ------------------------------------
            
            // [ì‹ ê·œ] ë©”ì¸ on('value') ë¦¬ìŠ¤ë„ˆ
            function listenToRoomChanges() {
                let playerStatesRef, attackEventsRef;
                
                roomRef.on('value', snapshot => {
                    if (isExiting) return;
                    if (!snapshot.exists()) {
                         if (!gameOverFlag) alert("ë°©ì¥ì´ ë‚˜ê°€ ë°©ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.");
                         cleanupAndExit();
                         return;
                    }

                    const oldRoomData = currentRoomData;
                    currentRoomData = snapshot.val();

                    // í˜¸ìŠ¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜ (ìœ ì§€)
                    const playerIds = Object.keys(currentRoomData.players || {});
                    if (playerIds.length > 0 && (!currentRoomData.hostId || !currentRoomData.players[currentRoomData.hostId])) {
                        const newHostId = playerIds.sort()[0];
                        isHost = (newHostId === myPlayerId);
                        if (isHost) {
                            console.log(`[í˜¸ìŠ¤íŠ¸ ë§ˆì´ê·¸ë ˆì´ì…˜] ë‚´ê°€ ìƒˆ í˜¸ìŠ¤íŠ¸(${myPlayerId})ê°€ ë¨.`);
                            const updates = {};
                            updates['hostId'] = newHostId;
                            playerIds.forEach(id => { updates['players/' + id + '/isHost'] = (id === newHostId); });
                            roomRef.update(updates);
                        }
                    }

                    // ë³´ë“œ í¬ê¸° ì„¤ì • (ìœ ì§€)
                    setBoardDimensions(playerIds.length);

                    // 1ëª… ë‚¨ì•˜ì„ ë•Œ ì¦‰ì‹œ ìŠ¹ë¦¬ (ìœ ì§€)
                    if (currentRoomData.status === 'playing' && playerIds.length === 1) {
                        if (playerIds[0] === myPlayerId && !gameOverFlag) {
                            console.log("[ê²Œì„ ì¢…ë£Œ] ìƒëŒ€ë°© ì´íƒˆë¡œ ìŠ¹ë¦¬.");
                            isGameLive = false;
                            gameOverFlag = true;
                            
                            // [ìˆ˜ì •] ë‚´ê°€ ìŠ¹ë¦¬ + "ê²Œì„ ì¢…ë£Œ" ìƒíƒœë¥¼ Firebaseì— ì „ì†¡
                            roomRef.update({
                                'status': 'gameOver',
                                [`playerStates/${myPlayerId}/isDead`]: false, // ìŠ¹ë¦¬ì
                                [`playerStates/${myPlayerId}/gauge`]: (myScore / (TILE_COUNT / 2)) * 100 // í˜„ì¬ ê²Œì´ì§€
                            });
                            
                            showGameOverScreen(true); // ë¡œì»¬ ì¦‰ì‹œ ë°˜ì‘
                        }
                        return; 
                    }

                    // ë‚´ê°€ ë°©ì—ì„œ ì œì™¸ë¨ (ìœ ì§€)
                    if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                         if (!gameOverFlag) alert("ë°©ì—ì„œ ì œì™¸ë˜ì—ˆìŠµë‹ˆë‹¤.");
                         cleanupAndExit();
                         return;
                    }

          // --- ìƒíƒœë³„ ì²˜ë¦¬ ---
            
            // 1. ê²Œì„ í”Œë ˆì´ ì¤‘
            if (currentRoomData.status === 'playing') {
     // 1a. (í˜¸ìŠ¤íŠ¸) ë§µ ìƒì„± ì‹ í˜¸ (ì‹ ê·œ: ìƒíƒœë§Œ ë³€ê²½)
                // [ìˆ˜ì •] ë§µ ìƒì„±ì„ ê° í´ë¼ì´ì–¸íŠ¸ê°€ ë¡œì»¬ë¡œ í•˜ë„ë¡ ë³€ê²½
                if (isHost && !currentRoomData.gameStarted) {
                    roomRef.update({ 
                        gameStarted: true, // ê²Œì„ ì‹œì‘ ì‹ í˜¸
                        startTime: firebase.database.ServerValue.TIMESTAMP // (ì„ íƒì )
                    }); 
                    return;
                }
                        
              // 1b. ê²Œì„ ì‹œì‘! (ëª¨ë“  í”Œë ˆì´ì–´)
            if (currentRoomData.gameStarted && !countdownStarted) {
                countdownStarted = true;
                
                infoOverlay.classList.remove('active'); // [ì‹ ê·œ] "ìƒëŒ€ë°© ê¸°ë‹¤ë¦¬ëŠ” ì¤‘" ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
                            
                            // [ì‹ ê·œ] ê°ì ë¡œì»¬ ë³´ë“œ ìƒì„±
                            initializeMyBoard(); 
                            // [ì‹ ê·œ] ë¦¬ìŠ¤ë„ˆ ì—°ê²°
                            if (!playerStatesRef) {
                                playerStatesRef = roomRef.child('playerStates');
                                playerStatesRef.on('value', updateHeaderGauges);
                            }
                            if (!attackEventsRef) {
                                // [ìˆ˜ì •] ê²Œì„ ì‹œì‘ ì‹œê°„ ì´í›„ì˜ ê³µê²©ë§Œ ë°›ë„ë¡
                                const startTime = currentRoomData.startTime || Date.now();
                                attackEventsRef = roomRef.child('attackEvents').orderByChild('timestamp').startAt(startTime);
                                attackEventsRef.on('child_added', handleAttackEvent);
                            }
                            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                            startCountdown(); 
                        }

                        // 1c. ê²Œì„ ì§„í–‰ ì¤‘ (í—¤ë” UI ì—…ë°ì´íŠ¸)
                        if (isGameLive) {
                            updateHeaderUI(); // í—¤ë” UIë§Œ ê°±ì‹ 
                        }
                    
                    // 2. ê²Œì„ ì¢…ë£Œ
                    } else if (currentRoomData.status === 'gameOver' && !gameOverFlag) {
                        // [ìˆ˜ì •] Firebaseì˜ 'gameOver'ëŠ” ì°¸ê³ ë§Œ í•˜ê³ ,
                        // 'isDead' í”Œë˜ê·¸ë¥¼ ë³´ê³  ìŠ¹/íŒ¨ë¥¼ ê²°ì •
                        gameOverFlag = true; 
                        isGameLive = false;
                        infoOverlay.classList.remove('active');
                        
                        // 'playerStates'ì—ì„œ ìµœì¢… ìŠ¹ì íŒë³„
                        const playerStates = currentRoomData.playerStates || {};
                        const myState = playerStates[myPlayerId];
                        
                        // ë‚´ê°€ 'isDead=true'ì´ë©´ íŒ¨ë°°, ì•„ë‹ˆë©´ ìŠ¹ë¦¬ (ë‹¨ìˆœí™”)
                        const iWon = (myState && !myState.isDead); 
                        showGameOverScreen(iWon); 
                    
                    // 3. ì¬ì‹œì‘ ëŒ€ê¸°
                    } else if (currentRoomData.status === 'waiting') {
                        // ... (ì¬ì‹œì‘ ë¡œì§ì€ ë™ì¼) ...
                        gameOverOverlay.classList.remove('active');
                        gameOverFlag = false;
                        countdownStarted = false; 

                        const readyPlayers = currentRoomData.readyPlayers || {};
                        const totalPlayers = Object.keys(currentRoomData.players).length;
                        const readyCount = Object.keys(readyPlayers).length;

                        if (!readyPlayers[myPlayerId]) {
                            roomRef.child('readyPlayers/' + myPlayerId).set(true);
                        }
                        
                        infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">ìƒëŒ€ë°© ê¸°ë‹¤ë¦¬ëŠ” ì¤‘ (${readyCount}/${totalPlayers})...</p>`;
                        infoOverlay.classList.add('active');

                        if (isHost && totalPlayers >= 2 && readyCount === totalPlayers) {
                            // [ìˆ˜ì •] ê²Œì„ ì‹œì‘ ì‹ í˜¸ë§Œ ë³´ëƒ„
                            roomRef.update({
                                status: 'playing',
                                gameStarted: true, // [ìˆ˜ì •]
                                readyPlayers: null,
                                playerStates: null, // [ì‹ ê·œ]
                                attackEvents: null  // [ì‹ ê·œ]
                            });
                        }
                    }
                });
            }

            // ------------------------------------
            // 6. ê²Œì„ ë¡œì§ (ë§µ ìƒì„± - ë¡œì»¬)
            // ------------------------------------
            function setBoardDimensions(playerCount) {
                if (playerCount >= 3) {
                    BOARD_ROWS = 8; // 3~4ì¸
                    BOARD_COLS = 6;
                } else {
                    BOARD_ROWS = 7; // 2ì¸
                    BOARD_COLS = 6;
                }
                TILE_COUNT = BOARD_ROWS * BOARD_COLS;
                console.log(`[ê²Œì„ ì„¤ì •] ${playerCount}ì¸. ë³´ë“œ ${BOARD_ROWS}x${BOARD_COLS} (${TILE_COUNT}íƒ€ì¼)`);
            }
            
            // [ì‹ ê·œ] 'í˜¼ìí•˜ê¸°' ë§µ ìƒì„± ë¡œì§ (ë¡œì»¬ ë³´ë“œ ìƒì„±)
            function initializeMyBoard() {
                console.log("[ë¡œì»¬] ë‚´ ê²Œì„íŒ ìƒì„± ì‹œì‘...");
                const iconsNeeded = TILE_COUNT / 2;
                const board = createSolvableBoard(iconsNeeded);
                
                if (!board) {
                    alert("ë§µ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ë¡œì»¬)");
                    cleanupAndExit();
                    return;
                }
                
                myBoard = board; // [ì‹ ê·œ] ë¡œì»¬ ë³€ìˆ˜ì— ë³´ë“œ ì €ì¥
                myScore = 0;
                myCombo = 0;
                lastMatchTime = 0;
                selectedTileElement = null;
                
                console.log("[ë¡œì»¬] ë‚´ ê²Œì„íŒ ìƒì„± ì™„ë£Œ.");
            }
            
            // [ì‹ ê·œ] í’€ì´ ê°€ëŠ¥ ë³´ë“œ ìƒì„± í•µì‹¬ í•¨ìˆ˜ (ë©€í‹°ì‚¬ì²œì„±.html ì›ë³¸)
             function createSolvableBoard(iconsNeeded) {
                 const board = new Array(TILE_COUNT).fill(null);
                 const selectedIcons = TILE_ICONS.slice(0, iconsNeeded);
                 
                 // 1. íƒ€ì¼ ìŒ ëª©ë¡ ìƒì„± (ì˜ˆ: [{icon: 'A'}, {icon: 'B'}, ...])
                 const tilePairs = [];
                 selectedIcons.forEach(icon => {
                     tilePairs.push({ icon, placed: false });
                 });
                 shuffleArray(tilePairs);

                 // 2. ë°°ì¹˜ ê¸°ë¡ (ì—­ìˆœìœ¼ë¡œ ì œê±°í•  ìˆ˜ ìˆê²Œ)
                 const placementOrder = [];

                 // 3. ê° íƒ€ì¼ ìŒ(ì˜ˆ: 'A' ìŒ)ì„ ì—°ê²° ê°€ëŠ¥í•œ ìœ„ì¹˜ì— ë°°ì¹˜
                 for (const pair of tilePairs) {
                     const emptySpots = findEmptySpots(board);
                     
                     if (emptySpots.length < 2) {
                         console.error("ë¹ˆ ì¹¸ ë¶€ì¡±!");
                         return null; // ë§µ ìƒì„± ì‹¤íŒ¨
                     }

                     // 4. ì—°ê²° ê°€ëŠ¥í•œ 2ê°œ ìœ„ì¹˜ ì°¾ê¸°
                     let placed = false;
                     shuffleArray(emptySpots); // ë¬´ì‘ìœ„ì„±

                     for (let i = 0; i < emptySpots.length && !placed; i++) {
                         for (let j = i + 1; j < emptySpots.length && !placed; j++) {
                             const pos1 = emptySpots[i];
                             const pos2 = emptySpots[j];

                             // 5. [í•µì‹¬] í˜„ì¬ ë³´ë“œ ìƒíƒœì—ì„œ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸
                             if (findPath_BFS(board, pos1, pos2)) {
                                 board[pos1] = pair.icon;
                                 board[pos2] = pair.icon;
                                 placementOrder.push({ pos1, pos2, icon: pair.icon });
                                 placed = true;
                             }
                         }
                     }

                     // 6. ë§Œì•½ 50% ì´ìƒ ì‹œë„í•´ë„ ëª» ì°¾ìœ¼ë©´ (ë§¤ìš° ë“œë¬¸ ê²½ìš°)
                     if (!placed) {
                         console.warn("íƒ€ì¼ ë°°ì¹˜ ì‹¤íŒ¨, ëœë¤ ë°°ì¹˜ë¡œ ì „í™˜");
                         // ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ ì•„ë¬´ ë¹ˆ ê³³ì— ë°°ì¹˜ (í’€ ìˆ˜ ì—†ì„ ìˆ˜ ìˆìŒ)
                         const pos1 = emptySpots[0];
                         const pos2 = emptySpots[1];
                         board[pos1] = pair.icon;
                         board[pos2] = pair.icon;
                     }
                 }

                 console.log(`ğŸ“Š ë°°ì¹˜ ì™„ë£Œ: ${placementOrder.length}ê°œ ìŒ`);
                 
                 // 7. (ì•ˆì „ì¥ì¹˜) ì´ë ‡ê²Œ ìƒì„±ëœ ë§µì´ í˜¹ì‹œ ë§‰í˜”ëŠ”ì§€ ìµœì¢… ê²€ì‚¬
                if (checkForAvailableMoves(board)) {
                    return board;
                } else {
                    // ë§‰í˜”ë‹¤ë©´ ê·¸ëƒ¥ ë¬´ì‘ìœ„ë¡œ ì„ì–´ì„œ ë°˜í™˜ (ìµœì•…ì˜ ê²½ìš°)
                    console.error("[ë§µ ìƒì„±] ì—­ìˆœ ë°°ì¹˜ í›„ ë§µì´ ë§‰í˜. ê°•ì œ ì…”í”Œ ì‹¤í–‰.");
                    return shuffleRemainingTiles(board);
                }
             }

            // ------------------------------------
            // 7. ê²Œì„ ë¡œì§ (í´ë¦­ ì²˜ë¦¬ - ë¡œì»¬)
            // ------------------------------------

            function handleTileClick(event) {
                if (!isGameLive || isShuffling) return; 

                const clickedEl = event.currentTarget;
                const clickedIndex = parseInt(clickedEl.dataset.index, 10);
                const clickedIcon = myBoard[clickedIndex];

                if (clickedIcon === null || clickedEl.classList.contains('hidden')) return;

                playSound('select');

                // 1. ì„ íƒëœ íƒ€ì¼ì´ ì—†ìŒ (ì²« ë²ˆì§¸ í´ë¦­)
                if (!selectedTileElement) {
                    selectedTileElement = clickedEl;
                    clickedEl.classList.add('selected');
                    return;
                }

                // 2. ì´ë¯¸ ì„ íƒëœ íƒ€ì¼ì„ ë‹¤ì‹œ í´ë¦­ (ì„ íƒ ì·¨ì†Œ)
                if (selectedTileElement === clickedEl) {
                    selectedTileElement.classList.remove('selected');
                    selectedTileElement = null;
                    return;
                }

                // 3. ë‘ ë²ˆì§¸ íƒ€ì¼ í´ë¦­
                const firstIndex = parseInt(selectedTileElement.dataset.index, 10);
                const firstIcon = myBoard[firstIndex];

                // 3-1. ì•„ì´ì½˜ì´ ê°™ì€ì§€ í™•ì¸
                if (firstIcon === clickedIcon) {
                    // 3-2. ê²½ë¡œ íƒìƒ‰ (ë¡œì»¬ ë³´ë“œ ì‚¬ìš©)
                    const path = findPath_BFS(myBoard, firstIndex, clickedIndex);

                   if (path) {
                        // --- ë§¤ì¹­ ì„±ê³µ! ---
                        playSound('match');
                        drawAnimatedPath(path, "#4A8DFF"); // [ìˆ˜ì •] íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½

            
                        // ë¡œì»¬ ë³´ë“œì—ì„œ íƒ€ì¼ ì¦‰ì‹œ ì œê±°
                        myBoard[firstIndex] = null;
                        myBoard[clickedIndex] = null;

                        // UIì—ì„œ íƒ€ì¼ ì¦‰ì‹œ ìˆ¨ê¸°ê¸°
                        selectedTileElement.classList.add('hidden');
                        clickedEl.classList.add('hidden');
                        selectedTileElement.classList.remove('selected');
                        selectedTileElement = null;
                        
                        // [ì‹ ê·œ] ì ìˆ˜ ë° ì½¤ë³´ ì²˜ë¦¬
                        myScore++;
                        const now = Date.now();
                        if (now - lastMatchTime <= 3000) { // [ìˆ˜ì •] 3ì´ˆ ì½¤ë³´
                            myCombo++;
                        } else {
                            myCombo = 1; // [ìˆ˜ì •] ì²« ì½¤ë³´ 1ë¡œ ë³€ê²½
                        }
                        lastMatchTime = now;
                        
                        // [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ í‘œì‹œ
                        showComboText(myCombo, clickedIndex);
                        // [ì‹ ê·œ] ì•„ì´í…œ ëœë¤ ë½‘ê¸°
                        triggerRandomItem();
                        // [ì‹ ê·œ] ê²Œì´ì§€ ê³„ì‚° (ì´ íƒ€ì¼ì˜ ì ˆë°˜ = ì´ ì ìˆ˜)
                        const totalMatches = TILE_COUNT / 2;
                        const gaugeValue = Math.min(100, (myScore / totalMatches) * 100);
                        roomRef.child('playerStates/' + myPlayerId).update({
                            gauge: gaugeValue,
                            combo: myCombo
                        });

                        // [ìˆ˜ì •] 7ì½¤ë³´ ëœë¤ ì•„ì´í…œ ë°œë™ (ê¸°ì¡´ 5, 8ì½¤ë³´ ì‚­ì œ)
                        if (myCombo === 7) {
                            triggerGuaranteedRandomItem(); // 5ê°€ì§€ ì•„ì´í…œ ì¤‘ 1ê°œ ëœë¤ ë°œë™
                            myCombo = 0; // ì½¤ë³´ ë¦¬ì…‹
                            roomRef.child('playerStates/' + myPlayerId + '/combo').set(0);
                        }

                        // [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ í™•ì¸ (ë¡œì»¬)
                        const remainingTiles = myBoard.filter(tile => tile !== null).length;
                        if (remainingTiles === 0) {
                            isGameLive = false;
                            gameOverFlag = true;
                            
                            // [ë²„ê·¸ ìˆ˜ì •] ë‚´ê°€ ìŠ¹ë¦¬! (ë‚˜=false, ë‚˜ë¨¸ì§€=true)
                            const updates = { 'status': 'gameOver' };
                            
                            // 1. í˜„ì¬ ë°©ì˜ ëª¨ë“  í”Œë ˆì´ì–´ IDë¥¼ ê°€ì ¸ì˜´
                            const playerIds = Object.keys(currentRoomData.players || {});
                            
                            playerIds.forEach(id => {
                                if (id === myPlayerId) {
                                    // 2. ë‚˜ëŠ” 'ìŠ¹ë¦¬' (isDead: false)
                                    updates[`playerStates/${id}/isDead`] = false;
                                    updates[`playerStates/${id}/gauge`] = 100; // ê²Œì´ì§€ 100%
                                } else {
                                    // 3. ë‚˜ë¨¸ì§€ëŠ” 'íŒ¨ë°°' (isDead: true)
                                    updates[`playerStates/${id}/isDead`] = true;
                                }
                            });
                            
                            roomRef.update(updates);
                            
                            // 0.5ì´ˆ í›„ ìŠ¹ë¦¬ í™”ë©´ í‘œì‹œëŠ” ë¡œì»¬ì—ì„œ ë™ì¼í•˜ê²Œ ì‹¤í–‰ (Firebase on()ì´ ì²˜ë¦¬í•˜ê² ì§€ë§Œ, ë¡œì»¬ ì¦‰ì‹œ ë°˜ì‘ì„ ìœ„í•´ ë‘ )
                            setTimeout(() => showGameOverScreen(true), 500);
                        } else {
                            // [ì‹ ê·œ] 0.1ì´ˆ ë’¤ ë§µ ê²€ì‚¬
                            setTimeout(() => checkAndShuffleIfNeeded_Local(0), 100);
                        }

                    } else {
                        // ê²½ë¡œ ì—†ìŒ -> ë‘ ë²ˆì§¸ íƒ€ì¼ì„ ìƒˆ ì„ íƒìœ¼ë¡œ
                        selectedTileElement.classList.remove('selected');
                        selectedTileElement = clickedEl;
                        clickedEl.classList.add('selected');
                        playVibrationEffect();
                    }
                } else {
                    // ì•„ì´ì½˜ ë‹¤ë¦„ -> ë‘ ë²ˆì§¸ íƒ€ì¼ì„ ìƒˆ ì„ íƒìœ¼ë¡œ
                    selectedTileElement.classList.remove('selected');
                    selectedTileElement = clickedEl;
                    clickedEl.classList.add('selected');
                }
            }
            
            // [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ í‘œì‹œ
            function showComboText(combo, index) {
                if (!comboTextOverlay) return;
                
                // íƒ€ì¼ ì¸ë±ìŠ¤ë¡œ DOM ìš”ì†Œ ì°¾ê¸°
                const tileEl = gameBoard.querySelector(`.tile[data-index="${index}"]`);
                if (!tileEl) return;
                
                const rect = tileEl.getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();
                
                const popup = document.createElement('div');
                popup.className = 'combo-text-popup';
                popup.textContent = `${combo}ì½¤ë³´!`; // [ìˆ˜ì •] í•œê¸€ ì½¤ë³´
                
                // ë³´ë“œ ê¸°ì¤€ ì¢Œí‘œë¡œ ì„¤ì •
                popup.style.left = `${rect.left - boardRect.left + rect.width / 2}px`;
                popup.style.top = `${rect.top - boardRect.top}px`;
                popup.style.transform = 'translateX(-50%)'; // ê°€ë¡œ ì¤‘ì•™ ì •ë ¬
                
                comboTextOverlay.appendChild(popup);
                
                // 2ì´ˆ í›„ DOMì—ì„œ ì œê±°
                setTimeout(() => {
                    popup.remove();
                }, 2000);
            }
            
            // [ì‹ ê·œ] ê³µê²© ì „ì†¡
            function sendAttack(attackType) {
                let attackText = "";
                if (attackType === "INK_SPLATTER") {
                    console.log("[ê³µê²©] 5ì½¤ë³´ ë‹¬ì„±! ë¨¹ë¬¼ ê³µê²© ì „ì†¡!");
                    attackText = "ë¨¹ë¬¼ ê³µê²©!";
                } else if (attackType === "SHAKE_BOARD") {
                    console.log("[ê³µê²©] 8ì½¤ë³´ ë‹¬ì„±! ì§€ì§„ ê³µê²© ì „ì†¡!");
                    attackText = "ì§€ì§„ ê³µê²©!";
                } else if (attackType === "FOG_BLIND") { // [ì‹ ê·œ]
                    console.log("[ê³µê²©] ì•„ì´í…œ! ì•ˆê°œ ê³µê²© ì „ì†¡!");
                    // attackText = "ì•ˆê°œ ê³µê²©!"; // (useItemì—ì„œ ì´ë¯¸ ë„ì›€)
                }
                
                // ì½¤ë³´ í…ìŠ¤íŠ¸ëŠ” ì½¤ë³´ì¼ ë•Œë§Œ ë„ì›€
                if (attackText) {
                    showComboText(attackText, TILE_COUNT / 2);
                }
                
                roomRef.child('attackEvents').push({
                    senderId: myPlayerId,
                    type: attackType, // [ìˆ˜ì •]
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            }
            
            // [ì‹ ê·œ] ê³µê²© ìˆ˜ì‹ 
            function handleAttackEvent(snapshot) {
                const attack = snapshot.val();
                if (!attack || attack.senderId === myPlayerId) return;

                // [ì‹ ê·œ] ë°©í™”ë²½ ë¡œì§
                if (isFirewallActive) {
                    isFirewallActive = false; // 1íšŒìš©
                    console.log("[ë°©ì–´] ë°©í™”ë²½ì´ ê³µê²©ì„ 1íšŒ ë§‰ì•˜ìŠµë‹ˆë‹¤!");
                    showItemGetText("FIREWALL_BLOCK");
                    // (í•„ìš”ì‹œ) ë°©í™”ë²½ UI ì œê±°
                    return; // ê³µê²© ë¬´íš¨í™”
                }

                playSound('shuffle'); // ê³µê²© ìˆ˜ì‹  ì‚¬ìš´ë“œ (ì •í¬ ì‚¬ìš´ë“œ)

                if (attack.type === "INK_SPLATTER") {
                    console.log("[ìˆ˜ì‹ ] ë¨¹ë¬¼ ê³µê²© ë°›ìŒ!");
                    
                    // [ìˆ˜ì •] 3ì´ˆê°„ ë¬´ì‘ìœ„ ì–¼ë£© 7ê°œ ìƒì„±
                    inkSplatterOverlay.innerHTML = ''; // ê¸°ì¡´ ì–¼ë£© ì œê±°
                    const boardRect = gameBoard.getBoundingClientRect();
                    const splatCount = 7;
                    
                    for (let i = 0; i < splatCount; i++) {
                        const splat = document.createElement('div');
                        splat.className = 'ink-splat';
                        
                        // ì–¼ë£© í¬ê¸° ë¬´ì‘ìœ„ (100px ~ 200px)
                        const size = Math.random() * 100 + 100;
                        splat.style.width = `${size}px`;
                        splat.style.height = `${size}px`;
                        
                        // ìœ„ì¹˜ ë¬´ì‘ìœ„ (ë³´ë“œ ë‚´ë¶€)
                        splat.style.left = `${Math.random() * (boardRect.width - size)}px`;
                        splat.style.top = `${Math.random() * (boardRect.height - size)}px`;
                        
                        // íšŒì „ ë¬´ì‘ìœ„
                        splat.style.transform = `rotate(${Math.random() * 360}deg) scale(0.5)`; // (ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ ìŠ¤ì¼€ì¼)
                        
                        inkSplatterOverlay.appendChild(splat);
                    }
                    
                    // 3ì´ˆ í›„ ì–¼ë£© DOM ì œê±°
                    setTimeout(() => {
                        inkSplatterOverlay.innerHTML = '';
                    }, 3000); // [ìˆ˜ì •] 2ì´ˆ -> 3ì´ˆ (CSS ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ê³¼ ì¼ì¹˜)
                    } else if (attack.type === "FOG_BLIND") { // [ì‹ ê·œ]
                    console.log("[ìˆ˜ì‹ ] ì•ˆê°œ ê³µê²© ë°›ìŒ!");
                    
                    // 1. ë®ì–´ì“¸ íƒ€ì¼ 8ê°œ ê³ ë¥´ê¸°
                    const availableIndices = [];
                    myBoard.forEach((icon, index) => {
                        // ë¹ˆì¹¸ì´ ì•„ë‹ˆê³ , DOMì—ì„œë„ ìˆ¨ê²¨ì§€ì§€ ì•Šì€ íƒ€ì¼
                        const tileEl = gameBoard.querySelector(`.tile[data-index="${index}"]`);
                        if (icon !== null && tileEl && !tileEl.classList.contains('hidden')) {
                            availableIndices.push(index);
                        }
                    });
                    
                    shuffleArray(availableIndices);
                    const tilesToFog = availableIndices.slice(0, 8); // 8ê°œ

                    // 2. 'â“'ë¡œ ë®ì–´ì“°ê¸°
                    const originalContents = new Map(); // ì›ë˜ ë‚´ìš© ì €ì¥ìš©
                    
                    tilesToFog.forEach(index => {
                        const tileEl = gameBoard.querySelector(`.tile[data-index="${index}"]`);
                        if (tileEl) {
                            originalContents.set(index, tileEl.innerHTML); // ì›ë˜ HTML(ì´ë¯¸ì§€ ë˜ëŠ” í…ìŠ¤íŠ¸) ì €ì¥
                            tileEl.innerHTML = 'â“';
                            tileEl.style.fontSize = `${currentTileSize * 0.55}px`; // í°íŠ¸ í¬ê¸° ê°•ì œ
                        }
                    });

                    // 3. 3ì´ˆ ë’¤ ë³µì›
                    setTimeout(() => {
                        originalContents.forEach((originalHTML, index) => {
                            const tileEl = gameBoard.querySelector(`.tile[data-index="${index}"]`);
                            // ê·¸ ì‚¬ì´ì— íƒ€ì¼ì´ ë§¤ì¹­(hidden)ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ ë³µì›
                            if (tileEl && !tileEl.classList.contains('hidden')) {
                                tileEl.innerHTML = originalHTML;
                                // ë§Œì•½ í…ìŠ¤íŠ¸ì˜€ë‹¤ë©´ í°íŠ¸ í¬ê¸° ë³µì› (ì´ë¯¸ì§€ë©´ ìë™)
                                if (!originalHTML.includes('<img')) {
                                    tileEl.style.fontSize = `${currentTileSize * 0.55}px`;
                                }
                            }
                        });
                    }, 3000); // 5ì´ˆ

                } else if (attack.type === "SHAKE_BOARD") {
                    console.log("[ìˆ˜ì‹ ] ì§€ì§„ ê³µê²© ë°›ìŒ!");
                    gameBoard.classList.add('board-shake');
                    
                    // 2ì´ˆ í›„ (CSS ì…”í”Œ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„) ì œê±°
                    setTimeout(() => {
                        gameBoard.classList.remove('board-shake');
                    }, 2000);
                }
            }

            // ------------------------------------
            // [ì‹ ê·œ] 7.5. ì•„ì´í…œ ì‹œìŠ¤í…œ ë¡œì§
            // ------------------------------------

            function triggerRandomItem() {
                if (Math.random() < 0.15) { // 15% í™•ë¥ 
                    const items = ["SHAKE_BOARD", "INK_SPLATTER", "FOG_BLIND", "SHOW_HINT", "FIREWALL"];
                    const selectedItem = items[Math.floor(Math.random() * items.length)];
                    console.log(`[ì•„ì´í…œ] íšë“! : ${selectedItem}`);
                    useItem(selectedItem);
                }
            }

            /**
             * [ì‹ ê·œ] 7ì½¤ë³´ ë‹¬ì„± ì‹œ 100% í™•ë¥ ë¡œ ì•„ì´í…œì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.
             */
            function triggerGuaranteedRandomItem() {
                const items = ["SHAKE_BOARD", "INK_SPLATTER", "FOG_BLIND", "SHOW_HINT", "FIREWALL"];
                const selectedItem = items[Math.floor(Math.random() * items.length)];
                console.log(`[ì•„ì´í…œ] 7ì½¤ë³´ íšë“! : ${selectedItem}`);
                useItem(selectedItem);
            }

            /**
             * [ì‹ ê·œ] íšë“í•œ ì•„ì´í…œì„ ì¦‰ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤.
             */
            function useItem(itemType) {
                showItemGetText(itemType); // ì•„ì´í…œ íšë“ ì•Œë¦¼

                switch (itemType) {
                    case "SHAKE_BOARD":
                        sendAttack("SHAKE_BOARD");
                        break;
                    case "INK_SPLATTER":
                        sendAttack("INK_SPLATTER");
                        break;
                    case "FOG_BLIND": // [ì‹ ê·œ] ì•ˆê°œ ê³µê²©
                        sendAttack("FOG_BLIND");
                        break;
                    case "SHOW_HINT": // [ì‹ ê·œ] íŒíŠ¸ ë³´ê¸°
                        activateHintItem();
                        break;
                    case "FIREWALL": // [ì‹ ê·œ] ë°©í™”ë²½
                        activateFirewallItem();
                        break;
                }
            }

            /**
             * [ì‹ ê·œ] ì•„ì´í…œ íšë“/ì‚¬ìš© ì•Œë¦¼ì„ í™”ë©´ ì¤‘ì•™ì— í‘œì‹œ
             */
            function showItemGetText(itemType) {
                if (!comboTextOverlay) return;

                let text = "";
                let color = "var(--secondary-color)"; // ê¸°ë³¸ê°’ (ì§€ì›/ë°©ì–´)

                switch (itemType) {
                    case "SHAKE_BOARD":
                        text = "ì§€ì§„ ê³µê²©!"; color = "var(--danger-color)"; break;
                    case "INK_SPLATTER":
                        text = "ë¨¹ë¬¼ ê³µê²©!"; color = "var(--danger-color)"; break;
                    case "FOG_BLIND":
                        text = "ì•ˆê°œ ê³µê²©!"; color = "var(--danger-color)"; break;
                    case "SHOW_HINT":
                        text = "íŒíŠ¸ íšë“!"; break;
                    case "FIREWALL":
                        text = "ë°©í™”ë²½ íšë“!"; break;
                    case "FIREWALL_BLOCK": // ë°©ì–´ ì„±ê³µ ì‹œ
                        text = "âœ¨ê³µê²© ë°©ì–´!âœ¨"; color = "var(--accent-color)"; break;
                }

                const popup = document.createElement('div');
                popup.className = 'combo-text-popup';
                popup.textContent = text;
                popup.style.fontSize = '2.0em'; // ì½¤ë³´ë³´ë‹¤ í¬ê²Œ
                popup.style.color = color;
                // í™”ë©´ ì¤‘ì•™ ë°°ì¹˜
                popup.style.left = '50%';
                popup.style.top = '40%';
                popup.style.transform = 'translateX(-50%)';

                comboTextOverlay.appendChild(popup);
                setTimeout(() => popup.remove(), 2000);
            }

            /**
             * [ì‹ ê·œ] íŒíŠ¸ ì•„ì´í…œ í™œì„±í™” (ë¡œì»¬)
             */
            function activateHintItem() {
                // 3ìŒì˜ íŒíŠ¸ ì°¾ê¸°
                const pairs = findAvailableMoves(myBoard, 3);
                if (!pairs || pairs.length === 0) return;

                const elementsToHighlight = [];

                pairs.forEach(pair => {
                    const el1 = gameBoard.querySelector(`.tile[data-index="${pair[0]}"]`);
                    const el2 = gameBoard.querySelector(`.tile[data-index="${pair[1]}"]`);

                    if (el1 && !el1.classList.contains('hidden')) {
                        el1.classList.add('selected');
                        elementsToHighlight.push(el1);
                    }
                    if (el2 && !el2.classList.contains('hidden')) {
                        el2.classList.add('selected');
                        elementsToHighlight.push(el2);
                    }
                });

                // 3ì´ˆ ë’¤ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                setTimeout(() => {
                    elementsToHighlight.forEach(el => {
                        // ìœ ì €ê°€ ê·¸ ì‚¬ì´ì— ë§¤ì¹­í–ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ, ì„ íƒëœ íƒ€ì¼ì´ ì•„ë‹ ë•Œë§Œ ì œê±°
                        if (selectedTileElement !== el) {
                            el.classList.remove('selected');
                        }
                    });
                }, 3000); // 3ì´ˆ
            }

            /**
             * [ì‹ ê·œ] ë°©í™”ë²½ ì•„ì´í…œ í™œì„±í™” (ë¡œì»¬)
             */
            function activateFirewallItem() {
                isFirewallActive = true;
                // (í•„ìš”ì‹œ) ì—¬ê¸°ì— ë°©í™”ë²½ UI(ì˜ˆ: í”Œë ˆì´ì–´ ì•„ë°”íƒ€ì— ë°©íŒ¨ í‘œì‹œ) ì¶”ê°€
            }

            // ------------------------------------
            // 8. ê²Œì„ ë¡œì§ (ê²½ë¡œ/ì…”í”Œ - ë¡œì»¬)
            // ------------------------------------
            
            function findPath_BFS(board, startIndex, endIndex) {
                // ... (ì‚¬ì²œì„±í˜¼ìí•˜ê¸°.htmlì™€ ë™ì¼í•œ ë¡œì§) ...
                const V_ROWS = BOARD_ROWS + 2;
                const V_COLS = BOARD_COLS + 2;
                const virtualBoard = Array(V_ROWS * V_COLS).fill(null);
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        const boardIndex = r * BOARD_COLS + c;
                        const virtualIndex = (r + 1) * V_COLS + (c + 1);
                        if (board[boardIndex] !== null) virtualBoard[virtualIndex] = 1; 
                    }
                }
                const startR = Math.floor(startIndex / BOARD_COLS) + 1;
                const startC = startIndex % BOARD_COLS + 1;
                const vStartIndex = startR * V_COLS + startC;
                const endR = Math.floor(endIndex / BOARD_COLS) + 1;
                const endC = endIndex % BOARD_COLS + 1;
                const vEndIndex = endR * V_COLS + endC;
                const queue = [{ i: vStartIndex, t: 0, d: 0, p: null }];
                const visited = Array(V_ROWS * V_COLS).fill(null);
                visited[vStartIndex] = { t: 0, p: -1 }; 
                const directions = [
                    { dr: -1, dc: 0, d: 1 }, { dr: 1, dc: 0, d: 2 },
                    { dr: 0, dc: -1, d: 3 }, { dr: 0, dc: 1, d: 4 }
                ];
                let endNode = null;
                while (queue.length > 0) {
                    const { i, t, d, p } = queue.shift();
                    if (i === vEndIndex) { endNode = { i, t, d, p }; break; }
                    for (const move of directions) {
                        const nextR = Math.floor(i / V_COLS) + move.dr;
                        const nextC = i % V_COLS + move.dc;
                        const nextIndex = nextR * V_COLS + nextC;
                        if (nextR < 0 || nextR >= V_ROWS || nextC < 0 || nextC >= V_COLS) continue;
                        if (virtualBoard[nextIndex] !== null && nextIndex !== vEndIndex) continue;
                        const nextTurns = (d !== 0 && d !== move.d) ? t + 1 : t;
                        if (nextTurns > 2) continue;
                        if (!visited[nextIndex] || visited[nextIndex].t >= nextTurns) {
                            visited[nextIndex] = { t: nextTurns, p: i };
                            queue.push({ i: nextIndex, t: nextTurns, d: move.d, p: i });
                        }
                    }
                }
                if (endNode) {
                    const path = [];
                    let currentIdx = endNode.i;
                    while (currentIdx !== -1 && visited[currentIdx]) {
                        path.push(currentIdx);
                        currentIdx = visited[currentIdx].p;
                    }
                    return path.reverse();
                }
               return null;
            }

            function checkForAvailableMoves(boardArray) {
                // ... (ì‚¬ì²œì„±í˜¼ìí•˜ê¸°.htmlì™€ ë™ì¼í•œ ë¡œì§) ...
                const availableTiles = {};
                boardArray.forEach((icon, index) => {
                    if (icon !== null) {
                        if (!availableTiles[icon]) availableTiles[icon] = [];
                        availableTiles[icon].push(index);
                    }
                });
                for (const icon in availableTiles) {
                    const indices = availableTiles[icon];
                    if (indices.length < 2) continue;
                    for (let i = 0; i < indices.length - 1; i++) {
                        for (let j = i + 1; j < indices.length; j++) {
                            if (findPath_BFS(boardArray, indices[i], indices[j])) {
                                return true; 
                            }
                        }
                    }
                }
                return false; 
            }

            /**
             * [ì‹ ê·œ] íŒíŠ¸ìš©: ë§¤ì¹­ ê°€ëŠ¥í•œ ìŒì„ ì°¾ì•„ ë°˜í™˜ (ìµœëŒ€ countê°œ)
             */
            function findAvailableMoves(boardArray, count) {
                const availableTiles = {};
                boardArray.forEach((icon, index) => {
                    if (icon !== null) {
                        if (!availableTiles[icon]) availableTiles[icon] = [];
                        availableTiles[icon].push(index);
                    }
                });

                const foundPairs = [];
                const icons = shuffleArray(Object.keys(availableTiles)); // ì•„ì´ì½˜ ìˆœì„œ ì„ê¸°

                for (const icon of icons) {
                    const indices = availableTiles[icon];
                    if (indices.length < 2) continue;
                    
                    // í•´ë‹¹ ì•„ì´ì½˜ì˜ ëª¨ë“  ì¡°í•© ê²€ì‚¬
                    for (let i = 0; i < indices.length - 1; i++) {
                        for (let j = i + 1; j < indices.length; j++) {
                            if (findPath_BFS(boardArray, indices[i], indices[j])) {
                                foundPairs.push([indices[i], indices[j]]);
                                // ì›í•˜ëŠ” ê°œìˆ˜ë§Œí¼ ì°¾ì•˜ìœ¼ë©´ ì¦‰ì‹œ ì¢…ë£Œ
                                if (foundPairs.length >= count) {
                                    return foundPairs;
                                }
                                // ì´ ìŒ(i, j)ì„ ì°¾ì•˜ìœ¼ë‹ˆ ë‹¤ìŒ ì•„ì´ì½˜ìœ¼ë¡œ ë„˜ì–´ê°€ê¸° (ë‹¤ì–‘ì„±)
                                // (ì£¼ì„ ì²˜ë¦¬: í•œ ì•„ì´ì½˜ì—ì„œ ì—¬ëŸ¬ ìŒì„ ì°¾ë„ë¡ í—ˆìš©)
                                // break; 
                            }
                        }
                        // if (foundPairs.length >= count) break; // (i ë£¨í”„)
                    }
                    // if (foundPairs.length >= count) break; // (icon ë£¨í”„)
                }
                return foundPairs; // ì°¾ì€ ë§Œí¼ ë°˜í™˜
            }

            function shuffleRemainingTiles(boardArray) {
                const remainingTiles = [];
                boardArray.forEach((icon) => {
                    if (icon !== null) remainingTiles.push(icon);
                });
                if (remainingTiles.length < 2) {
                     return new Array(TILE_COUNT).fill(null);
                }
                const allIndices = Array.from({ length: TILE_COUNT }, (_, i) => i);
                let attempts = 0;
                while (attempts < 50) {
                    const newBoard = new Array(TILE_COUNT).fill(null);
                    const shuffledTiles = shuffleArray([...remainingTiles]);
                    const shuffledIndices = shuffleArray([...allIndices]);
                    for (let i = 0; i < shuffledTiles.length; i++) {
                        newBoard[shuffledIndices[i]] = shuffledTiles[i];
                    }
                    if (checkForAvailableMoves(newBoard)) {
                        console.log(`[Shuffle] ìƒˆ ë³´ë“œ ìƒì„± ì„±ê³µ! (ì‹œë„: ${attempts + 1})`);
                        return newBoard;
                    }
                    attempts++;
                }
                console.error("[Shuffle] 50íšŒ ì‹œë„í–ˆìœ¼ë‚˜ í’€ ìˆ˜ ìˆëŠ” ë³´ë“œ ìƒì„± ì‹¤íŒ¨.");
                const finalBoard = new Array(TILE_COUNT).fill(null);
                const shuffledTiles = shuffleArray([...remainingTiles]);
                const shuffledIndices = shuffleArray([...allIndices]);
                for (let i = 0; i < shuffledTiles.length; i++) {
                    finalBoard[shuffledIndices[i]] = shuffledTiles[i];
                }
                return finalBoard;
            }

            // [ì‹ ê·œ] ë¡œì»¬ ì…”í”Œ ê²€ì‚¬ ë° ì‹¤í–‰
            function checkAndShuffleIfNeeded_Local(retryCount = 0) {
                if (isShuffling || !isGameLive) return; 

                if (checkForAvailableMoves(myBoard)) {
                    return; // ë§‰íˆì§€ ì•ŠìŒ
                }

                // --- ë§‰í˜”ì„ ê²½ìš° ---
                isShuffling = true;
                console.log(`[ë¡œì»¬ ì…”í”Œ] ë§‰í˜ ê°ì§€! (ì‹œë„: ${retryCount})`);

                // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ê²Œì„ ì˜¤ë²„
                if (retryCount >= 2) { 
                    console.error("[ë¡œì»¬ ì…”í”Œ] 2íšŒ ì…”í”Œ í›„ì—ë„ ë§‰í˜. ê²Œì„ ì˜¤ë²„.");
                    isGameLive = false;
                    gameOverFlag = true;
                    
                    // [ìˆ˜ì •] ë‚´ê°€ íŒ¨ë°° + "ê²Œì„ ì¢…ë£Œ" ìƒíƒœë¥¼ Firebaseì— ì „ì†¡
                    roomRef.update({
                        'status': 'gameOver',
                        [`playerStates/${myPlayerId}/isDead`]: true
                    });
                    
                    playSound('loss-sound-new');
                    showGameOverScreen(false); // 'false' = ë‚´ê°€ íŒ¨ë°°
                    return;
                }

                // ì¬ë°°ì—´ UI í‘œì‹œ (1ì´ˆ)
                infoOverlay.innerHTML = `<p style="color: white; font-size: 1.5em; font-weight: 700;">ğŸ² íƒ€ì¼ì„ ë‹¤ì‹œ ì„ê³  ìˆì–´ìš”!</p>`;
                infoOverlay.style.display = 'flex';
                gameBoard.classList.add('board-shake');
                playSound('shuffle');
                playVibrationEffect();

                // 1ì´ˆ ë’¤ì— ì‹¤ì œ ì…”í”Œ ì‹¤í–‰
                setTimeout(() => {
                    const newShuffledBoard = shuffleRemainingTiles(myBoard);
                    
                    myBoard = newShuffledBoard; // ë¡œì»¬ ë³´ë“œ êµì²´
                    renderBoard(myBoard); // ìƒˆ ë³´ë“œë¡œ ë Œë”ë§

                    // UI ìˆ¨ê¸°ê¸°
                    gameBoard.classList.remove('board-shake');
                    infoOverlay.style.display = 'none';
                    isShuffling = false; // í”Œë˜ê·¸ í•´ì œ

                    // ì…”í”Œëœ ìƒˆ ë³´ë“œê°€ *ë˜* ë§‰í˜”ëŠ”ì§€ 0.5ì´ˆ ë’¤ ì¬ê·€ì ìœ¼ë¡œ ê²€ì‚¬
                    setTimeout(() => checkAndShuffleIfNeeded_Local(retryCount + 1), 500);

                }, 1000); // 1ì´ˆ í˜ë„í‹°
            }
            
            // ------------------------------------
            // 9. UI ë Œë”ë§
            // ------------------------------------
            
            function startCountdown() {
                infoOverlay.classList.add('active');
                infoOverlay.innerHTML = `<div id="countdown-number" style="font-size: 4.5em; animation: countdown-pop 1s;">Ready?</div>`;
                let count = 3; 
                setTimeout(() => { 
                    const el = document.getElementById('countdown-number');
                    if (el) {
                        el.style.fontSize = '7em'; 
                        el.style.animation = 'countdown-pop 1s';
                        el.textContent = count;
                    }
                    const interval = setInterval(() => {
                        count--;
                        const el = document.getElementById('countdown-number');
                        if (el) {
                            el.style.animation = 'none'; el.offsetHeight; 
                            el.style.animation = 'countdown-pop 1s';
                            el.textContent = count > 0 ? count : 'GO!';
                        }
                        if (count <= -1) { 
                            clearInterval(interval);
                            infoOverlay.classList.remove('active');
                            isGameLive = true;
                            renderBoard(myBoard); // ë‚´ ë³´ë“œ ë Œë”ë§
                                    // ë§µ ê²€ì‚¬ ì‹œì‘
                            setTimeout(() => checkAndShuffleIfNeeded_Local(0), 500);
                        }
                    }, 1000);
                }, 1000); 
            }

            // [ì‹ ê·œ] í—¤ë” UI (ê²Œì´ì§€/ì½¤ë³´ ê°±ì‹ )
            function updateHeaderUI() {
                if (!currentRoomData || !currentRoomData.players) return;
                
                const players = currentRoomData.players;
                // [ì‹ ê·œ] 'playerStates'ì—ì„œ ìµœì‹  ê²Œì´ì§€/ì½¤ë³´ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const playerStates = currentRoomData.playerStates || {};
                
                gameHeader.innerHTML = ''; 
                const playerIds = Object.keys(players).sort((a, b) => (a === currentRoomData.hostId) ? -1 : (b === currentRoomData.hostId) ? 1 : a.localeCompare(b));

                 playerIds.forEach(playerId => {
                    const player = players[playerId];
                    if (!player) return; 
// [ì‹ ê·œ] 'ë‚˜'ëŠ” í—¤ë”ì— ê·¸ë¦¬ì§€ ì•Šê³  ê±´ë„ˆë›°ê¸°
                    if (playerId === myPlayerId) return;
                    // [ì‹ ê·œ]
                    const state = playerStates[playerId] || { gauge: 0, combo: 0 };
                    const gauge = state.gauge;
                    const combo = state.combo;

                    const avatarSet = AVATAR_SETS[player.avatar];
                    let avatarHTML = '';
                    if (avatarSet) avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                    else if (player.avatar && (player.avatar.startsWith('http') || player.avatar.includes('.'))) avatarHTML = `<img src="${escapeHTML(player.avatar)}" alt="avatar">`;
                    else avatarHTML = escapeHTML(player.avatar || 'â“');

                    const infoEl = document.createElement('div');
                    infoEl.className = 'player-info';
                    infoEl.dataset.playerId = playerId; // [ì‹ ê·œ] ID ì£¼ì…
                    // [ì‹ ê·œ] ê²Œì´ì§€ë°” HTML ì¶”ê°€
                    infoEl.innerHTML = `
                        <div class="avatar">${avatarHTML}</div>
                        <div class="info-text">
                            <div class="nickname">${escapeHTML(player.nickname || 'Unknown')}</div>
                            <div class="gauge-bar">
                                <div class="gauge-fill" style="width: ${gauge}%;"></div>
                            </div>
                        </div>
                        <div class="combo-display ${combo >= 2 ? 'combo-active' : ''}">
                            ${combo >= 2 ? `${combo} C` : ''}
                        </div>
                    `;
                    gameHeader.appendChild(infoEl);
                });
            }
            
            // [ì‹ ê·œ] playerStates ë¦¬ìŠ¤ë„ˆ ì „ìš© í•¨ìˆ˜
            function updateHeaderGauges(snapshot) {
                if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;
                
                const playerStates = snapshot.val();
               
                // [ì‹ ê·œ] 2. 'ìƒëŒ€ë°©' ê²Œì´ì§€ ë° ì½¤ë³´ ì—…ë°ì´íŠ¸
                const playerInfoElements = gameHeader.querySelectorAll('.player-info');
                
                // player-infoê°€ ì•„ì§ ë Œë”ë§ë˜ì§€ ì•Šì•˜ë‹¤ë©´ (ìµœì´ˆ 1íšŒ)
                if (playerInfoElements.length === 0 && Object.keys(playerStates).length > 1) {
                    updateHeaderUI();
                }

                playerInfoElements.forEach(infoEl => {
                    // [ìˆ˜ì •] ì¸ë±ìŠ¤ ê¸°ë°˜ì´ ì•„ë‹Œ, ì£¼ì…ëœ IDë¡œ ì°¾ê¸°
                    const playerId = infoEl.dataset.playerId; 
                    
                    if (playerId && playerStates[playerId]) {
                        const state = playerStates[playerId];
                        const gauge = state.gauge || 0;
                        const combo = state.combo || 0;
                        
                        const gaugeFillEl = infoEl.querySelector('.gauge-fill');
                        if (gaugeFillEl) gaugeFillEl.style.width = `${gauge}%`;
                        
                        const comboEl = infoEl.querySelector('.combo-display');
                        if (comboEl) {
                            // [ìˆ˜ì •] 1ì½¤ë³´ë¶€í„° "Xì½¤ë³´"ë¡œ í‘œì‹œ, "C" ì œê±°
                            comboEl.textContent = combo >= 1 ? `${combo}ì½¤ë³´` : ''; 
                            comboEl.classList.toggle('combo-active', combo >= 1);
                        }
                    }
                });
            }

            // [ì‹ ê·œ] ë¡œì»¬ ë³´ë“œ ë Œë”ë§
            function renderBoard(boardData) {
                 if (!boardData) return;
                 const boardArray = getBoardArray(boardData, TILE_COUNT);

                 // (ë³´ë“œ í¬ê¸° ê³„ì‚°)
                 const containerW = gameContainer.clientWidth;
                 const containerH = gameContainer.clientHeight;
                 const maxBoardW = containerW;
                 const maxBoardH = containerH;
                 let boardSizeW, boardSizeH;
                 const cellAspectRatio = 1;
                 const boardAspectRatio = (BOARD_COLS * cellAspectRatio) / BOARD_ROWS;
                 if (maxBoardW / boardAspectRatio < maxBoardH) {
                     boardSizeW = maxBoardW;
                     boardSizeH = maxBoardW / boardAspectRatio;
                 } else {
                     boardSizeH = maxBoardH;
                     boardSizeW = maxBoardH * boardAspectRatio;
                 }
                 gameBoard.style.width = `${boardSizeW}px`;
                 gameBoard.style.height = `${boardSizeH}px`;
                 gameBoard.style.gridTemplateColumns = `repeat(${BOARD_COLS}, 1fr)`;
                 gameBoard.style.gridTemplateRows = `repeat(${BOARD_ROWS}, 1fr)`;
                 const boardPadding = parseFloat(window.getComputedStyle(gameBoard).paddingTop) || 4;
                 currentGapSize = parseFloat(window.getComputedStyle(gameBoard).gap) || 2;
                 currentTileSize = (boardSizeW - (boardPadding * 2) - (BOARD_COLS - 1) * currentGapSize) / BOARD_COLS;
                 currentExtraMargin = currentTileSize / 2 + currentGapSize; 
                 const canvasWidth = boardSizeW + currentExtraMargin * 2;
                 const canvasHeight = boardSizeH + currentExtraMargin * 2;
                 pathCanvas.style.left = `${gameBoard.offsetLeft - currentExtraMargin + boardPadding}px`;
                 pathCanvas.style.top = `${gameBoard.offsetTop - currentExtraMargin + boardPadding}px`;
                 pathCanvas.width = canvasWidth; 
                 pathCanvas.height = canvasHeight;

                 // (íƒ€ì¼ DOM ìƒì„±/ì—…ë°ì´íŠ¸)
                 const existingTiles = new Map();
                 gameBoard.querySelectorAll('.tile').forEach(tile => {
                     existingTiles.set(parseInt(tile.dataset.index, 10), tile);
                 });
                 const fragment = document.createDocumentFragment();
                boardArray.forEach((tileIcon, index) => {
                    let tileEl = existingTiles.get(index);
                    const isEmpty = tileIcon === null;
                    if (!tileEl) {
                        tileEl = document.createElement('div');
                        tileEl.className = 'tile';
                        tileEl.dataset.index = index;
                        fragment.appendChild(tileEl);
                    }
                    tileEl.classList.toggle('hidden', isEmpty);
                    if (!isEmpty) {
                         const isImage = tileIcon.startsWith('.') || tileIcon.startsWith('http') || tileIcon.includes('/');
                         const currentContent = tileEl.firstChild;
                         if (isImage) {
                             if (!currentContent || currentContent.tagName !== 'IMG' || !currentContent.src.endsWith(tileIcon)) {
                                 tileEl.innerHTML = `<img src="${escapeHTML(tileIcon)}" alt="tile">`;
                             }
                         } else {
                             if (!currentContent || currentContent.nodeType !== Node.TEXT_NODE || currentContent.textContent !== tileIcon) {
                                 tileEl.textContent = tileIcon;
                             }
                             tileEl.style.fontSize = `${currentTileSize * 0.55}px`;
                         }
                         if (isGameLive) {
                             tileEl.onclick = handleTileClick;
                         } else {
                             tileEl.onclick = null;
                         }
                         // [ì‹ ê·œ] ë¡œì»¬ ì„ íƒ í•´ì œ
                         tileEl.classList.remove('selected');
                    } else {
                        tileEl.innerHTML = '';
                        tileEl.onclick = null;
                    }
                    existingTiles.delete(index);
                });
                 existingTiles.forEach(tile => tile.remove());
                 gameBoard.appendChild(fragment);
            }
            
            // ê²½ë¡œ ê·¸ë¦¬ê¸° (ê¸°ì¡´)
            function drawAnimatedPath(path, color) {
                if (!ctx || !path || path.length < 2) return;
                const pixelPath = _getPathPixelCoords(path);
                if (pixelPath.length < 2) return;
                const DURATION = 200; 
                const startTime = performance.now();
                const totalSegments = pixelPath.length - 1;
                const segmentProgress = 1.0 / totalSegments;
                // [ìˆ˜ì •] ì„  êµµê¸° ë¡¤ë°± ë° ê·¸ë¦¼ì ì œê±°
                ctx.strokeStyle = color; 
                ctx.lineWidth = 4; // 6 -> 4
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.shadowColor = "transparent"; // ê·¸ë¦¼ì ì œê±°
                ctx.shadowBlur = 0; // ê·¸ë¦¼ì ì œê±°
                // [ìˆ˜ì • ë]
                let animationId = null;
                function animate(timestamp) {
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / DURATION, 1.0); 
                    ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                    ctx.beginPath(); ctx.moveTo(pixelPath[0].x, pixelPath[0].y);
                    let currentProgress = 0.0;
                    for (let i = 1; i < pixelPath.length; i++) {
                        const segmentT = Math.min(Math.max(progress - currentProgress, 0) / segmentProgress, 1.0);
                        if (segmentT > 0) {
                            const prev = pixelPath[i - 1]; const curr = pixelPath[i];
                            const interpX = prev.x + (curr.x - prev.x) * segmentT;
                            const interpY = prev.y + (curr.y - prev.y) * segmentT;
                            ctx.lineTo(interpX, interpY);
                        }
                        currentProgress += segmentProgress;
                        if (segmentT < 1.0) break; 
                    }
                    ctx.stroke(); 
                    if (progress < 1.0) {
                        animationId = requestAnimationFrame(animate);
                    } else {
                        animationId = null;
                        setTimeout(() => {
                            if (ctx) { ctx.shadowColor = "transparent"; ctx.shadowBlur = 0;
                                ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                            }
                        }, 100); 
                    }
                }
                animationId = requestAnimationFrame(animate);
            }

            function _getPathPixelCoords(path) {
                // ... (ì‚¬ì²œì„±í˜¼ìí•˜ê¸°.htmlì™€ ë™ì¼í•œ ë¡œì§) ...
                const pixelPath = [];
                for (let i = 0; i < path.length; i++) {
                    const virtualIndex = path[i];
                    const vR = Math.floor(virtualIndex / (BOARD_COLS + 2));
                    const vC = virtualIndex % (BOARD_COLS + 2);
                    const bR = vR - 1; const bC = vC - 1; 
                    const x = bC * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    const y = bR * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    pixelPath.push({ x, y });
                }
                return pixelPath;
            }

            // ------------------------------------
            // 10. ê²Œì„ ì¢…ë£Œ ë° ì¬ì‹œì‘
            // ------------------------------------
            function showGameOverScreen(iWon) { // [ìˆ˜ì •] ìŠ¹/íŒ¨ ì—¬ë¶€ë¥¼ ì§ì ‘ ë°›ìŒ
                 if (!currentRoomData) return;
                 const { players } = currentRoomData;
                 const playerStates = currentRoomData.playerStates || {};
                 const playerIds = Object.keys(players);

                 const resultText = (iWon ? "ğŸ‰ ìŠ¹ë¦¬!" : "ğŸ˜¢ íŒ¨ë°°...");
                 playSound(iWon ? 'win' : 'lose');
                 
                 // ì „ì  ì—…ë°ì´íŠ¸
                 updatePlayerStats(iWon ? 'win' : 'loss');
                 // âœ¨ [ì‹ ê·œ] ì˜êµ¬ ìƒí˜¸ ì „ì  (H2H) ë¡œì§ (ë©€í‹°ì‚¬ì²œì„±.htmlì—ì„œ ë³µì›)
                 // 1:1 ëŒ€ì „ì¼ ë•Œë§Œ ìƒí˜¸ ì „ì  ì²˜ë¦¬
                 if (playerIds.length === 2) {
                     const opponentId = playerIds.find(id => id !== myPlayerId);
                     
                     // ì˜êµ¬ í‚¤ ìƒì„± (ID ì •ë ¬)
                     const sortedIds = [myPlayerId, opponentId].sort();
                     const h2hKey = sortedIds.join('_');
                     const h2hRef = db.ref(`h2hStats/shisenSho/${h2hKey}`); // ìµœìƒìœ„ ì˜êµ¬ ê²½ë¡œ

                     // ë°©ì¥(Host)ë§Œ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì „ì ì„ "ì—…ë°ì´íŠ¸"
                     if (isHost) {
                         h2hRef.transaction(currentStats => {
                             if (currentStats === null) {
                                 currentStats = { [sortedIds[0]]: 0, [sortedIds[1]]: 0, draws: 0 };
                             }
                             
                             // ì´ë²ˆ íŒ ê²°ê³¼ ëˆ„ì  (ë¬´ìŠ¹ë¶€ê°€ ì—†ìœ¼ë¯€ë¡œ ìŠ¹/íŒ¨ë§Œ)
                             if (iWon) { // ë‚´ê°€ ì´ê²¼ìœ¼ë©´
                                 currentStats[myPlayerId] = (currentStats[myPlayerId] || 0) + 1;
                             } else { // ë‚´ê°€ ì¡Œìœ¼ë©´ (ìƒëŒ€ê°€ ì´ê²¼ìœ¼ë©´)
                                 currentStats[opponentId] = (currentStats[opponentId] || 0) + 1;
                             }
                             // (ì°¸ê³ : ì´ ê²Œì„ì€ ë¬´ìŠ¹ë¶€ê°€ ì—†ìŒ)
                             
                             return currentStats; // ìƒˆ ì „ì  ë°˜í™˜
                         }).then(result => {
                             if (result.committed) {
                                 // ë°©ì¥ì´ íŠ¸ëœì­ì…˜ ì„±ê³µ ì‹œ, ì„ì‹œ ê²½ë¡œì— ê²°ê³¼ ì „íŒŒ
                                 if (roomRef) roomRef.child('displayH2HStats').set(result.snapshot.val());
                             }
                         }).catch(error => {
                             console.error("ì˜êµ¬ H2H ì „ì  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
                             // íŠ¸ëœì­ì…˜ ì‹¤íŒ¨ ì‹œ, ìµœì†Œí•œ 'í˜„ì¬' DBê°’ì´ë¼ë„ ì½ì–´ì„œ ê²ŒìŠ¤íŠ¸ì—ê²Œ ì „íŒŒ
                             h2hRef.once('value', currentSnapshot => {
                                 if(currentSnapshot.exists() && roomRef) {
                                     roomRef.child('displayH2HStats').set(currentSnapshot.val());
                                 }
                             });
                         });
                     }
                 }
                 // âœ¨ [ì‹ ê·œ] H2H ë¡œì§ ì¢…ë£Œ

                 // ì ìˆ˜íŒ HTML (playerStates ê¸°ë°˜)
                 const scoresHTML = playerIds.map(id => {
                     const player = players[id];
                     const state = playerStates[id] || { gauge: 0 };
                     const score = Math.round(state.gauge); // ê²Œì´ì§€ = ì ìˆ˜ (0-100)
                     const isWinner = (id === myPlayerId && iWon) || (id !== myPlayerId && !iWon);
                     const scoreClass = isWinner ? 'winner' : 'loser';
                     
                     const avatarSet = AVATAR_SETS[player.avatar];
                     let avatarHTML = '';
                     if (avatarSet) avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                     else if (player.avatar && (player.avatar.startsWith('http') || player.avatar.includes('.'))) avatarHTML = `<img src="${escapeHTML(player.avatar)}" alt="avatar">`;
                     else avatarHTML = escapeHTML(player.avatar || 'â“');

                     return `<div class="score-row ${scoreClass}">
                                 <span class="score-avatar"><div class="avatar">${avatarHTML}</div> ${escapeHTML(player.nickname || 'Unknown')}</span>
                                 <span>${score} ì </span>
                             </div>`;
                 }).join('');

                 // ... (ìƒí˜¸ ì „ì  ë¡œì§ì€ ë™ì¼) ...

                 // ëª¨ë‹¬ ì±„ìš°ê¸°
                 gameOverOverlay.innerHTML = `
                     <div class="modal-content">
                         <div class="modal-header"><h2>${resultText}</h2></div>
                         <div class="modal-body">
                             <div id="h2h-stats-placeholder"></div>
                             <div id="score-board">${scoresHTML}</div>
                              <div class="modal-buttons">
                                 <button id="rematch-btn" class="menu-btn secondary">ë‹¤ì‹œ í•˜ê¸°</button>
                                 <button id="lobby-btn" class="menu-btn primary">ëŒ€ê¸°ì‹¤ë¡œ</button>
                             </div>
                         </div>
                     </div>`;
                 gameOverOverlay.classList.add('active');
                 
                 // ... (ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ ë° ì¬ì‹œì‘ ë¦¬ìŠ¤ë„ˆëŠ” ë™ì¼) ...
                 document.getElementById('lobby-btn').addEventListener('click', cleanupAndExit);
                 // âœ¨ [ì‹ ê·œ] H2H ë¦¬ìŠ¤ë„ˆ í˜¸ì¶œ
                 if (playerIds.length === 2) {
                    listenForH2HDisplay(); 
                 }
                 const rematchBtn = document.getElementById('rematch-btn');
                 rematchBtn.addEventListener('click', () => {
                     rematchBtn.textContent = 'ìƒëŒ€ë°© ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
                     rematchBtn.disabled = true;
                     roomRef.child('rematchRequests/' + myPlayerId).set(true);
                 });
                 listenForRematch();
            }
// âœ¨ [ì‹ ê·œ] ì˜êµ¬ H2H ì „ì ì„ ëª¨ë‹¬ì— í‘œì‹œí•˜ëŠ” ë¦¬ìŠ¤ë„ˆ
            function listenForH2HDisplay() {
                 // displayH2HStats ê²½ë¡œë¥¼ êµ¬ë…
                 if (!roomRef) return; // [ìˆ˜ì •] roomRef null ì²´í¬
                 roomRef.child('displayH2HStats').on('value', snapshot => {
                     // 1. ë°ì´í„°ê°€ ì—†ê±°ë‚˜, ê²Œì„ì˜¤ë²„ ëª¨ë‹¬ì´ ì•ˆ ì¼œì ¸ìˆìœ¼ë©´ ë¬´ì‹œ
                     if (!snapshot.exists() || gameOverOverlay.style.display === 'none' || !currentRoomData || !currentRoomData.players) return;

                     const stats = snapshot.val();
                     const playerIds = Object.keys(currentRoomData.players);
                     
                     // 2. 1:1 ê²Œì„ì´ ì•„ë‹ˆë©´ ë¬´ì‹œ
                     if (playerIds.length !== 2) return;

                     // 3. ìƒëŒ€ë°© ì •ë³´ ì°¾ê¸°
                     const opponentId = playerIds.find(id => id !== myPlayerId);
                     const opponent = currentRoomData.players[opponentId];
                     if (!opponent) return; // ìƒëŒ€ë°© ì •ë³´ ì—†ìœ¼ë©´ ì¤‘ë‹¨

                     // 4. ì „ì  ê³„ì‚°
                     const myWins = stats[myPlayerId] || 0;
                     const oppWins = stats[opponentId] || 0;
                     const totalGames = myWins + oppWins; // [ìˆ˜ì •] ë¬´ìŠ¹ë¶€ ì œì™¸í•œ ìŠ¹ë¥  ê³„ì‚°
                     const winRate = totalGames > 0 ? Math.round((myWins / totalGames) * 100) : 0;
                     
                     // 5. HTML ìƒì„±
                     const h2hHTML = `<p class="h2h-stats">${escapeHTML(opponent.nickname)}ë‹˜ê³¼ì˜ ì „ì  (${myWins}ìŠ¹ ${oppWins}íŒ¨, ìŠ¹ë¥  ${winRate}%)</p>`;
                     
                     // 6. ëª¨ë‹¬ ë‚´ë¶€ì˜ ìë¦¬í‘œì‹œìì— HTML ì‚½ì…
                     const placeholder = document.getElementById('h2h-stats-placeholder');
                     if (placeholder) {
                         placeholder.innerHTML = h2hHTML;
                     }
                 });
            }
            function listenForRematch() {
                 // ... (ê¸°ì¡´ê³¼ ë™ì¼) ...
                 if (!roomRef) return;
                 const rematchRef = roomRef.child('rematchRequests');
                 rematchRef.on('value', snapshot => {
                      if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;
                      const requests = snapshot.val();
                      const requestCount = Object.keys(requests).length;
                      const playerCount = Object.keys(currentRoomData.players).length;
                      if (requestCount === playerCount && isHost) {
                            rematchRef.off();
                            roomRef.update({
                                rematchRequests: null,
                                status: 'waiting',
                                gameStarted: false, // [ìˆ˜ì •]
                                playerStates: null, // [ìˆ˜ì •]
                                attackEvents: null, // [ìˆ˜ì •]
                                readyPlayers: null
                            });
                      }
                 });
            }

            function updatePlayerStats(result) {
                 // ... (ê¸°ì¡´ê³¼ ë™ì¼) ...
                 if (!myPlayerId || myPlayerId.startsWith('guest_')) return; 
                 const userStatsRef = usersRef.child(myPlayerId).child('gameStats/shisenSho');
                 userStatsRef.transaction(stats => {
                     if (stats === null) stats = { wins: 0, losses: 0, draws: 0, plays: 0 };
                     stats.plays = (stats.plays || 0) + 1;
                     if (result === 'win') stats.wins = (stats.wins || 0) + 1;
                     else if (result === 'loss') stats.losses = (stats.losses || 0) + 1;
                     else if (result === 'draw') stats.draws = (stats.draws || 0) + 1;
                     return stats;
                 }, (error, committed, snapshot) => {
                      if (committed) {
                           let expGained = 0, pointsGained = 0;
                           if (result === 'win') { expGained = 100; pointsGained = 150; }
                           else if (result === 'loss') { expGained = 20; pointsGained = 50; }
                           else { expGained = 40; pointsGained = 75; } 
                           usersRef.child(myPlayerId).child('profile/exp').transaction(exp => (exp || 0) + expGained);
                           usersRef.child(myPlayerId).child('profile/points').transaction(points => (points || 0) + pointsGained);
                      }
                 });
             }
             
            function cleanupAndExit() {
                isExiting = true;
                if (roomRef) {
                    roomRef.off(); 
                    if (myPlayerId) {
                        // [ì‹ ê·œ] playersì™€ playerStatesì—ì„œ ëª¨ë‘ ì œê±°
                        roomRef.child('players/' + myPlayerId).remove();
                        roomRef.child('playerStates/' + myPlayerId).remove().finally(() => { // [ìˆ˜ì •] M ì˜¤íƒ€ ì œê±°
                            window.location.replace('ëŒ€ê¸°ì‹¤.html');
                        });
                    } else {
                        window.location.replace('ëŒ€ê¸°ì‹¤.html');
                    }
                } else {
                    window.location.replace('ëŒ€ê¸°ì‹¤.html');
                }
            }
            
            window.addEventListener('resize', () => {
                if (isGameLive) {
                    renderBoard(myBoard); // ë¡œì»¬ ë³´ë“œ ê¸°ì¤€ ë Œë”ë§
                }
            });

            // [ì‹ ê·œ] í† ìŠ¤íŠ¸ ì•Œë¦¼ (ì´ˆëŒ€/ìª½ì§€/ì¹œêµ¬) ë¦¬ìŠ¤ë„ˆ ì„¤ì • í•¨ìˆ˜
            let globalListenersAttached = false; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
            function setupGlobalNotificationListeners(userId) {
                if (globalListenersAttached || !userId || !db) return;
                globalListenersAttached = true;
                
                console.log("[ì•Œë¦¼] ì „ì—­ ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (ID:", userId, ")");
                
                // 1. ë°© ì´ˆëŒ€ ì•Œë¦¼
                const invitesRef = db.ref(`invitations/${userId}`);
                invitesRef.on('child_added', snapshot => {
                    const invite = snapshot.val();
                    if (invite && invite.from_name) {
                        showToast(`ğŸ”” [ë°© ì´ˆëŒ€] ${escapeHTML(invite.from_name)}ë‹˜ì´ '${escapeHTML(invite.game_name)}' ë°©ì— ì´ˆëŒ€í–ˆìŠµë‹ˆë‹¤.`);
                        playSound('select'); // 'select' ì‚¬ìš´ë“œ ì¬í™œìš©
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });

                // 2. ì¹œêµ¬ ìš”ì²­ ì•Œë¦¼ (ëŒ€ê¸°ì‹¤ ê²½ë¡œ: friend_requests)
                const friendReqRef = db.ref(`friend_requests/${userId}`);
                friendReqRef.on('child_added', snapshot => {
                    const req = snapshot.val();
                    if (req && req.from_name) {
                         showToast(`ğŸ’Œ [ì¹œêµ¬ ìš”ì²­] ${escapeHTML(req.from_name)}ë‹˜ì´ ì¹œêµ¬ë¥¼ ì‹ ì²­í–ˆìŠµë‹ˆë‹¤.`);
                         playSound('select');
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });

                // 3. ìª½ì§€(ê·“ì†ë§) ì•Œë¦¼ (ëŒ€ê¸°ì‹¤ ê²½ë¡œ: user_inboxes)
                const whisperRef = db.ref(`user_inboxes/${userId}`);
                whisperRef.on('child_added', async (snapshot) => {
                    const msg = snapshot.val();
                    const senderUid = snapshot.key; 

                    if (msg && msg.lastMessage && senderUid) { 
                        try {
                            const profileSnap = await db.ref(`users/${senderUid}/profile`).once('value');
                            if (profileSnap.exists()) {
                                const nickname = profileSnap.val().nickname || '...';
                                showToast(`ğŸ’¬ [ìª½ì§€] ${escapeHTML(nickname)}: ${escapeHTML(msg.lastMessage)}`);
                                playSound('select');
                            }
                        } catch (e) {
                            console.error("ìª½ì§€ ì•Œë¦¼ ë‹‰ë„¤ì„ ë¡œë“œ ì‹¤íŒ¨:", e);
                        }
                    }
                    snapshot.ref.remove(); // ì•Œë¦¼ í™•ì¸ í›„ ì¦‰ì‹œ ì œê±°
                });
            }

        }); // DOMContentLoaded End
    </script>
</body>
</html>