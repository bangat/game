<!DOCTYPE html>

<html lang="ko">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

    <title>타워 디펜스</title>

    <style>

        :root {

            --bg-color: #1a1a1a; --ui-bg: #2c2c2c; --border-color: #0f0;

            --text-color: #fff; --highlight-color: #0f0; --danger-color: #f00;

            --font-main: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {

            width: 100%; height: 100%; overflow: hidden; background-color: #111;

            color: var(--text-color); font-family: var(--font-main);

            -webkit-user-select: none; user-select: none; touch-action: manipulation;

        }

        .screen {

            width: 100%; height: 100%; position: absolute; top: 0; left: 0;

            display: flex; flex-direction: column; justify-content: center; align-items: center;

            transition: opacity 0.3s ease; background-color: #111;

        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 { font-size: 3.5em; color: var(--highlight-color); text-shadow: 0 0 15px var(--highlight-color); margin-bottom: 40px; }

        .menu-btn {

            padding: 15px 30px; font-size: 1.2em; font-weight: bold; border-radius: 12px;

            border: 2px solid var(--highlight-color); cursor: pointer; margin: 10px;

            background-color: rgba(0, 0, 0, 0.5); color: var(--highlight-color);

            transition: all 0.2s; text-shadow: 0 0 5px var(--highlight-color);

            width: 80%; max-width: 300px;

        }

        

        #game-screen { flex-direction: column; justify-content: flex-start; align-items: stretch; background-color: #000; }

        #game-canvas { flex-grow: 1; width: 100%; background-color: var(--bg-color); image-rendering: pixelated; cursor: pointer; }

        

        #ui-panel {

            padding: 10px; width: 100%; background-color: var(--ui-bg);

            display: flex; flex-direction: row; border-top: 3px solid var(--highlight-color);

            flex-shrink: 0; align-items: center;

        }

        #stats-display {

            width: 140px; padding-right: 15px; border-right: 1px solid #444;

            display: flex; flex-direction: column; justify-content: center; gap: 8px;

        }

        #stats-display div { font-size: clamp(1rem, 4vw, 1.2rem); font-weight: bold; }

        #controls-panel { flex-grow: 1; padding-left: 15px; display: flex; flex-direction: column; }

        .panel-title { margin: 0 0 8px 0; padding-bottom: 5px; color: var(--highlight-color); font-weight: bold; font-size: clamp(0.9rem, 3vw, 1rem); }

        .buttons-container { display: flex; gap: 8px; justify-content: space-around; flex-grow: 1; }

        .control-button {

            flex: 1; padding: 8px; background-color: #3e3e3e; border: 2px solid #555; color: #fff;

            cursor: pointer; border-radius: 8px; text-align: center;

            display: flex; flex-direction: column; justify-content: center; align-items: center; transition: all 0.2s;

        }

        .control-button.selected { border-color: var(--highlight-color); background-color: #555; box-shadow: 0 0 10px var(--highlight-color); transform: scale(1.05); }

        .control-button .emoji { font-size: clamp(1.8rem, 8vw, 2.5rem); }

        .control-button strong { font-size: clamp(0.8rem, 3vw, 1rem); margin: 5px 0; }

        .control-button small { display: block; color: #aaa; font-size: clamp(0.7rem, 2.5vw, 0.9rem); }

        

        #message-overlay {

            position: fixed; top: 20px; left: 50%; transform: translateX(-50%); font-size: 2em;

            font-weight: bold; color: #ff0; text-shadow: 0 0 10px #000, 0 0 20px #ffc107; pointer-events: none; z-index: 100;

            opacity: 0; transition: opacity 0.5s, transform 0.5s;

        }

    </style>

</head>

<body>

    <div id="start-menu" class="screen">

        <h1>🚀 Emoji TD</h1>

        <button id="play-solo-btn" class="menu-btn">혼자 하기</button>

    </div>

    <div id="game-screen" class="screen hidden">

        <canvas id="game-canvas"></canvas>

        <div id="ui-panel">

            <div id="stats-display">

                <div id="round-stat">Round: 0</div>

                <div id="lives-stat">❤️ Lives: 20</div>

                <div id="gold-stat">💰 Gold: 250</div>

            </div>

            <div id="controls-panel">

                <div id="tower-shop">

                    <h3 class="panel-title">타워 상점 (ESC로 건설/융합 취소)</h3>

                    <div class="buttons-container">

                        <button class="control-button" data-type="basic" data-cost="50"><span class="emoji">🔫</span><strong>기본 타워</strong><small>Cost: 50</small></button>

                        <button class="control-button" data-type="splash" data-cost="120"><span class="emoji">💣</span><strong>광역 타워</strong><small>Cost: 120</small></button>

                        <button class="control-button" data-type="slow" data-cost="80"><span class="emoji">❄️</span><strong>슬로우 타워</strong><small>Cost: 80</small></button>

                        <button class="control-button" data-type="sniper" data-cost="150"><span class="emoji">🎯</span><strong>저격 타워</strong><small>Cost: 150</small></button>

                    </div>

                </div>

            </div>

        </div>

        <div id="message-overlay"></div>

    </div>

    <div id="game-over-screen" class="screen hidden"></div>

    

    <script>

    document.addEventListener('DOMContentLoaded', () => {

        const screens = { start: document.getElementById('start-menu'), game: document.getElementById('game-screen'), gameOver: document.getElementById('game-over-screen') };

        const canvas = document.getElementById('game-canvas');

        const ctx = canvas.getContext('2d');

        const messageOverlay = document.getElementById('message-overlay');

        

        let localGameState = {};

        let animationFrameId, lastTime = 0;

        let enemies = [], projectiles = [], towers = [], splashEffects = [];

        let roundInProgress = false, timeToNextWave = 0;

        let selectedTowerForPlacement = null, selectedTowerForUpgrade = null;

        let playerLayout = {};

        let activeMenuButtons = [];

        let isCombining = false;

        let firstCombineTower = null;

        function showScreen(screenName) {

            Object.values(screens).forEach(s => s.classList.add('hidden'));

            screens[screenName].classList.remove('hidden');

            if (screenName === 'game') setTimeout(resizeCanvas, 50);

        }

        

        document.getElementById('play-solo-btn').addEventListener('click', () => {

            localGameState = { gameState: 'playing', round: 0, lives: 20, gold: 250 };

            towers = []; enemies = []; projectiles = []; splashEffects = [];

            startGame();

        });

        function startGame() {

            showScreen('game');

            roundInProgress = false; timeToNextWave = 5000; lastTime = 0;

            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            animationFrameId = requestAnimationFrame(gameLoop);

        }

        function gameLoop(currentTime) {

            if (localGameState.gameState !== 'playing') { cancelAnimationFrame(animationFrameId); return; }

            if (!lastTime) lastTime = currentTime;

            const deltaTime = currentTime - lastTime;

            update(deltaTime);

            draw();

            lastTime = currentTime;

            animationFrameId = requestAnimationFrame(gameLoop);

        }

        function cancelAllSelections() {

            selectedTowerForUpgrade = null; activeMenuButtons = [];

            isCombining = false; firstCombineTower = null;

            if (selectedTowerForPlacement) {

                document.querySelectorAll('.control-button.selected').forEach(b => b.classList.remove('selected'));

                selectedTowerForPlacement = null;

            }

        }

        document.querySelectorAll('.control-button').forEach(button => {

            button.addEventListener('click', () => {

                cancelAllSelections();

                button.classList.add('selected');

                selectedTowerForPlacement = { type: button.dataset.type, cost: parseInt(button.dataset.cost) };

            });

        });

        

        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') cancelAllSelections(); });

        canvas.addEventListener('click', (e) => {

            const rect = canvas.getBoundingClientRect();

            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);

            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

            

            if (isCombining) { handleFusionClick(mouseX, mouseY); return; }

            if (handleMenuClick(mouseX, mouseY)) return;

            const clickedTower = towers.find(t => Math.hypot(t.x - mouseX, t.y - mouseY) < playerLayout.gridSize);

            if (clickedTower) {

                cancelAllSelections(); selectedTowerForUpgrade = clickedTower;

                return;

            }

            if (selectedTowerForPlacement) {

                const cost = selectedTowerForPlacement.cost;

                if (localGameState.gold < cost) { displayMessage("골드가 부족합니다!"); cancelAllSelections(); return; }

                if (isTooCloseToPath(mouseX, mouseY) || isOccupied(mouseX, mouseY)) return;

                

                let finalTowerType = selectedTowerForPlacement.type;

                const baseType = selectedTowerForPlacement.type;

                if (Math.random() < 0.05) {

                    if (baseType === 'basic') finalTowerType = 'lightning'; else if (baseType === 'splash') finalTowerType = 'volcano';

                    else if (baseType === 'sniper') finalTowerType = 'ion_cannon'; else if (baseType === 'slow') finalTowerType = 'ice_shard';

                    if (finalTowerType !== baseType) displayMessage("✨ 전설 타워 등장! ✨");

                }

                towers.push({ ...getTowerConfig(finalTowerType), id: 'T' + Date.now(), x: mouseX, y: mouseY, type: finalTowerType, cooldown: 0, damageLevel: 1, rangeLevel: 1, totalSpent: cost });

                localGameState.gold -= cost;

                updateGameUI(localGameState);

                return;

            }

            cancelAllSelections();

        });

        function handleMenuClick(mouseX, mouseY) {

            for (const button of activeMenuButtons) { if (Math.hypot(mouseX - button.x, mouseY - button.y) < button.radius) { button.action(); return true; } }

            return false;

        }

        

        function upgradeStat(tower, stat, cost) {

            if (localGameState.gold < cost) return;

            localGameState.gold -= cost; tower.totalSpent += cost;

            const baseConfig = getTowerConfig(tower.type);

            if (stat === 'damage') { tower.damageLevel++; tower.damage = Math.floor(baseConfig.damage * Math.pow(1.4, tower.damageLevel - 1)); }

            else { tower.rangeLevel++; tower.range = Math.floor(baseConfig.range * Math.pow(1.2, tower.rangeLevel - 1)); }

            updateGameUI(localGameState);

        }

        function combineTowers(type, combineToType) {

            const towersToCombine = towers.filter(t => t.type === type).slice(0, 3);

            const totalSpent = towersToCombine.reduce((sum, t) => sum + t.totalSpent, 0);

            towers = towers.filter(t => !towersToCombine.some(ttc => ttc.id === t.id));

            const newPos = { x: towersToCombine[0].x, y: towersToCombine[0].y };

            const newConfig = getTowerConfig(combineToType);

            towers.push({ ...newConfig, id: 'T' + Date.now(), x: newPos.x, y: newPos.y, type: combineToType, cooldown: 0, damageLevel: 1, rangeLevel: 1, totalSpent: totalSpent });

            displayMessage(`${newConfig.emoji} 조합 성공!`);

            cancelAllSelections();

        }

        function sellTower(tower, sellValue) {

            localGameState.gold += sellValue; towers = towers.filter(t => t.id !== tower.id);

            updateGameUI(localGameState); cancelAllSelections();

        }

        

        function startFusion(tower) {

            isCombining = true; firstCombineTower = tower;

            displayMessage("융합할 다른 조합 타워를 선택하세요");

            selectedTowerForUpgrade = null;

        }

        function handleFusionClick(mouseX, mouseY) {

            const clickedTower = towers.find(t => Math.hypot(t.x - mouseX, t.y - mouseY) < playerLayout.gridSize);

            const recipe = clickedTower ? getFusionRecipe(firstCombineTower.type, clickedTower.type) : null;

            if (clickedTower && clickedTower.id !== firstCombineTower.id && recipe) {

                const totalSpent = firstCombineTower.totalSpent + clickedTower.totalSpent;

                towers = towers.filter(t => t.id !== firstCombineTower.id && t.id !== clickedTower.id);

                const newConfig = getTowerConfig(recipe.result);

                towers.push({ ...newConfig, id: 'T' + Date.now(), x: clickedTower.x, y: clickedTower.y, type: recipe.result, cooldown: 0, totalSpent: totalSpent });

                displayMessage(`${newConfig.emoji} 융합 성공!`);

            } else { displayMessage("융합 실패. 다른 종류의 조합 타워를 선택하세요."); }

            cancelAllSelections();

        }

        

        function update(deltaTime) {

            if (!roundInProgress) timeToNextWave -= deltaTime;

            if (timeToNextWave <= 0 && !roundInProgress) {

                if (localGameState.round >= 50) { showGameClear(); return; }

                localGameState.round++; spawnWave(localGameState.round);

                roundInProgress = true; updateGameUI(localGameState);

            }

            if (roundInProgress && enemies.length === 0) {

                const clearedRound = localGameState.round; const bonusGold = 50 + clearedRound * 10;

                localGameState.gold += bonusGold; roundInProgress = false; timeToNextWave = 5000;

                displayMessage(`${clearedRound} 라운드 클리어! +${bonusGold}G`); updateGameUI(localGameState);

            }

            enemies.forEach((enemy, i) => { 

                if (enemy.slowTimer > 0) {

                    enemy.slowTimer -= deltaTime;

                    if (enemy.slowTimer <= 0) { enemy.speed = enemy.originalSpeed; enemy.originalSpeed = null; }

                }

                const path = playerLayout.path; 

                if (enemy.pathIndex >= path.length) { handleEnemyLeak(enemies.splice(i, 1)[0]); return; } 

                const targetNode = path[enemy.pathIndex]; const moveSpeed = enemy.speed * (deltaTime / 16.67); 

                const dist = Math.hypot(targetNode.x - enemy.x, targetNode.y - enemy.y); 

                if (dist < moveSpeed) { enemy.x = targetNode.x; enemy.y = targetNode.y; enemy.pathIndex++; } 

                else { enemy.x += (targetNode.x - enemy.x) / dist * moveSpeed; enemy.y += (targetNode.y - enemy.y) / dist * moveSpeed; } 

            });

            towers.forEach(tower => {

                tower.cooldown -= deltaTime;

                if (tower.cooldown <= 0) {

                    const target = findTarget(tower);

                    if (target) {

                        // ✨ 수정된 부분: 발사체 생성 시 필요한 속성만 명시적으로 전달

                        projectiles.push({ x: tower.x, y: tower.y, target: target, damage: tower.damage, splashRadius: tower.splashRadius, color: tower.color, slowEffect: tower.slowEffect });

                        tower.cooldown = tower.fireRate;

                    }

                }

            });

            for (let i = projectiles.length - 1; i >= 0; i--) {

                const p = projectiles[i];

                if (!p.target || p.target.health <= 0) { projectiles.splice(i, 1); continue; }

                const projectileSpeed = 15 * (deltaTime / 16.67);

                const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);

                if (dist < projectileSpeed) {

                    handleHit(p.target, p.damage, p.splashRadius, p.target.x, p.target.y, p.slowEffect);

                    projectiles.splice(i, 1);

                } else { p.x += (p.target.x - p.x) / dist * projectileSpeed; p.y += (p.target.y - p.y) / dist * projectileSpeed; }

            }

            for (let i = splashEffects.length - 1; i >= 0; i--) { if ((splashEffects[i].life -= deltaTime) <= 0) splashEffects.splice(i, 1); }

        }

        

        function handleHit(target, damage, splashRadius, hitX, hitY, slowEffect = null) {

            target.health -= damage;

            function applySlow(enemy) { if (slowEffect) { if (!enemy.originalSpeed) enemy.originalSpeed = enemy.speed; enemy.speed = enemy.originalSpeed * (1 - slowEffect.power); enemy.slowTimer = slowEffect.duration; } }

            applySlow(target);

            if (splashRadius > 0) {

                splashEffects.push({ x: hitX, y: hitY, radius: splashRadius, life: 200 });

                enemies.forEach(e => { if (e !== target && Math.hypot(e.x - hitX, e.y - hitY) <= splashRadius) { e.health -= damage; applySlow(e); }});

            }

            for (let i = enemies.length - 1; i >= 0; i--) {

                const enemy = enemies[i];

                if (enemy.health <= 0) {

                    if (enemy.type === 'mega_boss') {

                        const bonusGold = (50 + localGameState.round * 10) * 2;

                        localGameState.gold += bonusGold;

                        displayMessage(`👑 보스 처치! +${bonusGold}G`);

                    } else { localGameState.gold += getEnemyConfig(enemy.type).gold; }

                    enemies.splice(i, 1);

                    updateGameUI(localGameState);

                }

            }

        }

        

        function draw() {

            ctx.clearRect(0, 0, canvas.width, canvas.height); if (!playerLayout.path) return;

            ctx.strokeStyle = '#333'; ctx.lineWidth = playerLayout.gridSize * 1.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(playerLayout.path[0].x, playerLayout.path[0].y); for(let i = 1; i < playerLayout.path.length; i++) ctx.lineTo(playerLayout.path[i].x, playerLayout.path[i].y); ctx.stroke();

            

            towers.forEach(t => { ctx.font = `${playerLayout.gridSize * 1.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t.emoji, t.x, t.y); });

            enemies.forEach(e => {

                // ✨ 수정된 부분: 체력바 계산 방식을 안정적으로 변경

                const config = getEnemyConfig(e.type);

                const maxHealth = config.health + Math.pow(localGameState.round - 1, 2.1) * (e.type === 'mega_boss' ? 8 : (e.type === 'boss' ? 3 : 1.5));

                const healthRatio = e.health / maxHealth;

                ctx.font = `${playerLayout.gridSize * (config.emoji === '👑' ? 2.5 : 1.5)}px sans-serif`; if(e.slowTimer > 0) ctx.filter = 'saturate(0.2) brightness(0.8)'; ctx.fillText(config.emoji, e.x, e.y); ctx.filter = 'none'; const barWidth = playerLayout.gridSize * 1.5; const barY = e.y - playerLayout.gridSize * 1.2; ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillRect(e.x - barWidth/2, barY, barWidth, 6); ctx.fillStyle = healthRatio > 0.5 ? 'rgba(0,255,0,0.7)' : 'rgba(255,255,0,0.7)'; ctx.fillRect(e.x - barWidth/2, barY, barWidth * healthRatio, 6);

            });

            projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2); ctx.fill(); });

            splashEffects.forEach(effect => { ctx.fillStyle = 'rgba(255, 165, 0, 0.4)'; ctx.beginPath(); ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2); ctx.fill(); });

            

            if (selectedTowerForUpgrade) {

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 3; ctx.setLineDash([10, 5]);

                ctx.beginPath(); ctx.arc(selectedTowerForUpgrade.x, selectedTowerForUpgrade.y, selectedTowerForUpgrade.range, 0, Math.PI * 2); ctx.stroke();

                ctx.setLineDash([]);

                drawUpgradeMenu(selectedTowerForUpgrade);

            }

             if (isCombining) {

                ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)'; ctx.lineWidth = 5;

                ctx.beginPath(); ctx.arc(firstCombineTower.x, firstCombineTower.y, playerLayout.gridSize, 0, Math.PI * 2); ctx.stroke();

            }

        }

        

        function drawUpgradeMenu(tower) {

            activeMenuButtons = [];

            const baseConfig = getTowerConfig(tower.type);

            const menuRadius = playerLayout.gridSize * 3.5;

            const buttonRadius = playerLayout.gridSize * 1.5;

            const positions = [ { angle: -Math.PI / 2, id: 'damage' }, { angle: Math.PI, id: 'range' }, { angle: 0, id: 'combine' }, { angle: Math.PI / 2, id: 'sell' }, ];

            

            ctx.save();

            ctx.textAlign = 'center'; ctx.fillStyle = '#fff'; ctx.font = `bold ${playerLayout.gridSize * 0.8}px sans-serif`;

            ctx.shadowColor = '#000'; ctx.shadowBlur = 5;

            if (baseConfig.tier < 3) ctx.fillText(`Lvl ${tower.damageLevel}/${tower.rangeLevel}`, tower.x, tower.y - menuRadius - buttonRadius * 1.2);

            ctx.fillText(`공격력: ${tower.damage}`, tower.x, tower.y - menuRadius - buttonRadius * 0.5);

            ctx.restore();

            positions.forEach(pos => {

                const x = tower.x + menuRadius * Math.cos(pos.angle); const y = tower.y + menuRadius * Math.sin(pos.angle);

                let text = '', action = () => {}, costText = '', disabled = false, color = '#0f0';

                

                switch (pos.id) {

                    case 'damage':

                        if (baseConfig.tier >= 3) { disabled = true; text = '강화불가'; }

                        else { const dmgCost = Math.floor(baseConfig.damageCost * Math.pow(1.5, tower.damageLevel - 1)); action = () => upgradeStat(tower, 'damage', dmgCost); text = '공격 UP'; costText = `${dmgCost}G`; if (localGameState.gold < dmgCost) disabled = true; }

                        break;

                    case 'range':

                        if (baseConfig.tier >= 3) { disabled = true; text = '강화불가'; }

                        else { const rangeCost = Math.floor(baseConfig.rangeCost * Math.pow(1.6, tower.rangeLevel - 1)); action = () => upgradeStat(tower, 'range', rangeCost); text = '사거리 UP'; costText = `${rangeCost}G`; if (localGameState.gold < rangeCost) disabled = true; }

                        break;

                    case 'sell':

                        const sellValue = Math.floor(tower.totalSpent * 0.7); action = () => sellTower(tower, sellValue);

                        text = '판매'; costText = `+${sellValue}G`; color = '#f00';

                        break;

                    case 'combine':

                        if (baseConfig.tier === 1) { const same = towers.filter(t => t.type === tower.type); if (same.length < 3) disabled = true; action = () => combineTowers(tower.type, baseConfig.combineTo); text = '조합'; costText = `${same.length}/3`; color = '#ffc107'; }

                        else if (baseConfig.tier === 2) { const others = towers.filter(t => t.tier === 2 && t.id !== tower.id); if (others.length === 0) disabled = true; action = () => startFusion(tower); text = '융합'; costText = `대상선택`; color = '#00ffff'; }

                        else { disabled = true; text = '최종단계'; }

                        break;

                }

                if (baseConfig.tier > 1 && pos.id === 'combine' && baseConfig.tier < 3) { /* Tier 2 융합 버튼은 위 로직에서 처리 */ }

                else if (baseConfig.tier >= 3 && pos.id === 'combine') { disabled = true; text = '최종단계'; }

                ctx.save(); ctx.globalAlpha = disabled ? 0.4 : 1.0; ctx.beginPath(); ctx.arc(x, y, buttonRadius, 0, Math.PI * 2); ctx.fillStyle = '#2c2c2c'; ctx.fill();

                ctx.lineWidth = 3; ctx.strokeStyle = disabled ? '#555' : color; ctx.stroke(); ctx.fillStyle = disabled ? '#888' : '#fff'; ctx.font = `bold ${buttonRadius * 0.5}px sans-serif`;

                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, x, y - buttonRadius * 0.3); ctx.font = `bold ${buttonRadius * 0.4}px sans-serif`;

                ctx.fillStyle = disabled ? '#888' : color; ctx.fillText(costText, x, y + buttonRadius * 0.4); ctx.restore();

                

                if (!disabled) activeMenuButtons.push({ id: pos.id, x, y, radius: buttonRadius, action });

            });

        }

        

        function isTooCloseToPath(mouseX, mouseY) { if (!playerLayout.path) return true; const pathPadding = playerLayout.gridSize * 2; for(let i = 0; i < playerLayout.path.length - 1; i++){ const p1 = playerLayout.path[i], p2 = playerLayout.path[i+1]; const len = Math.hypot(p2.x - p1.x, p2.y - p1.y); if (len === 0) continue; const dot = ((mouseX - p1.x) * (p2.x - p1.x) + (mouseY - p1.y) * (p2.y - p1.y)) / (len * len); const closestX = p1.x + dot * (p2.x - p1.x), closestY = p1.y + dot * (p2.y - p1.y); if(dot >= 0 && dot <= 1 && Math.hypot(mouseX-closestX, mouseY-closestY) < pathPadding){ displayMessage("경로와 너무 가깝습니다!"); return true; }} return false; }

        function isOccupied(mouseX, mouseY) { if (!playerLayout.gridSize) return true; if (towers.some(t => Math.hypot(t.x - mouseX, t.y - mouseY) < playerLayout.gridSize)) { displayMessage("다른 타워와 너무 가깝습니다!"); return true; } return false; }

        function resizeCanvas() { const uiPanel = document.getElementById('ui-panel'); const gameScreen = screens.game; canvas.width = gameScreen.offsetWidth; canvas.height = gameScreen.offsetHeight - uiPanel.offsetHeight; calculatePlayerLayouts(); draw(); }

        function calculatePlayerLayouts() { const gridSize = canvas.width / 25; const margin = gridSize * 2.5; playerLayout = { gridSize, path: [ {x: -gridSize, y: margin}, {x: canvas.width - margin, y: margin}, {x: canvas.width - margin, y: canvas.height - margin}, {x: margin, y: canvas.height - margin}, {x: margin, y: -gridSize}, ] }; }

        function updateGameUI(state) { document.getElementById('round-stat').textContent = `Round: ${state.round || 0}`; document.getElementById('lives-stat').textContent = `❤️ Lives: ${state.lives || 0}`; document.getElementById('gold-stat').textContent = `💰 Gold: ${state.gold || 0}`; }

        function displayMessage(msg) { messageOverlay.textContent = msg; messageOverlay.style.opacity = 1; messageOverlay.style.transform = 'translateX(-50%) scale(1)'; setTimeout(() => { messageOverlay.style.opacity = 0; messageOverlay.style.transform = 'translateX(-50%) scale(0.8)'; }, 2500); }

        function handleEnemyLeak(leakedEnemy) { if (leakedEnemy.type === 'mega_boss') { showGameOver("보스가 기지를 파괴했습니다!"); return; } localGameState.lives--; updateGameUI(localGameState); if(localGameState.lives <= 0) { localGameState.lives = 0; showGameOver("모든 생명력을 잃었습니다!"); } }

        function showGameOver(reason) { localGameState.gameState = 'gameOver'; if (animationFrameId) cancelAnimationFrame(animationFrameId); const gameOverScreen = screens.gameOver; gameOverScreen.innerHTML = `<h1>게임 오버</h1><p style="font-size: 1.5em; margin-bottom: 20px;">${reason}</p><button id="restart-btn" class="menu-btn">메인 메뉴로</button>`; showScreen('gameOver'); document.getElementById('restart-btn').addEventListener('click', () => window.location.reload()); }

        function showGameClear() { localGameState.gameState = 'cleared'; if (animationFrameId) cancelAnimationFrame(animationFrameId); const gameOverScreen = screens.gameOver; gameOverScreen.innerHTML = `<h1>🎉 게임 승리! 🎉</h1><p style="font-size: 1.5em; margin-bottom: 20px;">50 라운드를 모두 클리어했습니다!</p><button id="restart-btn" class="menu-btn">메인 메뉴로</button>`; showScreen('gameOver'); document.getElementById('restart-btn').addEventListener('click', () => window.location.reload()); }

        

        function spawnWave(round) {

            const createEnemy = (type) => {

                const config = getEnemyConfig(type);

                const health = config.health + Math.pow(round - 1, 2.1) * (type === 'mega_boss' ? 8 : (type === 'boss' ? 3 : 1.5));

                enemies.push({ ...config, health: health, maxHealth: health, type: type, x: playerLayout.path[0].x, y: playerLayout.path[0].y, pathIndex: 1, originalSpeed: null, slowTimer: 0 });

            };

            if (round % 10 === 0) { displayMessage(`🚨 BOSS 출현! 🚨`); createEnemy('mega_boss'); }

            else if (round % 5 === 0) { const count = 8 + round; for (let i = 0; i < count; i++) setTimeout(() => createEnemy('boss'), i * 300); }

            else { const count = 6 + round * 2; const type = round > 10 ? 'fast' : 'normal'; for (let i = 0; i < count; i++) setTimeout(() => createEnemy(type), i * 500); }

        }

        function findTarget(tower) { let closestEnemy = null; let minDistance = tower.range; enemies.forEach(enemy => { const distance = Math.hypot(enemy.x - tower.x, enemy.y - tower.y); if (distance < minDistance) { minDistance = distance; closestEnemy = enemy; } }); return closestEnemy; }

        

        function getFusionRecipe(type1, type2) {

            const recipes = [

                { pair: ['gatling', 'cluster'], result: 'flamethrower' }, { pair: ['gatling', 'blizzard'], result: 'cryo_gun' },

                { pair: ['gatling', 'railgun'], result: 'laser_cannon' }, { pair: ['cluster', 'blizzard'], result: 'hailstorm' },

                { pair: ['cluster', 'railgun'], result: 'missile_launcher' }, { pair: ['blizzard', 'railgun'], result: 'plasma_gun' }

            ];

            return recipes.find(r => r.pair.includes(type1) && r.pair.includes(type2));

        }

        function getTowerConfig(type) {

            const rangeMultiplier = playerLayout.gridSize || 20;

            const configs = {

                // Tier 1

                basic: { emoji: '🔫', damage: 35, range: rangeMultiplier * 8, fireRate: 700, color: '#00ffff', splashRadius: 0, damageCost: 30, rangeCost: 40, tier: 1, combineTo: 'gatling' },

                splash: { emoji: '💣', damage: 40, range: rangeMultiplier * 7, fireRate: 1500, color: '#ffa500', splashRadius: rangeMultiplier * 4, damageCost: 80, rangeCost: 100, tier: 1, combineTo: 'cluster' },

                slow: { emoji: '❄️', damage: 5, range: rangeMultiplier * 7.5, fireRate: 1000, color: '#87CEEB', splashRadius: rangeMultiplier * 3, slowEffect: { power: 0.3, duration: 2000 }, damageCost: 60, rangeCost: 70, tier: 1, combineTo: 'blizzard' },

                sniper: { emoji: '🎯', damage: 150, range: rangeMultiplier * 15, fireRate: 1800, color: '#ff00ff', splashRadius: 0, damageCost: 120, rangeCost: 150, tier: 1, combineTo: 'railgun' },

                // Tier 2

                gatling: { emoji: '🤖', damage: 80, range: rangeMultiplier * 9, fireRate: 400, color: '#00ffff', splashRadius: 0, damageCost: 150, rangeCost: 200, tier: 2 },

                cluster: { emoji: '💥', damage: 100, range: rangeMultiplier * 8, fireRate: 1300, color: '#ffa500', splashRadius: rangeMultiplier * 6, damageCost: 300, rangeCost: 350, tier: 2 },

                blizzard: { emoji: '🥶', damage: 15, range: rangeMultiplier * 8.5, fireRate: 800, color: '#87CEEB', splashRadius: rangeMultiplier * 4.5, slowEffect: { power: 0.5, duration: 2500 }, damageCost: 250, rangeCost: 300, tier: 2 },

                railgun: { emoji: '🛰️', damage: 400, range: rangeMultiplier * 20, fireRate: 1600, color: '#ff00ff', splashRadius: 0, damageCost: 500, rangeCost: 600, tier: 2 },

                // Tier 3

                flamethrower: { emoji: '🔥', damage: 150, range: rangeMultiplier * 8, fireRate: 200, color: '#FF4500', splashRadius: rangeMultiplier * 2, tier: 3 },

                cryo_gun: { emoji: '🧊', damage: 100, range: rangeMultiplier * 9, fireRate: 500, color: '#ADD8E6', splashRadius: 0, slowEffect: { power: 0.4, duration: 1000 }, tier: 3 },

                laser_cannon: { emoji: '☄️', damage: 600, range: rangeMultiplier * 22, fireRate: 1000, color: '#FF0000', splashRadius: 0, tier: 3 },

                hailstorm: { emoji: '🌨️', damage: 120, range: rangeMultiplier * 10, fireRate: 1500, color: '#FFFFFF', splashRadius: rangeMultiplier * 7, slowEffect: { power: 0.6, duration: 3000 }, tier: 3 },

                missile_launcher: { emoji: '🚀', damage: 800, range: rangeMultiplier * 18, fireRate: 2500, color: '#FFA500', splashRadius: rangeMultiplier * 8, tier: 3 },

                plasma_gun: { emoji: '🔮', damage: 500, range: rangeMultiplier * 15, fireRate: 1200, color: '#DA70D6', splashRadius: rangeMultiplier * 3, slowEffect: { power: 0.2, duration: 1000 }, tier: 3 },

                // Legendary

                lightning: { emoji: '⚡️', damage: 50, range: rangeMultiplier * 10, fireRate: 300, color: '#FFFF00', splashRadius: 0, damageCost: 400, rangeCost: 500, tier: 99 },

                volcano: { emoji: '🌋', damage: 75, range: rangeMultiplier * 9, fireRate: 1400, color: '#FF4500', splashRadius: rangeMultiplier * 5, damageCost: 500, rangeCost: 600, tier: 99 },

                ice_shard: { emoji: '💎', damage: 20, range: rangeMultiplier * 12, fireRate: 1500, color: '#FFFFFF', splashRadius: 0, slowEffect: { power: 0.6, duration: 3000 }, damageCost: 500, rangeCost: 500, tier: 99 },

                ion_cannon: { emoji: '☢️', damage: 500, range: rangeMultiplier * 25, fireRate: 2500, color: '#00FF00', splashRadius: 0, damageCost: 600, rangeCost: 700, tier: 99 },

            };

            return configs[type];

        }

        function getEnemyConfig(type) {

            const configs = {

                normal: { emoji: '👽', health: 60, speed: 1.2, gold: 5 }, fast: { emoji: '👹', health: 90, speed: 2.2, gold: 8 },

                boss: { emoji: '👿', health: 1500, speed: 1.0, gold: 50 }, mega_boss: { emoji: '👑', health: 6000, speed: 0.8, gold: 500 }

            };

            return configs[type];

        }

        

        showScreen('start');

        window.addEventListener('resize', resizeCanvas);

    });

    </script>

</body>

</html>
