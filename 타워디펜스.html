<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>타워 디펜스 (V4: 밸런스 및 그래픽 개선)</title>
    <style>
        :root{
            --bg:#0e0e10;
            --header-height: 60px;
            --nav-height: 88px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        *{box-sizing:border-box; margin:0; padding:0; user-select: none;}
        html,body{height:100%; width:100%; background:var(--bg); color:#fff; overflow:hidden;}
        
        header#topbar{
            position:fixed; top:0; left:0; right:0; height:var(--header-height); display:flex; align-items:center;
            gap:12px; padding:0 16px; z-index:120; backdrop-filter: blur(8px);
            background: rgba(14, 14, 16, 0.7); border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        #branding h1 { font-size:1.05rem; color:#33ff99; }
        #stats { display:flex; gap:10px; margin-left:auto; align-items:center; font-weight:700; }
        .stat { padding:6px 10px; background:rgba(255,255,255,0.05); border-radius:8px; font-size:0.95rem; color:#fff; }
       
        #game-wrap { position:absolute; inset:var(--header-height) 0 var(--nav-height) 0; }
        canvas#game-canvas{ width:100%; height:100%; display:block; background:var(--bg); image-rendering: auto; cursor:crosshair; }
        
        nav#bottom-shop {
            position:fixed; bottom:0; left:0; right:0; height:var(--nav-height); display:flex; align-items:center; padding:10px 16px; z-index:130;
            background: rgba(14, 14, 16, 0.7); border-top:1px solid rgba(255,255,255,0.06); backdrop-filter: blur(8px); justify-content: center;
        }
        .shop-grid { display:flex; gap:12px; justify-content:center; align-items:center; width: 100%; }
        .control-button {
            background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.08); padding:8px 10px; border-radius:10px;
            display:flex; flex:1; max-width: 150px; gap:10px; align-items:center; cursor:pointer; transition:all .12s; color:#fff;
        }
        .control-button:hover { background: rgba(255,255,255,0.05); }
        .control-button.selected { border-color: #33ff99; transform:scale(1.02); background: rgba(51,255,153,0.05); }
        .control-button img { width:38px; height:38px; object-fit:contain; }
        .control-button .meta { text-align:left; }
        .control-button strong { display:block; font-size:0.9rem; }
        .control-button small { color:#9aa0a6; font-size:0.8rem; }
       
        @media (max-width:720px){
            :root { --header-height: 56px; --nav-height: 80px; }
            #branding h1 { display: none; }
            #stats { gap: 8px; } .stat { font-size: 0.9rem; padding: 5px 8px; }
            .shop-grid { gap: 8px; }
            .control-button { flex-direction: column; min-width: 65px; gap: 2px; padding: 6px 4px; text-align:center;}
            .control-button .meta { text-align: center; }
            .control-button strong { font-size: 0.75rem; }
            .control-button small { font-size: 0.7rem; }
            .control-button img { width:30px; height:30px; }
        }
    </style>
</head>
<body>
    <header id="topbar">
        <div id="branding" style="gap:12px;">
            <button id="recipe-toggle" style="padding:6px 12px; border-radius:8px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:#fff; cursor:pointer;">조합법</button>
            <h1>타워디펜스</h1>
        </div>
        <div id="stats" aria-live="polite">
            <div id="round-stat" class="stat">R 0</div>
            <div id="lives-stat" class="stat">❤️ 20</div>
            <div id="gold-stat" class="stat">💰 250</div>
        </div>
        <div id="recipe-modal" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); min-width:280px; background:rgba(25,25,28,0.8); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:16px 20px; backdrop-filter:blur(8px); color:#eee; font-size:0.9rem; display:none; z-index:999;">
            <strong style="color:#33ff99; display:block; margin-bottom:8px;">조합법</strong>
            <div>• 같은 1티어 타워 3개 → 2티어 타워<br>• 2티어 + 2티어 → 특수 타워 (준비중)<br>• 전설: 타워 건설 시 낮은 확률로 등장</div>
        </div>
    </header>
    
    <div id="game-wrap"><canvas id="game-canvas"></canvas></div>

    <nav id="bottom-shop">
        <div class="shop-grid" id="shop-grid">
            <button class="control-button" data-type="basic" data-cost="50"><img src="img/기본타워.png" alt="기본"><div class="meta"><strong>기본</strong><small>50 G</small></div></button>
            <button class="control-button" data-type="splash" data-cost="120"><img src="img/광역타워.png" alt="광역"><div class="meta"><strong>광역</strong><small>120 G</small></div></button>
            <button class="control-button" data-type="slow" data-cost="80"><img src="img/슬로우타워.png" alt="슬로우"><div class="meta"><strong>슬로우</strong><small>80 G</small></div></button>
            <button class="control-button" data-type="sniper" data-cost="150"><img src="img/저격타워.png" alt="저격"><div class="meta"><strong>저격</strong><small>150 G</small></div></button>
        </div>
    </nav>

    <script>
    document.addEventListener('DOMContentLoaded', ()=> {
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        
        const COLORS = {
            grass: '#345234', path: '#2a2a2a', danger: '#e53935',
            warning: '#ffb300', info: '#039be5', upgrade: '#43a047'
        };

        let localGameState = { round: 0, lives: 20, gold: 250 };
        let towers = [], enemies = [], projectiles = [], splashEffects = [];
        let lastTime = 0, animId = null, roundInProgress = false, timeToNextWave = 4000;
        let selectedTowerForPlacement = null, selectedTowerForUpgrade = null;
        let placementArea = { x:0,y:0,w:0,h:0, cols:10, rows:8, cellW:0, cellH:0, cells:[] };

        const towerImages = {
            basic: loadImg('img/기본타워.png'), splash: loadImg('img/광역타워.png'),
            slow: loadImg('img/슬로우타워.png'), sniper: loadImg('img/저격타워.png'),
            legendary_basic: loadImg('img/기본전설타워.png'), legendary_splash: loadImg('img/전설광역타워.png'),
            legendary_slow: loadImg('img/전설슬로우타워.png'), legendary_sniper: loadImg('img/전설저격타워.png'),
            gatling: loadImg('img/기본타워.png'), cluster: loadImg('img/광역타워.png'),
            blizzard: loadImg('img/슬로우타워.png'), railgun: loadImg('img/저격타워.png'),
        };
        function loadImg(src){ const i = new Image(); i.src = src; return i; }

        function resize() {
            const wrap = document.getElementById('game-wrap');
            const rect = wrap.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            placementArea.cols = canvas.width < 600 ? 8 : 10;
            const pathMargin = 30;
            placementArea.x = pathMargin; placementArea.y = pathMargin;
            placementArea.w = canvas.width - pathMargin * 2;
            placementArea.h = canvas.height - pathMargin * 2;
            placementArea.rows = Math.round(placementArea.h / (placementArea.w / placementArea.cols));
            placementArea.cellW = placementArea.w / placementArea.cols;
            placementArea.cellH = placementArea.h / placementArea.rows;
            placementArea.cells = [];
            for(let r=0; r<placementArea.rows; r++){
                for(let c=0; c<placementArea.cols; c++){
                    placementArea.cells.push({
                        r,c, x: placementArea.x + c*placementArea.cellW, y: placementArea.y + r*placementArea.cellH,
                        cx: placementArea.x + c*placementArea.cellW + placementArea.cellW/2,
                        cy: placementArea.y + r*placementArea.cellH + placementArea.cellH/2, occupied: false
                    });
                }
            }
            towers.forEach(t => { const cell = findCellAt(t.x, t.y); if(cell) cell.occupied = true; });
        }

        function startGame(){
            localGameState = { round: 0, lives: 20, gold: 250 };
            towers = []; enemies = []; projectiles = []; splashEffects = [];
            roundInProgress = false; timeToNextWave = 3000; lastTime = 0;
            cancelSelections(); updateUI(); resize();
            if(animId) cancelAnimationFrame(animId);
            animId = requestAnimationFrame(loop);
        }

        document.querySelectorAll('.control-button').forEach(btn => {
            btn.addEventListener('click', ()=>{
                cancelSelections(); btn.classList.add('selected');
                selectedTowerForPlacement = { type: btn.dataset.type, cost: Number(btn.dataset.cost) };
            });
        });

        window.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ cancelSelections(); } });
        function cancelSelections(){
            selectedTowerForPlacement = null; selectedTowerForUpgrade = null;
            document.querySelectorAll('.control-button').forEach(b=>b.classList.remove('selected'));
        }

        canvas.addEventListener('click', (e)=>{
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left), my = (e.clientY - rect.top);
            if(selectedTowerForUpgrade?.ui?.buttons) {
                for(const btn of selectedTowerForUpgrade.ui.buttons) {
                    if(mx > btn.x && mx < btn.x + btn.w && my > btn.y && my < btn.y + btn.h) {
                        handleUpgradeAction(selectedTowerForUpgrade, btn.action); return;
                    }
                }
            }
            const clickedTower = towers.find(t => Math.hypot(t.x - mx, t.y - my) < placementArea.cellW * 0.5);
            if(clickedTower){ cancelSelections(); selectedTowerForUpgrade = clickedTower; return; }
            const cell = findCellAt(mx,my);
            if(cell && !cell.occupied && selectedTowerForPlacement){
                if(localGameState.gold < selectedTowerForPlacement.cost){ flashMsg("골드가 부족합니다."); cancelSelections(); return; }
                let finalType = selectedTowerForPlacement.type;
                if(Math.random() < 0.05){
                    const mapLegend = { basic: 'legendary_basic', splash: 'legendary_splash', slow: 'legendary_slow', sniper: 'legendary_sniper' };
                    finalType = mapLegend[selectedTowerForPlacement.type] || finalType; flashMsg("✨ 전설 타워 등장! ✨");
                }
                const cfg = getTowerConfig(finalType);
                towers.push({ ...cfg, id:'T'+Date.now(), x:cell.cx, y:cell.cy, type: finalType, cooldown:0, damageLevel:1, rangeLevel:1, totalSpent:selectedTowerForPlacement.cost, img: cfg.img });
                cell.occupied = true; localGameState.gold -= selectedTowerForPlacement.cost; updateUI();
            }
            cancelSelections();
        });

        function handleUpgradeAction(tower, action) {
            if (action.disabled) return;
            switch(action.type) {
                case 'sell':
                    localGameState.gold += action.value; towers = towers.filter(t => t.id !== tower.id);
                    const cell = findCellAt(tower.x, tower.y); if (cell) cell.occupied = false;
                    cancelSelections(); break;
                case 'upgrade_damage': case 'upgrade_range':
                    localGameState.gold -= action.cost; tower.totalSpent += action.cost;
                    const stat = action.type.split('_')[1];
                    if (stat === 'damage') { tower.damageLevel++; tower.damage = Math.floor(tower.baseDamage * Math.pow(1.4, tower.damageLevel - 1)); }
                    else { tower.rangeLevel++; tower.range = Math.floor(tower.baseRange * Math.pow(1.2, tower.rangeLevel - 1)); }
                    break;
                case 'combine':
                     const towersToCombine = towers.filter(t => t.type === tower.type).slice(0, 3);
                     if (towersToCombine.length >= 3) {
                        towers = towers.filter(t => !towersToCombine.some(ttc => ttc.id === t.id));
                        towersToCombine.forEach(t => { const c = findCellAt(t.x, t.y); if(c) c.occupied = false; });
                        const newPosCell = findCellAt(tower.x, tower.y);
                        const newConfig = getTowerConfig(tower.combineTo);
                        towers.push({ ...newConfig, id: 'T' + Date.now(), x: newPosCell.cx, y: newPosCell.cy, type: tower.combineTo, cooldown: 0, damageLevel: 1, rangeLevel: 1, totalSpent: tower.totalSpent * 3, img: newConfig.img });
                        newPosCell.occupied = true; flashMsg(`${newConfig.name} 조합 성공!`); cancelSelections();
                    } break;
                case 'fuse': flashMsg("융합 기능은 준비 중입니다."); break;
            }
            updateUI();
        }

        function findCellAt(x,y){ return placementArea.cells.find(c => x >= c.x && x <= c.x + placementArea.cellW && y >= c.y && y <= c.y + placementArea.cellH); }
        function loop(ts){ if(!lastTime) lastTime = ts; const dt = ts - lastTime; update(dt); draw(); lastTime = ts; animId = requestAnimationFrame(loop); }
        
        function update(deltaTime){
            if(!roundInProgress) timeToNextWave -= deltaTime;
            if(timeToNextWave <= 0 && !roundInProgress){ localGameState.round++; spawnWave(localGameState.round); roundInProgress = true; updateUI(); }
            const path = defaultPath(); if(!path) return;
            enemies.forEach((enemy,i)=>{
                if (enemy.slowTimer > 0) { enemy.slowTimer -= deltaTime; if (enemy.slowTimer <= 0) { enemy.speed = enemy.originalSpeed; } }
                if(enemy.pathIndex >= path.length){
                    enemies.splice(i,1); localGameState.lives--;
                    if(localGameState.lives <= 0) endGame("기지가 파괴되었습니다.");
                    updateUI(); return;
                }
                const target = path[enemy.pathIndex]; const mv = enemy.speed * (deltaTime / 16.67);
                const dist = Math.hypot(target.x - enemy.x, target.y - enemy.y);
                if(dist < mv){ enemy.x = target.x; enemy.y = target.y; enemy.pathIndex++; }
                else { enemy.x += (target.x-enemy.x)/dist*mv; enemy.y += (target.y-enemy.y)/dist*mv; }
            });
            towers.forEach(t=>{
                t.cooldown -= deltaTime;
                if(t.cooldown <= 0){ const target = findTarget(t); if(target){ 
                    projectiles.push({ 
                        x:t.x, y:t.y, target, damage:t.damage, splashRadius:t.splashRadius, 
                        slowEffect:t.slowEffect, projectileType: t.projectileType, angle: Math.atan2(target.y - t.y, target.x - t.x) 
                    }); 
                    t.cooldown = t.fireRate; 
                } }
            });
            for(let i=projectiles.length-1;i>=0;i--){
                const p = projectiles[i]; if(!p.target || p.target.health <= 0){ projectiles.splice(i,1); continue; }
                const sp = 20 * (deltaTime/16.67); const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);
                if(dist < sp){ hitTarget(p, p.target); projectiles.splice(i,1); }
                else { p.x += (p.target.x - p.x)/dist*sp; p.y += (p.target.y - p.y)/dist*sp; }
            }
            for(let i=splashEffects.length-1;i>=0;i--){ if((splashEffects[i].life -= deltaTime) <=0) splashEffects.splice(i,1); }
            if(roundInProgress && enemies.length === 0){
                roundInProgress = false; timeToNextWave = 3000; const bonus = 40 + localGameState.round * 6;
                localGameState.gold += bonus; flashMsg(`${localGameState.round} 라운드 클리어! +${bonus}G`); updateUI();
            }
        }
        
        // ✨ 수정: 광역 피해 로직 변경
        function hitTarget(projectile, target){
            const { damage, splashRadius, slowEffect } = projectile;
            const x = target.x, y = target.y;

            if(splashRadius > 0){
                splashEffects.push({x, y, radius:splashRadius, life:300});
                enemies.forEach(e => {
                    if (Math.hypot(e.x - x, e.y - y) <= splashRadius) {
                        e.health -= damage;
                        if(slowEffect) applySlow(e, slowEffect);
                    }
                });
            } else {
                target.health -= damage;
                if(slowEffect) applySlow(target, slowEffect);
            }

            let died = false;
            for(let i=enemies.length-1;i>=0;i--){ if(enemies[i].health <= 0){ localGameState.gold += getEnemyConfig(enemies[i].type).gold; enemies.splice(i,1); died = true; } }
            if(died) updateUI();
        }

        function applySlow(enemy, slowEffect) {
            if(!enemy.originalSpeed) enemy.originalSpeed = enemy.speed;
            enemy.speed = enemy.originalSpeed * (1 - slowEffect.power);
            enemy.slowTimer = slowEffect.duration;
        }

        function defaultPath(){
            const pa = placementArea; const m = pa.cellH/2;
            return [ {x: -20, y: pa.y + m}, {x: pa.x + pa.w + m, y: pa.y + m}, {x: pa.x + pa.w + m, y: pa.y + pa.h - m}, {x: pa.x - m, y: pa.y + pa.h - m}, {x: pa.x - m, y: -20} ];
        }
        function spawnWave(round){
            let eType = (round > 10) ? 'fast' : 'normal';
            if(round > 0 && round % 10 === 0){ const c = getEnemyConfig('mega_boss'); enemies.push({...c, maxHealth: c.health, x: defaultPath()[0].x, y: defaultPath()[0].y, pathIndex:1}); flashMsg("🚨 보스 출현!"); }
            else if(round > 0 && round % 5 === 0){ const cnt = Math.min(12 + round, 30); for(let i=0;i<cnt;i++) setTimeout(()=> spawnEnemy('fast'), i*220); }
            else { const cnt = Math.min(6 + round*2, 40); for(let i=0;i<cnt;i++) setTimeout(()=> spawnEnemy(eType), i*140); }
        }
        function spawnEnemy(type){ const p = defaultPath()[0]; const c = getEnemyConfig(type); enemies.push({...c, maxHealth: c.health, x:p.x, y:p.y, pathIndex:1}); }
        function findTarget(tower){
            let closest = null, minD = tower.range;
            enemies.forEach(e=>{ const d = Math.hypot(e.x - tower.x, e.y - tower.y); if(d < minD){ minD = d; closest = e; } });
            return closest;
        }

        // ✨ 수정: 타워 밸런스 대폭 상향 및 발사체 타입 추가
        function getTowerConfig(type){
            const cellAvg = placementArea.cellW || 40;
            const configs = {
                basic: { name:'기본', projectileType:'bullet', damage: 35, range: cellAvg * 3.5, fireRate: 700, damageCost:30, rangeCost:40, tier:1, combineTo:'gatling' },
                splash: { name:'광역', projectileType:'rocket', damage: 40, splashRadius: cellAvg * 1.5, range: cellAvg * 3.2, fireRate: 1500, damageCost:80, rangeCost:100, tier:1, combineTo:'cluster' },
                slow: { name:'슬로우', projectileType:'bullet', damage: 10, range: cellAvg * 3.4, fireRate: 1000, slowEffect:{power:0.3,duration:2200}, damageCost:60, rangeCost:70, tier:1, combineTo:'blizzard' },
                sniper: { name:'저격', projectileType:'railgun', damage:150, range: cellAvg * 6.2, fireRate:1800, damageCost:120, rangeCost:150, tier:1, combineTo:'railgun' },
                
                gatling: { name:'개틀링', projectileType:'laser', damage: 50, range: cellAvg * 4.0, fireRate: 150, damageCost:150, rangeCost:200, tier:2 },
                cluster: { name:'클러스터', projectileType:'rocket', damage: 120, splashRadius: cellAvg * 2.5, range: cellAvg * 3.8, fireRate:1400, damageCost:300, rangeCost:350, tier:2 },
                blizzard: { name:'블리자드', projectileType:'bullet', damage: 30, range: cellAvg * 4.2, fireRate:900, splashRadius: cellAvg * 1.8, slowEffect:{power:0.5,duration:2500}, damageCost:250, rangeCost:300, tier:2 },
                railgun: { name:'레일건', projectileType:'railgun', damage: 800, range: cellAvg * 8.5, fireRate:1600, damageCost:320, rangeCost:380, tier:2 },

                legendary_basic: { name:'전설-기본', projectileType:'laser', damage:100, range: cellAvg * 4.5, fireRate:100, damageCost:400, rangeCost:500, tier:99 },
                legendary_splash: { name:'전설-광역', projectileType:'rocket', damage:150, range: cellAvg * 4.2, fireRate:1400, splashRadius: cellAvg * 3.0, damageCost:500, rangeCost:600, tier:99 },
                legendary_slow: { name:'전설-슬로우', projectileType:'bullet', damage:50, range: cellAvg * 5.2, fireRate:800, splashRadius: cellAvg * 2.0, slowEffect:{power:0.6,duration:3000}, damageCost:500, rangeCost:500, tier:99 },
                legendary_sniper: { name:'전설-저격', projectileType:'railgun', damage:1200, range: cellAvg * 10.0, fireRate:2000, damageCost:600, rangeCost:700, tier:99 },
            };
            const config = { ...configs[type] } || { ...configs.basic };
            config.baseDamage = config.damage; config.baseRange = config.range;
            config.img = towerImages[type] || towerImages.basic;
            return config;
        }
        function getEnemyConfig(type){
            return {
                normal: { type:'normal', emoji:'👽', health: 60, speed:1.2, gold:5 },
                fast: { type:'fast', emoji:'👹', health: 90, speed:2.2, gold:8 },
                mega_boss: { type:'mega_boss', emoji:'👑', health: 5000, speed:0.8, gold:300 }
            }[type] || { type:'normal', emoji:'?', health:60, speed:1.2, gold:5 };
        }
        function endGame(reason){ flashMsg("게임 종료: "+reason, 5000); if(animId) cancelAnimationFrame(animId); animId = null; }

        function draw(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(placementArea.x, placementArea.y, placementArea.w, placementArea.h);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for(let i=0; i < (placementArea.w * placementArea.h / 50); i++){ ctx.fillRect(placementArea.x + Math.random() * placementArea.w, placementArea.y + Math.random() * placementArea.h, 2, 2); }
            const path = defaultPath();
            ctx.strokeStyle = COLORS.path;
            ctx.lineWidth = placementArea.cellH * 0.9; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); path.forEach(p=>ctx.lineTo(p.x, p.y)); ctx.stroke();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
            ctx.strokeRect(placementArea.x, placementArea.y, placementArea.w, placementArea.h);

            towers.forEach(t=>{ const size = placementArea.cellW * 0.9; if(t.img?.complete) ctx.drawImage(t.img, t.x - size/2, t.y - size/2, size, size); });
            enemies.forEach(e=>{
                ctx.font = `${placementArea.cellH * 0.9}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(e.emoji || '👾', e.x, e.y);
                const hpRatio = Math.max(0, e.health / e.maxHealth), barW = placementArea.cellW * 0.9, barY = e.y - placementArea.cellH*0.8;
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(e.x - barW/2, barY, barW, 6);
                ctx.fillStyle = hpRatio > 0.5 ? '#4caf50' : '#ffc107'; ctx.fillRect(e.x - barW/2, barY, barW*hpRatio, 6);
            });
            
            // ✨ 수정: 발사체 타입에 따라 다르게 그리기
            projectiles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                switch(p.projectileType) {
                    case 'laser':
                        ctx.fillStyle = '#ff3399';
                        ctx.shadowColor = '#ff3399'; ctx.shadowBlur = 10;
                        ctx.fillRect(0, -2, 25, 4);
                        break;
                    case 'rocket':
                        ctx.fillStyle = '#cccccc'; ctx.fillRect(0, -4, 18, 8);
                        ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-2, 0); ctx.lineTo(-10, -5); ctx.lineTo(-10, 5); ctx.closePath(); ctx.fill();
                        break;
                    case 'railgun':
                        ctx.fillStyle = '#33ccff';
                        ctx.shadowColor = '#33ccff'; ctx.shadowBlur = 15;
                        ctx.fillRect(0, -3, 35, 6);
                        break;
                    default: // bullet
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            });

            // ✨ 수정: 광역 효과 시각 강화
            splashEffects.forEach(s=>{ ctx.fillStyle = `rgba(255, 180, 50, ${s.life/300 * 0.7})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2); ctx.fill(); });
            
            if(selectedTowerForUpgrade) {
                const t = selectedTowerForUpgrade;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2; ctx.setLineDash([8, 4]);
                ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]);
                drawUpgradeUI(t);
            }
        }
        
        function drawUpgradeUI(tower) {
            const btns = getUpgradeButtons(tower);
            const btnW = placementArea.cellW * 0.9, btnH = placementArea.cellH * 0.5, gap = 5;
            const barW = (btnW + gap) * btns.length - gap, barH = btnH + placementArea.cellH * 0.4;
            let barX = tower.x - barW / 2, barY = tower.y - placementArea.cellH / 2 - barH;
            if (barY < 0) barY = tower.y + placementArea.cellH / 2;
            if (barX < 0) barX = 5; if (barX + barW > canvas.width) barX = canvas.width - barW - 5;
            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, 8); ctx.fill();
            tower.ui = { buttons: [] };
            btns.forEach((btn, i) => {
                const btnX = barX + (btnW + gap) * i; const btnY = barY + barH - btnH - 5;
                tower.ui.buttons.push({ ...btn, x: btnX, y: btnY, w: btnW, h: btnH });
                ctx.fillStyle = btn.action.disabled ? '#555' : btn.color;
                ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 5); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = `bold ${btnH*0.4}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(btn.text, btnX + btnW/2, btnY + btnH/2 - btnH*0.1);
                ctx.font = `${btnH*0.3}px sans-serif`; ctx.fillText(btn.subtext, btnX + btnW/2, btnY + btnH/2 + btnH*0.25);
            });
            ctx.fillStyle = '#fff'; ctx.font = `bold ${barH*0.2}px sans-serif`; ctx.textAlign = 'left';
            ctx.fillText(`${tower.name} | 💥${tower.damage} | Lv.${tower.damageLevel}/${tower.rangeLevel}`, barX + 8, barY + barH*0.2);
        }
        
        function getUpgradeButtons(tower) {
            const sellValue = Math.floor(tower.totalSpent * 0.7);
            const dmgCost = Math.floor(tower.damageCost * Math.pow(1.5, tower.damageLevel - 1));
            const rangeCost = Math.floor(tower.rangeCost * Math.pow(1.6, tower.rangeLevel - 1));
            const canUpgradeDmg = localGameState.gold >= dmgCost, canUpgradeRange = localGameState.gold >= rangeCost;
            const btns = [
                { text: '공격', subtext: `${dmgCost}G`, color: COLORS.upgrade, action: { type: 'upgrade_damage', cost: dmgCost, disabled: !canUpgradeDmg } },
                { text: '사거리', subtext: `${rangeCost}G`, color: COLORS.info, action: { type: 'upgrade_range', cost: rangeCost, disabled: !canUpgradeRange } },
            ];
            if (tower.tier === 1) {
                const sameTypeCount = towers.filter(t => t.type === tower.type).length;
                const canCombine = sameTypeCount >= 3;
                btns.push({ text: '조합', subtext: `${sameTypeCount}/3`, color: COLORS.warning, action: { type: 'combine', disabled: !canCombine } });
            }
            btns.push({ text: '판매', subtext: `${sellValue}G`, color: COLORS.danger, action: { type: 'sell', value: sellValue } });
            return btns;
        }

        function updateUI(){
            document.getElementById('round-stat').textContent = `R ${localGameState.round||0}`;
            document.getElementById('lives-stat').textContent = `❤️ ${localGameState.lives||0}`;
            document.getElementById('gold-stat').textContent = `💰 ${localGameState.gold||0}`;
        }
        let msgTimer = null;
        function flashMsg(m, duration = 2000){
            let el = document.getElementById('msg-overlay');
            if (!el) {
                el = document.createElement('div'); el.id = 'msg-overlay';
                Object.assign(el.style, {
                    position: 'fixed', top: '78px', left: '50%', padding: '8px 14px', borderRadius: '10px',
                    background: 'rgba(20,20,20,0.8)', backdropFilter: 'blur(4px)', color: '#ffd', zIndex: '200', fontWeight: '700', 
                    transition: 'opacity 0.5s, transform 0.5s', opacity: '0', transform: 'translateX(-50%) translateY(-20px)'
                });
                document.body.appendChild(el);
            }
            el.textContent = m; el.style.opacity = '1'; el.style.transform = 'translateX(-50%) translateY(0)';
            if(msgTimer) clearTimeout(msgTimer);
            msgTimer = setTimeout(()=>{ el.style.opacity = '0'; el.style.transform = 'translateX(-50%) translateY(-20px)'; }, duration);
        }

        const recipeBtn = document.getElementById('recipe-toggle'), recipeModal = document.getElementById('recipe-modal');
        recipeBtn.addEventListener('click', () => { recipeModal.style.display = recipeModal.style.display === 'none' ? 'block' : 'none'; });
        window.addEventListener('keydown', e => { if(e.key === 'Escape') recipeModal.style.display = 'none'; });

        startGame();
        window.addEventListener('resize', resize);
    });
    </script>
</body>
</html>
