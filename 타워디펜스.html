<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>타워 디펜스 (이미지 적용 & 반응형)</title>
    <style>
        :root{
            --bg:#0e0e10;
            --panel:#1f1f22;
            --accent:#33ff99;
            --muted:#9aa0a6;
            --danger:#ff6b6b;
            --glass: rgba(255,255,255,0.06);
            --glass-strong: rgba(255,255,255,0.08);
            --shop-bg: rgba(40,40,45,0.85);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
        }
        *{box-sizing:border-box; margin:0; padding:0;}
        html,body{height:100%; width:100%; background:var(--bg); color:#fff; overflow:hidden; -webkit-font-smoothing:antialiased;}
        /* 상단 고정 헤더 */
        header#topbar{
            position:fixed; top:0; left:0; right:0; height:64px; display:flex; align-items:center;
            gap:16px; padding:8px 16px; z-index:120; backdrop-filter: blur(6px);
            background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }
        #branding { display:flex; align-items:center; gap:12px; }
        #branding h1 { font-size:1.05rem; color:var(--accent); text-shadow:0 0 8px rgba(51,255,153,0.08); }
        #stats { display:flex; gap:16px; margin-left:auto; align-items:center; font-weight:700; color:var(--muted); }
        .stat { padding:6px 10px; background:var(--glass); border-radius:8px; font-size:0.95rem; color:#fff; box-shadow:inset 0 -2px 0 rgba(0,0,0,0.2); }
        /* 조합법 설명서 (반투명) */
        #recipe {
            position:absolute; left:16px; top:74px; z-index:110; padding:10px 14px; border-radius:10px;
            background: rgba(0,0,0,0.45); color: #ddd; font-size:0.9rem; border:1px solid rgba(255,255,255,0.03);
            max-width:360px; backdrop-filter: blur(4px);
        }
        #game-wrap { position:absolute; inset:96px 0 88px 0; display:flex; justify-content:center; align-items:stretch; }
        canvas#game-canvas{ width:100%; height:100%; display:block; background:linear-gradient(180deg,#0b0b0c,#0f0f11); image-rendering: auto; cursor:crosshair; }
        /* 하단 UI (상점) */
        nav#bottom-shop {
            position:fixed; bottom:0; left:0; right:0; height:88px; display:flex; align-items:center; padding:10px 18px; z-index:130;
            background: var(--shop-bg); border-top:1px solid rgba(255,255,255,0.04);
        }
        .shop-left { width:220px; display:flex; gap:8px; align-items:center; }
        .shop-left .hint { font-size:0.9rem; color:var(--muted); }
        .shop-grid { flex:1; display:flex; gap:12px; justify-content:flex-end; align-items:center; padding-right:18px; }
        .control-button {
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            border:1px solid rgba(255,255,255,0.04); padding:8px 12px; border-radius:10px; min-width:120px;
            display:flex; gap:10px; align-items:center; cursor:pointer; transition:all .12s; color:#fff;
        }
        .control-button:hover { transform:translateY(-3px); box-shadow:0 6px 18px rgba(0,0,0,0.5); }
        .control-button.selected { border-color: var(--accent); box-shadow:0 0 18px rgba(51,255,153,0.08); transform:scale(1.02); }
        .control-button img { width:40px; height:40px; object-fit:contain; filter: drop-shadow(0 6px 10px rgba(0,0,0,0.6)); }
        .control-button .meta { text-align:left; }
        .control-button strong { display:block; font-size:0.95rem; }
        .control-button small { color:var(--muted); font-size:0.8rem; }
        /* 반응형 */
        @media (max-width:720px){
            header#topbar{ height:68px; padding:8px 12px; }
            #recipe { display:none; }
            .control-button img { width:36px; height:36px; }
            nav#bottom-shop { padding:8px 10px; height:96px; }
        }
        /* 안내 레이어 (placement highlight) */
        .hintLayer { position:absolute; inset:96px 0 88px 0; pointer-events:none; z-index:115; }
    </style>
</head>
<body>
    <!-- 상단 고정 헤더 -->
    <header id="topbar">
        <div id="branding">
<!-- 조합법 버튼 추가 -->
<button id="recipe-toggle" style="
    padding:6px 12px;
    border-radius:8px;
    background:rgba(255,255,255,0.05);
    border:1px solid rgba(255,255,255,0.1);
    color:#fff;
    cursor:pointer;
">
  조합법
</button>
            <h1>타워디펜스</h1>
        </div>

        <div id="stats" aria-live="polite">
            <div id="round-stat" class="stat">Round: 0</div>
            <div id="lives-stat" class="stat">❤️ Lives: 20</div>
            <div id="gold-stat" class="stat">💰 Gold: 250</div>
        </div>
<!-- 조합법 팝업 (초기에는 숨김) -->
<div id="recipe-modal" style="
    position:fixed;
    top:50%; left:50%;
    transform:translate(-50%, -50%);
    min-width:280px;
    background:rgba(0,0,0,0.75);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;
    padding:16px 20px;
    backdrop-filter:blur(8px);
    color:#eee;
    font-size:0.9rem;
    display:none;
    z-index:999;
">
    <strong style="color:#33ff99; display:block; margin-bottom:8px;">조합법 가이드</strong>
    <div>
        • 같은 티어 타워 3개 조합 → 티어2<br>
        • 티어2 + 티어2 융합 → 특수 융합타워 (전설보다 약함)<br>
        • 전설 타워(랜덤): 기본계열에서 낮은 확률로 등장
    </div>
</div>

    </header>


    
    <!-- 게임 영역 -->
    <div id="game-wrap">
        <canvas id="game-canvas"></canvas>
        <div class="hintLayer" id="hint-layer"></div>
    </div>

    <!-- 하단 상점 -->
    <nav id="bottom-shop">
        <div class="shop-left">
            <div class="hint">ESC: 선택 취소 · 클릭: 설치 / 타워 클릭: 이동·업그레이드</div>
        </div>
        <div class="shop-grid" id="shop-grid">
            <button class="control-button" data-type="basic" data-cost="50"><img src="/img/기본타워.png" alt="기본"><div class="meta"><strong>기본 타워</strong><small>Cost: 50</small></div></button>
            <button class="control-button" data-type="splash" data-cost="120"><img src="/img/광역타워.png" alt="광역"><div class="meta"><strong>광역 타워</strong><small>Cost: 120</small></div></button>
            <button class="control-button" data-type="slow" data-cost="80"><img src="/img/슬로우타워.png" alt="슬로우"><div class="meta"><strong>슬로우 타워</strong><small>Cost: 80</small></div></button>
            <button class="control-button" data-type="sniper" data-cost="150"><img src="/img/저격타워.png" alt="저격"><div class="meta"><strong>저격 타워</strong><small>Cost: 150</small></div></button>
        </div>
    </nav>

    <script>
    document.addEventListener('DOMContentLoaded', ()=> {
        // 캔버스 설정
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const hintLayer = document.getElementById('hint-layer');

        // UI 요소
        const roundStat = document.getElementById('round-stat');
        const livesStat = document.getElementById('lives-stat');
        const goldStat = document.getElementById('gold-stat');
        const shopButtons = Array.from(document.querySelectorAll('.control-button'));

        // 게임 상태
        let localGameState = { gameState: 'idle', round: 0, lives: 20, gold: 250 };
        let towers = [], enemies = [], projectiles = [], splashEffects = [];
        let lastTime = 0, animId = null, roundInProgress = false, timeToNextWave = 4000;
        let selectedTowerForPlacement = null; // {type,cost}
        let movingTower = null; // when player selects a placed tower to move
        let activeMenuButtons = [];
        let isCombining = false, firstCombineTower = null;

        // 배치영역(Placement area) — 캔버스 크기에 따라 동적
        let placementArea = { x:0,y:0,w:0,h:0, cols:10, rows:10, cellW:0, cellH:0, cells:[] };

        // 이미지 프리로드 (파일명은 업로드한 이름 기준)
        const towerImages = {
            basic: loadImg('/img/기본타워.png'),
            splash: loadImg('/img/광역타워.png'),
            slow: loadImg('/img/슬로우타워.png'),
            sniper: loadImg('/img/저격타워.png'),
            // 전설 이미지들 (랜덤 전설용)
            legendary_basic: loadImg('/img/기본전설타워.png'),
            legendary_splash: loadImg('/img/전설광역타워.png'),
            legendary_slow: loadImg('/img/전설슬로우타워.png'),
            legendary_sniper: loadImg('/img/전설저격타워.png'),
            // tier2/융합 이미지(없으면 기본을 사용)
            gatling: loadImg('/img/기본타워.png'),
            cluster: loadImg('/img/광역타워.png'),
            blizzard: loadImg('/img/슬로우타워.png'),
            railgun: loadImg('/img/저격타워.png'),
        };

        function loadImg(src){
            const i = new Image();
            i.src = src;
            return i;
        }

        // 반응형 리사이즈
        function resize() {
            const top = document.getElementById('topbar').offsetHeight + 8;
            const bottom = document.getElementById('bottom-shop').offsetHeight + 8;
            const wrap = document.getElementById('game-wrap');
            const rect = wrap.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            // 배치영역은 캔버스 중앙의 76% 영역으로 설정 (경로와 UI 제외)
            const pad = 24;
            placementArea.x = pad;
            placementArea.y = pad;
            placementArea.w = Math.max( Math.floor(canvas.width * 0.76) - pad*2, 200 );
            placementArea.h = Math.max( Math.floor(canvas.height * 0.76) - pad*2, 200 );
            // 중앙에 배치
            placementArea.x = Math.floor((canvas.width - placementArea.w) / 2);
            placementArea.y = Math.floor((canvas.height - placementArea.h) / 2);
            placementArea.cellW = placementArea.w / placementArea.cols;
            placementArea.cellH = placementArea.h / placementArea.rows;
            // rebuild cells
            placementArea.cells = [];
            for(let r=0;r<placementArea.rows;r++){
                for(let c=0;c<placementArea.cols;c++){
                    placementArea.cells.push({
                        r,c,
                        x: placementArea.x + c*placementArea.cellW,
                        y: placementArea.y + r*placementArea.cellH,
                        cx: placementArea.x + c*placementArea.cellW + placementArea.cellW/2,
                        cy: placementArea.y + r*placementArea.cellH + placementArea.cellH/2,
                        occupied: false
                    });
                }
            }
            // update occupancy based on existing towers
            towers.forEach(t => {
                const cell = findCellAt(t.x, t.y);
                if(cell) cell.occupied = true;
            });
        }

        // 시작 버튼 대체: 바로 게임 시작
        function startGame(){
            localGameState.round = 0; localGameState.lives = 20; localGameState.gold = 250;
            towers = []; enemies = []; projectiles = []; splashEffects = [];
            roundInProgress = false; timeToNextWave = 3000; lastTime = 0;
            updateUI();
            resize();
            if(animId) cancelAnimationFrame(animId);
            animId = requestAnimationFrame(loop);
        }

        // UI shop 버튼 클릭 처리
        shopButtons.forEach(btn => {
            btn.addEventListener('click', ()=>{
                shopButtons.forEach(b=>b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedTowerForPlacement = { type: btn.dataset.type, cost: Number(btn.dataset.cost) };
                movingTower = null;
                isCombining = false; firstCombineTower = null;
                // hint: highlight available cells
                renderHintLayer();
            });
        });

        // ESC 누르면 선택 취소
        window.addEventListener('keydown', e=>{
            if(e.key === 'Escape'){ cancelSelections(); renderHintLayer(); }
        });

        function cancelSelections(){
            selectedTowerForPlacement = null;
            movingTower = null;
            shopButtons.forEach(b=>b.classList.remove('selected'));
            isCombining = false; firstCombineTower = null;
            renderHintLayer();
        }

        // 마우스 클릭 : 설치/이동/업그레이드/융합 처리
        canvas.addEventListener('click', (e)=>{
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left);
            const my = (e.clientY - rect.top);

            // 우선 기존 타워 클릭 (이동/업그레이드 선택)
            const clicked = towers.find(t => Math.hypot(t.x - mx, t.y - my) < Math.min(placementArea.cellW, placementArea.cellH) * 0.6);
            if(clicked && !selectedTowerForPlacement){
                // 선택한 타워를 이동 준비 (한번 더 클릭해서 이동셀 선택)
                movingTower = clicked;
                // unselect shop UI
                shopButtons.forEach(b=>b.classList.remove('selected'));
                renderHintLayer();
                return;
            }

            // 설치 또는 이동 시: 셀 클릭으로 스냅
            const cell = findCellAt(mx,my);
            if(cell && !cell.occupied){
                // 설치
                if(selectedTowerForPlacement){
                    if(localGameState.gold < selectedTowerForPlacement.cost){ flashMsg("골드 부족"); cancelSelections(); return; }
                    // 랜덤 전설 스폰 처리 (5% 확률)
                    let finalType = selectedTowerForPlacement.type;
                    if(Math.random() < 0.05){
                        // map to legendary variants
                        const mapLegend = { basic: 'legendary_basic', splash: 'legendary_splash', slow: 'legendary_slow', sniper: 'legendary_sniper' };
                        finalType = mapLegend[selectedTowerForPlacement.type] || finalType;
                        flashMsg("✨ 전설 타워 등장! ✨");
                    }
                    const cfg = getTowerConfig(finalType);
                    const tw = {
                        ...cfg,
                        id:'T'+Date.now(),
                        x:cell.cx, y:cell.cy, type: finalType,
                        cooldown:0, damageLevel:1, rangeLevel:1, totalSpent:selectedTowerForPlacement.cost,
                        img: cfg.img  // 이미지 참조
                    };
                    towers.push(tw);
                    cell.occupied = true;
                    localGameState.gold -= selectedTowerForPlacement.cost;
                    updateUI();
                    cancelSelections();
                    return;
                }
                // 이동: 선택된 기존 타워가 있다면 이동
                if(movingTower){
                    // mark old cell free and new occupied
                    const oldCell = findCellAt(movingTower.x, movingTower.y);
                    if(oldCell) oldCell.occupied = false;
                    movingTower.x = cell.cx; movingTower.y = cell.cy;
                    cell.occupied = true;
                    movingTower = null;
                    renderHintLayer();
                    return;
                }
            } else {
                // 클릭한 셀이 유효하지 않을때: 융합/업그레이드 처리 (타워가 클릭되었을 때 케어)
                if(clicked){
                    // 기존 로직: 선택해서 메뉴 렌더
                    // here we set selectedTowerForUpgrade as clicked and let draw() show radial menu
                    selectedTowerForPlacement = null;
                    movingTower = clicked;
                    renderHintLayer();
                } else {
                    // 아무 것도 없을 때 취소
                    cancelSelections();
                }
            }
        });

        // 셀 찾기
        function findCellAt(x,y){
            for(const c of placementArea.cells){
                if(x >= c.x && x <= c.x + placementArea.cellW && y >= c.y && y <= c.y + placementArea.cellH) return c;
            }
            return null;
        }

        // 그리기 루프
        function loop(ts){
            if(!lastTime) lastTime = ts;
            const dt = ts - lastTime;
            update(dt);
            draw();
            lastTime = ts;
            animId = requestAnimationFrame(loop);
        }

        // 업데이트 (적 이동, 타워 발사 등) - 기존 로직 최대한 유지
        function update(deltaTime){
            // 웨이브 타이머
            if(!roundInProgress) timeToNextWave -= deltaTime;
            if(timeToNextWave <= 0 && !roundInProgress){
                localGameState.round++;
                spawnWave(localGameState.round);
                roundInProgress = true;
                updateUI();
            }
            // 적 처리
            enemies.forEach((enemy,i)=>{
                const path = defaultPath();
                if(!path || path.length===0) return;
                if(enemy.pathIndex >= path.length){ // 유출
                    enemies.splice(i,1);
                    localGameState.lives--;
                    updateUI();
                    if(localGameState.lives <= 0) endGame("기지 파괴");
                    return;
                }
                const target = path[enemy.pathIndex];
                const mv = enemy.speed * (deltaTime / 16.67);
                const dist = Math.hypot(target.x - enemy.x, target.y - enemy.y);
                if(dist < mv){ enemy.x = target.x; enemy.y = target.y; enemy.pathIndex++; }
                else { enemy.x += (target.x-enemy.x)/dist*mv; enemy.y += (target.y-enemy.y)/dist*mv; }
            });
            // 타워 발사
            towers.forEach(t=>{
                t.cooldown -= deltaTime;
                if(t.cooldown <= 0){
                    const target = findTarget(t);
                    if(target){
                        projectiles.push({ x:t.x, y:t.y, target:target, damage:t.damage, splashRadius:t.splashRadius, slowEffect:t.slowEffect, color:t.color });
                        t.cooldown = t.fireRate;
                    }
                }
            });
            // 발사체 이동/충돌
            for(let i=projectiles.length-1;i>=0;i--){
                const p = projectiles[i];
                if(!p.target || p.target.health <= 0){ projectiles.splice(i,1); continue; }
                const sp = 12 * (deltaTime/16.67);
                const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);
                if(dist < sp){
                    hitTarget(p.target, p.damage, p.splashRadius, p.target.x, p.target.y, p.slowEffect);
                    projectiles.splice(i,1);
                } else {
                    p.x += (p.target.x - p.x)/dist*sp; p.y += (p.target.y - p.y)/dist*sp;
                }
            }
            // splash life reduce
            for(let i=splashEffects.length-1;i>=0;i--){
                splashEffects[i].life -= deltaTime;
                if(splashEffects[i].life <=0) splashEffects.splice(i,1);
            }
            // 라운드 클리어 체크
            if(roundInProgress && enemies.length === 0){
                roundInProgress = false;
                timeToNextWave = 3000;
                const bonus = 40 + localGameState.round * 6;
                localGameState.gold += bonus;
                flashMsg(`${localGameState.round} 라운드 클리어! +${bonus}G`);
                updateUI();
            }
        }

        function hitTarget(target, damage, splashRadius, x,y, slowEffect){
            target.health -= damage;
            if(slowEffect){
                if(!target.originalSpeed) target.originalSpeed = target.speed;
                target.speed = target.originalSpeed * (1 - slowEffect.power);
                target.slowTimer = slowEffect.duration;
            }
            if(splashRadius > 0){
                splashEffects.push({x,y,radius:splashRadius,life:250});
                enemies.forEach(e=>{
                    if(e !== target && Math.hypot(e.x - x, e.y - y) <= splashRadius) e.health -= damage;
                });
            }
            // 죽음 처리
            for(let i=enemies.length-1;i>=0;i--){
                if(enemies[i].health <= 0){
                    localGameState.gold += (getEnemyConfig(enemies[i].type).gold || 5);
                    enemies.splice(i,1);
                    updateUI();
                }
            }
        }

        // 기본 경로 (심플 사각 루프) — 플레이어가 바꿀 수 있도록 확장 가능
        function defaultPath(){
            // create a path around placementArea (outside)
            const m = 20;
            return [
                {x: m, y: m},
                {x: canvas.width - m, y: m},
                {x: canvas.width - m, y: canvas.height - m},
                {x: m, y: canvas.height - m},
                {x: m, y: -50}
            ];
        }

        // 적 스폰
        function spawnWave(round){
            if(round % 10 === 0){
                // 보스
                enemies.push({...getEnemyConfig('mega_boss'), x: defaultPath()[0].x, y: defaultPath()[0].y, pathIndex:1});
                flashMsg("🚨 보스 출현!");
            } else if(round % 5 === 0){
                const cnt = Math.min(12 + round, 30);
                for(let i=0;i<cnt;i++){
                    setTimeout(()=> spawnEnemy(round > 10 ? 'fast' : 'normal'), i*220);
                }
            } else {
                const cnt = Math.min(6 + round*2, 40);
                for(let i=0;i<cnt;i++){
                    setTimeout(()=> spawnEnemy(round > 10 ? 'fast' : 'normal'), i*140);
                }
            }
        }
        function spawnEnemy(type){
            const p = defaultPath()[0];
            enemies.push({...getEnemyConfig(type), x:p.x, y:p.y, pathIndex:1});
        }

        // 타깃 찾기
        function findTarget(tower){
            let closest = null;
            let minD = tower.range;
            enemies.forEach(e=>{
                const d = Math.hypot(e.x - tower.x, e.y - tower.y);
                if(d < minD){ minD = d; closest = e; }
            });
            return closest;
        }

        // 타워/적 구성값
        function getTowerConfig(type){
            // range multiplier uses average cell size for scaling
            const cellAvg = Math.max(placementArea.cellW, placementArea.cellH) || 40;
            const configs = {
                // Tier1 (기본)
                basic: { name:'기본', img: towerImages.basic, damage: 35, range: cellAvg * 3.5, fireRate: 700, color:'#a0f', splashRadius:0, damageCost:30, rangeCost:40, tier:1, combineTo:'gatling' },
                splash: { name:'광역', img: towerImages.splash, damage: 40, range: cellAvg * 3.2, fireRate: 1500, color:'#f90', splashRadius: cellAvg * 1.6, damageCost:80, rangeCost:100, tier:1, combineTo:'cluster' },
                slow: { name:'슬로우', img: towerImages.slow, damage: 6, range: cellAvg * 3.4, fireRate: 1000, color:'#7fd', splashRadius: cellAvg * 1.2, slowEffect:{power:0.28,duration:2200}, damageCost:60, rangeCost:70, tier:1, combineTo:'blizzard' },
                sniper: { name:'저격', img: towerImages.sniper, damage:150, range: cellAvg * 6.2, fireRate:1800, color:'#f0f', splashRadius:0, damageCost:120, rangeCost:150, tier:1, combineTo:'railgun' },

                // Tier2 (조합 결과) — 전설보다 약하게 조정 (요청 반영)
                gatling: { name:'개틀링', img: towerImages.gatling, damage: 40, range: cellAvg * 3.8, fireRate:450, color:'#9ff', splashRadius:0, damageCost:150, rangeCost:200, tier:2 },
                cluster: { name:'클러스터', img: towerImages.cluster, damage: 60, range: cellAvg * 3.6, fireRate:1200, color:'#ffb042', splashRadius: cellAvg * 2.2, damageCost:300, rangeCost:350, tier:2 },
                blizzard: { name:'블리자드', img: towerImages.blizzard, damage: 12, range: cellAvg * 3.9, fireRate:900, color:'#bfe', splashRadius: cellAvg * 1.8, slowEffect:{power:0.45,duration:2400}, damageCost:250, rangeCost:300, tier:2 },
                railgun: { name:'레일건', img: towerImages.railgun, damage:220, range: cellAvg * 8.0, fireRate:1600, color:'#ffd1ff', splashRadius:0, damageCost:320, rangeCost:380, tier:2 },

                // Legendary (랜덤 전설) — 강력하지만 희귀
                legendary_basic: { name:'전설-기본', img: towerImages.legendary_basic, damage:50, range: cellAvg * 4.5, fireRate:300, color:'#ffff66', splashRadius:0, damageCost:400, rangeCost:500, tier:99 },
                legendary_splash: { name:'전설-광역', img: towerImages.legendary_splash, damage:75, range: cellAvg * 4.2, fireRate:1400, color:'#ff7a3a', splashRadius: cellAvg * 2.8, damageCost:500, rangeCost:600, tier:99 },
                legendary_slow: { name:'전설-슬로우', img: towerImages.legendary_slow, damage:20, range: cellAvg * 5.2, fireRate:1500, color:'#ccf', slowEffect:{power:0.6,duration:3000}, splashRadius:0, damageCost:500, rangeCost:500, tier:99 },
                legendary_sniper: { name:'전설-저격', img: towerImages.legendary_sniper, damage:500, range: cellAvg * 9.5, fireRate:2500, color:'#88ff88', splashRadius:0, damageCost:600, rangeCost:700, tier:99 },
            };
            return configs[type] || configs.basic;
        }

        // 적 구성
        function getEnemyConfig(type){
            return {
                normal: { type:'normal', emoji:'👽', health: 60, speed:1.2, gold:5 },
                fast: { type:'fast', emoji:'👹', health: 90, speed:2.2, gold:8 },
                boss: { type:'boss', emoji:'👿', health: 1500, speed:1.0, gold:50 },
                mega_boss: { type:'mega_boss', emoji:'👑', health: 5000, speed:0.8, gold:300 }
            }[type] || { type:'normal', emoji:'?', health:60, speed:1.2, gold:5 };
        }

        // 적 타깃 찾기 (위와 동일)
        function getEnemyConfigForSpawn(t){ return getEnemyConfig(t); }

        // 적 타겟 탐색에 필요한 유틸
        function endGame(reason){ flashMsg("게임 종료: "+reason); cancelAnimationFrame(animId); animId = null; }

        // draw
        function draw(){
            // 캔버스 클리어
            ctx.clearRect(0,0,canvas.width,canvas.height);

            // 경로 그리기 (밑층)
            ctx.save();
            const path = defaultPath();
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 28;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
            ctx.restore();

            // 배치영역 그리기 (테두리)
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(255,255,255,0.02)';
            ctx.fillRect(placementArea.x, placementArea.y, placementArea.w, placementArea.h);
            ctx.strokeRect(placementArea.x+0.5, placementArea.y+0.5, placementArea.w-1, placementArea.h-1);
            // 그리드 라인
            ctx.globalAlpha = 0.06;
            for(let r=1;r<placementArea.rows;r++){
                const yy = placementArea.y + r*placementArea.cellH;
                ctx.beginPath(); ctx.moveTo(placementArea.x, yy); ctx.lineTo(placementArea.x+placementArea.w, yy); ctx.stroke();
            }
            for(let c=1;c<placementArea.cols;c++){
                const xx = placementArea.x + c*placementArea.cellW;
                ctx.beginPath(); ctx.moveTo(xx, placementArea.y); ctx.lineTo(xx, placementArea.y+placementArea.h); ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            // 타워들 그리기 (이미지 우선)
            towers.forEach(t=>{
                const size = Math.min(placementArea.cellW, placementArea.cellH) * 0.92; // 셀에 맞춘 크기
                if(t.img && t.img.complete){
                    ctx.drawImage(t.img, t.x - size/2, t.y - size/2, size, size);
                } else {
                    // fallback: 색 원
                    ctx.save();
                    ctx.fillStyle = t.color || '#fff';
                    ctx.beginPath(); ctx.arc(t.x, t.y, size*0.42, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                // 사거리 원
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            });

            // 적 그리기 (이모지)
            enemies.forEach(e=>{
                ctx.save();
                ctx.font = `${Math.max(12, Math.floor(placementArea.cellH * 0.9))}px sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(getEnemyConfig(e.type).emoji || '👾', e.x, e.y);
                // HP bar
                const hpRatio = Math.max(0, e.health / (e.maxHealth || getEnemyConfig(e.type).health));
                const barW = placementArea.cellW * 0.9;
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(e.x - barW/2, e.y - placementArea.cellH*0.9, barW, 6);
                ctx.fillStyle = hpRatio > 0.5 ? 'rgba(0,200,0,0.9)' : 'rgba(255,200,0,0.95)';
                ctx.fillRect(e.x - barW/2, e.y - placementArea.cellH*0.9, barW*hpRatio, 6);
                ctx.restore();
            });

            // 발사체
            projectiles.forEach(p=>{
                ctx.save();
                ctx.fillStyle = p.color || '#fff';
                ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            });

            // splash effects
            splashEffects.forEach(s=>{
                ctx.save();
                ctx.fillStyle = 'rgba(255,165,0,0.2)';
                ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            });

            // 선택된 타워(이동 대기) 표시
            if(movingTower){
                ctx.save();
                ctx.strokeStyle = 'rgba(60,255,120,0.9)';
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(movingTower.x, movingTower.y, Math.min(placementArea.cellW,placementArea.cellH)*0.55, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
            // 선택된 설치 버튼에 대해 가능한 셀 강조는 hintLayer에서 처리
        }

        // 힌트 레이어 (DOM overlay) : 가볍게 셀 강조
        function renderHintLayer(){
            hintLayer.innerHTML = ''; // clear
            const frag = document.createDocumentFragment();
            // highlight available cells lightly
            placementArea.cells.forEach(cell => {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.left = (canvas.getBoundingClientRect().left + cell.x) - canvas.getBoundingClientRect().left + 'px';
                // above calculation simplifies because hintLayer sits over canvas with same size and coords; so we can use cell coords directly
                div.style.left = `${cell.x}px`;
                div.style.top = `${cell.y}px`;
                div.style.width = `${placementArea.cellW}px`;
                div.style.height = `${placementArea.cellH}px`;
                div.style.borderRadius = '4px';
                // when selected for placement or moving, show available cells (unoccupied)
                if((selectedTowerForPlacement || movingTower) && !cell.occupied){
                    div.style.background = 'rgba(50,220,120,0.08)';
                    div.style.boxShadow = 'inset 0 0 18px rgba(50,220,120,0.04)';
                } else {
                    div.style.background = 'transparent';
                }
                // faint border for occupied cells
                if(cell.occupied){
                    div.style.border = '1px solid rgba(255,255,255,0.03)';
                } else {
                    div.style.border = '1px dashed rgba(255,255,255,0.02)';
                }
                frag.appendChild(div);
            });

            // also add a small legend near top-left of placementArea
            const legend = document.createElement('div');
            legend.style.position = 'absolute';
            legend.style.left = `${placementArea.x + 8}px`;
            legend.style.top = `${placementArea.y + 8}px`;
            legend.style.padding = '6px 8px';
            legend.style.borderRadius = '8px';
            legend.style.background = 'rgba(0,0,0,0.45)';
            legend.style.fontSize = '12px';
            legend.style.color = '#cfe';
            legend.textContent = (selectedTowerForPlacement ? '설치할 위치를 선택하세요' : (movingTower ? '이동할 위치를 선택하세요' : ''));
            frag.appendChild(legend);

            hintLayer.appendChild(frag);
        }

        // 유틸: UI 업데이트
        function updateUI(){
            roundStat.textContent = `Round: ${localGameState.round || 0}`;
            livesStat.textContent = `❤️ Lives: ${localGameState.lives || 0}`;
            goldStat.textContent = `💰 Gold: ${localGameState.gold || 0}`;
        }

        // 짧은 메시지 표시 (화면 중앙 위)
        let msgTimer = null;
        function flashMsg(m){
            const el = document.getElementById('msg-overlay') || (()=>{
                const d = document.createElement('div');
                d.id = 'msg-overlay';
                d.style.position = 'fixed';
                d.style.top = '78px';
                d.style.left = '50%';
                d.style.transform = 'translateX(-50%)';
                d.style.padding = '8px 14px';
                d.style.borderRadius = '10px';
                d.style.background = 'linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01))';
                d.style.color = '#ffd';
                d.style.zIndex = '200';
                d.style.fontWeight = '700';
                document.body.appendChild(d);
                return d;
            })();
            el.textContent = m;
            el.style.opacity = '1';
            if(msgTimer) clearTimeout(msgTimer);
            msgTimer = setTimeout(()=>{ el.style.opacity = '0'; }, 2000);
        }

        // 간단한 적 타겟/생성 관련 헬퍼들
        function getEnemyConfig(type){ return getEnemyConfigLegacy(type); }
        function getEnemyConfigLegacy(type){
            return {
                normal:{ type:'normal', emoji:'👽', health:60, speed:1.2, gold:5 },
                fast:{ type:'fast', emoji:'👹', health:90, speed:2.0, gold:8 },
                boss:{ type:'boss', emoji:'👿', health:1600, speed:1.0, gold:40 },
                mega_boss:{ type:'mega_boss', emoji:'👑', health:6000, speed:0.8, gold:300 }
            }[type] || { type:'normal', emoji:'?', health:60, speed:1.2, gold:5 };
        }

        // 적 타깃 찾기 이전 구현과 동일하도록 노출
        function findTarget(tower){
            return findTargetLegacy(tower);
        }
        function findTargetLegacy(tower){
            let closest=null; let minD = tower.range;
            enemies.forEach(e=>{
                const d = Math.hypot(e.x - tower.x, e.y - tower.y);
                if(d < minD){ minD = d; closest = e; }
            });
            return closest;
        }

        // 융합/조합 레시피
        function getFusionRecipe(type1, type2){
            const recipes = [
                { pair:['gatling','cluster'], result:'flamethrower' }, // 예시, 없음 -> 일반 로직으로
                { pair:['gatling','blizzard'], result:'cryo_gun' },
                { pair:['gatling','railgun'], result:'laser_cannon' },
                { pair:['cluster','blizzard'], result:'hailstorm' },
                { pair:['cluster','railgun'], result:'missile_launcher' },
                { pair:['blizzard','railgun'], result:'plasma_gun' }
            ];
            return recipes.find(r => r.pair.includes(type1) && r.pair.includes(type2));
        }

        // 메시지, 리사이즈 초기화
        updateUI();
        resize();
        renderHintLayer();

        // 반응형 이벤트
        window.addEventListener('resize', ()=>{
            resize();
            renderHintLayer();
        });

        // 자동 게임 시작
        startGame();

        // helper: legacy target find, used by tower fire
        function findTargetLegacy(tower){
            let closest = null;
            let minDist = tower.range;
            enemies.forEach(enemy=>{
                const d = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                if(d < minDist){ minDist = d; closest = enemy; }
            });
            return closest;
        }

    });

// ===== 조합법 팝업 토글 =====
const recipeBtn = document.getElementById('recipe-toggle');
const recipeModal = document.getElementById('recipe-modal');

recipeBtn.addEventListener('click', () => {
    recipeModal.style.display = recipeModal.style.display === 'none' ? 'block' : 'none';
});

// ESC로 닫기
window.addEventListener('keydown', e => {
    if(e.key === 'Escape') recipeModal.style.display = 'none';
});

    </script>
</body>
</html>
