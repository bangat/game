<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>인디언 포커</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --table-bg: #006442; --table-border: #8B4513; --card-bg: #fff;
            --card-border: #aaa; --chip-red: #d9534f; --chip-blue: #428bca;
            --chip-green: #5cb85c; --text-light: #fff; --text-dark: #333;
            --accent-color: #ffc107;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: 'GmarketSans', sans-serif;
            background-color: #1a1a1a; color: var(--text-light);
            -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }

        #game-wrapper {
            width: 100%; height: 100%; display: none; flex-direction: column;
            background: var(--table-bg);
            background-image: radial-gradient(ellipse at center, #00784e, #005034);
            position: relative;
        }

        #round-counter {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0,0,0,0.4); padding: 5px 15px;
            border-radius: 15px; font-size: 1em; font-weight: 700; z-index: 10;
        }

        .opponent-zone {
            flex: 1; display: flex; justify-content: center; align-items: center;
            width: 100%; gap: 20px;
        }
        
        .center-area {
            flex-shrink: 0;
            display: flex; flex-direction: column; align-items: center;
            padding: 10px;
        }

        .my-zone {
            flex: 1; display: flex; justify-content: center; align-items: center;
            width: 100%; position: relative;
        }

        .player-zone {
            display: flex; flex-direction: column; align-items: center;
            transition: all 0.3s ease; padding: 10px;
        }
        .player-zone.my-turn {
            transform: scale(1.1);
            filter: drop-shadow(0 0 15px var(--accent-color));
        }
        .player-zone.folded { opacity: 0.5; filter: grayscale(80%); }

        .player-info { text-align: center; }
        .player-info .avatar {
            width: 60px; height: 60px; border-radius: 50%;
            font-size: 2.5em; display: flex; justify-content: center; align-items: center;
            background-color: #f0f0f0; margin: 0 auto; border: 2px solid var(--text-light);
            overflow: hidden;
        }
        .player-info .avatar img { width: 100%; height: 100%; object-fit: contain; }
        .player-info .nickname { font-weight: 700; font-size: 1em; white-space: nowrap; margin-top: 8px; }
        .player-info .chips { font-size: 0.9em; font-weight: 700; color: var(--accent-color); }
        
        .player-card {
            width: 60px; height: 84px; background-color: var(--card-bg);
            border: 1px solid var(--card-border); border-radius: 8px;
            margin-bottom: 8px; display: flex; justify-content: center; align-items: center;
            font-size: 2.5em; font-weight: bold; color: var(--text-dark);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .my-zone .player-card { width: 70px; height: 98px; font-size: 3em; }

        .player-card.hidden {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #eee;
        }
        
        .bet-amount {
            background-color: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: 10px;
            font-size: 0.8em; font-weight: 700; margin-top: 4px; display: inline-block;
        }
        
        #pot-container { text-align: center; color: var(--text-light); }
        #game-log { font-size: 0.9em; margin-bottom: 5px; height: 20px; }
        #pot-label { font-size: 1em; }
        #pot-amount { font-size: 1.5em; font-weight: 700; color: var(--accent-color); }

        #action-controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: none; gap: 10px; z-index: 100;
        }
        .action-btn {
            padding: 12px 20px; font-size: 1.1em; font-weight: 700;
            border: none; border-radius: 25px; cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .action-btn:active { transform: scale(0.95); }
        #fold-btn { background-color: #777; color: white; }
        #call-btn { background-color: var(--chip-blue); color: white; }
        #bet-btn { background-color: var(--chip-red); color: white; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; text-align: center; background-color: rgba(0,0,0,0.8);
        }
        .modal-content { background: #2c3e50; padding: 30px; border-radius: 20px; width: 90%; max-width: 350px; }
        .modal-content h2 { font-size: 1.8em; margin-bottom: 15px; }
        .modal-content p { font-size: 1.1em; margin-bottom: 25px; color: #ddd; }
        .menu-btn { width: 100%; max-width: 250px; padding: 15px; font-size: 1.2em; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; }
        .menu-btn.primary { background-color: var(--accent-color); color: var(--text-dark); }
        
        .spinner {
            margin: 20px auto; border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; border-top: 4px solid white;
            width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="round-counter"></div>
        <div class="opponent-zone"></div>
        <div class="center-area">
            <div id="game-log"></div>
            <div id="pot-container">
                <div id="pot-label">POT</div>
                <div id="pot-amount">0</div>
            </div>
        </div>
        <div class="my-zone"></div>
        <div id="action-controls"></div>
    </div>

    <div id="info-overlay" class="overlay">
        <div class="modal-content">
            <h2 id="info-title">게임 접속 중</h2>
            <p id="info-message">잠시만 기다려주세요...</p>
            <div class="spinner" id="info-spinner"></div>
        </div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('memoryGameRooms');

        const gameWrapper = document.getElementById('game-wrapper');
        const potAmountEl = document.getElementById('pot-amount');
        const actionControls = document.getElementById('action-controls');
        const gameLogEl = document.getElementById('game-log');
        const infoOverlay = document.getElementById('info-overlay');
        const roundCounterEl = document.getElementById('round-counter');
        const opponentZone = document.querySelector('.opponent-zone');
        const myZone = document.querySelector('.my-zone');

        let myPlayerId, myNickname, myAvatar, roomId, roomRef, isHost = false;
        let currentRoomData = null;
        let isGameInitialized = false;

        const CARD_RANKS = ['2','3','4','5','6','7','8','9','10','A'];
        const TOTAL_ROUNDS = 5;
        const STARTING_CHIPS = 100;
        const ANTE = 1;

        function initialize() {
            myPlayerId = localStorage.getItem('myPlayerId');
            myNickname = localStorage.getItem('userNickname');
            myAvatar = localStorage.getItem('userAvatar');
            const urlParams = new URLSearchParams(window.location.search);
            roomId = urlParams.get('roomId');

            if (!myPlayerId || !roomId) {
                alert("잘못된 접근입니다."); window.location.href = 'index.html'; return;
            }
            
            roomRef = gameRoomsRef.child(roomId);
            joinGame();
        }

        function showInfoModal(title, message, showSpinner = false, onConfirm = null) {
            infoOverlay.querySelector('#info-title').textContent = title;
            infoOverlay.querySelector('#info-message').textContent = message;
            infoOverlay.querySelector('#info-spinner').style.display = showSpinner ? 'block' : 'none';
            
            let confirmBtn = infoOverlay.querySelector('#info-confirm-btn');
            if (!confirmBtn) {
                confirmBtn = document.createElement('button');
                confirmBtn.id = 'info-confirm-btn';
                confirmBtn.className = 'menu-btn primary';
                infoOverlay.querySelector('.modal-content').appendChild(confirmBtn);
            }
            
            if (onConfirm) {
                confirmBtn.style.display = 'block';
                confirmBtn.textContent = '확인';
                confirmBtn.onclick = () => { infoOverlay.style.display = 'none'; onConfirm(); };
            } else {
                confirmBtn.style.display = 'none';
            }
            infoOverlay.style.display = 'flex';
        }

        function joinGame() {
            roomRef.child('players/' + myPlayerId).set({ nickname: myNickname, avatar: myAvatar })
                .then(() => { roomRef.on('value', handleSnapshot); });
        }

        function handleSnapshot(snapshot) {
            if (!snapshot.exists()) {
                roomRef.off();
                showInfoModal('알림', '방이 사라졌습니다.', false, () => window.location.href = '대기실.html');
                return;
            }
            currentRoomData = snapshot.val();
            isHost = currentRoomData.hostId === myPlayerId;

            if (isHost) { roomRef.onDisconnect().remove(); } 
            else { roomRef.child('players/' + myPlayerId).onDisconnect().remove(); }

            if (isHost && currentRoomData.gameState === 'launching' && !isGameInitialized) {
                isGameInitialized = true;
                startGame();
                return;
            }

            if (currentRoomData.gameState && currentRoomData.gameState !== 'launching') {
                gameWrapper.style.display = 'flex';
                infoOverlay.style.display = 'none';
                renderGame(currentRoomData);
            }
            
            if (isHost) {
                handleGameLogic(currentRoomData);
            }
        }
        
        function startGame() {
            if (!isHost) return;
            const playerIds = Object.keys(currentRoomData.players);
            const players = {};
            playerIds.forEach(pid => {
                players[pid] = { ...currentRoomData.players[pid], chips: STARTING_CHIPS };
            });
            const firstDealerId = playerIds[0];
            roomRef.update({
                players,
                dealerId: firstDealerId,
                gameState: 'startingRound',
                currentRound: 1 
            }).then(() => {
                startNewRound({ ...currentRoomData, players, dealerId: firstDealerId, currentRound: 1 });
            });
        }

        function handleGameLogic(data) {
            const { gameState, players } = data;
            if (!gameState || !players) return;
            
            switch (gameState) {
                case 'betting':
                    const activePlayers = Object.keys(players).filter(pid => players[pid] && !players[pid].hasFolded);
                    if (activePlayers.length <= 1) {
                        setTimeout(() => endRound(data), 1000); return;
                    }
                    const firstBettor = activePlayers.find(pid => players[pid].lastAction);
                    const allBettingDone = firstBettor && activePlayers.every(pid => 
                        players[pid].lastAction && players[pid].bet === data.currentBet
                    );
                    if (allBettingDone) {
                        roomRef.update({ gameState: 'showdown' });
                    }
                    break;
                case 'showdown':
                     setTimeout(() => endRound(data), 3000);
                    break;
            }
        }
        
        function startNewRound(data) {
            if (!isHost) return;
            
            const playerIdsWithChips = Object.keys(data.players).filter(pid => data.players[pid].chips > 0);
            if (playerIdsWithChips.length < 2) {
                const winner = data.players[playerIdsWithChips[0]];
                roomRef.update({ gameState: 'finalGameOver', finalWinnerId: winner.id });
                return;
            }

            const deck = shuffleDeck();
            const updates = { pot: 0, currentBet: 0, gameLog: `라운드 ${data.currentRound} 시작!`, gameState: 'dealing' };
            const players = { ...data.players };
            let currentPot = 0;
            
            playerIdsWithChips.forEach(pid => {
                const p = players[pid];
                p.card = deck.pop();
                p.hasFolded = false;
                p.bet = Math.min(ANTE, p.chips);
                p.chips -= p.bet;
                p.lastAction = null;
                currentPot += p.bet;
            });

            updates.pot = currentPot;
            updates.currentBet = ANTE;
            updates.players = players;
            updates.currentRound = data.currentRound;

            const dealerIndex = playerIdsWithChips.indexOf(data.dealerId);
            const nextTurnIndex = (dealerIndex + 1) % playerIdsWithChips.length;
            updates.currentTurnPlayerId = playerIdsWithChips[nextTurnIndex];
            
            roomRef.update(updates).then(() => {
                setTimeout(() => roomRef.update({ gameState: 'betting' }), 1000);
            });
        }

        function endRound(data) {
            if (!isHost || data.gameState === 'startingRound') return;
            roomRef.update({ gameState: 'startingRound' });

            const { players, pot } = data;
            const activePlayers = Object.keys(players).filter(pid => players[pid] && !players[pid].hasFolded && players[pid].chips >= 0);

            let winnerId, logMessage;
            if (activePlayers.length === 1) {
                winnerId = activePlayers[0];
                logMessage = `${players[winnerId].nickname}님이 라운드 승리!`;
            } else {
                // ... (기존 승자 결정 로직과 동일) ...
                let highestCardRank = -1, winners = [];
                activePlayers.forEach(pid => {
                    const rank = CARD_RANKS.indexOf(players[pid].card);
                    if (rank > highestCardRank) { highestCardRank = rank; winners = [pid]; } 
                    else if (rank === highestCardRank) { winners.push(pid); }
                });
                if (winners.length === 1) { winnerId = winners[0]; } 
                else {
                    const playerIds = Object.keys(players);
                    const dealerIndex = playerIds.indexOf(data.dealerId);
                    let minDistance = playerIds.length;
                    winners.forEach(pid => {
                        const playerIndex = playerIds.indexOf(pid);
                        const distance = (playerIndex - dealerIndex + playerIds.length) % playerIds.length;
                        if (distance < minDistance) { minDistance = distance; winnerId = pid; }
                    });
                }
                logMessage = `${players[winnerId].nickname}님이 승리! (카드: ${players[winnerId].card})`;
            }

            const updatedPlayers = { ...players };
            updatedPlayers[winnerId].chips += pot;
            
            // 다음 라운드 또는 게임 종료 처리
            if (data.currentRound >= TOTAL_ROUNDS) {
                const finalWinner = Object.values(updatedPlayers).reduce((a, b) => a.chips > b.chips ? a : b);
                roomRef.update({ gameState: 'finalGameOver', finalWinnerId: finalWinner.id, players: updatedPlayers, gameLog: logMessage });
            } else {
                const playerIdsWithChips = Object.keys(players).filter(p => players[p].chips > 0);
                const currentDealerIndex = playerIdsWithChips.indexOf(data.dealerId);
                const nextDealerId = playerIdsWithChips.length > 0 ? playerIdsWithChips[(currentDealerIndex + 1) % playerIdsWithChips.length] : data.dealerId;
                const nextRound = data.currentRound + 1;

                roomRef.update({ players: updatedPlayers, dealerId: nextDealerId, gameLog: logMessage }).then(() => {
                    setTimeout(() => startNewRound({ ...data, players: updatedPlayers, dealerId: nextDealerId, currentRound: nextRound }), 3000);
                });
            }
        }
        
        function renderGame(data) {
            if (data.gameState === 'finalGameOver') {
                const winnerId = data.finalWinnerId;
                const winnerNickname = data.players[winnerId].nickname;
                const message = winnerId === myPlayerId ? "🎉 당신이 최종 승리했습니다! 🎉" : `😢 ${winnerNickname}님의 최종 승리! 😢`;
                showInfoModal('게임 종료!', message, false, () => {
                     if (isHost) roomRef.remove();
                     window.location.href = '대기실.html';
                });
                return;
            }

            const { players } = data;
            opponentZone.innerHTML = '';
            myZone.innerHTML = '';
            roundCounterEl.textContent = `Round ${data.currentRound || 1} / ${TOTAL_ROUNDS}`;
            potAmountEl.textContent = data.pot || 0;
            gameLogEl.textContent = data.gameLog || '인디언 포커';
            
            const playerIds = Object.keys(players || {});
            
            playerIds.forEach(pid => {
                const p = players[pid];
                if (!p) return;

                const cardToShow = (pid === myPlayerId) ? '❓' : p.card;
                const cardClass = (pid === myPlayerId) ? 'hidden' : '';
                const avatarHTML = p.avatar.startsWith('http') ? `<img src="${p.avatar}">` : p.avatar;
                const betHTML = p.bet > 0 ? `<div class="bet-amount">배팅: ${p.bet}</div>` : '';

                const playerZoneHTML = `
                    <div class="player-zone ${pid === data.currentTurnPlayerId ? 'my-turn' : ''} ${p.hasFolded ? 'folded' : ''}">
                        <div class="player-card ${cardClass}">${p.card ? cardToShow : ''}</div>
                        <div class="player-info">
                            <div class="avatar">${avatarHTML}</div>
                            <div class="nickname">${p.nickname}</div>
                            <div class="chips">칩: ${p.chips || 0}</div>
                            ${betHTML} 
                        </div>
                    </div>`;
                
                if (pid === myPlayerId) {
                    myZone.innerHTML = playerZoneHTML;
                } else {
                    opponentZone.innerHTML += playerZoneHTML;
                }
            });
            
            actionControls.innerHTML = '';
            if (data.gameState === 'betting' && data.currentTurnPlayerId === myPlayerId) {
                actionControls.style.display = 'flex';
                const myBet = players[myPlayerId].bet || 0;
                const toCall = data.currentBet - myBet;
                actionControls.innerHTML = `
                    <button id="fold-btn" class="action-btn">폴드</button>
                    <button id="call-btn" class="action-btn">${toCall > 0 ? `콜 (${toCall})` : '체크'}</button>
                    <button id="bet-btn" class="action-btn">베팅 (10)</button>
                `;
                document.getElementById('fold-btn').onclick = handleFold;
                document.getElementById('call-btn').onclick = handleCall;
                document.getElementById('bet-btn').onclick = () => handleBet(10);
            } else {
                actionControls.style.display = 'none';
            }
        }
        
        function handleFold() {
            const updates = {
                [`/players/${myPlayerId}/hasFolded`]: true,
                [`/players/${myPlayerId}/lastAction`]: 'fold',
                '/gameLog': `${myNickname}님이 폴드했습니다.`
            };
            roomRef.update(updates).then(() => advanceTurn());
        }

        function handleCall() {
            const myPlayer = currentRoomData.players[myPlayerId];
            const toCall = currentRoomData.currentBet - myPlayer.bet;
            if (myPlayer.chips < toCall) { alert('칩이 부족합니다.'); return; }
            const updates = {
                [`/players/${myPlayerId}/chips`]: myPlayer.chips - toCall,
                [`/players/${myPlayerId}/bet`]: myPlayer.bet + toCall,
                [`/pot`]: currentRoomData.pot + toCall,
                [`/players/${myPlayerId}/lastAction`]: 'call',
                '/gameLog': `${toCall > 0 ? myNickname + '님이 콜했습니다.' : myNickname + '님이 체크했습니다.'}`
            };
            roomRef.update(updates).then(() => advanceTurn());
        }

        function handleBet(amount) {
            const myPlayer = currentRoomData.players[myPlayerId];
            const toCall = currentRoomData.currentBet - myPlayer.bet;
            const totalBetAmount = toCall + amount;
            if (myPlayer.chips < totalBetAmount) { alert('칩이 부족합니다.'); return; }
            const updates = {
                [`/players/${myPlayerId}/chips`]: myPlayer.chips - totalBetAmount,
                [`/players/${myPlayerId}/bet`]: myPlayer.bet + totalBetAmount,
                [`/pot`]: currentRoomData.pot + totalBetAmount,
                [`/currentBet`]: myPlayer.bet + totalBetAmount,
                [`/players/${myPlayerId}/lastAction`]: 'bet',
                '/gameLog': `${myNickname}님이 ${amount}만큼 베팅했습니다.`
            };
            Object.keys(currentRoomData.players).forEach(pid => {
                if (pid !== myPlayerId) { updates[`/players/${pid}/lastAction`] = null; }
            });
            roomRef.update(updates).then(() => advanceTurn());
        }

        function advanceTurn() {
            if (!isHost) return;
            const playerIdsWithChips = Object.keys(currentRoomData.players).filter(pid => currentRoomData.players[pid].chips >= 0);
            const activePlayers = playerIdsWithChips.filter(pid => !currentRoomData.players[pid].hasFolded);
            if (activePlayers.length === 0) return;
            const currentIndex = activePlayers.indexOf(currentRoomData.currentTurnPlayerId);
            const nextIndex = (currentIndex + 1) % activePlayers.length;
            roomRef.child('currentTurnPlayerId').set(activePlayers[nextIndex]);
        }

        function shuffleDeck() {
            const deck = [...CARD_RANKS];
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        initialize();
    });
    </script>
</body>
</html>
