<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>리버시 게임</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #1a2a1a;
            --board-bg: #006A4E;
            --border-color: #4a2c2a;
            --primary-color: #4a8dff;
            --accent-color: #ffc84a;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
        }
        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-around; align-items: center;
            padding: 10px 15px; background-color: rgba(0,0,0,0.3);
            gap: 15px;
        }
        
        .player-info {
            display: flex; flex-direction: column;
            gap: 5px;
            flex: 1; min-width: 0;
            position: relative;
        }
        .profile-box {
            display: flex; align-items: center; gap: 8px;
            background-color: rgba(255,255,255,0.1);
            padding: 8px; border-radius: 10px;
            transition: all 0.3s ease;
        }
        .player-info.my-turn .profile-box {
            background-color: var(--accent-color);
            color: #111;
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-color);
        }
        .profile-box .avatar { 
            font-size: 1.8em; 
            width: 36px; height: 36px;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0;
        }
        .profile-box .avatar img {
            width: 100%; height: 100%;
            object-fit: contain; border-radius: 50%;
        }
        .profile-box .nickname {
            font-weight: 700; font-size: 1em;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .status-box {
            display: flex; justify-content: space-between; align-items: center;
            padding: 4px 8px; border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
        }
        .status-box .timer { font-weight: 700; font-size: 0.9em; }
        .status-box .stone-count { font-weight: 700; font-size: 1em; }

        #game-container {
            width: 100%; flex-grow: 1;
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 15px;
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
        }
       #game-board {
            position: relative;
            background-color: var(--board-bg);
            border: 8px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.4);
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            padding: 5px; gap: 2px;
            width: 95vmin;
            height: 95vmin;
            max-width: 500px;
            max-height: 500px;
        }
        .board-cell {
            background-color: rgba(0,0,0,0.15);
            border-radius: 4px;
            display: flex; justify-content: center; align-items: center;
        }
        .board-cell.valid-move::after {
            content: '';
            width: 30%; height: 30%;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            animation: pulse-valid 1.5s infinite;
        }
        @keyframes pulse-valid { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        
        /* ▼▼▼ [추가] AI 가이드를 위한 새로운 스타일 ▼▼▼ */
        .board-cell.best-move::after {
            content: '★';
            width: 70%; height: 70%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.5em;
            color: white;
            background-color: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            animation: pulse-best 1.2s infinite;
            text-shadow: 0 0 5px black;
        }
        @keyframes pulse-best {
            0% { transform: scale(0.9); box-shadow: 0 0 5px var(--accent-color); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px var(--accent-color); }
            100% { transform: scale(0.9); box-shadow: 0 0 5px var(--accent-color); }
        }
        /* ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ */

        .stone {
            width: 90%; height: 90%;
            border-radius: 50%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }
        .stone-face {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%;
            backface-visibility: hidden; -webkit-backface-visibility: hidden;
            box-shadow: inset 0 -3px 6px rgba(0,0,0,0.3), inset 0 3px 6px rgba(255,255,255,0.2), 0 3px 6px rgba(0,0,0,0.4);
        }
        .stone-face.black-face {
            background: radial-gradient(circle at 30% 30%, #555, #333 50%, #222);
            transform: rotateY(180deg);
        }
        .stone-face.white-face {
            background: radial-gradient(circle at 30% 30%, #ffffff, #f5f5f5 50%, #e0e0e0);
        }
        .stone.black { transform: rotateY(180deg); }
        .stone.white { transform: rotateY(0deg); }
        .stone.placed { animation: place-anim 0.3s ease-out; }
        @keyframes place-anim { from { transform: scale(0.5); } to { transform: scale(1); } }
        
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.7); }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid white; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal-content { background: var(--bg-color); color: #333; padding: 0; border-radius: 20px; width: 90%; max-width: 400px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; }
        .modal-header { background-color: var(--primary-color); padding: 15px; }
        .modal-header h2 { color: white; font-size: 1.8em; }
        .modal-body { padding: 25px; }
        .menu-btn { width: 100%; padding: 15px; font-size: 1.2em; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; margin: 8px 0; }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #e9eff8; color: #333; }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn:disabled { background-color: #ccc; color: #888; cursor: not-allowed; }
        #countdown-number { font-size: 8em; font-weight: 700; color: white; text-shadow: 0 0 30px rgba(255,255,255,0.8); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #score-board { margin: 20px 0; }
        .score-row { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-radius: 8px; font-size: 1.2em; font-weight: 700; margin: 8px auto; max-width: 300px; }
        .score-row.winner { background-color: var(--accent-color); color: #111; transform: scale(1.05); }
        .score-row.loser { background-color: #f0f3f4; color: #333; }
        
        .score-avatar { display: inline-flex; align-items: center; gap: 8px; }
        .score-avatar img { width: 28px; height: 28px; object-fit: contain; border-radius: 50%; }

        #chat-bubble-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.6);
            font-size: 1.8em;
            color: white;
            cursor: pointer;
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .chat-bubble {
            position: absolute;
            background-color: white; color: black;
            padding: 8px 12px; border-radius: 15px;
            max-width: 180px;
            word-wrap: break-word;
            white-space: normal;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateY(10px);
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .chat-bubble.show {
            opacity: 1;
            transform: translateY(0);
        }

        #chat-modal-content {
            max-width: 320px;
            background-color: #2c3e50;
        }
        #chat-input {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border-radius: 8px;
            border: 2px solid #95a5a6;
            background-color: #34495e;
            color: white;
            text-align: center;
        }
        #chat-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        #chat-bubbles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 150;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="chat-bubbles-container"></div>
    <div id="game-wrapper" style="display: none;">
        <div id="game-header"></div>
        <div id="game-container"><div id="game-board"></div></div>
    </div>
    
    <button id="chat-bubble-btn">💬</button>

    <div id="chat-modal" class="overlay" style="display: none;">
        <div id="chat-modal-content" class="modal-content">
            <div class="modal-header" style="background-color: #34495e;">
                <h2>채팅 메시지</h2>
            </div>
            <div class="modal-body">
                <input type="text" id="chat-input" placeholder="메시지를 입력하세요 (최대 20자)" maxlength="20">
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="chat-cancel-btn" class="menu-btn secondary" style="margin:0;">취소</button>
                    <button id="chat-send-btn" class="menu-btn primary" style="margin:0; background-color: var(--accent-color); color: #111;">전송</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="info-overlay" class="overlay">
        <div class="modal-content" style="background: white; padding: 25px;">
            <p style="color: #333; font-size: 1.3em; margin-bottom: 20px;">게임을 불러오는 중...</p>
            <div class="spinner" style="border-top-color: var(--primary-color);"></div>
        </div>
    </div>

    <audio id="place-sound" src="https://blog.kakaocdn.net/dna/cnH2Cr/dJMb9MbM5sW/AAAAAAAAAAAAAAAAAAAAAK8LHWNFSSUShSE7hgIkidBVnIkUD5U5vzXrBx2W9hE-/%EC%98%A4%EB%8D%B8%EB%A1%9C.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=CCe1TksJn9y0CIFXF%2Bwys7LCNYA%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    <audio id="flip-sound" src="https://blog.kakaocdn.net/dna/bBfLgT/dJMb9YwY4fF/AAAAAAAAAAAAAAAAAAAAAAKzHw-12dE9FjL7iWk1m70Y0JqL243dYvG7b5gJ0wK1/cardsound32562-37691.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=2XU4lIeFhV%2Fz11qWnQc4%252B0V5I8o%253D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    <audio id="win-sound" src="https://blog.kakaocdn.net/dna/kC4is/dJMb8WZJowA/AAAAAAAAAAAAAAAAAAAAAIQeZhVDJf0ZGAWyyMr_hsc6TMe3BFUVXd0FNTl5VDcY/%EA%B2%8C%EC%9D%B4%EC%8A%B9%EB%A6%AC.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=qZKwGj5NQeAFNrOvCPAMXc6aX9I%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    <audio id="loss-sound" src="https://blog.kakaocdn.net/dna/Zqr4u/dJMb9V0NWlD/AAAAAAAAAAAAAAAAAAAAANQFEr99iVFS25T5ZW3Q2dixeZXsbUzh7OWB40uYQMu9/%EC%95%8C%EA%B9%8C%EA%B8%B0%ED%8C%A8%EB%B0%B0.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=2xNnbSadPzs2ZZi1BssfyCye8jI%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
               (function() {
    const devtools = {
        isOpen: false,
        orientation: undefined
    };
    const threshold = 160;
    const emitEvent = (isOpen, orientation) => {
        window.dispatchEvent(new CustomEvent('devtoolschange', {
            detail: {
                isOpen,
                orientation
            }
        }));
    };
    const main = ({emitEvents = true} = {}) => {
        const widthThreshold = window.outerWidth - window.innerWidth > threshold;
        const heightThreshold = window.outerHeight - window.innerHeight > threshold;
        const orientation = widthThreshold ? 'vertical' : 'horizontal';
        if (!(heightThreshold && widthThreshold) && ((window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized) || widthThreshold || heightThreshold)) {
            if (!devtools.isOpen || devtools.orientation !== orientation) {
                if (emitEvents) {
                    emitEvent(true, orientation);
                }
            }
            devtools.isOpen = true;
            devtools.orientation = orientation;
        } else {
            if (devtools.isOpen) {
                if (emitEvents) {
                    emitEvent(false, undefined);
                }
            }
            devtools.isOpen = false;
            devtools.orientation = undefined;
        }
    };
    main({emitEvents: false});
    setInterval(main, 500);
    window.addEventListener('devtoolschange', event => {
        if (event.detail.isOpen) {
            document.body.innerHTML = '<div style="color:white; font-size:2em; text-align:center; padding-top:100px;">Developer tools are not allowed.</div>';
        }
    });
    document.addEventListener('contextmenu', e => e.preventDefault());
    function blockKeys(e) {
        if (
            e.keyCode === 123 ||
            (e.ctrlKey && e.shiftKey && (e.keyCode === 'I'.charCodeAt(0) || e.keyCode === 'J'.charCodeAt(0) || e.keyCode === 'C'.charCodeAt(0))) ||
            (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0))
        ) {
            e.preventDefault();
        }
    }
    window.addEventListener('keydown', blockKeys);
    function checkDebugger() {
        const before = new Date().getTime();
        debugger;
        const after = new Date().getTime();
        if (after - before > 100) {
            document.body.innerHTML = '<div style="color:white; font-size:2em; text-align:center; padding-top:100px;">Developer tools are not allowed.</div>';
        }
    }
    if (document.readyState === 'complete') {
        checkDebugger();
        setInterval(checkDebugger, 1000);
    } else {
        window.addEventListener('load', () => {
            checkDebugger();
            setInterval(checkDebugger, 1000);
        });
    }
})();
      

        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('memoryGameRooms');
        const playersStatsRef = database.ref('users');

        const gameWrapper = document.getElementById('game-wrapper');
        const gameBoard = document.getElementById('game-board');
        const gameHeader = document.getElementById('game-header');
        const infoOverlay = document.getElementById('info-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const chatBubbleBtn = document.getElementById('chat-bubble-btn');
        
        let myPlayerId, myNickname, myAvatar, myColor;
        let roomRef, currentRoomData, isHost;
        let isGameLive = false, roomListener, gameOverFlag = false;
        let previousPlayerIds = [];

        let turnTimerInterval = null;
        const SPECIAL_USER_ID = "6LSUyYe5gQVZOQiMBsOCJOSBfWf2"; 
        const WEIGHT_MAP = [
            120, -20,  20,   5,   5,  20, -20, 120,
            -20, -40,  -5,  -5,  -5,  -5, -40, -20,
             20,  -5,  15,   3,   3,  15,  -5,  20,
              5,  -5,   3,   3,   3,   3,  -5,   5,
              5,  -5,   3,   3,   3,   3,  -5,   5,
             20,  -5,  15,   3,   3,  15,  -5,  20,
            -20, -40,  -5,  -5,  -5,  -5, -40, -20,
            120, -20,  20,   5,   5,  20, -20, 120
        ];

        let lastChatTimestamp = 0;
        let lastRenderedBoardState = null;
        let lastRenderedHeaderState = null;
        
        function playSound(id) {
            const sound = document.getElementById(id);
            if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
        }

        function getPlayerInfo() {
            myPlayerId = localStorage.getItem('myPlayerId');
            myNickname = localStorage.getItem('userNickname');
            myAvatar = localStorage.getItem('userAvatar');
            if (!myPlayerId) {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
                return false;
            }
            return true;
        }

        function listenToRoomChanges() {
            if(roomListener) roomRef.off('value', roomListener);

            roomListener = roomRef.on('value', snapshot => {
                if (snapshot.val() && snapshot.val().gameState === 'restarting') {
                    location.reload();
                    return;
                }
                if (!snapshot.exists()) {
                    if(isGameLive) alert("방이 해체되었습니다. 대기실로 이동합니다.");
                    cleanupAndExit();
                    return;
                }
                currentRoomData = snapshot.val();
                
                const currentPlayerIds = Object.keys(currentRoomData.players || {});
                if (['playing', 'ready'].includes(currentRoomData.gameState) && !gameOverFlag && previousPlayerIds.length === 2 && currentPlayerIds.length < 2) {
                    const loserId = previousPlayerIds.find(id => !currentPlayerIds.includes(id));
                    if (loserId) {
                        handleDisconnectWin(loserId);
                        return;
                    }
                }
                previousPlayerIds = currentPlayerIds;
                
                if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                    if (isGameLive) alert("방에서 제외되었습니다. 대기실로 이동합니다.");
                    cleanupAndExit();
                    return;
                }
                
                isGameLive = true; 
                roomRef.child('players/' + myPlayerId).onDisconnect().remove();

                isHost = currentRoomData.hostId === myPlayerId;
                myColor = currentRoomData.players[myPlayerId]?.color;

                if (currentRoomData.latestChat && currentRoomData.latestChat.timestamp > lastChatTimestamp) {
                    lastChatTimestamp = currentRoomData.latestChat.timestamp;
                    showChatBubble(currentRoomData.latestChat.senderId, currentRoomData.latestChat.message);
                }
                
                if(isHost) {
                    manageTurnTimer();
                }

                const newHeaderState = JSON.stringify({ players: currentRoomData.players, turn: currentRoomData.turn });
                if (newHeaderState !== lastRenderedHeaderState) {
                    updateHeaderUI();
                    lastRenderedHeaderState = newHeaderState;
                }

                const newBoardState = JSON.stringify({ board: currentRoomData.board, turn: currentRoomData.turn, gameState: currentRoomData.gameState });
                if (newBoardState !== lastRenderedBoardState) {
                    drawBoard();
                    lastRenderedBoardState = newBoardState;
                }

                switch(currentRoomData.gameState) {
                    case 'launching':
                        if (isHost) initializeMultiplayerGame();
                        break;
                    case 'ready':
                        gameWrapper.style.display = 'flex';
                        infoOverlay.style.display = 'none';
                        if (!document.querySelector('#countdown-number')) startCountdown();
                        break;
                    case 'playing':
                        infoOverlay.style.display = 'none';
                        break;
                    case 'gameOver':
                        if (!gameOverFlag) {
                            gameOverFlag = true;
                            if(turnTimerInterval) clearInterval(turnTimerInterval);
                            showGameOverScreen();
                        }
                        break;
                }
            });
        }
        
        function initializeMultiplayerGame() {
            if (!isHost || !currentRoomData) return;
            const players = currentRoomData.players;
            const playerIds = Object.keys(players);
            playerIds.sort(() => Math.random() - 0.5);
            players[playerIds[0]].color = 'black';
            players[playerIds[1]].color = 'white';
            
            players[playerIds[0]].remainingTime = 300;
            players[playerIds[1]].remainingTime = 300;
            
            const initialBoard = Array(64).fill(null);
            initialBoard[27] = 'white'; initialBoard[28] = 'black';
            initialBoard[35] = 'black'; initialBoard[36] = 'white';

            roomRef.update({
                gameState: 'ready',
                board: initialBoard,
                turn: 'black',
                players: players,
                passedTurn: false,
                lastMove: null,
                gameOver: null,
                rematchRequests: null,
                latestChat: null
            });
        }

        function startCountdown() {
            infoOverlay.innerHTML = `<div id="countdown-number">3</div>`;
            infoOverlay.style.background = 'rgba(0,0,0,0.7)';
            infoOverlay.style.display = 'flex';
            let count = 3;
            const countdownInterval = setInterval(() => {
                const countdownEl = document.getElementById('countdown-number');
                count--;
                if (count > 0) {
                    if(countdownEl) {
                        countdownEl.style.animation = 'none';
                        countdownEl.offsetHeight;
                        countdownEl.style.animation = 'countdown-pop 1s';
                        countdownEl.textContent = count;
                    }
                } else {
                    clearInterval(countdownInterval);
                    if (isHost) {
                        roomRef.child('gameState').set('playing');
                    }
                }
            }, 1000);
        }
function findBestMove(board, color) {
            const validMoves = findValidMoves(board, color);
            if (validMoves.length === 0) return -1;

            let bestMove = -1;
            let maxScore = -Infinity; 

            const opponentColor = color === 'black' ? 'white' : 'black';
            const directions = [-9, -8, -7, -1, 1, 7, 8, 9];

            validMoves.forEach(move => {
                let currentFlips = 0;
                directions.forEach(dir => {
                    const stonesToFlip = [];
                    let current = move + dir;
                    while (current >= 0 && current < 64 && Math.abs((current % 8) - ((current - dir) % 8)) <= 1) {
                        if (board[current] === opponentColor) {
                            stonesToFlip.push(current);
                        } else if (board[current] === color) {
                            currentFlips += stonesToFlip.length;
                            break;
                        } else { break; }
                        current += dir;
                    }
                });

                const positionScore = WEIGHT_MAP[move];
                const totalScore = currentFlips + positionScore;

                if (totalScore > maxScore) {
                    maxScore = totalScore;
                    bestMove = move;
                }
            });

            return bestMove;
        }

        function drawBoard() {
            if (!currentRoomData || !currentRoomData.board) return;
            gameBoard.innerHTML = '';
            const { board, turn, gameState } = currentRoomData;
            const validMoves = (myColor === turn && gameState === 'playing') ? findValidMoves(board, myColor) : [];
            
            // ▼▼▼ [수정] 특정 유저일 경우, 최적의 수를 계산합니다. ▼▼▼
            let bestMoveIndex = -1;
            if (myPlayerId === SPECIAL_USER_ID && myColor === turn && gameState === 'playing') {
                bestMoveIndex = findBestMove(board, myColor);
            }
            // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

            for (let index = 0; index < 64; index++) {
                const cell = board[index];
                const cellEl = document.createElement('div');
                cellEl.className = 'board-cell';

                // ▼▼▼ [수정] 최적의 수와 일반 수를 구분하여 클래스를 추가합니다. ▼▼▼
                if (validMoves.includes(index)) {
                    if (index === bestMoveIndex) {
                        cellEl.classList.add('best-move'); // 최적의 수는 다른 스타일 적용
                    } else {
                        cellEl.classList.add('valid-move');
                    }
                    cellEl.addEventListener('click', () => handleCellClick(index));
                }
                // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

                if (cell) {
                    const stoneEl = document.createElement('div');
                    stoneEl.className = 'stone';
                    stoneEl.innerHTML = `<div class="stone-face white-face"></div><div class="stone-face black-face"></div>`;
                    stoneEl.classList.add(cell); 
                    if (currentRoomData.lastMove === index) {
                         stoneEl.classList.add('placed');
                    }
                    cellEl.appendChild(stoneEl);
                }
                gameBoard.appendChild(cellEl);
            }
        }

       function handleCellClick(index) {
            if(currentRoomData.turn !== myColor) return;
            playSound('place-sound');
            const newBoard = Array.from({ length: 64 }, (_, i) => currentRoomData.board[i] || null);
            newBoard[index] = myColor;
            const opponentColor = myColor === 'black' ? 'white' : 'black';
            const directions = [-9, -8, -7, -1, 1, 7, 8, 9];
            let flipped = false;
            directions.forEach(dir => {
                const stonesToFlip = [];
                let current = index + dir;
                while (current >= 0 && current < 64 && Math.abs((current % 8) - ((current - dir) % 8)) <= 1) {
                    if (newBoard[current] === opponentColor) stonesToFlip.push(current);
                    else if (newBoard[current] === myColor) {
                        stonesToFlip.forEach(pos => newBoard[pos] = myColor);
                        if(stonesToFlip.length > 0) flipped = true;
                        break;
                    } 
                    else break;
                    current += dir;
                }
            });
            if(flipped) setTimeout(() => playSound('flip-sound'), 200);
            const nextTurnColor = opponentColor;
            const nextPlayerHasMoves = findValidMoves(newBoard, nextTurnColor).length > 0;
            const currentPlayerHasMoves = findValidMoves(newBoard, myColor).length > 0;
            const updates = { board: newBoard, lastMove: index };
            if (nextPlayerHasMoves) {
                updates.turn = nextTurnColor;
                updates.passedTurn = false;
            } else if (currentPlayerHasMoves) {
                updates.turn = myColor;
                updates.passedTurn = true;
            } else {
                updates.gameState = 'gameOver';
            }
            roomRef.update(updates);
        }

        function findValidMoves(board, color) {
            const opponentColor = color === 'black' ? 'white' : 'black';
            const validMoves = [];
            const directions = [-9, -8, -7, -1, 1, 7, 8, 9];
            for (let i = 0; i < 64; i++) {
                if (board[i]) continue;
                let isValidForThisCell = false;
                for (const dir of directions) {
                    const firstStep = i + dir;
                    const col = i % 8;
                    if ((dir === 1 || dir === -7 || dir === 9) && col === 7) continue;
                    if ((dir === -1 || dir === 7 || dir === -9) && col === 0) continue;
                    if (firstStep < 0 || firstStep >= 64 || board[firstStep] !== opponentColor) continue;
                    let current = firstStep + dir;
                    while (current >= 0 && current < 64) {
                        const currentCol = current % 8;
                        const prevCol = (current - dir) % 8;
                        if(Math.abs(currentCol - prevCol) > 1) break;
                        if (board[current] === color) { isValidForThisCell = true; break; }
                        if (!board[current]) break;
                        current += dir;
                    }
                    if (isValidForThisCell) break;
                }
                if (isValidForThisCell) validMoves.push(i);
            }
            return validMoves;
        }

        function updateHeaderUI() {
            if (!currentRoomData || !currentRoomData.players) return;
            const { players, board, turn } = currentRoomData;
            const playerIds = Object.keys(players);
            gameHeader.innerHTML = '';
            let playerInfos = playerIds.map(pid => ({ ...players[pid], id: pid }));
            
            if (players[playerIds[0]].color) {
                 playerInfos.sort((a,b) => (a.id === myPlayerId ? -1 : 1));
            }

            playerInfos.forEach((p, index) => {
                const stoneCount = board ? Object.values(board).filter(c => c === p.color).length : 2;
                const stoneIcon = p.color ? (p.color === 'black' ? '⚫' : '⚪') : '';
                const avatarHTML = p.avatar.startsWith('http') ? `<img src="${p.avatar}" alt="av">` : p.avatar;
                const time = p.remainingTime ?? 300;
                const minutes = Math.floor(time / 60).toString().padStart(2, '0');
                const seconds = (time % 60).toString().padStart(2, '0');
                const infoEl = document.createElement('div');
                infoEl.className = 'player-info';
                infoEl.dataset.playerId = p.id;
                if (turn === p.color) infoEl.classList.add('my-turn');
                infoEl.classList.add(index === 0 ? 'player-left' : 'player-right');
                infoEl.innerHTML = `
                    <div class="profile-box">
                        <div class="avatar">${avatarHTML}</div>
                        <div class="nickname">${p.nickname}</div>
                    </div>
                    <div class="status-box">
                        <div class="timer">${minutes}:${seconds}</div>
                        <div class="stone-count">${stoneIcon} ${stoneCount}</div>
                    </div>`;
                gameHeader.appendChild(infoEl);
            });
        }
        
       async function showGameOverScreen() {
            const { players, board, winReason } = currentRoomData;
            let winnerColor, message;

            // --- ★★★ 핵심 수정: 방장이 모든 플레이어의 전적을 책임지고 업데이트 ★★★ ---
            if (isHost && !currentRoomData.gameOver) {
                if (winReason === 'timeout') {
                    // 시간 초과 시
                    const winner = players[currentRoomData.winnerId];
                    const loser = Object.values(players).find(p => p.id !== currentRoomData.winnerId);
                    await updatePlayerStats(winner.id, true, false);
                    await updatePlayerStats(loser.id, false, false);
                } else {
                    // 일반 종료 시
                    const blackCount = Object.values(board).filter(c => c === 'black').length;
                    const whiteCount = Object.values(board).filter(c => c === 'white').length;
                    
                    if (blackCount === whiteCount) { // 무승부
                        for (const pid in players) { await updatePlayerStats(pid, false, true); }
                    } else { // 승패
                        const winningColor = blackCount > whiteCount ? 'black' : 'white';
                        for (const pid in players) { await updatePlayerStats(pid, players[pid].color === winningColor, false); }
                    }
                }
                roomRef.child('gameOver').set(true); // 모든 업데이트 후 상태 변경
            }
            // --- ★★★ 수정 종료 ★★★ ---

            // 아래는 화면 표시 로직이므로 기존과 거의 동일합니다.
            if (winReason === 'timeout') {
                const winner = players[currentRoomData.winnerId];
                winnerColor = winner.color;
            } else {
                const blackCount = Object.values(board).filter(c => c === 'black').length;
                const whiteCount = Object.values(board).filter(c => c === 'white').length;
                if (blackCount > whiteCount) winnerColor = 'black';
                else if (whiteCount > blackCount) winnerColor = 'white';
            }
            
            const amITheWinnerFinal = winnerColor === myColor;
            message = winnerColor ? (amITheWinnerFinal ? "🎉 승 리 !" : "😢 패 배...") : "무승부!";
            playSound(winnerColor ? (amITheWinnerFinal ? 'win-sound' : 'loss-sound') : 'loss-sound');

            const scoresHTML = Object.values(players).sort((a,b) => (a.color === 'black' ? -1 : 1)).map(p => {
                const count = Object.values(board).filter(c => c === p.color).length;
                const avatarHTML = p.avatar.startsWith('http') ? `<img src="${p.avatar}" alt="avatar">` : p.avatar;
                return `<div class="score-row ${p.color === winnerColor ? 'winner' : 'loser'}"><span class="score-avatar">${avatarHTML} ${p.nickname}</span><span>${p.color === 'black' ? '⚫' : '⚪'} ${count}</span></div>`;
            }).join('');

            gameOverOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>${message}</h2></div><div class="modal-body"><div id="score-board">${scoresHTML}</div><button id="rematch-btn" class="menu-btn primary">다시 하기</button><button id="lobby-btn" class="menu-btn secondary">나가기</button></div></div>`;
            gameOverOverlay.style.display = 'flex';
            
            const rematchBtn = document.getElementById('rematch-btn');
            rematchBtn.addEventListener('click', () => {
                rematchBtn.textContent = '상대방 기다리는 중...'; 
                rematchBtn.disabled = true;
                roomRef.child('rematchRequests/' + myPlayerId).set(true);
            });
            document.getElementById('lobby-btn').addEventListener('click', cleanupAndExit);
            
            const rematchListener = roomRef.child('rematchRequests').on('value', snapshot => {
                if (!snapshot.exists() || !currentRoomData.players) return;
                if (snapshot.numChildren() === Object.keys(currentRoomData.players).length) {
                    roomRef.child('rematchRequests').off('value', rematchListener);
                    if (isHost) startRematch();
                }
            });
        }
        
        function startRematch() {
            if (!isHost) return;
            gameOverFlag = false;
            lastRenderedBoardState = null;
            lastRenderedHeaderState = null;
            roomRef.update({ 
                gameState: 'launching', 
                board: null, turn: null, 
                players: Object.fromEntries(Object.entries(currentRoomData.players).map(([id, p]) => [id, {...p, color: null}])),
                gameOver: null, rematchRequests: null, winReason: null, winnerId: null
            });
        }
        
        async function handleDisconnectWin(loserId) {
            if (gameOverFlag) return;
            gameOverFlag = true;
            if (turnTimerInterval) clearInterval(turnTimerInterval);

            await updatePlayerStats(myPlayerId, true, false);
            await updatePlayerStats(loserId, false, false);

            playSound('win-sound');

            gameOverOverlay.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header"><h2>🎉 승 리 !</h2></div>
                    <div class="modal-body">
                        <p style="color: white; font-size: 1.2em; margin-bottom: 25px;">
                            상대방이 게임을 나가서 승리했습니다.
                        </p>
                        <button id="lobby-btn" class="menu-btn secondary">나가기</button>
                    </div>
                </div>`;
            gameOverOverlay.style.display = 'flex';
            
            document.getElementById('lobby-btn').addEventListener('click', cleanupAndExit);
        }

        async function updatePlayerStats(pid, isWinner, isDraw = false) {
            if (!pid || pid.startsWith('guest_')) return;
            
            const playerStatRef = playersStatsRef.child(pid);
            const gameId = 'reversi';
            let expToAdd = 10;
            if (isDraw) expToAdd = 25;
            if (isWinner) expToAdd = 50;

            try {
                await playerStatRef.transaction(currentData => {
                    if (currentData) {
                        if (!currentData.stats) currentData.stats = {};
                        if (!currentData.stats[gameId]) {
                            currentData.stats[gameId] = { wins: 0, losses: 0, draws: 0 };
                        }

                        if (isDraw) {
                            currentData.stats[gameId].draws = (currentData.stats[gameId].draws || 0) + 1;
                        } else if (isWinner) {
                            currentData.stats[gameId].wins = (currentData.stats[gameId].wins || 0) + 1;
                        } else {
                            currentData.stats[gameId].losses = (currentData.stats[gameId].losses || 0) + 1;
                        }
                        currentData.exp = (currentData.exp || 0) + expToAdd;
                    }
                    return currentData;
                });
            } catch (e) {
                console.error("리버시 전적 업데이트 실패:", pid, e);
            }
        }

        function showChatBubble(senderId, message) {
            const isMyMessage = senderId === myPlayerId;
            const targetClass = isMyMessage ? '.player-left' : '.player-right';
            const playerInfoEl = document.querySelector(`.player-info${targetClass}`);
            if (!playerInfoEl) return;

            const bubblesContainer = document.getElementById('chat-bubbles-container');
            const rect = playerInfoEl.getBoundingClientRect();
            const bubbleEl = document.createElement('div');
            bubbleEl.className = 'chat-bubble';
            bubbleEl.textContent = message;
            const escapeHtml = (unsafe) => {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            };
            bubbleEl.innerHTML = escapeHtml(message);
            
            bubbleEl.style.top = `${rect.bottom + 5}px`;

            if (isMyMessage) {
                bubbleEl.style.left = `${rect.left}px`;
            } else {
                bubbleEl.style.right = `${window.innerWidth - rect.right}px`;
            }

            bubblesContainer.appendChild(bubbleEl);
            setTimeout(() => {
                bubbleEl.classList.add('show');
            }, 10);

            setTimeout(() => {
                bubbleEl.classList.remove('show');
                setTimeout(() => {
                    if (bubbleEl.parentElement) {
                        bubbleEl.parentElement.removeChild(bubbleEl);
                    }
                }, 500);
            }, 3000); 
        }

        function manageTurnTimer() {
            if (turnTimerInterval) clearInterval(turnTimerInterval);
            if (currentRoomData.gameState !== 'playing') return;
            const turnPlayerId = Object.keys(currentRoomData.players).find(pid => currentRoomData.players[pid].color === currentRoomData.turn);
            if (!turnPlayerId) return;
            let remainingTime = currentRoomData.players[turnPlayerId].remainingTime;
            turnTimerInterval = setInterval(() => {
                if (remainingTime > 0) {
                    remainingTime--;
                    roomRef.child('players/' + turnPlayerId + '/remainingTime').set(remainingTime);
                } else {
                    clearInterval(turnTimerInterval);
                    handleTimeOutLoss(turnPlayerId);
                }
            }, 1000);
        }

        function handleTimeOutLoss(loserId) {
            if (!isHost || currentRoomData.gameState === 'gameOver') return;
            const winnerId = Object.keys(currentRoomData.players).find(pid => pid !== loserId);
            roomRef.update({
                gameState: 'gameOver',
                winReason: 'timeout',
                winnerId: winnerId
            });
        }

        function cleanupAndExit() {
            isGameLive = false;
            if (turnTimerInterval) clearInterval(turnTimerInterval);
            if (roomRef) {
                if(roomListener) roomRef.off('value', roomListener);
                roomRef.child('players/' + myPlayerId).onDisconnect().cancel();
                const playerRef = roomRef.child('players/' + myPlayerId);
                playerRef.remove().then(() => {
                    roomRef.child('players').once('value', snapshot => {
                       if (!snapshot.exists() || snapshot.numChildren() < 2) {
                           if(isHost) roomRef.remove();
                           else roomRef.update({ gameState: 'restarting' });
                       }
                    });
                });
            }
            roomRef = null;
            window.location.href = '대기실.html';
        }

        if (getPlayerInfo()) {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            if (roomId) {
                roomRef = gameRoomsRef.child(roomId);
                listenToRoomChanges();

                const chatModal = document.getElementById('chat-modal');
                const chatInput = document.getElementById('chat-input');
                const chatSendBtn = document.getElementById('chat-send-btn');
                const chatCancelBtn = document.getElementById('chat-cancel-btn');

                const sendMessage = () => {
                    const message = chatInput.value;
                    if (message && message.trim() !== '' && roomRef) {
                        roomRef.child('latestChat').set({
                            senderId: myPlayerId,
                            message: message.substring(0, 20),
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        });
                        chatInput.value = '';
                        chatModal.style.display = 'none';
                    }
                };

                chatBubbleBtn.addEventListener('click', () => {
                    chatModal.style.display = 'flex';
                    setTimeout(() => chatInput.focus(), 50);
                });

                chatSendBtn.addEventListener('click', sendMessage);

                chatCancelBtn.addEventListener('click', () => {
                    chatInput.value = '';
                    chatModal.style.display = 'none';
                });

                chatInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        sendMessage();
                    }
                });
            } else {
                alert("잘못된 접근입니다. 대기실을 통해 입장해주세요.");
                window.location.href = '대기실.html';
            }
        }
    });
    </script>
</body>
</html>
