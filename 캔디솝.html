<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>캔디솝 챌린지</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #F8F0E5; --primary-color: #FF69B4; --accent-color: #89CFF0;
            --text-dark: #3A3A3A; --correct-color: #28a745; --wrong-color: #dc3545;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif; background-color: var(--bg-color);
            color: var(--text-dark); -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }

        #game-wrapper {
            width: 100%; height: 100%; display: flex; flex-direction: column; opacity: 0; transition: opacity 0.5s;
        }

        #header {
            padding: 10px 5px; text-align: center; display: flex; justify-content: space-around;
        }
        .stat-box { 
            font-size: 1.1em; font-weight: 700; flex: 1; text-align: center; white-space: nowrap;
        }
        #combo-display { color: var(--primary-color); }

        #game-area {
            flex-grow: 1; position: relative; display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
        }
        #instruction-text {
            font-size: 2.5em; font-weight: 700; padding: 20px;
            background-color: rgba(255,255,255,0.7); border-radius: 20px;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            position: absolute; top: 10px;
        }
        
        #feedback-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3em; font-weight: 700; color: var(--primary-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            z-index: 20; opacity: 0; pointer-events: none;
            transition: opacity 0.5s, transform 0.5s;
        }
        #feedback-text.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        #mode-change-alert {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 2em; font-weight: 700; padding: 25px;
            background-color: var(--primary-color); color: white; border-radius: 20px;
            z-index: 20; opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }

        #hands-container {
            display: flex; width: 100%; height: 45%; align-items: center; justify-content: center;
        }
        .hand-area {
            width: 50%; height: 100%; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s, width 0.3s;
        }
        .hand-area .hand-image {
            width: 80%; max-width: 250px; position: relative;
        }
        
        #hands-container.three-item-mode .hand-area {
            width: 33.33%;
        }
        
        #middle-item-area .hand-image {
             width: 65%; max-width: 200px;
        }
        
        .item-emoji {
            position: absolute;
            font-size: 5em;
            transform: translate(-50%, -100%);
            left: 50%; top: 50%;
            z-index: 5;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        #left-hand-area .hand-image { transform: scaleX(-1); }

        #feedback-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #feedback-overlay.correct { background-color: rgba(40, 167, 69, 0.3); opacity: 1; }
        #feedback-overlay.wrong { background-color: rgba(220, 53, 69, 0.3); opacity: 1; animation: shake 0.3s; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); }
        }

        #timer-bar-container { width: 100%; height: 10px; background-color: #ddd; }
        #timer-bar { width: 100%; height: 100%; background-color: var(--accent-color); transition: width 0.1s linear; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center; background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background: #fff; padding: 30px; border-radius: 20px;
            width: 90%; max-width: 350px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-content h2 { font-size: 2em; margin-bottom: 20px; }
        #final-score { font-size: 3em; color: var(--primary-color); font-weight: 700; }
        .modal-buttons { margin-top: 30px; display: flex; flex-direction: column; gap: 15px; }
        .menu-btn { padding: 15px; font-size: 1.2em; font-weight: 700; border-radius: 12px; border: none; cursor: pointer; }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #eee; color: var(--text-dark); }
        .menu-btn:disabled { background-color: #ccc; cursor: not-allowed; }

        #countdown-text { font-size: 10em; color: white; font-weight: 700; animation: countdown-pop 0.9s ease-out; }
        @keyframes countdown-pop {
            from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="header">
            <div class="stat-box">점수: <span id="score-display">0</span></div>
            <div class="stat-box">콤보: <span id="combo-display">0</span></div>
            <div class="stat-box">❤️ <span id="lives-display">4</span></div>
            <div class="stat-box">시간: <span id="time-display">60</span></div>
        </div>

        <div id="game-area">
            <div id="instruction-text"></div>
            <div id="feedback-text"></div>
            <div id="mode-change-alert">솜사탕 추가!</div>
            <div id="hands-container">
                <div id="left-hand-area" class="hand-area">
                    <div class="hand-image">
                        <svg viewBox="0 0 512 512" style="width:100%; fill:#ffdeb2;"><path d="M192 128C192 92.65 220.7 64 256 64C291.3 64 320 92.65 320 128V384C320 401.7 305.7 416 288 416H224C206.3 416 192 401.7 192 384V128zM32 224C32 188.7 60.65 160 96 160C131.3 160 160 188.7 160 224V384C160 401.7 145.7 416 128 416H96C78.33 416 64 401.7 64 384V224zM352 224V384C352 401.7 366.3 416 384 416H416C433.7 416 448 401.7 448 384V224C448 188.7 420.7 160 384 160C348.7 160 320 188.7 320 224H352zM448 128C448 110.3 462.3 96 480 96C497.7 96 512 110.3 512 128V384C512 457.7 457.7 512 384 512H128C52.25 512 0 457.7 0 384V128C0 110.3 14.33 96 32 96C49.67 96 64 110.3 64 128V384C64 422.1 93.88 448 128 448H384C422.1 448 448 422.1 448 384V128z"/></svg>
                        <span id="left-item" class="item-emoji"></span>
                    </div>
                </div>
                <div id="middle-item-area" class="hand-area" style="display: none;">
                     <div class="hand-image">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width:100%; fill:#ffdeb2;"><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"/></svg>
                        <span id="middle-item" class="item-emoji"></span>
                    </div>
                </div>
                <div id="right-hand-area" class="hand-area">
                    <div class="hand-image">
                        <svg viewBox="0 0 512 512" style="width:100%; fill:#ffdeb2;"><path d="M192 128C192 92.65 220.7 64 256 64C291.3 64 320 92.65 320 128V384C320 401.7 305.7 416 288 416H224C206.3 416 192 401.7 192 384V128zM32 224C32 188.7 60.65 160 96 160C131.3 160 160 188.7 160 224V384C160 401.7 145.7 416 128 416H96C78.33 416 64 401.7 64 384V224zM352 224V384C352 401.7 366.3 416 384 416H416C433.7 416 448 401.7 448 384V224C448 188.7 420.7 160 384 160C348.7 160 320 188.7 320 224H352zM448 128C448 110.3 462.3 96 480 96C497.7 96 512 110.3 512 128V384C512 457.7 457.7 512 384 512H128C52.25 512 0 457.7 0 384V128C0 110.3 14.33 96 32 96C49.67 96 64 110.3 64 128V384C64 422.1 93.88 448 128 448H384C422.1 448 448 422.1 448 384V128z"/></svg>
                        <span id="right-item" class="item-emoji"></span>
                    </div>
                </div>
            </div>
            <div id="feedback-overlay"></div>
        </div>

        <div id="timer-bar-container"><div id="timer-bar"></div></div>
    </div>

    <div id="info-overlay" class="overlay">
        <div id="countdown-text">3</div>
    </div>

    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="game-over-title">게임 종료!</h2>
            <p style="font-size: 1.2em;">최종 점수</p>
            <p id="final-score">0</p>
            <div class="modal-buttons">
                <button id="retry-btn" class="menu-btn primary">다시 하기</button>
                <button id="exit-btn" class="menu-btn secondary">나가기</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();
        const usersRef = database.ref('users');
        const gameRoomsRef = database.ref('memoryGameRooms');

        // DOM Elements
        const gameWrapper = document.getElementById('game-wrapper');
        const scoreDisplay = document.getElementById('score-display');
        const comboDisplay = document.getElementById('combo-display');
        const livesDisplay = document.getElementById('lives-display');
        const timeDisplay = document.getElementById('time-display');
        const instructionText = document.getElementById('instruction-text');
        const feedbackText = document.getElementById('feedback-text');
        const handsContainer = document.getElementById('hands-container');
        const leftHandArea = document.getElementById('left-hand-area');
        const rightHandArea = document.getElementById('right-hand-area');
        const middleItemArea = document.getElementById('middle-item-area');
        let leftItem = document.getElementById('left-item');
        let rightItem = document.getElementById('right-item');
        let middleItem = document.getElementById('middle-item');
        const feedbackOverlay = document.getElementById('feedback-overlay');
        const timerBar = document.getElementById('timer-bar');
        const infoOverlay = document.getElementById('info-overlay');
        const countdownText = document.getElementById('countdown-text');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverTitle = document.getElementById('game-over-title');
        const finalScoreDisplay = document.getElementById('final-score');
        const retryBtn = document.getElementById('retry-btn');
        const exitBtn = document.getElementById('exit-btn');
        const modeChangeAlert = document.getElementById('mode-change-alert');


        // Emojis
        const candyEmoji = '🍬';
        const soapEmoji = '🧼';
        const cottonCandyEmoji = '🍭';

        // Game State
        let myPlayerId, roomRef, gameMode;
        let score = 0, combo = 0, lives = 4, maxCombo = 0;
        let gameTimeLeft = 60;
        let roundTimer, gameTimerInterval;
        let currentQuestion = { instruction: '', answer: '' };
        let canInteract = false;
        let isThreeItemMode = false;
        let feedbackTimer;

        // Authentication
        auth.onAuthStateChanged(user => {
            if (user) {
                myPlayerId = user.uid;
                initialize();
            } else if (sessionStorage.getItem('isGuest') === 'true') {
                myPlayerId = localStorage.getItem('myPlayerId');
                initialize();
            } else {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
            }
        });

        // Initialization
        function initialize() {
            if (!myPlayerId) {
                alert("플레이어 ID를 가져올 수 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html'; return;
            }
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            if (roomId) {
                roomRef = gameRoomsRef.child(roomId);
                gameMode = urlParams.get('mode') || 'solo';
            } else {
                gameMode = 'solo';
            }

            startCountdown();

            leftHandArea.addEventListener('click', () => handleInput('left'));
            rightHandArea.addEventListener('click', () => handleInput('right'));
            middleItemArea.addEventListener('click', () => handleInput('middle'));
            exitBtn.addEventListener('click', () => {
                sessionStorage.setItem('returnFromGame', 'true');
                if(roomRef) window.location.href = '대기실.html';
                else window.location.href = 'index.html';
            });
            retryBtn.addEventListener('click', handleRetry);
        }

        function startCountdown() {
            infoOverlay.style.display = 'flex';
            let count = 3;
            countdownText.textContent = count;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.style.animation = 'none';
                    countdownText.offsetHeight;
                    countdownText.style.animation = 'countdown-pop 0.9s ease-out';
                    countdownText.textContent = count;
                } else {
                    clearInterval(interval);
                    infoOverlay.style.display = 'none';
                    gameWrapper.style.opacity = '1';
                    startGame();
                }
            }, 1000);
        }

        function startGame() {
            score = 0; combo = 0; lives = 4; maxCombo = 0; gameTimeLeft = 60;
            isThreeItemMode = false;
            handsContainer.classList.remove('three-item-mode');
            middleItemArea.style.display = 'none';
            
            updateUI();
            
            gameTimerInterval = setInterval(updateGameTimer, 1000);
            nextRound();
        }

        function updateGameTimer() {
            gameTimeLeft--;
            timeDisplay.textContent = Math.ceil(gameTimeLeft);
            if (gameTimeLeft <= 0) {
                endGame("시간 초과!");
            }
        }

        function showBonusFeedback(text) {
            clearTimeout(feedbackTimer);
            feedbackText.textContent = text;
            feedbackText.classList.add('show');
            feedbackTimer = setTimeout(() => {
                feedbackText.classList.remove('show');
            }, 500);
        }
        
        function checkForModeChange() {
            if (score >= 20000 && !isThreeItemMode) {
                isThreeItemMode = true;
                canInteract = false;
                clearInterval(roundTimer);
                
                modeChangeAlert.style.opacity = '1';
                setTimeout(() => {
                    modeChangeAlert.style.opacity = '0';
                    handsContainer.classList.add('three-item-mode');
                    middleItemArea.style.display = 'flex';
                    setTimeout(nextRound, 300);
                }, 1500);
                return true; 
            }
            return false;
        }

        function nextRound() {
            canInteract = false;
            
            const items = { candy: { name: '사탕', emoji: candyEmoji }, soap: { name: '비누', emoji: soapEmoji } };
            const instructions = [ { text: '사탕 먹어!', answer: 'candy' }, { text: '비누 냄새 맡아!', answer: 'soap' }];
            const locations = ['left', 'right'];
            
            if (isThreeItemMode) {
                items.cotton_candy = { name: '솜사탕', emoji: cottonCandyEmoji };
                instructions.push({ text: '솜사탕 먹어!', answer: 'cotton_candy' });
                locations.push('middle');
            }
            
            const currentInstruction = instructions[Math.floor(Math.random() * instructions.length)];
            const correctItemKey = currentInstruction.answer;
            currentQuestion.instruction = currentInstruction.text;
            
            const itemKeys = Object.keys(items);
            const incorrectItemKeys = itemKeys.filter(k => k !== correctItemKey);
            
            // Shuffle locations
            for (let i = locations.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [locations[i], locations[j]] = [locations[j], locations[i]];
            }

            currentQuestion.answer = locations[0];
            currentQuestion[locations[0]] = items[correctItemKey];
            currentQuestion[locations[1]] = items[incorrectItemKeys[0]];
            if (isThreeItemMode) {
                currentQuestion[locations[2]] = items[incorrectItemKeys[1]];
            }

            instructionText.textContent = currentQuestion.instruction;
            leftItem.textContent = currentQuestion.left ? currentQuestion.left.emoji : '';
            rightItem.textContent = currentQuestion.right ? currentQuestion.right.emoji : '';
            if (isThreeItemMode) {
                 middleItem.textContent = currentQuestion.middle ? currentQuestion.middle.emoji : '';
            }


            let timeLimit;
            if (score < 10000) {
                 timeLimit = Math.max(800, 2000 - (combo * 50));
            } else {
                 timeLimit = Math.max(500, 800 - (score - 10000) * 0.015);
            }
            
            let timerWidth = 100;
            const intervalTime = 20;

            canInteract = true;
            roundTimer = setInterval(() => {
                timerWidth -= (100 / (timeLimit / intervalTime));
                timerBar.style.width = `${timerWidth}%`;
                if (timerWidth <= 0) {
                    handleInput('timeout');
                }
            }, intervalTime);
        }

        function handleInput(choice) {
            if (!canInteract) return;
            canInteract = false;
            clearInterval(roundTimer);
            timerBar.style.width = '100%';

            let isCorrect = (choice === currentQuestion.answer);
            if (choice === 'timeout') isCorrect = false;

            if (isCorrect) {
                const comboBonus = 10 + Math.floor(combo / 5) * 2;
                score += 100 + (combo * comboBonus);

                combo++;
                maxCombo = Math.max(maxCombo, combo);
                showFeedback('correct');
                
                if (combo > 0 && combo % 5 === 0) {
                    showBonusFeedback(`COMBO x${combo}`);
                    if (score >= 5000) {
                        setTimeout(() => showBonusFeedback('+1.5초'), 600);
                        gameTimeLeft = Math.min(60, gameTimeLeft + 1.5);
                    }
                }

            } else {
                lives--;
                combo = 0;
                showFeedback('wrong');
            }

            updateUI();

            if (lives <= 0) {
                endGame("체력 소진!");
            } else {
                if (!checkForModeChange()) {
                    setTimeout(nextRound, 300);
                }
            }
        }

        function showFeedback(type) {
            feedbackOverlay.className = 'feedback-overlay';
            feedbackOverlay.offsetHeight;
            feedbackOverlay.classList.add(type);
            setTimeout(() => {
                feedbackOverlay.classList.remove(type);
            }, 300);
        }

        function updateUI() {
            scoreDisplay.textContent = score;
            comboDisplay.textContent = combo;
            livesDisplay.textContent = lives;
            timeDisplay.textContent = Math.ceil(gameTimeLeft);
        }

        async function endGame(reason = "게임 종료!") {
            if (!canInteract && reason === "게임 종료!") return; 
            canInteract = false;
            clearInterval(roundTimer);
            clearInterval(gameTimerInterval);

            retryBtn.disabled = true;
            exitBtn.disabled = true;
            retryBtn.textContent = '저장 중...';

            gameOverTitle.textContent = reason;
            gameOverOverlay.style.display = 'flex';
            finalScoreDisplay.textContent = score;

            await updatePlayerStats(score); 

            retryBtn.disabled = false;
            exitBtn.disabled = false;
            retryBtn.textContent = '다시 하기';
        }

        function handleRetry() {
            if (gameMode !== 'solo') {
                retryBtn.textContent = '상대방 기다리는 중...';
                retryBtn.disabled = true;
                alert('멀티플레이 다시하기는 아직 구현되지 않았습니다.');
                window.location.href = '대기실.html';
            } else {
                gameOverOverlay.style.display = 'none';
                startCountdown();
            }
        }

        async function updatePlayerStats(finalScore, isWin = false) {
            if (!myPlayerId || myPlayerId.startsWith('guest_')) {
                console.log("게스트 유저이거나 PlayerID가 없어 저장을 건너뜁니다.");
                return;
            }

            const gameId = 'candysoap';
            const playerStatRef = usersRef.child(myPlayerId);

            try {
                await playerStatRef.transaction(currentData => {
                    if (currentData) {
                        if (!currentData.stats) {
                            currentData.stats = {};
                        }
                        if (!currentData.stats[gameId]) {
                            currentData.stats[gameId] = { highscore: 0, wins: 0, losses: 0 };
                        }

                        const gameStats = currentData.stats[gameId];

                        if (finalScore > (gameStats.highscore || 0)) {
                            gameStats.highscore = finalScore;
                        }

                        if (gameMode !== 'solo') {
                            if(isWin) {
                                gameStats.wins = (gameStats.wins || 0) + 1;
                            } else {
                                gameStats.losses = (gameStats.losses || 0) + 1;
                            }
                        }

                        const expToAdd = Math.floor(finalScore / 10) + (isWin ? 25 : 0);
                        if (expToAdd > 0) {
                            currentData.exp = (currentData.exp || 0) + expToAdd;
                        }
                    }
                    return currentData;
                });
            } catch (error) {
                console.error("캔디솝 전적 업데이트 실패:", error);
            }
        }
    });
    </script>
</body>
</html>
