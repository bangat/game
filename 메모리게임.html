<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>메모리게임</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
        }

        :root {
            --bg-color: #F3F7FD; --primary-color: #4A8DFF; --accent-color: #FFC84A;
            --card-back-color: #6DA4FF; --card-front-color: #ffffff;
            --text-color-dark: #333D4B; --text-color-light: #ffffff;
            --danger-color: #F76363; --success-color: #30D394;
            --panel-bg: #ffffff; --panel-border: #E5E8EB;
            --btn-secondary-bg: #F0F3F4; --btn-secondary-text: #566573;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        .view { width: 100%; height: 100%; display: flex; flex-direction: column; }
        .hidden { display: none !important; }

        /* [수정] 모바일 UI 고정 및 레이아웃 개선 */
        #game-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            align-items: center;
        }
        #game-header {
            flex-shrink: 0;
            padding: 10px;
            padding-top: 15px; /* 모바일 상단 바 고려 */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            flex-wrap: wrap;
            gap: 5px 10px;
            background: var(--bg-color);
            z-index: 10;
        }
        .status-box { background-color: rgba(255,255,255,0.9); color: var(--text-color-dark); padding: 8px 15px; border-radius: 20px; font-size: 1em; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: all 0.3s ease; border: 2px solid transparent; }
        .status-box.my-turn {
            background-color: var(--accent-color); color: var(--text-color-dark);
            transform: scale(1.05); border-color: #fff; font-weight: 700;
            animation: pulse-turn 1.5s infinite;
        }
        @keyframes pulse-turn {
            0% { box-shadow: 0 4px 12px rgba(255, 200, 74, 0.7); }
            50% { box-shadow: 0 4px 20px rgba(255, 200, 74, 1); }
            100% { box-shadow: 0 4px 12px rgba(255, 200, 74, 0.7); }
        }
        #game-container {
            width: 100%;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            min-height: 0;
            overflow-y: auto; /* 카드판이 클 경우 여기만 스크롤됨 */
        }
        #card-grid {
            display: grid;
            gap: 8px;
            width: 100%;
            max-width: 450px;
            aspect-ratio: 4 / 5.5; /* 세로로 조금 더 긴 안정적인 비율 */
        }
        #card-grid.p2, #card-grid.single { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(5, 1fr); }
        #card-grid.p3 { grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(6, 1fr); }
        #card-grid.p4 { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(10, 1fr); }
        .card { perspective: 1000px; cursor: pointer; }
        .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; border-radius: 10px; }
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card.matched { cursor: default; }
        .card.matched .card-inner { transform: scale(0.9); opacity: 0.4; transition: all 0.5s ease; }
        .card.matched .card-front { box-shadow: 0 0 0 4px var(--success-color) inset; }
        .card.matched .card-front::after { content: '✓'; position: absolute; font-size: 1.2em; font-weight: 700; color: var(--success-color); background-color: rgba(255, 255, 255, 0.85); border-radius: 50%; padding: 2px 5px; line-height: 1; bottom: 5px; right: 5px; }
        .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-size: clamp(1.5em, 5vw, 2.5em); }
        .card-back { background: var(--card-back-color); }
        .card-front { background-color: var(--card-front-color); transform: rotateY(180deg); }
        
        /* --- 공통 UI 스타일 --- */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.6); }
        .modal-content { background: var(--panel-bg); border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); width: 90%; max-width: 400px; overflow: hidden; }
        .modal-header { background-color: var(--primary-color); padding: 15px; }
        .modal-header h2 { color: var(--text-color-light); font-size: 1.8em; font-weight: 700; letter-spacing: 2px; }
        .modal-body { padding: 25px; }
        .modal-body p { font-size: 1.1em; margin-bottom: 20px; color: #555; font-weight: 500; line-height: 1.5; }

        .menu-btn {
            width: 100%; max-width: 320px; padding: 15px; font-size: 1.2em; font-weight: 700; letter-spacing: 1px;
            font-family: 'GmarketSans', sans-serif; border-radius: 12px; border: none; cursor: pointer;
            margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.15s ease-out;
        }
        .menu-btn:active { transform: scale(0.97); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .menu-btn.primary { background-color: var(--primary-color); color: var(--text-color-light); }
        .menu-btn.secondary { background-color: #E9EEF2; color: var(--text-color-dark); }
        .menu-btn:disabled { background-color: #ccc !important; color: #888 !important; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .spinner { margin: 20px auto; border: 4px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* --- 시작 메뉴 --- */
        #start-menu { justify-content: center; align-items: center; }
        #start-menu-buttons { width: 100%; max-width: 320px; }
        .main-title { font-size: 2.8em; font-weight: 700; color: var(--text-color-dark); margin-bottom: 30px; text-align: center; }

        /* --- 공개 방 목록 (로비) --- */
        #lobby-view { padding: 15px; align-items: center; }
        .lobby-panel { display: flex; flex-direction: column; width: 100%; max-width: 500px; height: calc(100% - 80px); background: var(--panel-bg); border-radius: 16px; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); border: 1px solid var(--panel-border); }
        .lobby-header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-shrink: 0; }
        .lobby-header h1 { font-size: 1.8em; font-weight: 700; color: var(--text-color-dark); }
        .lobby-actions button { padding: 10px 15px; font-size: 1em; margin: 0; width: auto; font-weight: 700; }
        #room-list-container { width: 100%; flex-grow: 1; overflow-y: auto; }
        .room-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; border: 1px solid var(--panel-border); border-radius: 12px; margin-bottom: 10px; }
        .room-info { text-align: left; }
        .room-name { font-weight: 700; font-size: 1.1em; color: var(--text-color-dark); }
        .room-details { font-size: 0.9em; color: #777; font-weight: 500; }
        .room-status.waiting { color: var(--success-color); font-weight: 700; }
        .room-status.playing { color: var(--danger-color); font-weight: 700; }
        .join-btn { padding: 10px 20px; font-size: 1em; font-weight: 700; border-radius: 8px; margin: 0; }
        #lobby-bottom-actions { width: 100%; max-width: 500px; margin-top: 15px; display: flex; gap: 10px; }
        #lobby-bottom-actions .menu-btn { margin-bottom: 0; }

        /* --- 인게임 대기실, 게임오버 --- */
        #player-list { margin-top: 20px; font-size: 1.1em; width: 100%; max-width: 320px; }
        .player-item { background-color: #F3F7FD; color: var(--text-color-dark); padding: 12px; border-radius: 8px; margin-bottom: 8px; font-weight: 700; cursor: pointer; transition: background-color 0.2s; }
        .player-item:hover { background-color: #e9eff8; }
        .player-item.is-host::after { content: ' (방장)'; color: var(--primary-color); font-weight: 700; }
        #game-over-message { font-size: 2em; font-weight: 700; }
        #score-board { margin-top: 20px; width: 100%; }
        .score-row { padding: 10px; border-radius: 8px; font-size: 1.2em; font-weight: 700; margin: 5px auto; max-width: 280px; }
        .score-row.winner { background-color: var(--accent-color); color: var(--text-color-dark); transform: scale(1.05); }
        .score-row.loser { background-color: #F3F7FD; color: var(--text-color-dark); }
        
        #countdown-container { color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); text-align: center; }
        #countdown-container h2 { font-size: 1.8em; font-weight: 700; }
        #countdown-number { font-size: 6em; font-weight: 700; margin-top: 10px; animation: countdown-pop 1s infinite; }
        @keyframes countdown-pop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .modal-buttons { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 25px; width: 100%; max-width: 300px; }
        
        /* [추가] 프로필 모달 스타일 */
        #profile-modal .modal-content { max-width: 340px; }
        #profile-header { display: flex; flex-direction: column; align-items: center; margin-bottom: 20px; }
        #profile-avatar { font-size: 4em; }
        #profile-nickname { font-size: 1.5em; font-weight: 700; margin-top: 10px; }
        #profile-level { font-size: 1em; background-color: var(--accent-color); color: #333; padding: 3px 10px; border-radius: 15px; font-weight: 700; }
        #exp-bar-container { width: 100%; background-color: #e0e0e0; border-radius: 15px; height: 20px; margin-top: 15px; overflow: hidden; }
        #exp-bar { width: 0%; height: 100%; background-color: var(--success-color); border-radius: 15px; transition: width 0.5s ease; text-align: right; }
        #exp-text { color: white; font-weight: 700; font-size: 0.8em; padding-right: 8px; line-height: 20px; }
        #profile-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 25px; text-align: center; }
        .stat-item h4 { color: #888; font-size: 1em; margin-bottom: 5px; }
        .stat-item p { font-size: 1.4em; font-weight: 700; color: #333; }
        #profile-close-btn { width: 100%; max-width: 300px; margin-top: 25px; }
    </style>
</head>
<body>
    <div id="start-menu" class="view">
        <div>
            <h1 class="main-title">미니게임 천국</h1>
            <div id="start-menu-buttons">
                <button id="single-player-btn" class="menu-btn secondary">혼자 하기</button>
                <button id="multiplayer-btn" class="menu-btn primary">같이 하기</button>
            </div>
        </div>
    </div>

    <div id="lobby-view" class="view hidden">
        <div class="lobby-panel">
            <div class="lobby-header">
                <h1>게임 대기실</h1>
                <div class="lobby-actions">
                    <button id="refresh-rooms-btn" class="menu-btn secondary">새로고침</button>
                </div>
            </div>
            <div id="room-list-container"></div>
        </div>
        <div id="lobby-bottom-actions">
            <button id="back-to-main-btn" class="menu-btn secondary">뒤로</button>
            <button id="create-room-btn" class="menu-btn primary">방 만들기</button>
        </div>
    </div>

    <div id="game-wrapper" class="view hidden">
        <div id="game-header"></div>
        <div id="game-container"><div id="card-grid"></div></div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="waiting-overlay" class="overlay" style="display: none;"></div>
    
    <div id="profile-modal" class="overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-body">
                <div id="profile-header">
                    <span id="profile-avatar"></span>
                    <h3 id="profile-nickname"></h3>
                    <span id="profile-level"></span>
                </div>
                <div id="exp-bar-container">
                    <div id="exp-bar"><span id="exp-text"></span></div>
                </div>
                <div id="profile-stats">
                    <div class="stat-item"><h4>승리</h4><p id="profile-wins"></p></div>
                    <div class="stat-item"><h4>패배</h4><p id="profile-losses"></p></div>
                    <div class="stat-item"><h4>승률</h4><p id="profile-winrate"></p></div>
                    <div class="stat-item"><h4>-</h4><p>-</p></div>
                </div>
                <button id="profile-close-btn" class="menu-btn secondary">닫기</button>
            </div>
        </div>
    </div>
    
    <audio id="flip-sound" src="https://blog.kakaocdn.net/dna/pcEQl/dJMb9LDWoy9/AAAAAAAAAAAAAAAAAAAAAPVGU4wkmgnOb3PqlOYeqvyLhYszCxnHFVpLXXwERBCq/cardsound32562-37691.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=RqFQGsIaZLVnhgC7ca5CNdmTQXc%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('memoryGameRooms');
        const playersRef = database.ref('memoryGamePlayers');
        
        const startMenu = document.getElementById('start-menu'), singlePlayerBtn = document.getElementById('single-player-btn'),
              multiplayerBtn = document.getElementById('multiplayer-btn'), lobbyView = document.getElementById('lobby-view'),
              backToMainBtn = document.getElementById('back-to-main-btn'), createRoomBtn = document.getElementById('create-room-btn'),
              refreshRoomsBtn = document.getElementById('refresh-rooms-btn'), roomListContainer = document.getElementById('room-list-container'),
              gameWrapper = document.getElementById('game-wrapper'), cardGrid = document.getElementById('card-grid'),
              gameHeader = document.getElementById('game-header'), waitingOverlay = document.getElementById('waiting-overlay'),
              gameOverOverlay = document.getElementById('game-over-overlay'),
              flipSound = document.getElementById('flip-sound'),
              profileModal = document.getElementById('profile-modal'),
              profileCloseBtn = document.getElementById('profile-close-btn');

        const cardEmojis = ['🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯','🦁','🐮','🐷','🐸','🐵','🐔','🐧','🐦','🐤','🦆'];
        let myPlayerId, myNickname, myAvatar, roomRef, currentRoomData, isHost = false, isGameInProgress = false;

        function getPlayerId() {
            let id = localStorage.getItem('myPlayerId');
            if (!id) {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
                return null;
            }
            myNickname = localStorage.getItem('userNickname');
            myAvatar = localStorage.getItem('userAvatar');
            return id;
        }
        myPlayerId = getPlayerId();

        window.addEventListener('beforeunload', (event) => {
            if (isGameInProgress) {
                event.preventDefault();
                event.returnValue = '';
            }
        });
        
        profileCloseBtn.addEventListener('click', () => profileModal.style.display = 'none');

        function cleanupOldRoomState() {
            if (roomRef) {
                roomRef.off();
                roomRef.onDisconnect().cancel();
            }
            roomRef = null;
            currentRoomData = null;
            isGameInProgress = false;
            isHost = false;
        }

        function playFlipSound() { flipSound.currentTime = 0; flipSound.play().catch(e => {}); }
        function generateCards(pairCount) { const d=[...cardEmojis.slice(0,pairCount),...cardEmojis.slice(0,pairCount)]; d.sort(()=>Math.random()-0.5); return d.map(e=>({emoji:e,matched:false}));}

        function showView(viewToShow) {
            document.querySelectorAll('.view').forEach(view => view.classList.add('hidden'));
            viewToShow.classList.remove('hidden');
        }

        singlePlayerBtn.addEventListener('click', startSinglePlayerGame);
        multiplayerBtn.addEventListener('click', () => { showView(lobbyView); loadRoomList(); });
        backToMainBtn.addEventListener('click', () => { cleanupOldRoomState(); showView(startMenu); });
        createRoomBtn.addEventListener('click', createNewPublicRoom);
        refreshRoomsBtn.addEventListener('click', loadRoomList);
        
        function loadRoomList() {
            roomListContainer.innerHTML = `<div class="spinner"></div>`;
            gameRoomsRef.orderByChild('createdAt').limitToLast(20).once('value', snapshot => {
                roomListContainer.innerHTML = '';
                if (!snapshot.exists()) {
                    roomListContainer.innerHTML = `<p style="color: #999; padding: 20px 0; text-align: center; font-weight: 500;">활성화된 방이 없어요.<br>새로운 방을 만들어보세요!</p>`;
                    return;
                }
                let roomCount = 0;
                snapshot.forEach(childSnapshot => {
                    const room = childSnapshot.val();
                    if(!room || !room.players || !room.roomName || Object.keys(room.players).length === 0) return;
                    roomCount++;
                    const playerCount = Object.keys(room.players).length;
                    const isPlaying = room.gameState === 'playing';
                    const isFull = playerCount >= 4;
                    const roomItem = document.createElement('div');
                    roomItem.className = 'room-item';
                    roomItem.innerHTML = `<div class="room-info"><div class="room-name">${room.roomName}</div><div class="room-details"><span class="room-players">${playerCount} / 4</span> | <span class="room-status ${isPlaying ? 'playing' : 'waiting'}">${isPlaying ? '게임중' : '대기중'}</span></div></div><button class="menu-btn join-btn primary" data-room-id="${childSnapshot.key}" ${isFull || isPlaying ? 'disabled' : ''}>참가</button>`;
                    roomListContainer.prepend(roomItem);
                });
                if (roomCount === 0) { roomListContainer.innerHTML = `<p style="color: #999; padding: 20px 0; text-align: center; font-weight: 500;">활성화된 방이 없어요.<br>새로운 방을 만들어보세요!</p>`; }
                document.querySelectorAll('.join-btn').forEach(btn => btn.addEventListener('click', e => joinRoom(e.target.dataset.roomId)));
            });
        }

        function createNewPublicRoom() {
            cleanupOldRoomState();
            isHost = true;
            const newRoomData = { 
                roomName: `${myNickname}님의 방`, hostId: myPlayerId, 
                players: { [myPlayerId]: { nickname: myNickname, avatar: myAvatar, score: 0, isHost: true }}, 
                gameState: 'waiting', createdAt: firebase.database.ServerValue.TIMESTAMP 
            };
            roomRef = gameRoomsRef.push();
            roomRef.onDisconnect().remove();
            roomRef.set(newRoomData).then(listenToRoomChanges);
        }

        function joinRoom(roomId) {
            cleanupOldRoomState();
            isHost = false;
            roomRef = gameRoomsRef.child(roomId);
            roomRef.transaction(currentData => {
                if (currentData === null) return null;
                if (currentData.gameState === 'waiting' && currentData.players && Object.keys(currentData.players).length < 4) {
                    currentData.players[myPlayerId] = { nickname: myNickname, avatar: myAvatar, score: 0, isHost: false };
                    return currentData;
                }
                return;
            }, (error, committed) => {
                 if (!committed) { alert("방이 꽉 찼거나 이미 시작되어 참여할 수 없습니다."); loadRoomList(); }
                 else { roomRef.child('players/' + myPlayerId).onDisconnect().remove(); listenToRoomChanges(); }
            });
        }
        
        function listenToRoomChanges() {
            isGameInProgress = true;
            showView(gameWrapper);
            roomRef.on('value', snapshot => {
                if (!isGameInProgress) return;
                currentRoomData = snapshot.val();
                if (!currentRoomData || !currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                    alert("방과의 연결이 끊겼거나 방장이 나갔습니다.");
                    cleanupOldRoomState();
                    gameOverOverlay.style.display = 'none'; waitingOverlay.style.display = 'none';
                    showView(lobbyView); loadRoomList();
                    return;
                }
                if(currentRoomData.gameState === 'waiting') { gameWrapper.classList.add('hidden'); updateInGameLobbyUI(); }
                else { waitingOverlay.style.display = 'none'; gameWrapper.classList.remove('hidden'); }
                updateStatusUI();
                switch(currentRoomData.gameState) {
                    case 'ready': startCountdown(); break;
                    case 'playing': drawMultiplayerCards(); break;
                    case 'gameOver': showGameOverScreen(); break;
                }
            });
        }
        
        function updateInGameLobbyUI() {
            if (currentRoomData.gameState !== 'waiting') { waitingOverlay.style.display = 'none'; return; }
            const players = currentRoomData.players;
            const playerCount = Object.keys(players).length;
            let playerListHTML = '';
            Object.entries(players).sort().forEach(([pid, p]) => {
                playerListHTML += `<div class="player-item ${p.isHost ? 'is-host' : ''}" data-player-id="${pid}">${p.avatar} ${p.nickname} ${pid === myPlayerId ? ' (나)' : ''}</div>`;
            });
            const startGameBtnHTML = isHost ? `<button id="start-game-btn" class="menu-btn primary" ${playerCount < 2 ? 'disabled' : ''}>게임 시작</button>` : '';
            waitingOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>${currentRoomData.roomName}</h2></div><div class="modal-body"><p>${isHost ? '모두 준비되면 게임을 시작해주세요!' : '방장이 시작하기를 기다리는 중...'}</p><div id="player-list">${playerListHTML}</div><div class="modal-buttons">${startGameBtnHTML}<button id="leave-room-btn" class="menu-btn secondary">나가기</button></div></div></div>`;
            waitingOverlay.style.display = 'flex';
            if(isHost) { document.getElementById('start-game-btn').addEventListener('click', startGame); }
            document.getElementById('leave-room-btn').addEventListener('click', () => {
                waitingOverlay.style.display = 'none';
                roomRef.child('players/' + myPlayerId).remove();
                cleanupOldRoomState(); showView(lobbyView); loadRoomList();
            });
            document.querySelectorAll('.player-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const pid = e.currentTarget.dataset.playerId;
                    showPlayerProfile(pid);
                });
            });
        }

        function startGame() {
            if (!isHost || !currentRoomData) return;
            const playerCount = Object.keys(currentRoomData.players).length;
            if (playerCount < 2) return;
            let pairCount;
            if (playerCount === 2) pairCount = 10; else if (playerCount === 3) pairCount = 15; else pairCount = 20;
            const newCards = generateCards(pairCount);
            const playerOrder = Object.keys(currentRoomData.players).sort();
            const players = currentRoomData.players;
            Object.keys(players).forEach(pid => { players[pid].score = 0; });
            roomRef.update({ gameState: 'ready', cards: newCards, turn: playerOrder[0], playerOrder, players, flippedCards: [] });
        }
        
        function startCountdown() {
            waitingOverlay.innerHTML = `<div id="countdown-container"><h2>게임 시작!</h2><p id="countdown-number"></p></div>`;
            waitingOverlay.style.display = 'flex';
            let count = 3;
            const countdownEl = document.getElementById('countdown-number');
            const updateCount = () => { countdownEl.textContent = count; };
            updateCount();
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    updateCount();
                } else {
                    clearInterval(interval);
                    if (isHost) roomRef.child('gameState').set('playing');
                }
            }, 1000);
        }
        
        function updateStatusUI() {
            if (!currentRoomData || !currentRoomData.players || currentRoomData.gameState === 'waiting') { gameHeader.innerHTML = ''; return; }
            gameHeader.innerHTML = '';
            
            let playerIds = [...(currentRoomData.playerOrder || Object.keys(currentRoomData.players).sort())];
            const myIndex = playerIds.indexOf(myPlayerId);
            if (myIndex > -1) {
                const me = playerIds.splice(myIndex, 1)[0];
                playerIds.unshift(me);
            }

            playerIds.forEach(pid => {
                const player = currentRoomData.players[pid];
                if (!player) return;
                const statusBox = document.createElement('div');
                const isMyTurn = currentRoomData.turn === pid;
                statusBox.classList.add('status-box');
                if (isMyTurn) statusBox.classList.add('my-turn');

                let statusText = `${player.avatar} ${player.nickname} ${player.score}`;
                if (isMyTurn && pid === myPlayerId) {
                    statusText += ' (내 차례)';
                }
                statusBox.textContent = statusText;
                gameHeader.appendChild(statusBox);
            });
        }

        function drawMultiplayerCards() {
            if(!currentRoomData.cards) return;
            cardGrid.innerHTML = currentRoomData.cards.map((card, index) => {
                let cardStateClass = '';
                if(card.matched) cardStateClass = 'matched';
                if(currentRoomData.flippedCards?.includes(index)) cardStateClass += ' flipped';
                return `<div class="card ${cardStateClass}" data-index="${index}"><div class="card-inner"><div class="card-face card-back"></div><div class="card-face card-front">${card.emoji}</div></div></div>`;
            }).join('');
            cardGrid.className = `p${Object.keys(currentRoomData.players).length}`;
            document.querySelectorAll('.card:not(.matched)').forEach(c => c.addEventListener('click', () => handleMultiplayerCardClick(parseInt(c.dataset.index))));
        }

        function handleMultiplayerCardClick(index) {
            if (currentRoomData.turn !== myPlayerId || currentRoomData.cards[index].matched || currentRoomData.flippedCards?.length >= 2 || currentRoomData.flippedCards?.includes(index)) return;
            playFlipSound();
            const flippedCards = [...(currentRoomData.flippedCards || []), index];
            const updates = { flippedCards };
            if (flippedCards.length < 2) { roomRef.update(updates); return; }
            
            const [card1, card2] = [currentRoomData.cards[flippedCards[0]], currentRoomData.cards[flippedCards[1]]];
            if (card1.emoji === card2.emoji) {
                updates.flippedCards = [];
                updates[`cards/${flippedCards[0]}/matched`] = true;
                updates[`cards/${flippedCards[1]}/matched`] = true;
                updates[`players/${myPlayerId}/score`] = currentRoomData.players[myPlayerId].score + 1;
                const allMatched = currentRoomData.cards.every((c, i) => c.matched || flippedCards.includes(i));
                if (allMatched) {
                    updates.gameState = 'gameOver';
                }
            } else {
                const pOrder = currentRoomData.playerOrder;
                updates.turn = pOrder[(pOrder.indexOf(myPlayerId) + 1) % pOrder.length];
                setTimeout(() => roomRef.child('flippedCards').set([]), 1000);
            }
            roomRef.update(updates);
        }
        
        async function showGameOverScreen() {
            const playersArray = Object.entries(currentRoomData.players).map(([id, data]) => ({ id, ...data }));
            const maxScore = Math.max(...playersArray.map(p => p.score));
            const winners = playersArray.filter(p => p.score === maxScore && p.score > 0);
            const losers = playersArray.filter(p => !winners.some(w => w.id === p.id));
            
            if (isHost && winners.length > 0 && (winners.length !== playersArray.length)) {
                for (const winner of winners) { await updatePlayerStats(winner.id, true); }
                for (const loser of losers) { await updatePlayerStats(loser.id, false); }
            }

            const amIWinner = winners.some(w => w.id === myPlayerId);
            let message = "";
            if (winners.length > 1 && amIWinner) message = "무승부!";
            else if (amIWinner) message = "승 리 !";
            else if (winners.length === 0 || winners.length === playersArray.length) message = "무승부!";
            else message = "패 배 !";
            
            playersArray.sort((a, b) => b.score - a.score);
            const finalScoresHTML = playersArray.map(p => {
                const isWinner = winners.some(w => w.id === p.id);
                return `<div class="score-row ${isWinner ? 'winner' : 'loser'}">${p.avatar} ${p.nickname} : ${p.score}점</div>`;
            }).join('');

            const rematchListenerRef = roomRef.child('players');
            function cleanupAndLeave() {
                rematchListenerRef.off();
                if (roomRef) roomRef.child('players/' + myPlayerId).remove();
                cleanupOldRoomState();
                gameOverOverlay.style.display = 'none';
                showView(lobbyView); loadRoomList();
            }
            gameOverOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2 id="game-over-message">${message}</h2></div><div class="modal-body"><div id="score-board">${finalScoresHTML}</div><div class="modal-buttons"><button id="rematch-btn" class="menu-btn primary">다시 하기</button><button id="lobby-btn" class="menu-btn secondary">나가기</button></div></div></div>`;
            gameOverOverlay.style.display = 'flex';

            document.getElementById('rematch-btn').addEventListener('click', () => {
                const btn = document.getElementById('rematch-btn');
                btn.textContent = '대기중...'; btn.disabled = true;
                roomRef.child(`players/${myPlayerId}/wantsRematch`).set(true);
            });
            document.getElementById('lobby-btn').addEventListener('click', cleanupAndLeave);
            
            rematchListenerRef.on('value', snapshot => {
                if (!isGameInProgress || !snapshot.exists() || currentRoomData?.gameState !== 'gameOver') { rematchListenerRef.off(); return; }
                const currentPlayers = snapshot.val();
                if (Object.values(currentPlayers).every(p => p.wantsRematch)) {
                    rematchListenerRef.off(); gameOverOverlay.style.display = 'none';
                    if (isHost) {
                        const updates = {};
                        Object.keys(currentPlayers).forEach(pid => { updates[`/players/${pid}/wantsRematch`] = null; });
                        roomRef.update(updates).then(startGame);
                    }
                }
            });
        }

        async function updatePlayerStats(playerId, isWinner) {
            const playerStatRef = playersRef.child(playerId);
            try {
                await playerStatRef.transaction(currentData => {
                    if (currentData) {
                        if (isWinner) {
                            currentData.wins = (currentData.wins || 0) + 1;
                            currentData.exp = (currentData.exp || 0) + 50;
                        } else {
                            currentData.losses = (currentData.losses || 0) + 1;
                            currentData.exp = (currentData.exp || 0) + 10;
                        }
                        
                        let expForNextLevel = (currentData.level || 1) * 100;
                        while (currentData.exp >= expForNextLevel) {
                            currentData.level++;
                            currentData.exp -= expForNextLevel;
                            expForNextLevel = currentData.level * 100;
                        }
                    }
                    return currentData;
                });
            } catch (error) { console.error("전적 업데이트 실패:", error); }
        }
        
        function showPlayerProfile(playerId) {
            playersRef.child(playerId).once('value', snapshot => {
                if (!snapshot.exists()) { alert('플레이어 정보를 찾을 수 없습니다.'); return; }
                const data = snapshot.val();
                const totalGames = data.wins + data.losses;
                const winRate = totalGames > 0 ? ((data.wins / totalGames) * 100).toFixed(1) + '%' : '-';
                const expForNextLevel = data.level * 100;
                const expPercent = expForNextLevel > 0 ? (data.exp / expForNextLevel) * 100 : 0;

                document.getElementById('profile-avatar').textContent = data.avatar;
                document.getElementById('profile-nickname').textContent = data.nickname;
                document.getElementById('profile-level').textContent = `Lv. ${data.level}`;
                document.getElementById('profile-wins').textContent = `${data.wins} 승`;
                document.getElementById('profile-losses').textContent = `${data.losses} 패`;
                document.getElementById('profile-winrate').textContent = winRate;
                
                const expBar = document.getElementById('exp-bar');
                const expText = document.getElementById('exp-text');
                expBar.style.width = `${expPercent}%`;
                expText.textContent = `${data.exp} / ${expForNextLevel}`;
                
                profileModal.style.display = 'flex';
            });
        }
        
        let singlePlayerFlipped = [], singlePlayerMatched = 0;
        function startSinglePlayerGame() {
            cleanupOldRoomState();
            showView(gameWrapper);
            gameWrapper.classList.remove('hidden');
            singlePlayerFlipped = []; singlePlayerMatched = 0;
            const cards = generateCards(10);
            cardGrid.className = 'single';
            gameHeader.innerHTML = `<div class="status-box">정답: <span id="matched-counter">0</span> / 10</div>`;
            cardGrid.innerHTML = cards.map((card, index) => `<div class="card" data-index="${index}"><div class="card-inner"><div class="card-face card-back"></div><div class="card-face card-front">${card.emoji}</div></div></div>`).join('');
            document.querySelectorAll('#card-grid .card').forEach(cardEl => cardEl.addEventListener('click', () => handleSinglePlayerCardClick(cardEl, cards)));
        }

        function handleSinglePlayerCardClick(cardEl, cards) {
            if (cardEl.classList.contains('flipped') || singlePlayerFlipped.length >= 2) return;
            playFlipSound();
            cardEl.classList.add('flipped');
            singlePlayerFlipped.push(cardEl);
            if (singlePlayerFlipped.length === 2) {
                const [el1, el2] = singlePlayerFlipped;
                const [idx1, idx2] = [parseInt(el1.dataset.index), parseInt(el2.dataset.index)];
                if (cards[idx1].emoji === cards[idx2].emoji) {
                    singlePlayerMatched++;
                    document.getElementById('matched-counter').textContent = singlePlayerMatched;
                    el1.classList.add('matched'); el2.classList.add('matched');
                    singlePlayerFlipped = [];
                    if (singlePlayerMatched === 10) {
                        gameOverOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>🎉 성공! 🎉</h2></div><div class="modal-body"><p>모든 카드를 맞췄습니다!</p><div class="modal-buttons"><button id="single-main-menu-btn" class="menu-btn primary">메인으로</button></div></div></div>`;
                        gameOverOverlay.style.display = 'flex';
                        document.getElementById('single-main-menu-btn').addEventListener('click', () => { gameOverOverlay.style.display = 'none'; showView(startMenu); });
                    }
                } else { setTimeout(() => { el1.classList.remove('flipped'); el2.classList.remove('flipped'); singlePlayerFlipped = []; }, 1000); }
            }
        }
    });
    </script>
</body>
</html>
