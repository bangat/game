<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>짝꿍 카드 뒤집기</title>
    <style>
        :root {
            --bg-color: #e3f2fd; --primary-color: #1e88e5; --accent-color: #ffc107;
            --card-back-color: #42a5f5; --card-front-color: #ffffff;
            --text-color: #212121; --light-text-color: #ffffff;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        #game-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; }
        #game-header {
            flex-shrink: 0; padding: 10px; display: flex;
            justify-content: space-around; align-items: center; width: 100%;
        }
        .status-box {
            background-color: rgba(255, 255, 255, 0.7); color: var(--text-color); padding: 8px 15px;
            border-radius: 20px; font-size: 1.1em; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s, background-color 0.3s;
        }
        .status-box.my-turn {
            background-color: var(--accent-color);
            color: var(--text-color);
            transform: scale(1.1);
        }
        #game-container {
            width: 100%; flex-grow: 1; display: flex;
            justify-content: center; align-items: center; padding: 10px;
        }
        #card-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%; max-width: 400px;
            aspect-ratio: 4 / 5;
        }
        .card {
            perspective: 1000px;
            cursor: pointer;
        }
        .card-inner {
            position: relative;
            width: 100%; height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 10px;
        }
        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card.matched .card-inner {
            transform: scale(0.9);
            opacity: 0.5;
        }
        .card-face {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            display: flex; justify-content: center; align-items: center;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .card-back {
            background-color: var(--card-back-color);
            color: var(--light-text-color);
            font-size: 2.5em;
        }
        .card-front {
            background-color: var(--card-front-color);
            font-size: 2.5em;
            transform: rotateY(180deg);
        }
        #start-menu, .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; z-index: 100; text-align: center;
        }
        #start-menu { background-color: var(--bg-color); }
        .overlay { color: white; background-color: rgba(0,0,0,0.8); }
        .overlay > div { padding: 20px; }
        #start-menu h1 { font-size: 3em; color: var(--primary-color); margin-bottom: 40px; }
        .menu-btn {
            width: 100%; max-width: 300px; padding: 15px; font-size: 1.2em; font-weight: bold;
            border-radius: 12px; border: none; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn.primary { background-color: var(--primary-color); color: var(--light-text-color); }
        #join-form { width: 100%; max-width: 300px; margin-top: 20px; border-top: 2px solid #ddd; padding-top: 30px; }
        #room-code-input { width: 100%; padding: 15px; font-size: 1.2em; text-align: center; border: 2px solid #ccc; border-radius: 12px; margin-bottom: 15px; }
        #waiting-room-code { font-size: 3em; font-weight: bold; background-color: #fff; color: var(--text-color); padding: 10px 30px; border-radius: 10px; margin: 15px 0; display: inline-block; }
        .spinner { margin: 20px auto; border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .result-message, #start-countdown { font-size: 2.5em; font-weight: bold; margin-bottom: 15px; }
        .score-info { font-size: 1.5em; }
        #game-over-message { font-size: 4em; }
        #game-over-buttons { display: flex; gap: 15px; margin-top: 30px; }
    </style>
</head>
<body>
    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div> 
            <h2 id="game-over-message"></h2> 
            <div id="game-over-buttons">
                <button id="rematch-btn" class="menu-btn">다시 하기</button> 
                <button id="lobby-btn" class="menu-btn primary">로비로</button> 
            </div> 
        </div>
    </div>
    <div id="round-over-overlay" class="overlay" style="display: none;">
        <div> <h2 class="result-message" id="round-result-message"></h2> <p class="score-info" id="round-score-info"></p> </div>
    </div>
    <div id="waiting-overlay" class="overlay" style="display: none;">
        <div> 
            <h2 id="waiting-title">친구를 기다리는 중...</h2> 
            <p id="waiting-subtitle">친구에게 아래 코드를 알려주세요!</p> 
            <div id="waiting-room-code">1234</div> <div class="spinner"></div> <p id="start-countdown"></p> 
        </div>
    </div>

    <div id="start-menu">
        <h1>🧠 짝꿍 카드 뒤집기</h1>
        <button id="create-room-btn" class="menu-btn primary">방 만들기</button>
        <div id="join-form"> <input type="number" id="room-code-input" placeholder="게임 코드 입력"> <button id="join-room-btn" class="menu-btn">코드로 참가하기</button> </div>
    </div>

    <div id="game-wrapper" style="display: none;">
        <div id="game-header"> <div id="player1-status" class="status-box"></div> <div id="player2-status" class="status-box"></div> </div>
        <div id="game-container"> <div id="card-grid"></div> </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12", measurementId: "G-9K2BE1X5D6"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('memoryGameRooms');

        const startMenu = document.getElementById('start-menu'), createRoomBtn = document.getElementById('create-room-btn'),
              roomCodeInput = document.getElementById('room-code-input'), joinRoomBtn = document.getElementById('join-room-btn'),
              gameWrapper = document.getElementById('game-wrapper'), cardGrid = document.getElementById('card-grid'),
              player1Status = document.getElementById('player1-status'), player2Status = document.getElementById('player2-status'),
              waitingOverlay = document.getElementById('waiting-overlay'), waitingRoomCodeEl = document.getElementById('waiting-room-code'),
              waitingTitleEl = document.getElementById('waiting-title'), waitingSubtitleEl = document.getElementById('waiting-subtitle'),
              startCountdownEl = document.getElementById('start-countdown'), gameOverOverlay = document.getElementById('game-over-overlay'),
              gameOverMessageEl = document.getElementById('game-over-message'), lobbyBtn = document.getElementById('lobby-btn'),
              rematchBtn = document.getElementById('rematch-btn'), roundOverOverlay = document.getElementById('round-over-overlay'),
              roundResultMessageEl = document.getElementById('round-result-message'), roundScoreInfoEl = document.getElementById('round-score-info');
        
        const cardEmojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯'];
        let myPlayerId = getPlayerId(), opponentId, currentRoomCode, roomRef, currentRoomData, isHost = false, isMyTurn = false, isCountingDown = false;

        function getPlayerId() {
            let playerId = sessionStorage.getItem('memoryPlayerId');
            if (!playerId) { playerId = `p_${Math.random().toString(36).substr(2, 9)}`; sessionStorage.setItem('memoryPlayerId', playerId); }
            return playerId;
        }

       createRoomBtn.addEventListener('click', () => {
            isHost = true; currentRoomCode = Math.floor(1000 + Math.random() * 9000).toString();
            roomRef = gameRoomsRef.child(currentRoomCode);
            const myEmoji = cardEmojis[Math.floor(Math.random() * cardEmojis.length)];
            const newRoomData = {
                players: { [myPlayerId]: { emoji: myEmoji, score: 0, isHost: true } },
                scores: { [myPlayerId]: 0 }, gameState: 'waiting', createdAt: firebase.database.ServerValue.TIMESTAMP
            };
            roomRef.set(newRoomData).then(() => { showWaitingScreen(currentRoomCode); listenToRoomChanges(); });
        });
        joinRoomBtn.addEventListener('click', () => {
            const enteredCode = roomCodeInput.value;
            if (!enteredCode || enteredCode.length !== 4) { alert('4자리 게임 코드를 정확히 입력하세요.'); return; }
            const potentialRoomRef = gameRoomsRef.child(enteredCode);
            potentialRoomRef.once('value', (snapshot) => {
                const roomData = snapshot.val();
                if (snapshot.exists() && roomData.gameState === 'waiting' && Object.keys(roomData.players).length < 2) {
                    currentRoomCode = enteredCode; roomRef = potentialRoomRef;
                    const usedEmojis = Object.values(roomData.players).map(p => p.emoji);
                    let myEmoji;
                    do { myEmoji = cardEmojis[Math.floor(Math.random() * cardEmojis.length)]; } while (usedEmojis.includes(myEmoji));
                    roomRef.child('players/' + myPlayerId).set({ emoji: myEmoji, score: 0 });
                    roomRef.child('scores/' + myPlayerId).set(0);
                    listenToRoomChanges(); showWaitingScreen(currentRoomCode);
                } else { alert('존재하지 않거나 이미 시작된 방입니다.'); }
            });
        });
        lobbyBtn.addEventListener('click', () => { if (isHost && roomRef) { roomRef.remove(); } window.location.reload(); });
        rematchBtn.addEventListener('click', () => {
            rematchBtn.textContent = '상대방 기다리는 중...';
            rematchBtn.disabled = true;
            roomRef.child('players/' + myPlayerId + '/wantsRematch').set(true);
        });

        function showWaitingScreen(code) {
            startMenu.style.display = 'none';
            waitingTitleEl.style.display = 'block'; waitingSubtitleEl.style.display = 'block';
            waitingRoomCodeEl.style.display = 'inline-block';
            document.querySelector('#waiting-overlay .spinner').style.display = 'block';
            waitingRoomCodeEl.textContent = code;
            waitingOverlay.style.display = 'flex';
        }

        function listenToRoomChanges() {
            roomRef.on('value', (snapshot) => {
                currentRoomData = snapshot.val();
                if (!currentRoomData || !currentRoomData.players) return;
                const players = currentRoomData.players;
                const playerCount = Object.keys(players).length;
                opponentId = Object.keys(players).find(pid => pid !== myPlayerId);

                updateStatusUI();

                switch(currentRoomData.gameState) {
                    case 'waiting':
                        if (isHost && playerCount === 2) {
                            const newCards = generateCards();
                            roomRef.update({ gameState: 'ready', cards: newCards, turn: myPlayerId, flippedCards: [] });
                        }
                        break;
                    case 'ready':
                        startCountdown(currentRoomData);
                        break;
                    case 'playing':
                        roundOverOverlay.style.display = 'none';
                        drawCards();
                        break;
                    case 'roundOver':
                        showRoundResult(currentRoomData);
                        break;
                    case 'gameOver':
                        showGameOverScreen(currentRoomData.gameWinner === myPlayerId);
                        if(isHost && players[myPlayerId]?.wantsRematch && players[opponentId]?.wantsRematch) {
                            roomRef.child('gameState').set('rematch');
                        }
                        break;
                    case 'rematch':
                        if(isHost) {
                            const newCards = generateCards();
                            const resetPlayers = players; for(const pid in resetPlayers) { if(resetPlayers[pid]) { resetPlayers[pid].wantsRematch = null; resetPlayers[pid].score = 0; } }
                            roomRef.update({
                                cards: newCards, players: resetPlayers,
                                scores: {[myPlayerId]: 0, [opponentId]: 0}, gameState: 'ready',
                                roundWinner: null, gameWinner: null, turn: myPlayerId
                            });
                        }
                        break;
                }
            });
        }

        function startCountdown(roomData) {
            if (isCountingDown) return;
            isCountingDown = true;
            gameOverOverlay.style.display = 'none';
            waitingTitleEl.style.display = 'none'; waitingSubtitleEl.style.display = 'none';
            waitingRoomCodeEl.style.display = 'none';
            document.querySelector('#waiting-overlay .spinner').style.display = 'none';

            const isFinal = (roomData.scores[myPlayerId] === 1 && roomData.scores[opponentId] === 1);
            let count = 3;
            startCountdownEl.innerHTML = isFinal ? "🔥 마지막 라운드! 🔥" : `곧 시작합니다!`;
            waitingOverlay.style.display = 'flex';
            setTimeout(() => {
                const interval = setInterval(() => {
                    if (count > 0) { startCountdownEl.textContent = count; } 
                    else {
                        clearInterval(interval);
                        waitingOverlay.style.display = 'none';
                        gameWrapper.style.display = 'flex';
                        isCountingDown = false;
                        if (isHost) roomRef.child('gameState').set('playing');
                    }
                    count--;
                }, 1000);
            }, 1000);
        }

        function updateStatusUI() {
            if (!currentRoomData || !currentRoomData.players || !opponentId) return;
            isMyTurn = currentRoomData.turn === myPlayerId;
            const myData = currentRoomData.players[myPlayerId];
            const opponentData = currentRoomData.players[opponentId];
            if (!myData || !opponentData) return;
            
            const player1Data = (myData.isHost) ? myData : opponentData;
            const player2Data = (myData.isHost) ? opponentData : myData;
            
            player1Status.textContent = `${player1Data.emoji} ${player1Data.score}`;
            player2Status.textContent = `${player2Data.emoji} ${player2Data.score}`;
            
            player1Status.classList.toggle('my-turn', currentRoomData.turn === Object.keys(currentRoomData.players).find(id => currentRoomData.players[id].isHost));
            player2Status.classList.toggle('my-turn', currentRoomData.turn !== Object.keys(currentRoomData.players).find(id => currentRoomData.players[id].isHost));
        }

        function drawCards() {
            cardGrid.innerHTML = '';
            if (!currentRoomData.cards) return;
            currentRoomData.cards.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card');
                cardEl.dataset.index = index;

                let cardState = 'unflipped';
                if (currentRoomData.flippedCards && currentRoomData.flippedCards.includes(index)) cardState = 'flipped';
                if (card.matched) cardState = 'matched';

                cardEl.innerHTML = `
                    <div class="card-inner">
                        <div class="card-face card-back">?</div>
                        <div class="card-face card-front">${card.emoji}</div>
                    </div>
                `;
                if(cardState === 'flipped') cardEl.classList.add('flipped');
                if(cardState === 'matched') cardEl.classList.add('matched', 'flipped');

                cardEl.addEventListener('click', () => handleCardClick(index));
                cardGrid.appendChild(cardEl);
            });
        }

        function handleCardClick(index) {
            if (!isMyTurn || currentRoomData.cards[index].matched || (currentRoomData.flippedCards && currentRoomData.flippedCards.length >= 2)) return;
            
            let flippedCards = currentRoomData.flippedCards ? [...currentRoomData.flippedCards] : [];
            if(flippedCards.includes(index)) return;

            flippedCards.push(index);
            roomRef.child('flippedCards').set(flippedCards);

            if (flippedCards.length === 2) {
                const card1 = currentRoomData.cards[flippedCards[0]];
                const card2 = currentRoomData.cards[flippedCards[1]];
                
                if (card1.emoji === card2.emoji) {
                    const newCards = [...currentRoomData.cards];
                    newCards[flippedCards[0]].matched = true; newCards[flippedCards[1]].matched = true;
                    const newMyScore = currentRoomData.players[myPlayerId].score + 1;
                    const allMatched = newCards.every(c => c.matched);
                    
                    const updates = {};
                    updates['cards'] = newCards;
                    updates['players/' + myPlayerId + '/score'] = newMyScore;
                    updates['flippedCards'] = [];

                    if (allMatched) {
                        updates['gameState'] = 'roundOver';
                        const oppScore = currentRoomData.players[opponentId].score;
                        updates['roundWinner'] = (newMyScore > oppScore) ? myPlayerId : (newMyScore < oppScore ? opponentId : 'draw');
                    }
                    roomRef.update(updates);
                } else {
                    setTimeout(() => { roomRef.update({ 'flippedCards': [], 'turn': opponentId }); }, 1000);
                }
            }
        }
        
        function showRoundResult(roomData) {
            const myFinalScore = roomData.players[myPlayerId].score;
            const oppFinalScore = roomData.players[opponentId].score;
            let winnerId = null;
            if (myFinalScore > oppFinalScore) winnerId = myPlayerId;
            else if (myFinalScore < oppFinalScore) winnerId = opponentId;
            else winnerId = 'draw';

            roundResultMessageEl.innerHTML = winnerId !== 'draw' ? `${roomData.players[winnerId].emoji}님이 라운드 승리!` : '무승부입니다!';
            roundScoreInfoEl.textContent = `현재 점수 ${roomData.scores[myPlayerId] || 0} : ${roomData.scores[opponentId] || 0}`;
            roundOverOverlay.style.display = 'flex';

            if(isHost) {
                setTimeout(() => {
                    const scores = roomData.scores;
                    if(winnerId !== 'draw') scores[winnerId]++;
                    
                    if (scores[myPlayerId] >= 2 || scores[opponentId] >= 2) {
                        roomRef.update({ gameState: 'gameOver', gameWinner: scores[myPlayerId] >= 2 ? myPlayerId : opponentId });
                    } else {
                        const newCards = generateCards();
                        const resetPlayers = roomData.players; for(const pid in resetPlayers) { if(resetPlayers[pid]) resetPlayers[pid].score = 0; }
                        roomRef.update({ cards: newCards, players: resetPlayers, gameState: 'ready', roundWinner: null, turn: opponentId });
                    }
                }, 2000);
            }
        }
        
        function showGameOverScreen(didIWin) {
            roundOverOverlay.style.display = 'none';
            gameOverMessageEl.textContent = didIWin ? "🎉 최종 승리! 🎉" : "😭 최종 패배! 😭";
            rematchBtn.textContent = '다시 하기'; rematchBtn.disabled = false;
            gameOverOverlay.style.display = 'flex';
        }

        function generateCards() {
            const cardPairs = cardEmojis.slice(0, 10);
            const fullDeck = [...cardPairs, ...cardPairs];
            fullDeck.sort(() => Math.random() - 0.5);
            return fullDeck.map(emoji => ({ emoji: emoji, matched: false }));
        }

        window.addEventListener('resize', () => { if (gameWrapper.style.display === 'flex') drawCards(); });
    });
    </script>
</body>
</html>