<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ë©”ëª¨ë¦¬ê²Œì„</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
        }

        :root {
            --bg-color: #F3F7FD; --primary-color: #4A8DFF; --accent-color: #FFC84A;
            --card-back-color: #6DA4FF; --card-front-color: #ffffff;
            --text-color-dark: #333D4B; --text-color-light: #ffffff;
            --danger-color: #F76363; --success-color: #30D394;
            --panel-bg: #ffffff; --panel-border: #E5E8EB;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        .view { width: 100%; height: 100%; display: flex; flex-direction: column; }
        .hidden { display: none !important; }

        #game-wrapper { display: flex; flex-direction: column; height: 100%; align-items: center; }
        #game-header { flex-shrink: 0; padding: 10px; padding-top: 15px; display: flex; justify-content: center; align-items: center; width: 100%; flex-wrap: wrap; gap: 5px 10px; background: var(--bg-color); z-index: 10; }
        .status-box { background-color: rgba(255,255,255,0.9); color: var(--text-color-dark); padding: 8px 15px; border-radius: 20px; font-size: 1em; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.05); transition: all 0.3s ease; border: 2px solid transparent; display: flex; align-items: center; gap: 8px; }
        .status-avatar-emoji { font-size: 1.2em; }
        .status-avatar-img { width: 24px; height: 24px; object-fit: contain; vertical-align: middle; }
        .status-box .nickname { font-weight: 700; }
        .status-box.my-turn { background-color: var(--accent-color); color: var(--text-color-dark); transform: scale(1.05); border-color: #fff; font-weight: 700; animation: pulse-turn 1.5s infinite; }
        @keyframes pulse-turn { 0% { box-shadow: 0 4px 12px rgba(255, 200, 74, 0.7); } 50% { box-shadow: 0 4px 20px rgba(255, 200, 74, 1); } 100% { box-shadow: 0 4px 12px rgba(255, 200, 74, 0.7); } }
        
        #game-container { width: 100%; flex-grow: 1; display: flex; justify-content: center; align-items: center; padding: 10px; min-height: 0; overflow-y: auto; }
        #card-grid { display: grid; gap: 8px; width: 100%; max-width: 450px; aspect-ratio: 4 / 5.5; }
        #card-grid.p2, #card-grid.single { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(5, 1fr); }
        #card-grid.p3 { grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(6, 1fr); }
        #card-grid.p4 { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(10, 1fr); }
        .card { perspective: 1000px; cursor: pointer; }
        .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; border-radius: 10px; }
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card.matched { cursor: default; }
        .card.matched .card-inner { transform: scale(0.9); opacity: 0.4; transition: all 0.5s ease; }
        .card.matched .card-front { box-shadow: 0 0 0 4px var(--success-color) inset; }
        .card.matched .card-front::after { content: 'âœ“'; position: absolute; font-size: 1.2em; font-weight: 700; color: var(--success-color); background-color: rgba(255, 255, 255, 0.85); border-radius: 50%; padding: 2px 5px; line-height: 1; bottom: 5px; right: 5px; }
        .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-size: clamp(1.5em, 5vw, 2.5em); }
        .card-back { background: var(--card-back-color); }
        .card-front { background-color: var(--card-front-color); transform: rotateY(180deg); }
        
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.6); }
        .modal-content { background: var(--panel-bg); border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); width: 90%; max-width: 400px; overflow: hidden; }
        .modal-header { background-color: var(--primary-color); padding: 15px; }
        .modal-header h2 { color: var(--text-color-light); font-size: 1.8em; font-weight: 700; letter-spacing: 2px; }
        .modal-body { padding: 25px; }
        .modal-body p { font-size: 1.1em; margin-bottom: 20px; color: #555; font-weight: 500; line-height: 1.5; }

        .menu-btn { width: 100%; max-width: 320px; padding: 15px; font-size: 1.2em; font-weight: 700; letter-spacing: 1px; font-family: 'GmarketSans', sans-serif; border-radius: 12px; border: none; cursor: pointer; margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: all 0.15s ease-out; }
        .menu-btn:active { transform: scale(0.97); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .menu-btn.primary { background-color: var(--primary-color); color: var(--text-color-light); }
        .menu-btn.secondary { background-color: #E9EEF2; color: var(--text-color-dark); }
        
        #start-menu { justify-content: center; align-items: center; }
        #start-menu-buttons { width: 100%; max-width: 320px; }
        .main-title { font-size: 2.8em; font-weight: 700; color: var(--text-color-dark); margin-bottom: 30px; text-align: center; }

        #game-over-message { font-size: 2em; font-weight: 700; }
        #score-board { margin-top: 20px; width: 100%; }
        .score-row { padding: 10px; border-radius: 8px; font-size: 1.2em; font-weight: 700; margin: 5px auto; max-width: 280px; }
        .score-row.winner { background-color: var(--accent-color); color: var(--text-color-dark); transform: scale(1.05); }
        .score-row.loser { background-color: #F3F7FD; color: var(--text-color-dark); }
        
        #countdown-container { color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); text-align: center; }
        #countdown-container h2 { font-size: 1.8em; font-weight: 700; }
        #countdown-number { font-size: 6em; font-weight: 700; margin-top: 10px; animation: countdown-pop 1s infinite; }
        @keyframes countdown-pop { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        .modal-buttons { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 25px; width: 100%; max-width: 300px; }
    </style>
</head>
<body>
    <div id="start-menu" class="view hidden">
        <div>
            <h1 class="main-title">ë©”ëª¨ë¦¬ ê²Œì„</h1>
            <div id="start-menu-buttons">
                <button id="single-player-btn" class="menu-btn secondary">í˜¼ì í•˜ê¸°</button>
                <button id="multiplayer-btn" class="menu-btn primary">ê°™ì´ í•˜ê¸°</button>
                <button id="back-to-index-btn" class="menu-btn secondary">ë©”ì¸ìœ¼ë¡œ</button> 
            </div>
        </div>
    </div>

    <div id="game-wrapper" class="view hidden">
        <div id="game-header"></div>
        <div id="game-container"><div id="card-grid"></div></div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="waiting-overlay" class="overlay" style="display: none;"></div>
    
    <div id="info-overlay" class="overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header"><h2 id="info-title">ì•Œë¦¼</h2></div>
            <div class="modal-body">
                <p id="info-message" style="margin-bottom: 25px;"></p>
                <button id="info-confirm-btn" class="menu-btn primary" style="margin: 0; max-width: 200px;">í™•ì¸</button>
            </div>
        </div>
   </div>
    
    <div id="confirm-exit-modal" class="overlay" style="display: none;">
        <div style="background: white; border-radius: 16px; width: 90%; max-width: 350px; overflow: hidden; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
            <div style="padding: 30px 20px 20px; text-align: center;">
                <h3 style="font-size: 1.4em; margin-bottom: 15px;">ê²Œì„ì—ì„œ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?</h3>
                <p style="font-size: 0.9em; color: #666;" id="exit-modal-subtext">ê²Œì„ì´ ì¢…ë£Œë©ë‹ˆë‹¤.</p>
            </div>
            <div style="display: flex; gap: 10px; padding: 15px; background-color: #f8f9fa; border-top: 1px solid #eee;">
                <button id="exit-cancel-btn" class="menu-btn secondary">ì·¨ì†Œ</button>
                <button id="exit-confirm-btn" class="menu-btn primary" style="background-color: var(--danger-color);">í™•ì¸</button>
            </div>
        </div>
    </div>
    
    <audio id="flip-sound" src="https://blog.kakaocdn.net/dna/pcEQl/dJMb9LDWoy9/AAAAAAAAAAAAAAAAAAAAAPVGU4wkmgnOb3PqlOYeqvyLhYszCxnHFVpLXXwERBCq/cardsound32562-37691.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=RqFQGsIaZLVnhgC7ca5CNdmTQXc%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script>
document.addEventListener('DOMContentLoaded', () => {

    function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return str.replace(/[&<>"']/g, m => map[m]);
    }

    // âœ¨ [ì‹ ê·œ] ë’¤ë¡œê°€ê¸° ëª¨ë‹¬ ê´€ë ¨ (ì•„ë˜ ì½”ë“œ ì¶”ê°€)
    const confirmExitModal = document.getElementById('confirm-exit-modal');
    const exitModalSubtext = document.getElementById('exit-modal-subtext');
    const exitConfirmBtn = document.getElementById('exit-confirm-btn');
    const exitCancelBtn = document.getElementById('exit-cancel-btn');

    history.pushState(null, '', location.href);
    window.addEventListener('popstate', (e) => {
        history.pushState(null, '', location.href); // ë’¤ë¡œê°€ê¸° ë°©ì§€ ìœ ì§€
        
        // ë©€í‹°í”Œë ˆì´ ì¤‘ì¸ì§€, ì‹±ê¸€í”Œë ˆì´ ì¤‘ì¸ì§€ í™•ì¸
        if (roomRef) { // roomRefê°€ ìˆìœ¼ë©´ ë©€í‹°í”Œë ˆì´
            exitModalSubtext.textContent = isHost ? "ë°©ì¥ì´ ë‚˜ê°€ë©´ ë°©ì´ í•´ì²´ë©ë‹ˆë‹¤." : "ê²Œì„ì„ í¬ê¸°í•˜ê³  ë‚˜ê°€ê²Œ ë©ë‹ˆë‹¤.";
        } else { // ì‹±ê¸€í”Œë ˆì´
            exitModalSubtext.textContent = "ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ë©”ì¸ìœ¼ë¡œ ë‚˜ê°‘ë‹ˆë‹¤.";
        }
        confirmExitModal.style.display = 'flex'; // ëª¨ë‹¬ í‘œì‹œ
    });

    exitConfirmBtn.addEventListener('click', () => {
        // ë‚˜ê°€ê¸° ë²„íŠ¼ ë¡œì§
        confirmExitModal.style.display = 'none';
        if (roomRef) {
            // ë©€í‹°í”Œë ˆì´ì–´ ë‚˜ê°€ê¸° ë¡œì§ (cleanup)
            isGameInProgress = false; // âœ¨ ê²Œì„ ì§„í–‰ ì¤‘ í”Œë˜ê·¸ ë„ê¸°
            cleanupOldRoomState(); // ë¦¬ìŠ¤ë„ˆ ë„ê¸°
            
            // ë°©ì¥ì´ë©´ ë°© í­íŒŒ, ê²ŒìŠ¤íŠ¸ë©´ ë‚´ ì •ë³´ë§Œ ì‚­ì œ
            const promise = isHost ? roomRef.remove() : roomRef.child('players/' + myPlayerId).remove();
            promise.finally(() => {
                window.location.href = 'ëŒ€ê¸°ì‹¤.html';
            });
        } else {
            // ì‹±ê¸€í”Œë ˆì´ ë‚˜ê°€ê¸° ë¡œì§
            sessionStorage.setItem('returnFromGame', 'true'); 
            window.location.href = 'index.html';
        }
    });

    exitCancelBtn.addEventListener('click', () => {
        confirmExitModal.style.display = 'none'; // ëª¨ë‹¬ ë‹«ê¸°
    });
    // âœ¨ [ì‹ ê·œ] ë

     (function() {
                    document.addEventListener('contextmenu', e => e.preventDefault());
            function blockKeys(e) {
                if (
                    e.keyCode === 123 ||
                    (e.ctrlKey && e.shiftKey && (e.keyCode === 'I'.charCodeAt(0) || e.keyCode === 'J'.charCodeAt(0) || e.keyCode === 'C'.charCodeAt(0))) ||
                    (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0))
                ) {
                    e.preventDefault();
                }
            }
            window.addEventListener('keydown', blockKeys);

            setInterval(function () {
                const before = new Date().getTime();
                debugger; 
                const after = new Date().getTime();
                if (after - before > 100) { 
                              document.body.innerHTML = 'Developer tools are not allowed.';
                }
            }, 1000);
        })();
    const firebaseConfig = {
        apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
        databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
        storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
        appId: "1:858281658455:web:9131280a459be983933b12"
    };
    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
const database = firebase.database();
const auth = firebase.auth();
const gameRoomsRef = database.ref('rooms'); // âœ¨ [ìˆ˜ì •] 'memoryGameRooms' -> 'rooms'
    const playersRef = database.ref('users');
    
    const startMenu = document.getElementById('start-menu'),
          singlePlayerBtn = document.getElementById('single-player-btn'),
          multiplayerBtn = document.getElementById('multiplayer-btn'),
          backToIndexBtn = document.getElementById('back-to-index-btn'),
          gameWrapper = document.getElementById('game-wrapper'),
          cardGrid = document.getElementById('card-grid'),
          gameHeader = document.getElementById('game-header'),
          waitingOverlay = document.getElementById('waiting-overlay'),
          gameOverOverlay = document.getElementById('game-over-overlay'),
          flipSound = document.getElementById('flip-sound'),
          infoOverlay = document.getElementById('info-overlay'),
          infoTitle = document.getElementById('info-title'),
          infoMessage = document.getElementById('info-message'),
          infoConfirmBtn = document.getElementById('info-confirm-btn');

    const emojiThemes = {
        animals: ['ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¨','ğŸ¯','ğŸ¦','ğŸ®','ğŸ·','ğŸ¸','ğŸµ','ğŸ”','ğŸ§','ğŸ¦','ğŸ¤','ğŸ¦†'],
        monsters: ['ğŸ’€','ğŸ‘»','ğŸ‘½','ğŸ‘¾','ğŸ¤–','ğŸƒ','ğŸ‘¹','ğŸ‘º','ğŸ‘¿','ğŸ§›','ğŸ§Ÿ','ğŸ§','ğŸ¤¡','â˜ ï¸','ğŸ§ ','ğŸ¦‡','ğŸ•·ï¸','ğŸ¦‰','ğŸº','â˜„ï¸'],
        foods: ['ğŸ”','ğŸ•','ğŸŸ','ğŸŒ­','ğŸ¿','ğŸ¥¨','ğŸ¥¯','ğŸ¥','ğŸ§‡','ğŸ§€','ğŸ—','ğŸ–','ğŸ¥©','ğŸ¥“','ğŸ¥','ğŸ','ğŸ¥–','ğŸ©','ğŸª','ğŸ¥¤']
    };
    
    // âœ¨ [ì‹ ê·œ] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸ ì •ì˜
    const AVATAR_SETS = {
        'default_bomber': {
            front: './ì•„ë°”íƒ€í´ë”/ê¸°ë³¸ìºì •ë©´.png'
        },
        'penguin_parka': { // Firebase profile/avatarì— ì €ì¥ë  ê³ ìœ  ID
            front: './ì•„ë°”íƒ€í´ë”/í­ê·„ì •ë©´.png'
        },
        'puppy_set': { 
            front: './ì•„ë°”íƒ€í´ë”/ê°•ì•„ì§€ì •ë©´.png'
        }
    };
    
    let myPlayerId, myNickname, myAvatar, roomRef, currentRoomData, isHost = false, isGameInProgress = false;

function getPlayerId() {
        const urlParams = new URLSearchParams(window.location.search);
        // â˜…â˜…â˜… URLì—ì„œ myPlayerIdë¥¼ ë¨¼ì € ì½ê³ , ì—†ìœ¼ë©´ localStorageì—ì„œ ì°¾ë„ë¡ ìˆ˜ì • â˜…â˜…â˜…
        const id = urlParams.get('myPlayerId') || localStorage.getItem('myPlayerId');
        if (!id) {
            alert("í”Œë ˆì´ì–´ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.");
            window.location.href = 'index.html';
            return null;
        }
        myNickname = localStorage.getItem('userNickname');
        myAvatar = localStorage.getItem('userAvatar');
        return id;
    }

    function showView(viewToShow) {
        document.querySelectorAll('.view').forEach(view => view.classList.add('hidden'));
        viewToShow.classList.remove('hidden');
    }

    function showInfoModal(title, message, onConfirm) {
        infoTitle.textContent = title;
        infoMessage.textContent = message;
        infoConfirmBtn.onclick = () => {
            infoOverlay.style.display = 'none';
            if (onConfirm) onConfirm();
        };
        infoOverlay.style.display = 'flex';
    }

    function cleanupOldRoomState() {
        if (roomRef) { roomRef.off(); roomRef.onDisconnect().cancel(); }
        roomRef = null; currentRoomData = null; isGameInProgress = false; isHost = false;
    }

    function playFlipSound() { flipSound.currentTime = 0; flipSound.play().catch(e => {}); }
    
    function generateCards(pairCount) {
        const themeNames = Object.keys(emojiThemes);
        const randomThemeName = themeNames[Math.floor(Math.random() * themeNames.length)];
        const selectedEmojis = [...emojiThemes[randomThemeName]];
        selectedEmojis.sort(() => Math.random() - 0.5);
        const d=[...selectedEmojis.slice(0,pairCount),...selectedEmojis.slice(0,pairCount)];
        d.sort(()=>Math.random()-0.5); 
        return d.map(e=>({emoji:e,matched:false}));
    }
    
    function initializeFirstGame() {
        if (!isHost || !currentRoomData) return;
        const playerCount = Object.keys(currentRoomData.players).length;
        let pairCount;
        if (playerCount <= 2) pairCount = 10;
        else if (playerCount === 3) pairCount = 15;
        else pairCount = 20;
        const newCards = generateCards(pairCount);
        const playerOrder = Object.keys(currentRoomData.players).sort(() => Math.random() - 0.5);
        const players = currentRoomData.players;
        Object.keys(players).forEach(pid => { players[pid].score = 0; players[pid].wantsRematch = null; });

        roomRef.update({
            gameState: 'ready',
            cards: newCards,
            turn: playerOrder[0],
            playerOrder: playerOrder,
            players: players,
            flippedCards: []
        });
    }

    function joinMultiplayerGame(roomId) {
        cleanupOldRoomState();
        roomRef = gameRoomsRef.child(roomId);
        
        // â˜… [ì¶”ê°€] ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•˜ê¸° ì „ì— ë¨¼ì € ê²Œì„ ë·°ì™€ ë¡œë”©ì°½ì„ ë„ì›ë‹ˆë‹¤.
        showView(gameWrapper);
        waitingOverlay.innerHTML = `<div>ê²Œì„ ë°©ì— ì—°ê²°í•˜ëŠ” ì¤‘...</div>`;
        waitingOverlay.style.display = 'flex';
        
        listenToRoomChanges();
    }

    function listenToRoomChanges() {
        isGameInProgress = true;
        // showView(gameWrapper); // â˜… [ì‚­ì œ] ì´ ì¤„ì„ ì‚­ì œí•©ë‹ˆë‹¤. (joinMultiplayerGameìœ¼ë¡œ ì´ë™)

        roomRef.on('value', snapshot => {
            if (!isGameInProgress) return; // ê²Œì„ ì§„í–‰ ì¤‘ ì•„ë‹ˆë©´ ë¬´ì‹œ

            if (!snapshot.exists()) { // ë°©ì´ ì‚¬ë¼ì¡Œìœ¼ë©´
                showInfoModal("ë°©ì´ í•´ì²´ë˜ì—ˆìŠµë‹ˆë‹¤", "ë°©ì¥ì´ ê²Œì„ì„ ë– ë‚˜ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.", () => {
                    cleanupOldRoomState();
                    window.location.href = 'ëŒ€ê¸°ì‹¤.html';
                });
                return;
            }

            currentRoomData = snapshot.val(); // ìµœì‹  ë°ì´í„° ì €ì¥

            // ë‚´ ì •ë³´ê°€ ì—†ìœ¼ë©´ (ê°•í‡´ ë“±)
            if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                 showInfoModal("ë°©ì—ì„œ í‡´ì¥ë˜ì—ˆìŠµë‹ˆë‹¤", "ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.", () => {
                    cleanupOldRoomState();
                    window.location.href = 'ëŒ€ê¸°ì‹¤.html';
                });
                return;
            }

            isHost = currentRoomData.hostId === myPlayerId; // ë°©ì¥ ì—¬ë¶€ ì—…ë°ì´íŠ¸
            console.log('[MemoryGame] Firebase Update Received. gameState:', currentRoomData.gameState, 'isHost:', isHost); // ë¡œê·¸ ì¶”ê°€

            // 1. ë°©ì¥ì´ê³  ê²Œì„ ìƒíƒœê°€ ì•„ì§ ì„¤ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì´ˆê¸° ìƒíƒœë¼ë©´ ê²Œì„ ì´ˆê¸°í™” ì‹œì‘
            // [ìˆ˜ì •] ì¡°ê±´ ì¶”ê°€: (!currentRoomData.gameState) ì¦‰, N/A ìƒíƒœì¼ ë•Œë„ ì´ˆê¸°í™” ì‹¤í–‰
            if (isHost && (!currentRoomData.gameState || currentRoomData.gameState === 'launching' || currentRoomData.gameState === 'waiting')) {
                console.log('[MemoryGame] Host initiating game setup. Current State:', currentRoomData.gameState);
                initializeFirstGame(); // ì¹´ë“œ ìƒì„± ë° 'ready' ìƒíƒœë¡œ ì—…ë°ì´íŠ¸ ìš”ì²­
                return; // â˜…â˜…â˜… ì¤‘ìš”: HostëŠ” ì—¬ê¸°ì„œ returní•˜ì—¬ ìì‹ ì´ ë°©ê¸ˆ ìš”ì²­í•œ 'ready' ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ê¸°ë‹¤ë¦¼
            }

            // 2. í—¤ë” UI ì—…ë°ì´íŠ¸ (í•­ìƒ)
            if (currentRoomData.players) {
                updateStatusUI();
            } else {
                console.warn('[MemoryGame] Player data missing for header update.');
            }

            // 3. ê²Œì„ ìƒíƒœë³„ ì²˜ë¦¬
            switch (currentRoomData.gameState) {
                case 'ready': // ê²Œì„ ì‹œì‘ ì¤€ë¹„ ì™„ë£Œ (ì¹´ë“œ ìƒì„±ë¨)
                    console.log('[MemoryGame] Ready state detected. Checking cards:', currentRoomData.cards ? currentRoomData.cards.length : 'No cards');
                    // ì¹´ë“œ ë°ì´í„°ê°€ í™•ì‹¤íˆ ì¡´ì¬í•  ë•Œë§Œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                    if (currentRoomData.cards && currentRoomData.cards.length > 0) {
                        console.log('[MemoryGame] Cards found, starting countdown.');
                        startCountdown(); // 3, 2, 1 ì‹œì‘
                    } else {
                        console.warn('[MemoryGame] Ready state but no cards data found yet. Waiting...');
                        // ì¹´ë“œ ë°ì´í„° ë¡œë”© ì¤‘ í‘œì‹œ (ì„ íƒ ì‚¬í•­)
                        waitingOverlay.innerHTML = `<div>ì¹´ë“œ ì •ë³´ ë¡œë”© ì¤‘...</div>`;
                        waitingOverlay.style.display = 'flex';
                    }
                    break;

                case 'playing': // ê²Œì„ ì§„í–‰ ì¤‘
                    console.log('[MemoryGame] Playing state detected. Checking cards:', currentRoomData.cards ? currentRoomData.cards.length : 'No cards');
                    // ì¹´ë“œ ë°ì´í„°ê°€ í™•ì‹¤íˆ ì¡´ì¬í•  ë•Œë§Œ ì¹´ë“œ ê·¸ë¦¬ê¸°
                    if (currentRoomData.cards && currentRoomData.cards.length > 0) {
                        waitingOverlay.style.display = 'none'; // ì¹´ìš´íŠ¸ë‹¤ìš´/ë¡œë”© ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
                        console.log('[MemoryGame] Cards found, drawing board.');
                        drawMultiplayerCards(); // ì¹´ë“œ í™”ë©´ì— ê·¸ë¦¬ê¸°
                    } else {
                        // ë¹„ì •ìƒ ìƒíƒœ: playingì¸ë° ì¹´ë“œê°€ ì—†ìŒ
                        console.error('[MemoryGame] CRITICAL: Playing state but no cards data found!');
                        waitingOverlay.innerHTML = `<div>ì˜¤ë¥˜: ì¹´ë“œ ë°ì´í„°ë¥¼ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</div>`;
                        waitingOverlay.style.display = 'flex';
                    }
                    break;

                case 'gameOver': // ê²Œì„ ì¢…ë£Œ
                    console.log('[MemoryGame] GameOver state detected.');
                    waitingOverlay.style.display = 'none'; // ì¹´ìš´íŠ¸ë‹¤ìš´/ë¡œë”© ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
                    showGameOverScreen(); // ê²Œì„ ê²°ê³¼ í™”ë©´ í‘œì‹œ
                    break;

                case 'launching': // ê²Œì„ ì‹œì‘ ì¤‘ (ê²ŒìŠ¤íŠ¸ê°€ ì´ ìƒíƒœë¥¼ ë³¼ ìˆ˜ ìˆìŒ)
                    console.log('[MemoryGame] Launching state detected (Guest). Showing waiting overlay.');
                    waitingOverlay.innerHTML = `<div>ê²Œì„ ì´ˆê¸°í™” ì¤‘...</div>`; // ë¡œë”© ì¤‘ í‘œì‹œ
                    waitingOverlay.style.display = 'flex';
                    break;

                default: // ì•Œ ìˆ˜ ì—†ê±°ë‚˜ ì´ˆê¸° ìƒíƒœ
                    console.log('[MemoryGame] Unknown or initial gameState:', currentRoomData.gameState);
                    waitingOverlay.innerHTML = `<div>ê²Œì„ ìƒíƒœ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘... (${currentRoomData.gameState || 'N/A'})</div>`;
                    waitingOverlay.style.display = 'flex';
            }
        });
    }
    
    function startCountdown() {
        // ì´ë¯¸ ì¹´ìš´íŠ¸ë‹¤ìš´ UIê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        if (document.getElementById('countdown-number')) {
            console.log('[MemoryGame] Countdown already in progress. Skipping.');
            return;
        }
        console.log('[MemoryGame] Starting countdown sequence.');

        // ì¹´ìš´íŠ¸ë‹¤ìš´ UI ìƒì„± ë° í‘œì‹œ
        waitingOverlay.innerHTML = `<div id="countdown-container"><h2>ê²Œì„ ì‹œì‘!</h2><p id="countdown-number">3</p></div>`; // ì‹œì‘ ìˆ«ì 3 í‘œì‹œ
        waitingOverlay.style.display = 'flex';
        let count = 3;
        const countdownEl = document.getElementById('countdown-number'); // ìˆ«ì í‘œì‹œ ì—˜ë¦¬ë¨¼íŠ¸

        // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ ê°ì†Œ
        const interval = setInterval(() => {
            count--;
            console.log('[MemoryGame] Countdown:', count);

            if (count > 0) { // 2, 1 í‘œì‹œ
                if (countdownEl) countdownEl.textContent = count;
            } else { // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ
                clearInterval(interval); // íƒ€ì´ë¨¸ ì¤‘ì§€
                console.log('[MemoryGame] Countdown finished.');
                waitingOverlay.style.display = 'none'; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€

                // â˜…â˜…â˜… ì¤‘ìš”: ë°©ì¥(isHost)ë§Œ gameStateë¥¼ 'playing'ìœ¼ë¡œ ë³€ê²½
                if (isHost) {
                     console.log('[MemoryGame] Host setting gameState to playing.');
                     roomRef.child('gameState').set('playing'); // Firebase ì—…ë°ì´íŠ¸ ìš”ì²­
                }
                // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸(ë°©ì¥ í¬í•¨)ëŠ” ì´ ì—…ë°ì´íŠ¸ë¥¼ ë°›ê³  'playing' ìƒíƒœ ë¡œì§(drawMultiplayerCards)ì„ ì‹¤í–‰í•˜ê²Œ ë¨
            }
        }, 1000);
    }
    
    function updateStatusUI() {
        if (!currentRoomData || !currentRoomData.players) { gameHeader.innerHTML = ''; return; }
        gameHeader.innerHTML = '';
        let playerIds = [...(currentRoomData.playerOrder || Object.keys(currentRoomData.players).sort())];
        const myIndex = playerIds.indexOf(myPlayerId);
        if (myIndex > -1) {
            const me = playerIds.splice(myIndex, 1)[0];
            playerIds.unshift(me);
        }
        playerIds.forEach(pid => {
            const player = currentRoomData.players[pid];
            if (!player) return;
            const statusBox = document.createElement('div');
            const isMyTurn = currentRoomData.turn === pid;
            statusBox.classList.add('status-box');
            if (isMyTurn) statusBox.classList.add('my-turn');

            // âœ¨ [ìˆ˜ì •] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸(ID), ì´ë¯¸ì§€, ì´ëª¨ì§€ ìˆœìœ¼ë¡œ í™•ì¸
            const avatarSet = AVATAR_SETS[player.avatar];
            let avatarHTML = '';
            if (avatarSet) {
                avatarHTML = `<img src="${avatarSet.front}" class="status-avatar-img">`;
            } else if (player.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(player.avatar)) {
                avatarHTML = `<img src="${player.avatar}" class="status-avatar-img">`;
            } else {
                avatarHTML = `<span class="status-avatar-emoji">${escapeHTML(player.avatar)}</span>`; // ì´ëª¨ì§€
            }
            
            let statusText = `${avatarHTML} <span class="nickname">${escapeHTML(player.nickname)}</span> ${player.score}`;
            if (isMyTurn && pid === myPlayerId) statusText += ' (ë‚´ ì°¨ë¡€)';
            statusBox.innerHTML = statusText;
            gameHeader.appendChild(statusBox);
        });
    }

    function drawMultiplayerCards() {
        if(!currentRoomData.cards) return;
        cardGrid.innerHTML = currentRoomData.cards.map((card, index) => {
            let cardStateClass = '';
            if(card.matched) cardStateClass = 'matched';
            if(currentRoomData.flippedCards?.includes(index)) cardStateClass += ' flipped';
            return `<div class="card ${cardStateClass}" data-index="${index}"><div class="card-inner"><div class="card-face card-back"></div><div class="card-face card-front">${card.emoji}</div></div></div>`;
        }).join('');
        cardGrid.className = `p${Object.keys(currentRoomData.players).length}`;
        document.querySelectorAll('.card:not(.matched)').forEach(c => c.addEventListener('click', () => handleMultiplayerCardClick(parseInt(c.dataset.index))));
    }

    function handleMultiplayerCardClick(index) {
        if (currentRoomData.turn !== myPlayerId || currentRoomData.cards[index].matched || currentRoomData.flippedCards?.length >= 2 || currentRoomData.flippedCards?.includes(index)) return;
        playFlipSound();
        const flippedCards = [...(currentRoomData.flippedCards || []), index];
        const updates = { flippedCards };

        if (flippedCards.length < 2) {
            roomRef.update(updates);
            return;
        }

        const [card1, card2] = [currentRoomData.cards[flippedCards[0]], currentRoomData.cards[flippedCards[1]]];
        if (card1.emoji === card2.emoji) {
            updates.flippedCards = [];
            updates[`cards/${flippedCards[0]}/matched`] = true;
            updates[`cards/${flippedCards[1]}/matched`] = true;
            updates[`players/${myPlayerId}/score`] = currentRoomData.players[myPlayerId].score + 1;
            const allMatched = currentRoomData.cards.every((c, i) => c.matched || flippedCards.includes(i));
            if (allMatched) {
                updates.gameState = 'gameOver';
            }
            roomRef.update(updates); // ë§¤ì¹˜ ì„±ê³µ ì‹œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        } else {
            // ë§¤ì¹˜ ì‹¤íŒ¨ ì‹œ: 1ì´ˆ ì§€ì—° í›„ í„´ ë„˜ê¸°ê¸°ì™€ ì¹´ë“œ ë’¤ì§‘ê¸°ë¥¼ í•¨ê»˜ ì²˜ë¦¬
            roomRef.update(updates); // ìš°ì„  ë‘ ë²ˆì§¸ ì¹´ë“œê°€ ë’¤ì§‘íŒ ê²ƒì„ ë³´ì—¬ì£¼ê¸° ìœ„í•´ ì—…ë°ì´íŠ¸
            setTimeout(() => {
                const pOrder = currentRoomData.playerOrder;
                const nextTurn = pOrder[(pOrder.indexOf(myPlayerId) + 1) % pOrder.length];
                roomRef.update({
                    flippedCards: [], // ì¹´ë“œ ë‹¤ì‹œ ë’¤ì§‘ê¸°
                    turn: nextTurn     // í„´ ë„˜ê¸°ê¸°
                });
            }, 1000);
        }
    }
    
    async function showGameOverScreen() {
        isGameInProgress = false; // ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸
        const playersArray = Object.entries(currentRoomData.players).map(([id, data]) => ({ id, ...data }));
        const maxScore = Math.max(...playersArray.map(p => p.score));
        const winners = playersArray.filter(p => p.score === maxScore && p.score > 0);
        
        if (isHost) {
            const updates = {};
            for(const p of playersArray){
                const isWinner = winners.some(w => w.id === p.id) && winners.length === 1;
                updates[p.id] = { isWinner };
            }
            await Promise.all(Object.entries(updates).map(([pid, res]) => updatePlayerStats(pid, res.isWinner)));
        }

        const amIWinner = winners.some(w => w.id === myPlayerId);
        let message = amIWinner && winners.length === 1 ? "ìŠ¹ ë¦¬ !" : (winners.length > 1 ? "ë¬´ìŠ¹ë¶€!" : "íŒ¨ ë°° !");
        
        playersArray.sort((a, b) => b.score - a.score);
        
        // [ìˆ˜ì •] ì•„ë°”íƒ€ ì´ë¯¸ì§€/ì´ëª¨ì§€ íŒë³„ ë¡œì§ ì¶”ê°€
        const finalScoresHTML = playersArray.map(p => {
            const avatarSet = AVATAR_SETS[p.avatar];
            let avatarHTML = '';
            
            if (avatarSet) {
                // 1. ì•„ë°”íƒ€ ì„¸íŠ¸(ID)ì¸ ê²½ìš°
                avatarHTML = `<img src="${avatarSet.front}" style="width:30px; height:30px; vertical-align:middle; margin-right:5px; border-radius:50%;">`;
            } else if (p.avatar && (p.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(p.avatar) || p.avatar.startsWith('.'))) {
                // 2. ì§ì ‘ ì´ë¯¸ì§€ URLì¸ ê²½ìš°
                avatarHTML = `<img src="${p.avatar}" style="width:30px; height:30px; vertical-align:middle; margin-right:5px; border-radius:50%;">`;
            } else {
                // 3. ì´ëª¨ì§€ì¸ ê²½ìš°
                avatarHTML = `<span style="margin-right:5px; font-size:1.2em;">${p.avatar || 'â“'}</span>`;
            }

            return `<div class="score-row ${winners.some(w=>w.id===p.id) && winners.length === 1 ? 'winner' : 'loser'}">
                        ${avatarHTML} ${p.nickname} : ${p.score}ì 
                    </div>`;
        }).join('');

        gameOverOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2 id="game-over-message">${message}</h2></div><div class="modal-body"><div id="score-board">${finalScoresHTML}</div><div class="modal-buttons"><button id="rematch-btn" class="menu-btn primary">ë‹¤ì‹œ í•˜ê¸°</button><button id="lobby-btn" class="menu-btn secondary">ë‚˜ê°€ê¸°</button></div></div></div>`;
        gameOverOverlay.style.display = 'flex';
        
        document.getElementById('rematch-btn').addEventListener('click', () => {
            const btn = document.getElementById('rematch-btn');
            btn.textContent = 'ëŒ€ê¸°ì¤‘...'; btn.disabled = true;
            roomRef.child(`players/${myPlayerId}/wantsRematch`).set(true);
        });
        document.getElementById('lobby-btn').addEventListener('click', () => { window.location.href = 'ëŒ€ê¸°ì‹¤.html'; });
        
        const rematchListenerRef = roomRef.child('players');
        rematchListenerRef.on('value', snapshot => {
            if (!snapshot.exists() || currentRoomData?.gameState !== 'gameOver') { rematchListenerRef.off(); return; }
            const currentPlayers = snapshot.val();
            if (Object.values(currentPlayers).every(p => p.wantsRematch)) {
                rematchListenerRef.off(); gameOverOverlay.style.display = 'none';
                if (isHost) startRematch();
            }
        });
    }
    
    function startRematch() {
        if (!isHost || !currentRoomData) return;
        isGameInProgress = true; // ê²Œì„ ì¬ì‹œì‘ í”Œë˜ê·¸
        const playerCount = Object.keys(currentRoomData.players).length;
        let pairCount;
        if (playerCount <= 2) pairCount = 10; else if (playerCount === 3) pairCount = 15; else pairCount = 20;
        const newCards = generateCards(pairCount);
        const playerOrder = Object.keys(currentRoomData.players).sort(() => Math.random() - 0.5);
        const players = currentRoomData.players;
        Object.keys(players).forEach(pid => { players[pid].score = 0; players[pid].wantsRematch = null; });
        roomRef.update({ gameState: 'ready', cards: newCards, turn: playerOrder[0], playerOrder, players, flippedCards: [] });
    }

    async function updatePlayerStats(playerId, isWinner) {
        if (playerId.startsWith('guest_')) return; // ê²ŒìŠ¤íŠ¸ëŠ” ì „ì  ì—…ë°ì´íŠ¸ ì•ˆí•¨
        const playerStatRef = playersRef.child(playerId);
        try {
            await playerStatRef.transaction(currentData => {
                if (currentData) {
                    // â˜… [ìˆ˜ì •] 'stats' -> 'gameStats'ë¡œ ë³€ê²½ (DB ê·œì¹™ê³¼ ì¼ì¹˜ì‹œí‚´)
                    if (!currentData.gameStats) currentData.gameStats = {};
                    if (!currentData.gameStats.memoryGame) currentData.gameStats.memoryGame = { wins: 0, losses: 0, plays: 0 };
                    
                    // â˜… [ì¶”ê°€] í”Œë ˆì´ íšŸìˆ˜ 1 ì¦ê°€ (ë­í‚¹ ì§‘ê³„ìš©)
                    currentData.gameStats.memoryGame.plays = (currentData.gameStats.memoryGame.plays || 0) + 1;

                    // â˜… [ìˆ˜ì •] 'profile' ê°ì²´ ë‚´ë¶€ì˜ 'exp', 'level'ì„ ì°¸ì¡°í•˜ë„ë¡ ë³€ê²½
                    if (!currentData.profile) currentData.profile = {}; // (ì•ˆì „ì¥ì¹˜)

                    if (isWinner) {
                        currentData.gameStats.memoryGame.wins = (currentData.gameStats.memoryGame.wins || 0) + 1;
                        currentData.profile.exp = (currentData.profile.exp || 0) + 50; // profile.exp
                    } else {
                        currentData.gameStats.memoryGame.losses = (currentData.gameStats.memoryGame.losses || 0) + 1;
                        currentData.profile.exp = (currentData.profile.exp || 0) + 10; // profile.exp
                    }
                    
                    let level = currentData.profile.level || 1;
                    let exp = currentData.profile.exp || 0;
                    let expForNextLevel = level * 100;
                    
                    while (exp >= expForNextLevel) { // 'exp' ë³€ìˆ˜ ì‚¬ìš©
                        level++;
                        exp -= expForNextLevel; // 'exp' ë³€ìˆ˜ì—ì„œ ì°¨ê°
                        expForNextLevel = level * 100;
                    }
                    currentData.profile.level = level; // profile.level
                    currentData.profile.exp = exp; // â˜… [ìˆ˜ì •] ë‚¨ì€ ê²½í—˜ì¹˜ë„ profile.expì— ë‹¤ì‹œ ì €ì¥

                } return currentData;
            });
        } catch (error) { console.error("ì „ì  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error); }
    }
    
    let singlePlayerFlipped = [], singlePlayerMatched = 0;
    
    function startSinglePlayerCountdown() {
        showView(gameWrapper);
        gameWrapper.classList.add('hidden');
        waitingOverlay.innerHTML = `<div id="countdown-container"><h2>ê²Œì„ ì‹œì‘!</h2><p id="countdown-number"></p></div>`;
        waitingOverlay.style.display = 'flex';
        let count = 3;
        const countdownEl = document.getElementById('countdown-number');
        const updateCount = () => { countdownEl.textContent = count; };
        updateCount();
        const interval = setInterval(() => {
            count--;
            if (count > 0) updateCount();
            else {
                clearInterval(interval);
                waitingOverlay.style.display = 'none';
                startSinglePlayerGame();
            }
        }, 1000);
    }

    function startSinglePlayerGame() {
        cleanupOldRoomState();
        showView(gameWrapper);
        gameWrapper.classList.remove('hidden');
        singlePlayerFlipped = []; singlePlayerMatched = 0;
        const cards = generateCards(10);
        cardGrid.className = 'single';
        gameHeader.innerHTML = `<div class="status-box">ì •ë‹µ: <span id="matched-counter">0</span> / 10</div>`;
        cardGrid.innerHTML = cards.map((card, index) => `<div class="card" data-index="${index}"><div class="card-inner"><div class="card-face card-back"></div><div class="card-face card-front">${card.emoji}</div></div></div>`).join('');
        document.querySelectorAll('#card-grid .card').forEach(cardEl => cardEl.addEventListener('click', () => handleSinglePlayerCardClick(cardEl, cards)));
    }

    function handleSinglePlayerCardClick(cardEl, cards) {
        if (cardEl.classList.contains('flipped') || singlePlayerFlipped.length >= 2) return;
        playFlipSound();
        cardEl.classList.add('flipped');
        singlePlayerFlipped.push(cardEl);
        if (singlePlayerFlipped.length === 2) {
            const [el1, el2] = singlePlayerFlipped;
            const [idx1, idx2] = [parseInt(el1.dataset.index), parseInt(el2.dataset.index)];
            if (cards[idx1].emoji === cards[idx2].emoji) {
                singlePlayerMatched++;
                document.getElementById('matched-counter').textContent = singlePlayerMatched;
                el1.classList.add('matched'); el2.classList.add('matched');
                singlePlayerFlipped = [];
                if (singlePlayerMatched === 10) {
                    gameOverOverlay.innerHTML = `<div class="modal-content"><div class="modal-header"><h2>ğŸ‰ ì„±ê³µ! ğŸ‰</h2></div><div class="modal-body"><p>ëª¨ë“  ì¹´ë“œë¥¼ ë§ì·„ìŠµë‹ˆë‹¤!</p><div class="modal-buttons"><button id="single-retry-btn" class="menu-btn primary">ë‹¤ì‹œ í•˜ê¸°</button><button id="single-main-menu-btn" class="menu-btn secondary">ë©”ì¸ìœ¼ë¡œ</button></div></div></div>`;
                    gameOverOverlay.style.display = 'flex';
                    document.getElementById('single-retry-btn').addEventListener('click', () => { gameOverOverlay.style.display = 'none'; startSinglePlayerGame(); });
                    document.getElementById('single-main-menu-btn').addEventListener('click', () => { sessionStorage.setItem('returnFromGame', 'true'); window.location.href = 'index.html'; });
                }
            } else { setTimeout(() => { el1.classList.remove('flipped'); el2.classList.remove('flipped'); singlePlayerFlipped = []; }, 1000); }
        }
    }

    auth.onAuthStateChanged(user => {
        if (user) {
            // getPlayerId()ë¥¼ í˜¸ì¶œí•˜ì—¬ myPlayerId, myNickname, myAvatarë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
            myPlayerId = getPlayerId(); 
            
            // getPlayerIdê°€ ì„±ê³µì ìœ¼ë¡œ IDë¥¼ ê°€ì ¸ì™”ê³ , ê·¸ IDê°€ í˜„ì¬ ë¡œê·¸ì¸ëœ user.uidì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
            if (myPlayerId && myPlayerId === user.uid) {
                const urlParams = new URLSearchParams(window.location.search);
                const roomId = urlParams.get('roomId');
    
                if (roomId) {
                    joinMultiplayerGame(roomId);
                } else {
                    // roomIdê°€ ì—†ëŠ” ê²½ìš° (ì˜ˆ: ì‹±ê¸€ í”Œë ˆì´)
                    showView(startMenu);
                    singlePlayerBtn.addEventListener('click', startSinglePlayerCountdown);
                    multiplayerBtn.addEventListener('click', () => { window.location.href = 'ëŒ€ê¸°ì‹¤.html'; });
                    backToIndexBtn.addEventListener('click', () => { window.location.href = 'index.html'; });
                }
            } else if (myPlayerId && myPlayerId !== user.uid) {
                // ì¸ì¦ IDì™€ localStorage/URL ID ë¶ˆì¼ì¹˜
                alert('í”Œë ˆì´ì–´ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.');
                window.location.href = 'index.html';
            }
            // getPlayerId()ê°€ nullì„ ë°˜í™˜í•˜ë©´ (ì •ë³´ê°€ ì—†ìŒ) ì´ë¯¸ alertë¥¼ ë„ìš°ê³  index.htmlë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸í•©ë‹ˆë‹¤.

        } else {
            // ë¹„ë¡œê·¸ì¸ ìƒíƒœ
            alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            window.location.href = 'index.html';
        }
    });

});
</script>
</body>
</html>