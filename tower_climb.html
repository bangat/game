<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Christmas Tower Climb</title>
  <style>
    :root{
      --ui-black: rgba(0,0,0,0.82);
      --ui-line: rgba(255,255,255,0.24);
      --green: #1ed933;
      --yellow: #ffbf1c;
      --btn: clamp(70px, 14vw, 106px);
    }

    *{
      box-sizing:border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body{
      margin:0;
      width:100%;
      height:100%;
      overflow:hidden;
      touch-action:none;
      user-select:none;
      font-family:"Trebuchet MS","Arial Black",sans-serif;
      background:#2ab53f;
    }

    #app{
      position:fixed;
      inset:0;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    #topHud{
      position:fixed;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      left: calc(env(safe-area-inset-left, 0px) + 10px);
      right: calc(env(safe-area-inset-right, 0px) + 10px);
      z-index:20;
      display:flex;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
      gap:10px;
    }

    #menuDock{
      pointer-events:auto;
      display:flex;
      gap:10px;
      align-items:center;
      background:var(--ui-black);
      border:1px solid var(--ui-line);
      border-radius:999px;
      padding:8px 12px;
      box-shadow:0 8px 20px rgba(0,0,0,0.25);
      min-width:130px;
    }

    .dotBtn{
      border:0;
      width:24px;
      height:24px;
      border-radius:50%;
      background:transparent;
      color:#fff;
      font-size:18px;
      font-weight:900;
      line-height:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0;
    }

    #stageHud{
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:12px;
      text-shadow:0 5px 12px rgba(0,0,0,0.35);
      margin-left:auto;
      margin-right:auto;
      transform:translateY(2px);
    }

    #stageHud .arrow{
      color:var(--green);
      font-size: clamp(44px, 8.4vw, 66px);
      font-weight:900;
      line-height:0.8;
    }

    #uiStage{
      color:var(--yellow);
      font-size: clamp(52px, 9vw, 74px);
      font-weight:900;
      line-height:0.82;
      min-width:60px;
      text-align:center;
    }

    #btnReset{
      pointer-events:auto;
      border:0;
      border-radius:14px;
      background:#ffbe18;
      color:#111;
      font-size: clamp(20px, 3.3vw, 28px);
      font-weight:900;
      letter-spacing:0.4px;
      padding:8px 15px;
      box-shadow:0 6px 18px rgba(0,0,0,0.24);
      cursor:pointer;
    }

    #btnReset:active{
      transform:translateY(1px);
    }

    #mobileHud{
      position:fixed;
      left: calc(env(safe-area-inset-left, 0px) + 10px);
      right: calc(env(safe-area-inset-right, 0px) + 10px);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      z-index:25;
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      pointer-events:none;
    }

    #stickZone{
      width: calc(var(--btn) * 1.42);
      height: calc(var(--btn) * 1.42);
      pointer-events:auto;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #stickBase{
      width:100%;
      height:100%;
      border-radius:50%;
      background:rgba(10,14,10,0.34);
      border:2px solid rgba(255,255,255,0.35);
      box-shadow: inset 0 0 0 4px rgba(255,255,255,0.06);
      position:relative;
      backdrop-filter: blur(6px);
    }

    #stickKnob{
      width:46%;
      height:46%;
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.35);
      background:rgba(10,14,10,0.8);
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      box-shadow:0 4px 12px rgba(0,0,0,0.28);
    }

    #btnJump{
      pointer-events:auto;
      width:var(--btn);
      height:var(--btn);
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.3);
      background:rgba(10,14,10,0.38);
      color:rgba(120,255,120,0.95);
      font-size:48px;
      font-weight:900;
      line-height:1;
      display:flex;
      align-items:center;
      justify-content:center;
      text-shadow:0 3px 10px rgba(0,0,0,0.3);
      box-shadow:0 6px 16px rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
      cursor:pointer;
    }

    #btnJump:active{
      transform:translateY(1px);
    }

    #toast{
      position:fixed;
      left:50%;
      top: calc(env(safe-area-inset-top, 0px) + 84px);
      transform:translateX(-50%);
      z-index:30;
      display:none;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.28);
      background:rgba(0,0,0,0.72);
      color:#fff;
      padding:7px 12px;
      font-size:13px;
      font-weight:900;
      white-space:nowrap;
      pointer-events:none;
    }

    @media (orientation: landscape){
      :root{
        --btn: clamp(64px, 11vh, 98px);
      }
      #topHud{
        top: calc(env(safe-area-inset-top, 0px) + 8px);
      }
      #btnReset{
        padding:7px 13px;
      }
      #mobileHud{
        bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
      }
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="topHud">
    <div id="menuDock">
      <button class="dotBtn" type="button">o</button>
      <button class="dotBtn" type="button">=</button>
      <button class="dotBtn" type="button">.</button>
      <button class="dotBtn" type="button">*</button>
    </div>
    <div id="stageHud">
      <span class="arrow">&lt;</span>
      <span id="uiStage">1</span>
      <span class="arrow">&gt;</span>
    </div>
    <button id="btnReset" type="button">RESET</button>
  </div>

  <div id="mobileHud">
    <div id="stickZone">
      <div id="stickBase">
        <div id="stickKnob"></div>
      </div>
    </div>
    <button id="btnJump" type="button">^</button>
  </div>

  <div id="toast"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const CHECKPOINT_TOTAL = 168;
    const ROOM_SIZE = 98;
    const ROOM_HEIGHT = 255;
    const BOUND = ROOM_SIZE * 0.43;

    const app = document.getElementById("app");
    const uiStage = document.getElementById("uiStage");
    const toastEl = document.getElementById("toast");

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2ab53f);
    scene.fog = new THREE.Fog(0x2ab53f, 70, 300);

    const camera = new THREE.PerspectiveCamera(64, innerWidth / innerHeight, 0.1, 1200);

    scene.add(new THREE.HemisphereLight(0xdcffdc, 0x205d2d, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 1.02);
    sun.position.set(45, 120, 25);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left = -120;
    sun.shadow.camera.right = 120;
    sun.shadow.camera.top = 120;
    sun.shadow.camera.bottom = -120;
    sun.shadow.camera.near = 10;
    sun.shadow.camera.far = 400;
    scene.add(sun);

    function makeStudTexture(base, stud, line) {
      const cvs = document.createElement("canvas");
      cvs.width = 256;
      cvs.height = 256;
      const ctx = cvs.getContext("2d");

      ctx.fillStyle = base;
      ctx.fillRect(0, 0, 256, 256);

      for (let y = 0; y < 256; y += 32) {
        for (let x = 0; x < 256; x += 32) {
          ctx.strokeStyle = line;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, 32, 32);

          ctx.fillStyle = stud;
          ctx.beginPath();
          ctx.roundRect(x + 7, y + 7, 18, 18, 4);
          ctx.fill();

          ctx.strokeStyle = line;
          ctx.strokeRect(x + 7, y + 7, 18, 18);
        }
      }

      const tex = new THREE.CanvasTexture(cvs);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const greenTex = makeStudTexture("#24b53c", "#1f9f34", "#168328");
    greenTex.repeat.set(20, 20);

    const wallTex = greenTex.clone();
    wallTex.repeat.set(20, 36);

    const whiteTex = makeStudTexture("#f0f0f0", "#d9d9d9", "#b7b7b7");
    whiteTex.repeat.set(2, 2);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(ROOM_SIZE, ROOM_SIZE),
      new THREE.MeshStandardMaterial({ map: greenTex, roughness: 0.86, metalness: 0.03 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    function addWall(x, z, ry) {
      const wall = new THREE.Mesh(
        new THREE.PlaneGeometry(ROOM_SIZE, ROOM_HEIGHT),
        new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.88, metalness: 0.02 })
      );
      wall.position.set(x, ROOM_HEIGHT * 0.5, z);
      wall.rotation.y = ry;
      wall.receiveShadow = true;
      scene.add(wall);
    }

    const half = ROOM_SIZE * 0.5;
    addWall(0, -half, 0);
    addWall(0, half, Math.PI);
    addWall(-half, 0, Math.PI * 0.5);
    addWall(half, 0, -Math.PI * 0.5);

    const matPlatform = new THREE.MeshStandardMaterial({ map: whiteTex, roughness: 0.66, metalness: 0.06 });
    const matBlock = new THREE.MeshStandardMaterial({ map: whiteTex, roughness: 0.54, metalness: 0.13 });
    const matCheckpoint = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.55 });
    const matActive = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 1.4 });

    const platforms = [];
    const checkpointMarks = [];
    const checkpointPlatforms = [];

    function addPlatform(opts) {
      const {
        x, y, z,
        shape = "box",
        sx = 2.8,
        sy = 0.58,
        sz = 2.8,
        radius = 1.3,
        stage = 1
      } = opts;

      let mesh;
      if (shape === "circle") {
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, sy, 28), matPlatform);
      } else {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), matBlock);
      }

      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { shape, sx, sy, sz, radius, stage };

      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }

    function addCheckpointMark(platform, stage) {
      const mark = new THREE.Mesh(
        new THREE.CylinderGeometry(0.64, 0.64, 0.18, 20),
        stage === 0 ? matActive.clone() : matCheckpoint.clone()
      );
      mark.position.y = platform.userData.sy * 0.5 + 0.17;
      mark.castShadow = false;
      mark.receiveShadow = false;
      platform.add(mark);

      checkpointMarks[stage] = mark;
      checkpointPlatforms[stage] = platform;
    }

    const spawnPlatform = addPlatform({ x: -35, y: 1, z: 0, shape: "circle", radius: 4.3, sy: 2.0, stage: 0 });
    addCheckpointMark(spawnPlatform, 0);

    let angle = 0;
    let height = 2.25;
    let lastX = -35;
    let lastZ = 0;

    for (let i = 1; i <= CHECKPOINT_TOTAL; i++) {
      const phase = (i - 1) / CHECKPOINT_TOTAL;
      const radius = 34 - phase * 14;
      angle += 0.103 + Math.sin(i * 0.27) * 0.012;

      let x = Math.cos(angle) * radius + Math.sin(i * 0.63) * 0.65;
      let z = Math.sin(angle) * radius + Math.cos(i * 0.51) * 0.65;
      x = THREE.MathUtils.clamp(x, -BOUND, BOUND);
      z = THREE.MathUtils.clamp(z, -BOUND, BOUND);

      const dx = x - lastX;
      const dz = z - lastZ;
      const dist = Math.hypot(dx, dz);
      if (dist > 4.55) {
        const s = 4.55 / dist;
        x = lastX + dx * s;
        z = lastZ + dz * s;
      }

      const section = Math.floor((i - 1) / 24);
      const dy = 0.96 + section * 0.03 + (i % 4) * 0.04;
      height += dy;

      let shape = "circle";
      let sx = 2.8;
      let sz = 2.8;
      let sy = 0.56;
      let radiusPad = 1.26;

      if (section >= 2 && section <= 3) {
        shape = "box";
        sx = 2.9;
        sz = 2.9;
        sy = 0.58;
      }
      if (section === 4) {
        shape = "box";
        sx = i % 2 ? 3.2 : 2.1;
        sz = i % 2 ? 2.1 : 3.2;
        sy = 0.52;
      }
      if (section >= 5) {
        shape = i % 3 ? "box" : "circle";
        sx = 2.35;
        sz = 2.35;
        sy = 0.54;
        radiusPad = 1.14;
      }

      const platform = addPlatform({
        x,
        y: height,
        z,
        shape,
        sx,
        sz,
        sy,
        radius: radiusPad,
        stage: i
      });

      if (section >= 1 && shape === "box") {
        const column = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, Math.max(3, height * 0.6), 0.9),
          new THREE.MeshStandardMaterial({ color: 0xe3e3e3, roughness: 0.78 })
        );
        column.position.set(x, height * 0.3, z);
        column.castShadow = false;
        column.receiveShadow = true;
        scene.add(column);
      }

      addCheckpointMark(platform, i);
      lastX = x;
      lastZ = z;
    }

    const finishPlatform = checkpointPlatforms[CHECKPOINT_TOTAL];
    const clearHalo = new THREE.Mesh(
      new THREE.TorusGeometry(2.2, 0.16, 10, 32),
      new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xe8ffd0, emissiveIntensity: 1.4 })
    );
    clearHalo.rotation.x = Math.PI / 2;
    clearHalo.position.y = finishPlatform.position.y + 2.2;
    clearHalo.position.x = finishPlatform.position.x;
    clearHalo.position.z = finishPlatform.position.z;
    scene.add(clearHalo);

    const player = {
      pos: new THREE.Vector3(-35, 4.1, 0),
      vel: new THREE.Vector3(),
      radius: 0.38,
      height: 1.86,
      grounded: false,
      onPlatform: null,
      facing: Math.PI
    };
    const halfH = player.height * 0.5;

    const avatar = new THREE.Group();
    const matSkin = new THREE.MeshStandardMaterial({ color: 0xc5d5e4, roughness: 0.5 });
    const matTop = new THREE.MeshStandardMaterial({ color: 0x2f3134, roughness: 0.72 });
    const matBottom = new THREE.MeshStandardMaterial({ color: 0x1a1a1d, roughness: 0.8 });

    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.78, 0.9, 0.42), matTop);
    torso.position.y = 1.02;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.44, 0.44), matSkin);
    head.position.y = 1.72;
    const hair = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.18, 0.46), new THREE.MeshStandardMaterial({ color: 0x2e2017, roughness: 0.84 }));
    hair.position.y = 1.93;
    const hip = new THREE.Mesh(new THREE.BoxGeometry(0.74, 0.3, 0.42), matBottom);
    hip.position.y = 0.55;

    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.62, 0.2), matSkin);
    armL.position.set(-0.52, 1.03, 0);
    const armR = armL.clone();
    armR.position.x = 0.52;

    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.58, 0.24), matSkin);
    legL.position.set(-0.18, 0.18, 0);
    const legR = legL.clone();
    legR.position.x = 0.18;

    const shoeL = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.12, 0.4), matBottom);
    shoeL.position.set(-0.18, -0.16, 0.08);
    const shoeR = shoeL.clone();
    shoeR.position.x = 0.18;

    avatar.add(torso, head, hair, hip, armL, armR, legL, legR, shoeL, shoeR);
    avatar.traverse((obj) => {
      if (obj.isMesh) obj.castShadow = true;
    });
    scene.add(avatar);

    const cam = {
      yaw: Math.PI * 0.68,
      pitch: -0.35,
      dist: 8.6,
      dragId: -1,
      lastX: 0,
      lastY: 0
    };

    const keys = { up: false, down: false, left: false, right: false };
    const stick = { x: 0, y: 0 };
    let jumpQueued = false;

    let checkpointIndex = 0;
    let respawnPos = new THREE.Vector3(-35, 4.1, 0);
    let cleared = false;

    function toast(msg, ms = 900) {
      toastEl.textContent = msg;
      toastEl.style.display = "block";
      clearTimeout(toast.tid);
      toast.tid = setTimeout(() => { toastEl.style.display = "none"; }, ms);
    }

    function setCheckpoint(index) {
      if (index <= checkpointIndex) return;
      checkpointIndex = index;
      const p = checkpointPlatforms[index];
      respawnPos.set(p.position.x, p.position.y + 2.0, p.position.z);
      uiStage.textContent = String(Math.max(1, checkpointIndex));

      for (let i = 0; i < checkpointMarks.length; i++) {
        const m = checkpointMarks[i];
        if (!m) continue;
        if (i === checkpointIndex) {
          m.material = matActive.clone();
          m.scale.setScalar(1.08);
        } else {
          m.material = matCheckpoint.clone();
          m.scale.setScalar(1);
        }
      }

      if (checkpointIndex > 0 && checkpointIndex < CHECKPOINT_TOTAL) {
        toast(`CHECKPOINT ${checkpointIndex}`);
      }
      if (checkpointIndex === CHECKPOINT_TOTAL && !cleared) {
        cleared = true;
        toast("CLEAR!", 1700);
      }
    }

    function resetToCheckpoint(manual = false) {
      player.pos.copy(respawnPos);
      player.vel.set(0, 0, 0);
      player.grounded = false;
      player.onPlatform = null;
      if (manual) toast(`RESET CP ${Math.max(1, checkpointIndex)}`);
    }

    function insidePlatform(p, x, z, padding = player.radius) {
      const u = p.userData;
      if (u.shape === "circle") {
        const dx = x - p.position.x;
        const dz = z - p.position.z;
        const rr = u.radius + padding;
        return dx * dx + dz * dz <= rr * rr;
      }
      return (
        Math.abs(x - p.position.x) <= u.sx * 0.5 + padding &&
        Math.abs(z - p.position.z) <= u.sz * 0.5 + padding
      );
    }

    function tryLand(p, footPrev, footNow) {
      if (!insidePlatform(p, player.pos.x, player.pos.z)) return false;
      const top = p.position.y + p.userData.sy * 0.5;
      if (footPrev >= top - 0.24 && footNow <= top + 0.14 && player.vel.y <= 0) {
        player.pos.y = top + halfH;
        player.vel.y = 0;
        player.grounded = true;
        player.onPlatform = p;
        setCheckpoint(p.userData.stage);
        return true;
      }
      return false;
    }

    function angleLerp(a, b, t) {
      let d = (b - a + Math.PI) % (Math.PI * 2);
      if (d < 0) d += Math.PI * 2;
      d -= Math.PI;
      return a + d * t;
    }

    function getInput() {
      let ix = 0;
      let iz = 0;
      if (keys.left) ix -= 1;
      if (keys.right) ix += 1;
      if (keys.up) iz += 1;
      if (keys.down) iz -= 1;
      ix += stick.x;
      iz += -stick.y;
      const len = Math.hypot(ix, iz);
      if (len > 1) {
        ix /= len;
        iz /= len;
      }
      return { x: ix, z: iz };
    }

    function updatePlayer(dt, now) {
      const input = getInput();
      const fwdX = -Math.sin(cam.yaw);
      const fwdZ = -Math.cos(cam.yaw);
      const rightX = Math.cos(cam.yaw);
      const rightZ = -Math.sin(cam.yaw);

      const moveX = rightX * input.x + fwdX * input.z;
      const moveZ = rightZ * input.x + fwdZ * input.z;

      const accel = player.grounded ? 25 : 11;
      const maxSpeed = player.grounded ? 10 : 8.3;
      player.vel.x += moveX * accel * dt;
      player.vel.z += moveZ * accel * dt;

      const damp = player.grounded ? 0.78 : 0.92;
      const damping = Math.pow(damp, dt * 60);
      player.vel.x *= damping;
      player.vel.z *= damping;

      const flat = Math.hypot(player.vel.x, player.vel.z);
      if (flat > maxSpeed) {
        player.vel.x = (player.vel.x / flat) * maxSpeed;
        player.vel.z = (player.vel.z / flat) * maxSpeed;
      }

      if (jumpQueued && player.grounded) {
        player.vel.y = 8.8;
        player.grounded = false;
        player.onPlatform = null;
      }
      jumpQueued = false;

      player.vel.y -= 23 * dt;

      const prevY = player.pos.y;
      player.pos.addScaledVector(player.vel, dt);
      player.grounded = false;
      player.onPlatform = null;

      const footPrev = prevY - halfH;
      const footNow = player.pos.y - halfH;
      for (const p of platforms) {
        if (tryLand(p, footPrev, footNow)) break;
      }

      if (player.pos.y < -18) {
        resetToCheckpoint(false);
        toast("FALL", 700);
      }

      const speed = Math.hypot(player.vel.x, player.vel.z);
      if (speed > 0.12) {
        const targetYaw = Math.atan2(player.vel.x, player.vel.z);
        player.facing = angleLerp(player.facing, targetYaw, 0.2);
      }

      const cycle = now * 0.012;
      const stride = Math.min(1, speed / 4);
      legL.rotation.x = Math.sin(cycle) * 0.48 * stride;
      legR.rotation.x = Math.sin(cycle + Math.PI) * 0.48 * stride;
      armL.rotation.x = Math.sin(cycle + Math.PI) * 0.36 * stride;
      armR.rotation.x = Math.sin(cycle) * 0.36 * stride;

      avatar.position.set(player.pos.x, player.pos.y - halfH, player.pos.z);
      avatar.rotation.y = player.facing;
    }

    function updateCamera() {
      const desiredDist = innerWidth > innerHeight ? 9.2 : 8.2;
      cam.dist += (desiredDist - cam.dist) * 0.08;

      const x = player.pos.x + Math.sin(cam.yaw) * Math.cos(cam.pitch) * cam.dist;
      const y = player.pos.y + 2.0 + Math.sin(cam.pitch) * cam.dist;
      const z = player.pos.z + Math.cos(cam.yaw) * Math.cos(cam.pitch) * cam.dist;

      camera.position.lerp(new THREE.Vector3(x, y, z), 0.18);
      camera.lookAt(player.pos.x, player.pos.y + 0.95, player.pos.z);
    }

    function loop(now) {
      const dt = Math.min((now - (loop.prev || now)) / 1000, 0.033);
      loop.prev = now;

      updatePlayer(dt, now);
      updateCamera();

      clearHalo.rotation.z += 0.01;
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    const stickZone = document.getElementById("stickZone");
    const stickBase = document.getElementById("stickBase");
    const stickKnob = document.getElementById("stickKnob");
    let stickPointer = -1;

    function setStick(clientX, clientY) {
      const rect = stickBase.getBoundingClientRect();
      const cx = rect.left + rect.width * 0.5;
      const cy = rect.top + rect.height * 0.5;
      let dx = clientX - cx;
      let dy = clientY - cy;
      const max = rect.width * 0.33;
      const len = Math.hypot(dx, dy);
      if (len > max) {
        dx = (dx / len) * max;
        dy = (dy / len) * max;
      }
      stick.x = dx / max;
      stick.y = dy / max;
      stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }

    function resetStick() {
      stick.x = 0;
      stick.y = 0;
      stickKnob.style.transform = "translate(-50%, -50%)";
    }

    stickZone.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      stickPointer = e.pointerId;
      stickZone.setPointerCapture(e.pointerId);
      setStick(e.clientX, e.clientY);
    }, { passive: false });

    stickZone.addEventListener("pointermove", (e) => {
      if (e.pointerId !== stickPointer) return;
      e.preventDefault();
      setStick(e.clientX, e.clientY);
    }, { passive: false });

    function endStick(e) {
      if (e.pointerId !== stickPointer) return;
      stickPointer = -1;
      resetStick();
    }

    stickZone.addEventListener("pointerup", endStick);
    stickZone.addEventListener("pointercancel", endStick);

    document.getElementById("btnJump").addEventListener("pointerdown", (e) => {
      e.preventDefault();
      jumpQueued = true;
    }, { passive: false });

    document.getElementById("btnReset").addEventListener("click", () => {
      resetToCheckpoint(true);
    });

    renderer.domElement.addEventListener("pointerdown", (e) => {
      if (e.clientX < innerWidth * 0.45) return;
      cam.dragId = e.pointerId;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });

    renderer.domElement.addEventListener("pointermove", (e) => {
      if (e.pointerId !== cam.dragId) return;
      const dx = e.clientX - cam.lastX;
      const dy = e.clientY - cam.lastY;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
      cam.yaw -= dx * 0.0051;
      cam.pitch -= dy * 0.0042;
      cam.pitch = Math.max(-1.2, Math.min(0.32, cam.pitch));
    });

    function endDrag(e) {
      if (e.pointerId === cam.dragId) cam.dragId = -1;
    }

    renderer.domElement.addEventListener("pointerup", endDrag);
    renderer.domElement.addEventListener("pointercancel", endDrag);

    addEventListener("keydown", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keys.up = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.down = true;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
      if (e.code === "Space") {
        jumpQueued = true;
        e.preventDefault();
      }
    }, { passive: false });

    addEventListener("keyup", (e) => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keys.up = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.down = false;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
    });

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    setCheckpoint(0);
    resetToCheckpoint(false);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
