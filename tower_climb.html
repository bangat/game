<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Christmas Tower Climb</title>
  <style>
    :root{
      --bg0:#081126;
      --bg1:#112347;
      --ink:#eef4ff;
      --muted:#b7c2d9;
      --line:rgba(255,255,255,.16);
      --panel:rgba(7,12,26,.68);
      --good:#54f2ac;
      --bad:#ff6666;
      --btn: clamp(50px, 10vw, 74px);
      --gap: clamp(8px, 1.8vw, 12px);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{
      width:100%;
      height:100%;
      margin:0;
      overflow:hidden;
      touch-action:none;
      user-select:none;
      color:var(--ink);
      font-family:"Pretendard","Apple SD Gothic Neo","Malgun Gothic",system-ui,sans-serif;
      background:
        radial-gradient(1200px 700px at 20% 5%, rgba(84,242,172,.15), transparent 55%),
        radial-gradient(1100px 700px at 80% 15%, rgba(101,161,255,.22), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }
    #app{
      position:fixed;
      inset:0;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
    }

    #hud{
      position:fixed;
      top: calc(env(safe-area-inset-top, 0px) + 8px);
      left: calc(env(safe-area-inset-left, 0px) + 8px);
      right: calc(env(safe-area-inset-right, 0px) + 8px);
      z-index:20;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:flex-start;
      justify-content:space-between;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      border:1px solid var(--line);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:8px 10px;
      box-shadow:0 12px 34px rgba(0,0,0,.32);
    }
    .metrics{
      display:grid;
      grid-template-columns:repeat(3,minmax(72px,1fr));
      gap:8px;
      min-width:min(96vw, 430px);
    }
    .metric{
      border:1px solid rgba(255,255,255,.08);
      border-radius:10px;
      background:rgba(255,255,255,.03);
      padding:6px 8px;
      line-height:1.15;
    }
    .metric .k{
      font-size:11px;
      font-weight:800;
      color:var(--muted);
      margin-bottom:4px;
      letter-spacing:.2px;
    }
    .metric .v{
      font-size:15px;
      font-weight:950;
    }
    .btnRow{
      display:flex;
      gap:8px;
    }
    .btn{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.15), rgba(255,255,255,.05));
      color:var(--ink);
      border-radius:10px;
      font-size:12px;
      font-weight:950;
      padding:8px 10px;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn:active{ transform:translateY(1px); }

    #controls{
      position:fixed;
      left: calc(env(safe-area-inset-left, 0px) + 10px);
      right: calc(env(safe-area-inset-right, 0px) + 10px);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      z-index:30;
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      pointer-events:none;
    }
    .pad{
      pointer-events:auto;
      display:grid;
      grid-template-columns:var(--btn) var(--btn) var(--btn);
      grid-template-rows:var(--btn) var(--btn);
      gap:var(--gap);
      grid-template-areas:
        ". up ."
        "left down right";
    }
    .act{
      pointer-events:auto;
      display:grid;
      gap:var(--gap);
    }
    .ctrl-btn{
      width:var(--btn);
      height:var(--btn);
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(7,12,26,.58);
      backdrop-filter:blur(8px);
      color:var(--ink);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:22px;
      font-weight:950;
      touch-action:manipulation;
      pointer-events:auto;
    }
    .ctrl-btn:active{ transform:translateY(1px); background:rgba(7,12,26,.9); }
    .up{grid-area:up}
    .left{grid-area:left}
    .down{grid-area:down}
    .right{grid-area:right}
    .jump{ font-size:14px; letter-spacing:.2px; }

    #toast{
      position:fixed;
      left:50%;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      transform:translateX(-50%);
      z-index:40;
      border:1px solid var(--line);
      background:rgba(7,12,26,.88);
      color:var(--ink);
      border-radius:12px;
      font-size:13px;
      font-weight:950;
      padding:7px 11px;
      display:none;
      pointer-events:none;
    }

    @media (orientation: landscape){
      :root{
        --btn: clamp(44px, 7.2vh, 66px);
      }
      #controls{
        bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
      }
      .metrics{
        grid-template-columns:repeat(6,minmax(66px,1fr));
        min-width:min(98vw, 700px);
      }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="toast"></div>

  <div id="hud">
    <div class="panel metrics">
      <div class="metric"><div class="k">STAGE</div><div class="v" id="uiStage">1/72</div></div>
      <div class="metric"><div class="k">HEIGHT</div><div class="v" id="uiHeight">0m</div></div>
      <div class="metric"><div class="k">TIME</div><div class="v" id="uiTime">0.0s</div></div>
      <div class="metric"><div class="k">RESPAWN</div><div class="v" id="uiDeath">0</div></div>
      <div class="metric"><div class="k">CHECK</div><div class="v" id="uiCp">0</div></div>
      <div class="metric"><div class="k">BEST</div><div class="v" id="uiBest">-</div></div>
    </div>
    <div class="panel btnRow">
      <button class="btn" id="btnRespawn" type="button">체크포인트</button>
      <button class="btn" id="btnReset" type="button">리셋</button>
    </div>
  </div>

  <div id="controls">
    <div class="pad">
      <button class="ctrl-btn up" data-key="up" type="button">▲</button>
      <button class="ctrl-btn left" data-key="left" type="button">◀</button>
      <button class="ctrl-btn down" data-key="down" type="button">▼</button>
      <button class="ctrl-btn right" data-key="right" type="button">▶</button>
    </div>
    <div class="act">
      <button class="ctrl-btn jump" data-key="jump" type="button">JUMP</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const STAGES = 72;
    const STEP_Y = 1.22;
    const PATH_R = 8.2;
    const BEST_KEY = "tower_christmas_best_v1";

    const ui = {
      stage: document.getElementById("uiStage"),
      height: document.getElementById("uiHeight"),
      time: document.getElementById("uiTime"),
      death: document.getElementById("uiDeath"),
      cp: document.getElementById("uiCp"),
      best: document.getElementById("uiBest"),
      toast: document.getElementById("toast")
    };

    const app = document.getElementById("app");
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0d1f43, 0.014);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(68, innerWidth / innerHeight, 0.1, 1200);
    camera.position.set(0, 4.6, 8.8);

    scene.add(new THREE.HemisphereLight(0xaecbff, 0x203458, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(14, 26, 8);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024, 1024);
    scene.add(dir);

    // Ground and tower core
    const base = new THREE.Mesh(
      new THREE.CircleGeometry(30, 60),
      new THREE.MeshStandardMaterial({ color: 0x17315d, roughness: 0.95 })
    );
    base.rotation.x = -Math.PI / 2;
    base.receiveShadow = true;
    scene.add(base);

    const core = new THREE.Mesh(
      new THREE.CylinderGeometry(2.6, 3.0, STAGES * STEP_Y + 28, 22, 1, true),
      new THREE.MeshStandardMaterial({ color: 0x203b70, transparent: true, opacity: 0.62, roughness: 0.85 })
    );
    core.position.y = (STAGES * STEP_Y) * 0.5 + 4;
    scene.add(core);

    const grid = new THREE.GridHelper(64, 64, 0x2a4b82, 0x1d3564);
    grid.position.y = 0.02;
    scene.add(grid);

    // decorative garland rings
    for (let i = 0; i < 11; i++) {
      const ry = 3 + i * 8.5;
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(4.7 + (i % 2) * 0.25, 0.09, 8, 44),
        new THREE.MeshStandardMaterial({ color: i % 2 ? 0xff5555 : 0x57f1ad, emissive: 0x162236, roughness: 0.4 })
      );
      ring.rotation.x = Math.PI / 2;
      ring.position.y = ry;
      scene.add(ring);
    }

    const floors = [];
    const hazards = [];
    const checkpoints = [];
    let finishY = 0;

    function addFloor(opts) {
      const { x, y, z, sx, sy, sz, color = 0x3f7ded, moving = false, axis = "x", amp = 0, speed = 0, phase = 0, stage = 0 } = opts;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(sx, sy, sz),
        new THREE.MeshStandardMaterial({ color, roughness: 0.55, metalness: 0.08 })
      );
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.set(x, y, z);
      mesh.userData = { sx, sy, sz, moving, axis, amp, speed, phase, baseX: x, baseZ: z, prevX: x, prevZ: z, stage };
      scene.add(mesh);
      floors.push(mesh);
      return mesh;
    }

    function addHazard(opts) {
      const { x, y, z, sx, sy, sz } = opts;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(sx, sy, sz),
        new THREE.MeshStandardMaterial({ color: 0xc93f53, emissive: 0x380d16, roughness: 0.5 })
      );
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.set(x, y, z);
      mesh.userData = { sx, sy, sz };
      scene.add(mesh);
      hazards.push(mesh);
      return mesh;
    }

    function addCheckpoint(x, y, z, stage) {
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(1.05, 0.13, 10, 26),
        new THREE.MeshStandardMaterial({ color: 0x54f2ac, emissive: 0x113a2b, roughness: 0.4 })
      );
      ring.rotation.x = Math.PI / 2;
      ring.position.set(x, y + 0.56, z);
      ring.userData.stage = stage;
      ring.userData.active = false;
      scene.add(ring);
      checkpoints.push(ring);
    }

    function buildCourse() {
      // spawn
      addFloor({ x: 0, y: 0.4, z: 0, sx: 7.4, sy: 0.8, sz: 7.4, color: 0x5f87ff, stage: 0 });
      addCheckpoint(0, 0.4, 0, 0);

      let prevA = 0;
      for (let i = 1; i <= STAGES; i++) {
        const y = 0.95 + i * STEP_Y;
        const a = prevA + 0.55 + (i % 3 === 0 ? 0.08 : 0);
        prevA = a;
        const x = Math.cos(a) * PATH_R;
        const z = Math.sin(a) * PATH_R;

        const moving = i % 13 === 8 || i % 17 === 12;
        const dangerStage = i % 7 === 4 || i % 11 === 6;
        const color = moving ? 0x7f86ff : (dangerStage ? 0x4e8aff : 0x4e8aff);

        const floor = addFloor({
          x, y, z,
          sx: moving ? 3.0 : 3.6,
          sy: 0.7,
          sz: moving ? 3.0 : 3.6,
          color,
          moving,
          axis: i % 2 ? "x" : "z",
          amp: moving ? 1.15 : 0,
          speed: moving ? 1.0 + (i % 5) * 0.12 : 0,
          phase: i * 0.33,
          stage: i
        });

        if (dangerStage) {
          // small jump bar on platform
          const dirX = Math.cos(a + Math.PI * 0.5);
          const dirZ = Math.sin(a + Math.PI * 0.5);
          addHazard({
            x: floor.position.x + dirX * 0.2,
            y: floor.position.y + 0.58,
            z: floor.position.z + dirZ * 0.2,
            sx: 2.2,
            sy: 0.55,
            sz: 0.45
          });
        }

        if (i % 8 === 0) {
          addCheckpoint(x, y, z, i);
        }
      }

      finishY = 0.95 + STAGES * STEP_Y + 1.8;
      const fin = new THREE.Mesh(
        new THREE.CylinderGeometry(2.2, 2.2, 0.4, 32),
        new THREE.MeshStandardMaterial({ color: 0xffde73, emissive: 0x3b2c08 })
      );
      fin.position.set(0, finishY, 0);
      fin.receiveShadow = true;
      fin.castShadow = true;
      scene.add(fin);
    }
    buildCourse();

    // Player physics
    const player = {
      pos: new THREE.Vector3(0, 2.1, 0),
      vel: new THREE.Vector3(0, 0, 0),
      radius: 0.34,
      height: 1.78,
      grounded: false,
      onFloor: null
    };
    const halfH = player.height * 0.5;

    // Character (blocky style)
    const avatar = new THREE.Group();
    const matBody = new THREE.MeshStandardMaterial({ color: 0xf4f8ff, roughness: 0.35 });
    const matTrim = new THREE.MeshStandardMaterial({ color: 0xe2464e, roughness: 0.4 });
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.62, 0.78, 0.4), matBody);
    torso.position.y = 0.92;
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.24, 18, 14), matBody);
    head.position.y = 1.52;
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.14, 0.3, 12), matTrim);
    hat.position.y = 1.78;
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.42, 0.18), matTrim);
    legL.position.set(-0.14, 0.23, 0);
    const legR = legL.clone();
    legR.position.x = 0.14;
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.48, 0.14), matTrim);
    armL.position.set(-0.42, 0.94, 0);
    const armR = armL.clone();
    armR.position.x = 0.42;
    avatar.add(torso, head, hat, legL, legR, armL, armR);
    avatar.castShadow = true;
    scene.add(avatar);

    // Camera orbit state
    const cam = {
      yaw: Math.PI,
      pitch: -0.28,
      dist: 6.8,
      dragId: -1,
      lastX: 0,
      lastY: 0
    };

    const keys = { up: false, down: false, left: false, right: false, jump: false };
    let timerStart = 0;
    let deaths = 0;
    let won = false;
    let cp = { x: 0, y: 2.1, z: 0, stage: 0 };
    let topStage = 0;

    function fmtSec(ms) { return (ms / 1000).toFixed(1) + "s"; }
    function getBest() {
      const v = Number(localStorage.getItem(BEST_KEY) || 0);
      return Number.isFinite(v) && v > 0 ? v : 0;
    }
    function setBest(v) { localStorage.setItem(BEST_KEY, String(v)); }
    function syncBest() { ui.best.textContent = getBest() ? fmtSec(getBest()) : "-"; }
    syncBest();

    function toast(msg, ms = 1050) {
      ui.toast.textContent = msg;
      ui.toast.style.display = "block";
      clearTimeout(toast.tid);
      toast.tid = setTimeout(() => ui.toast.style.display = "none", ms);
    }

    function hardReset() {
      cp = { x: 0, y: 2.1, z: 0, stage: 0 };
      topStage = 0;
      deaths = 0;
      won = false;
      player.pos.set(cp.x, cp.y, cp.z);
      player.vel.set(0, 0, 0);
      player.grounded = false;
      player.onFloor = null;
      timerStart = performance.now();
      ui.death.textContent = "0";
      ui.cp.textContent = "0";
      checkpoints.forEach(r => {
        r.userData.active = false;
        r.material.color.setHex(0x54f2ac);
      });
    }

    function respawn(msg = "") {
      player.pos.set(cp.x, cp.y, cp.z);
      player.vel.set(0, 0, 0);
      player.grounded = false;
      player.onFloor = null;
      deaths++;
      ui.death.textContent = String(deaths);
      if (msg) toast(msg);
    }

    function setCheckpoint(ring) {
      cp = { x: ring.position.x, y: ring.position.y + 1.2, z: ring.position.z, stage: ring.userData.stage };
      topStage = Math.max(topStage, cp.stage);
      ui.cp.textContent = String(Math.floor(topStage / 8));
      checkpoints.forEach(r => { r.userData.active = false; r.material.color.setHex(0x54f2ac); });
      ring.userData.active = true;
      ring.material.color.setHex(0x9dffcb);
      toast(`CHECK ${cp.stage}`);
    }

    function carryByMovingPlatform() {
      const f = player.onFloor;
      if (!f || !f.userData.moving || !player.grounded) return;
      const dx = f.position.x - f.userData.prevX;
      const dz = f.position.z - f.userData.prevZ;
      player.pos.x += dx;
      player.pos.z += dz;
    }

    function updateMovers(timeSec) {
      for (const f of floors) {
        f.userData.prevX = f.position.x;
        f.userData.prevZ = f.position.z;
        if (!f.userData.moving) continue;
        const u = f.userData;
        const w = Math.sin(timeSec * u.speed + u.phase) * u.amp;
        if (u.axis === "x") f.position.x = u.baseX + w;
        else f.position.z = u.baseZ + w;
      }
    }

    function getMoveDir() {
      let x = 0, z = 0;
      if (keys.up) z -= 1;
      if (keys.down) z += 1;
      if (keys.left) x -= 1;
      if (keys.right) x += 1;
      if (!x && !z) return new THREE.Vector3();
      const len = Math.hypot(x, z) || 1;
      x /= len; z /= len;
      const s = Math.sin(cam.yaw), c = Math.cos(cam.yaw);
      return new THREE.Vector3(x * c - z * s, 0, x * s + z * c);
    }

    function overlapHazard(h) {
      const u = h.userData;
      return (
        Math.abs(player.pos.x - h.position.x) <= (u.sx * 0.5 + player.radius) &&
        Math.abs(player.pos.z - h.position.z) <= (u.sz * 0.5 + player.radius) &&
        Math.abs(player.pos.y - h.position.y) <= (u.sy * 0.5 + halfH * 0.72)
      );
    }

    function tryLand(f, footPrev, footNow) {
      const u = f.userData;
      if (
        Math.abs(player.pos.x - f.position.x) > (u.sx * 0.5 + player.radius) ||
        Math.abs(player.pos.z - f.position.z) > (u.sz * 0.5 + player.radius)
      ) return false;
      const top = f.position.y + u.sy * 0.5 + player.radius;
      if (footPrev >= top - 0.2 && footNow <= top + 0.08 && player.vel.y <= 0) {
        player.pos.y = top + halfH - player.radius;
        player.vel.y = 0;
        player.grounded = true;
        player.onFloor = f;
        return true;
      }
      return false;
    }

    function update(dt, now) {
      if (!timerStart) timerStart = now;

      const t = now * 0.001;
      updateMovers(t);
      carryByMovingPlatform();

      const dirMove = getMoveDir();
      const accel = player.grounded ? 19 : 8.8;
      const max = player.grounded ? 8.4 : 7.4;
      player.vel.x += dirMove.x * accel * dt;
      player.vel.z += dirMove.z * accel * dt;
      const damp = player.grounded ? 0.80 : 0.93;
      player.vel.x *= Math.pow(damp, dt * 60);
      player.vel.z *= Math.pow(damp, dt * 60);
      const flat = Math.hypot(player.vel.x, player.vel.z);
      if (flat > max) {
        player.vel.x = (player.vel.x / flat) * max;
        player.vel.z = (player.vel.z / flat) * max;
      }

      if (keys.jump && player.grounded) {
        player.vel.y = 7.9;
        player.grounded = false;
        player.onFloor = null;
      }
      keys.jump = false;

      player.vel.y -= 22 * dt;
      const prevY = player.pos.y;
      player.pos.addScaledVector(player.vel, dt);
      player.grounded = false;
      player.onFloor = null;

      const footPrev = prevY - halfH + player.radius;
      const footNow = player.pos.y - halfH + player.radius;
      for (const f of floors) {
        if (tryLand(f, footPrev, footNow)) break;
      }

      for (const h of hazards) {
        if (overlapHazard(h)) {
          respawn("HIT");
          return;
        }
      }

      if (player.pos.y < -8) {
        respawn("FALL");
        return;
      }

      for (const r of checkpoints) {
        if (r.userData.stage <= cp.stage) continue;
        const dx = player.pos.x - r.position.x;
        const dz = player.pos.z - r.position.z;
        const dy = Math.abs(player.pos.y - (r.position.y + 0.8));
        if (dx * dx + dz * dz < 1.8 * 1.8 && dy < 1.5) setCheckpoint(r);
      }

      topStage = Math.max(topStage, Math.max(0, Math.floor((player.pos.y - 0.9) / STEP_Y)));
      ui.stage.textContent = `${Math.min(STAGES, Math.max(1, topStage))}/${STAGES}`;
      ui.height.textContent = `${Math.max(0, Math.floor(player.pos.y))}m`;
      const elapsed = now - timerStart;
      ui.time.textContent = fmtSec(elapsed);

      if (!won && player.pos.y > finishY) {
        won = true;
        const best = getBest();
        if (!best || elapsed < best) {
          setBest(elapsed);
          syncBest();
          toast(`CLEAR ${fmtSec(elapsed)} NEW`, 1800);
        } else {
          toast(`CLEAR ${fmtSec(elapsed)}`, 1800);
        }
      }

      // avatar pose
      const spd = Math.hypot(player.vel.x, player.vel.z);
      const cycle = now * 0.012;
      legL.rotation.x = Math.sin(cycle) * 0.42 * Math.min(1, spd / 4);
      legR.rotation.x = Math.sin(cycle + Math.PI) * 0.42 * Math.min(1, spd / 4);
      armL.rotation.x = Math.sin(cycle + Math.PI) * 0.22 * Math.min(1, spd / 4);
      armR.rotation.x = Math.sin(cycle) * 0.22 * Math.min(1, spd / 4);
      avatar.position.set(player.pos.x, player.pos.y - halfH, player.pos.z);
      if (spd > 0.08) {
        const tyaw = Math.atan2(player.vel.x, player.vel.z);
        avatar.rotation.y += (tyaw - avatar.rotation.y) * 0.2;
      }
    }

    function updateCamera() {
      const dist = innerWidth > innerHeight ? 7.1 : 6.5;
      cam.dist += (dist - cam.dist) * 0.08;
      const tx = player.pos.x + Math.sin(cam.yaw) * Math.cos(cam.pitch) * cam.dist;
      const ty = player.pos.y + 2.0 + Math.sin(cam.pitch) * cam.dist;
      const tz = player.pos.z + Math.cos(cam.yaw) * Math.cos(cam.pitch) * cam.dist;
      camera.position.lerp(new THREE.Vector3(tx, ty, tz), 0.18);
      camera.lookAt(player.pos.x, player.pos.y + 0.95, player.pos.z);
    }

    function loop(now) {
      const dt = Math.min(((now - (loop.prev || now)) / 1000), 0.033);
      loop.prev = now;
      update(dt, now);
      updateCamera();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    function handlePointerDown(e) {
      if (e.target.closest(".ctrl-btn")) return;
      if (cam.dragId !== -1) return;
      cam.dragId = e.pointerId;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
    }
    function handlePointerMove(e) {
      if (cam.dragId !== e.pointerId) return;
      const dx = e.clientX - cam.lastX;
      const dy = e.clientY - cam.lastY;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
      cam.yaw -= dx * 0.0053;
      cam.pitch -= dy * 0.0044;
      cam.pitch = Math.max(-1.18, Math.min(0.42, cam.pitch));
    }
    function handlePointerUp(e) {
      if (cam.dragId === e.pointerId) cam.dragId = -1;
    }

    function bindKeyboard() {
      addEventListener("keydown", (e) => {
        if (e.code === "KeyW" || e.code === "ArrowUp") keys.up = true;
        if (e.code === "KeyS" || e.code === "ArrowDown") keys.down = true;
        if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
        if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
        if (e.code === "Space") { keys.jump = true; e.preventDefault(); }
      }, { passive: false });
      addEventListener("keyup", (e) => {
        if (e.code === "KeyW" || e.code === "ArrowUp") keys.up = false;
        if (e.code === "KeyS" || e.code === "ArrowDown") keys.down = false;
        if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
        if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
      });
    }

    function bindMobileButtons() {
      document.querySelectorAll(".ctrl-btn[data-key]").forEach((btn) => {
        const k = btn.getAttribute("data-key");
        const down = (e) => {
          e.preventDefault();
          if (k === "jump") keys.jump = true;
          else keys[k] = true;
        };
        const up = (e) => {
          e.preventDefault();
          if (k !== "jump") keys[k] = false;
        };
        btn.addEventListener("pointerdown", down, { passive: false });
        btn.addEventListener("pointerup", up, { passive: false });
        btn.addEventListener("pointercancel", up, { passive: false });
        btn.addEventListener("pointerleave", up, { passive: false });
      });
    }

    renderer.domElement.addEventListener("pointerdown", handlePointerDown);
    addEventListener("pointermove", handlePointerMove, { passive: true });
    addEventListener("pointerup", handlePointerUp, { passive: true });
    addEventListener("pointercancel", handlePointerUp, { passive: true });

    document.getElementById("btnRespawn").addEventListener("click", () => respawn("GO CHECK"));
    document.getElementById("btnReset").addEventListener("click", hardReset);

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    bindKeyboard();
    bindMobileButtons();
    hardReset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>

