<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ì•Œê¹Œê¸°</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #3d2f2b;
            --board-color: #e4b476;
            --border-color: #6a4a3a;
            --stone-white: #f5f5f5;
            --stone-black: #333;
            --shadow-color: rgba(0,0,0,0.2);
            --primary-color: #8d6e63;
            --accent-color: #ffab40;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: none;
        }
        .view {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .hidden { display: none !important; }

        .menu-btn {
            width: 90%; max-width: 320px; padding: 15px;
            font-size: 1.5em; font-weight: 700;
            font-family: 'GmarketSans', sans-serif;
            border-radius: 12px; border: none; cursor: pointer;
            margin: 10px 0; box-shadow: 0 5px 10px var(--shadow-color);
            transition: all 0.2s ease-out;
        }
        .menu-btn:active { transform: scale(0.97); }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #eee; color: #333; }
        .main-title {
            font-size: 3.5em; font-weight: 700; color: white;
            margin-bottom: 30px; text-shadow: 3px 3px 5px var(--shadow-color);
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
        }
        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-between; align-items: center;
            padding: 15px 20px; background-color: rgba(0,0,0,0.3);
            gap: 20px;
        }
        .player-info {
            display: flex; flex-direction: row;
            align-items: center; gap: 12px; padding: 10px 15px;
            border-radius: 12px; transition: all 0.3s ease;
            background-color: rgba(255,255,255,0.1);
            min-width: 140px;
        }
        .player-info.my-turn {
            background-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 171, 64, 0.5);
        }
        .player-info.my-turn .nickname { color: black; }
        .player-info .avatar { font-size: 2em; }
        .player-info .avatar img {
            width: 40px; height: 40px;
            object-fit: contain; border-radius: 50%;
        }
        .player-info .nickname {
            font-weight: 700; font-size: 1em;
        }
        .player-info .stone-count {
            font-size: 0.85em; opacity: 0.9;
        }
        .player-info .info-text {
            display: flex; flex-direction: column; align-items: flex-start;
        }
        
        #game-container {
            width: 100%; flex-grow: 1;
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 20px 10px;
        }
        #game-board {
            position: relative; background-color: var(--board-color);
            border: 6px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 8px;
            background-image:
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
        }

        .stone {
            position: absolute; border-radius: 50%;
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 4px 8px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-weight: 700;
            cursor: grab;
            /* transform ì†ì„±ì˜ ë³€í™”ê°€ ë¶€ë“œëŸ½ê²Œ ì ìš©ë˜ë„ë¡ transition ì¶”ê°€ */
            transition: transform 0.05s linear;
        }
        .stone:active { cursor: grabbing; }
        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #f5f5f5 50%, #e0e0e0);
        }
        .stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #333 50%, #222);
        }
        .stone.selected {
            /* ìë°”ìŠ¤í¬ë¦½íŠ¸ì™€ ì¶©ëŒì„ ë§‰ê¸° ìœ„í•´ transform ì†ì„± ì œê±° */
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 0 20px rgba(255, 171, 64, 0.8),
                0 4px 12px rgba(0,0,0,0.5);
        }
        .stone.removed {
            transition: all 0.4s ease;
            transform: scale(0) !important;
            opacity: 0;
        }
        
        #power-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 300px;
            height: 30px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 15px;
            overflow: hidden;
            display: none;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #power-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.05s linear;
            border-radius: 13px;
        }

        #trajectory-canvas {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            opacity: 0.85;
        }

        .overlay {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 200; text-align: center;
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 40px;
            border-radius: 25px;
            width: 90%; max-width: 380px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #game-over-message {
            font-size: 2.5em; font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .modal-buttons {
            display: flex; flex-direction: column;
            gap: 12px; align-items: center; margin-top: 25px;
        }
        #countdown-number {
            font-size: 8em; font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 30px rgba(255, 171, 64, 0.8);
            animation: countdown-pop 1s ease-in-out;
        }
        @keyframes countdown-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        .spinner { 
            margin: 20px auto; 
            border: 4px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; 
            border-top: 4px solid white; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        .style-option {
            border: 3px solid transparent;
            border-radius: 12px;
            padding: 15px;
            background-color: rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .style-option:hover {
            border-color: var(--accent-color);
            background-color: rgba(0,0,0,0.3);
        }
        .style-option.selected { 
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
        }
        .style-option h4 {
            margin-top: 10px;
            font-size: 1em;
        }
        .preview-board {
            width: 120px;
            height: 70px;
            background-color: var(--board-color);
            border-radius: 6px;
            position: relative;
        }
        .preview-stone {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .preview-stone.white { background-color: var(--stone-white); }
        .preview-stone.black { background-color: var(--stone-black); }

    </style>
</head>
<body>

    <div id="game-wrapper" class="view">
        <div id="game-header"></div>
        <div id="game-container">
            <div id="game-board">
                <canvas id="trajectory-canvas"></canvas>
            </div>
            <div id="power-indicator">
                <div id="power-fill"></div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="waiting-overlay" class="overlay" style="display: none;"></div>

    <script src="ì•„ë°”íƒ€.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
            function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return str.replace(/[&<>"']/g, m => map[m]);
    }
            document.addEventListener('contextmenu', event => event.preventDefault());
 document.addEventListener('keydown', event => {
    if (event.key === 'F12' ||
         (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
         (event.ctrlKey && event.key.toUpperCase() === 'U')) {
       event.preventDefault();
     }
 });
 setInterval(() => { try { debugger; } catch (e) {} }, 1000);

 // âœ¨ [ì‹ ê·œ] ë’¤ë¡œê°€ê¸° ëª¨ë‹¬ ê´€ë ¨ ë³€ìˆ˜ ë° ì´ë²¤íŠ¸
        const confirmExitModal = document.getElementById('confirm-exit-modal');
        const exitConfirmBtn = document.getElementById('exit-confirm-btn');
        const exitCancelBtn = document.getElementById('exit-cancel-btn');

        history.pushState(null, '', location.href);
        window.addEventListener('popstate', (e) => {
            history.pushState(null, '', location.href); // ë’¤ë¡œê°€ê¸° ë°©ì§€ ìœ ì§€
            confirmExitModal.style.display = 'flex'; // ëª¨ë‹¬ í‘œì‹œ
        });

        exitConfirmBtn.addEventListener('click', () => {
            // cleanupAndExit í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ì§ì ‘ ì²˜ë¦¬
            if (typeof cleanupAndExit === 'function') {
                cleanupAndExit();
            } else {
                 if (roomRef && isHost) roomRef.remove();
                 window.location.href = 'ëŒ€ê¸°ì‹¤.html';
            }
        });

        exitCancelBtn.addEventListener('click', () => {
            confirmExitModal.style.display = 'none'; // ëª¨ë‹¬ ë‹«ê¸°
        });
        // âœ¨ [ì‹ ê·œ] ë
    
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
            authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
            projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app",
            messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };

 

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();
        const playersStatsRef = database.ref('users');

        const gameWrapper = document.getElementById('game-wrapper');
        const gameContainer = document.getElementById('game-container');
        const gameBoard = document.getElementById('game-board');
        const trajectoryCanvas = document.getElementById('trajectory-canvas');
        const trajectoryCtx = trajectoryCanvas.getContext('2d');
        const powerIndicator = document.getElementById('power-indicator');
        const powerFill = document.getElementById('power-fill');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const waitingOverlay = document.getElementById('waiting-overlay');
        
        let myPlayerId, myNickname, myAvatar;
        let gameMode = null;
        let stones = [];
        let myColor = 'white';
        let opponentColor = 'black';
        let currentTurnColor = 'white';
        let isMyTurn = false;
        let isDragging = false;
        let selectedStone = null;
        let isGameOver = false;
        let boardWidth = 0, boardHeight = 0;
        let roomRef = null;
        let currentRoomData = null;
        let dragStartPos = null;
        let isHost = false;
        let canShoot = true;
        let hasShotThisTurn = false;
        let isFirstTurn = true;
        let movementCheckTimeout = null;
		let isGameLive = false; // ê²Œì„ì´ í™œì„±í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë³€ìˆ˜
        let aiDifficulty = 'medium'; // AI ë‚œì´ë„ (easy, medium, hard)
        let selectedPlacementStyle = null; // ì„ íƒí•œ ë°°ì¹˜ ìŠ¤íƒ€ì¼ ì €ì¥

        const FRICTION = 0.985;
        const RESTITUTION = 0.9;
        const MIN_SPEED = 0.1;

        let player1Info = null;
        let player2Info = null;

        function playSound(id) {
            const sound = document.getElementById(id);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        // ë³€ê²½ ì½”ë“œ
        function initialize() {
            myPlayerId = localStorage.getItem('myPlayerId');
            if (!myPlayerId) {
                alert("í”Œë ˆì´ì–´ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.");
                window.location.href = 'index.html';
                return;
            }
            myNickname = localStorage.getItem('userNickname') || 'Player';
            myAvatar = localStorage.getItem('userAvatar') || 'ğŸ˜Š';

            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            const mode = urlParams.get('mode');

            if (roomId) {
                // ë©€í‹°í”Œë ˆì´ ë˜ëŠ” AIë°©ìœ¼ë¡œ ì§„ì…
                joinMultiplayerGame(roomId);
            } else if (mode === 'solo') {
                // âœ¨ [ìˆ˜ì •] 'í˜¼ì í•˜ê¸°'ì¼ ë•Œ, ì¹´ìš´íŠ¸ë‹¤ìš´ ëŒ€ì‹  ë°°ì¹˜ ì„ íƒì°½ì„ ë¨¼ì € ë„ì›ë‹ˆë‹¤.
                gameMode = 'single';      // 1. ê²Œì„ ëª¨ë“œë¥¼ 'single'ë¡œ ì„¤ì •
                showPlacementModal();     // 2. ë°°ì¹˜ ì„ íƒì°½ í˜¸ì¶œ
            } else {
                // ì˜ëª»ëœ ì ‘ê·¼ ì‹œ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™
                alert("ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤. ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
                window.location.href = 'ëŒ€ê¸°ì‹¤.html';
            }
        }

        function startCountdown(mode) {
            gameMode = mode;
            waitingOverlay.innerHTML = `<div id="countdown-number">3</div>`;
            waitingOverlay.style.display = 'flex';
            let count = 3;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    waitingOverlay.innerHTML = `<div id="countdown-number">${count}</div>`;
                } else {
                    clearInterval(interval);
                    playSound('game-start-sound');
                    waitingOverlay.style.display = 'none';

                    // âœ¨ ê²Œì„ ëª¨ë“œì— ë”°ë¼ ì‹œì‘ ë¡œì§ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤.
                    if (gameMode === 'single') {
                        // 'í˜¼ì í•˜ê¸°'ëŠ” ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ëë‚œ í›„ ê²Œì„íŒê³¼ ëŒì„ ìƒì„±í•©ë‹ˆë‹¤.
                        setupSinglePlayerGame(selectedPlacementStyle);
                    } else { // 'multi'
                        // 'ê°™ì´ í•˜ê¸°'ëŠ” ì´ë¯¸ ëŒì´ ë°°ì¹˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ê²Œì„ ìƒíƒœë§Œ í™œì„±í™”í•©ë‹ˆë‹¤.
                        isGameLive = true;
                        currentTurnColor = 'white';
                        isMyTurn = (currentTurnColor === myColor);
                        canShoot = true;
                        updateHeaderUI();
                    }
                    // ë‘ ëª¨ë“œ ëª¨ë‘ í„´ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.
                    checkTurn();
                }
            }, 1000);
        }

        function showPlacementModal() {
            const modal = document.getElementById('placement-modal');
            modal.style.display = 'flex';
            const waitingText = document.getElementById('placement-waiting-text');
            waitingText.style.display = 'none'; // ëŒ€ê¸° í…ìŠ¤íŠ¸ ì´ˆê¸°í™”

            const options = modal.querySelectorAll('.style-option');
            options.forEach(opt => {
                opt.style.pointerEvents = 'auto'; // ì„ íƒ ê°€ëŠ¥í•˜ë„ë¡ ì´ˆê¸°í™”
                const newOpt = opt.cloneNode(true);
                opt.parentNode.replaceChild(newOpt, opt);
                
                newOpt.addEventListener('click', () => {
                    selectedPlacementStyle = newOpt.dataset.style;
                    
                    if (gameMode === 'single') {
                        modal.style.display = 'none';
                        showAIDifficultyModal();
                    } else {
                        // âœ¨ ê°™ì´í•˜ê¸°: ëª¨ë‹¬ì„ ë‹«ì§€ ì•Šê³  ëŒ€ê¸° ìƒíƒœë¡œ ë§Œë“­ë‹ˆë‹¤.
                        options.forEach(o => o.classList.remove('selected'));
                        newOpt.classList.add('selected');
                        // ëª¨ë“  ë²„íŠ¼ì„ ë¹„í™œì„±í™”í•˜ê³  ëŒ€ê¸° í…ìŠ¤íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
                        modal.querySelectorAll('.style-option').forEach(o => o.style.pointerEvents = 'none');
                        waitingText.style.display = 'block';
                        roomRef.child('placementChoices').child(myPlayerId).set(selectedPlacementStyle);
                    }
                });
            });

            if (gameMode === 'multi') {
                if (isHost) {
                    roomRef.child('placementChoices').set(null); 
                }
                
                roomRef.child('placementChoices').on('value', function onBothChosen(snapshot) {
                    if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;

                    const choices = snapshot.val();
                    const playerCount = Object.keys(currentRoomData.players).filter(id => id !== 'ai_player').length;
                    
                    if (Object.keys(choices).length === playerCount) {
                        roomRef.child('placementChoices').off('value', onBothChosen);
                        
                        // âœ¨ ì–‘ìª½ ëª¨ë‘ ì„ íƒí–ˆì„ ë•Œ ë¹„ë¡œì†Œ ëª¨ë‹¬ì„ ë‹«ìŠµë‹ˆë‹¤.
                        modal.style.display = 'none';
                        
                        const hostChoice = choices[currentRoomData.hostId];
                        const guestId = Object.keys(currentRoomData.players).find(id => id !== currentRoomData.hostId && id !== 'ai_player');
                        const guestChoice = choices[guestId];
                        setupMultiplayerGame(hostChoice, guestChoice);
                        
                        startCountdown('multi');
                    }
                });
            }
        }

        // ìƒˆë¡œìš´ í•¨ìˆ˜: AI ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        function showAIDifficultyModal() {
            const modal = document.getElementById('ai-difficulty-modal');
            modal.style.display = 'flex';

            const difficultyButtons = modal.querySelectorAll('.menu-btn');
            difficultyButtons.forEach(btn => {
                btn.onclick = () => {
                    aiDifficulty = btn.dataset.difficulty;
                    modal.style.display = 'none';
                    // ë‚œì´ë„ ì„ íƒì´ ëë‚˜ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ì„ ì‹œì‘í•©ë‹ˆë‹¤.
                    startCountdown('single');
                };
            });
        }
        
     function placeStones(whiteStyle, blackStyle) {
		const stoneSize = boardWidth / 14;
		stones = [];
		gameBoard.querySelectorAll('.stone').forEach(el => el.remove());

		// --- í°ìƒ‰ ëŒ ë°°ì¹˜ (5ê°œ) ---
		if (whiteStyle === 'style1') {
			for (let i = 0; i < 5; i++) {
				const x = boardWidth * 0.5 + (i - 2) * stoneSize * 2.2; // 2.0ì—ì„œ 2.2ë¡œ ê°„ê²© í™•ëŒ€
				createStone(x, boardHeight * 0.15, stoneSize, 'white', `white${i}`);
			}
		} else if (whiteStyle === 'style2') { // ê·¸ë ¤ì£¼ì‹  3-2 ë°°ì¹˜
			for (let i = 0; i < 3; i++) {
				createStone(boardWidth * 0.5 + (i - 1) * stoneSize * 3.5, boardHeight * 0.1, stoneSize, 'white', `white${i}`); // 2.2ì—ì„œ 3.5ë¡œ ëŒ€í­ í™•ëŒ€
			}
			for (let i = 0; i < 2; i++) {
				createStone(boardWidth * 0.5 + (i - 0.5) * stoneSize * 2.0, boardHeight * 0.25, stoneSize, 'white', `white${i + 3}`); // 2.8ì—ì„œ 2.0ìœ¼ë¡œ ì¢í˜€ ì•ˆìª½ìœ¼ë¡œ ë°°ì¹˜
			}
		}

		// --- ê²€ì€ìƒ‰ ëŒ ë°°ì¹˜ (5ê°œ) ---
		if (blackStyle === 'style1') {
			for (let i = 0; i < 5; i++) {
				const x = boardWidth * 0.5 + (i - 2) * stoneSize * 2.2; // 2.0ì—ì„œ 2.2ë¡œ ê°„ê²© í™•ëŒ€
				createStone(x, boardHeight * 0.85, stoneSize, 'black', `black${i}`);
			}
		} else if (blackStyle === 'style2') { // ê·¸ë ¤ì£¼ì‹  3-2 ë°°ì¹˜
			for (let i = 0; i < 3; i++) {
				createStone(boardWidth * 0.5 + (i - 1) * stoneSize * 3.5, boardHeight * 0.9, stoneSize, 'black', `black${i}`); // 2.2ì—ì„œ 3.5ë¡œ ëŒ€í­ í™•ëŒ€
			}
			for (let i = 0; i < 2; i++) {
				createStone(boardWidth * 0.5 + (i - 0.5) * stoneSize * 2.0, boardHeight * 0.75, stoneSize, 'black', `black${i + 3}`); // 2.8ì—ì„œ 2.0ìœ¼ë¡œ ì¢í˜€ ì•ˆìª½ìœ¼ë¡œ ë°°ì¹˜
			}
		}
	}

        function setupGame() {
            isGameOver = false;
            canShoot = true;
            hasShotThisTurn = false;
            gameWrapper.style.display = 'flex';
            
            const containerW = gameContainer.clientWidth;
            const containerH = gameContainer.clientHeight;
            boardWidth = Math.min(containerW * 0.92, 400);
            boardHeight = Math.min(containerH * 0.75, boardWidth * 1.4); 
            
            gameBoard.style.width = `${boardWidth}px`;
            gameBoard.style.height = `${boardHeight}px`;
            gameBoard.style.backgroundSize = `${boardWidth / 10}px ${boardWidth / 10}px`;
            
            trajectoryCanvas.width = boardWidth;
            trajectoryCanvas.height = boardHeight;
            
            gameBoard.innerHTML = '';
            gameBoard.appendChild(trajectoryCanvas);

            stones = [];
            
            if (gameMode === 'multi' && isHost) {
                setInterval(hostBroadcastGameState, 16);
            }
            
            requestAnimationFrame(gameLoop);
            
            setupInputHandlers();
        }
        
        function setupSinglePlayerGame(style) {
            setupGame();
            placeStones(style, style);
            myColor = 'white';
            opponentColor = 'black';
            currentTurnColor = 'white';
            isMyTurn = true;
            player1Info = { nickname: myNickname, avatar: myAvatar };
            player2Info = { nickname: 'AI', avatar: 'ğŸ¤–' };
            updateHeaderUI();
        }

        function setupMultiplayerGame(whiteStyle, blackStyle) {
             isGameLive = true; // ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŒì„ ëª…ì‹œì ìœ¼ë¡œ ê¸°ë¡
            setupGame();
            placeStones(whiteStyle, blackStyle);
            currentTurnColor = 'white';
            isMyTurn = (currentTurnColor === myColor);
            canShoot = true;
            updateHeaderUI();
        }

        function createStone(x, y, diameter, color, id) {
            const element = document.createElement('div');
            element.className = `stone ${color}`;
            element.id = id;
            element.style.width = `${diameter}px`;
            element.style.height = `${diameter}px`;
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';
            gameBoard.appendChild(element);

            const stoneRadius = diameter / 2;
            const stone = {
                id, element, color, active: true,
                x: x, y: y,
                targetX: x, targetY: y, // ëª©í‘œ ìœ„ì¹˜ ì¶”ê°€
                vx: 0, vy: 0,
                radius: stoneRadius,
                mass: 2.5
            };
            stones.push(stone);
        }
        
        function updatePhysics() {
            stones.forEach(stone => {
                if (!stone.active) return;

                stone.vx *= FRICTION;
                stone.vy *= FRICTION;

                stone.x += stone.vx;
                stone.y += stone.vy;
            });
            
            for (let i = 0; i < stones.length; i++) {
                for (let j = i + 1; j < stones.length; j++) {
                    const s1 = stones[i];
                    const s2 = stones[j];
                    if (!s1.active || !s2.active) continue;

                    const dx = s2.x - s1.x;
                    const dy = s2.y - s1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const totalRadius = s1.radius + s2.radius;

                    if (distance < totalRadius) {
                        resolveCollision(s1, s2);
                    }
                }
            }
            if(gameMode === 'multi' && !isHost) return;
            checkMovementEnd();
        }

        function resolveCollision(s1, s2) {
            const dx = s2.x - s1.x;
            const dy = s2.y - s1.y;
            const distance = Math.max(0.01, Math.sqrt(dx * dx + dy * dy));
            
            const overlap = s1.radius + s2.radius - distance;
            if(overlap > 0) {
                const overlapX = (overlap * dx) / distance;
                const overlapY = (overlap * dy) / distance;

                s1.x -= overlapX / 2;
                s1.y -= overlapY / 2;
                s2.x += overlapX / 2;
                s2.y += overlapY / 2;
            }
            
            const nx = dx / distance;
            const ny = dy / distance;
            
            const kx = s1.vx - s2.vx;
            const ky = s1.vy - s2.vy;
            const p = 2 * (nx * kx + ny * ky) / (s1.mass + s2.mass);
            
            s1.vx -= p * s2.mass * nx * RESTITUTION;
            s1.vy -= p * s2.mass * ny * RESTITUTION;
            s2.vx += p * s1.mass * nx * RESTITUTION;
            s2.vy += p * s1.mass * ny * RESTITUTION;
        }
        
       function gameLoop() {
			if (isGameOver) return;

			if (gameMode === 'single' || (gameMode === 'multi' && isHost)) {
				// ë°©ì¥ì€ ë¬¼ë¦¬ì—”ì§„ì„ ì§ì ‘ ì‹¤í–‰
				updatePhysics();
			} else if (gameMode === 'multi' && !isHost) {
				// ê²ŒìŠ¤íŠ¸ëŠ” ë°©ì¥ì˜ ëª©í‘œ ìœ„ì¹˜ë¥¼ í–¥í•´ ë¶€ë“œëŸ½ê²Œ ì´ë™(ë³´ê°„)
				stones.forEach(stone => {
					if (stone.active) {
						const smoothingFactor = 0.2; // í´ìˆ˜ë¡ ë¹ ë¥´ê²Œ ë”°ë¼ì¡ìŒ (0.1 ~ 0.5 ì¶”ì²œ)
						stone.x += (stone.targetX - stone.x) * smoothingFactor;
						stone.y += (stone.targetY - stone.y) * smoothingFactor;
					}
				});
			}

			stones.forEach(stone => {
				if (stone.active) {
					const x = stone.x - stone.radius;
					const y = stone.y - stone.radius;
					let transformValue = `translate(${x}px, ${y}px)`;

					if (selectedStone && stone.id === selectedStone.id) {
						transformValue += ' scale(1.15)';
					}
					stone.element.style.transform = transformValue;

					// íƒˆë½ íŒì •ì€ ë°©ì¥ë§Œ í•˜ë„ë¡ ìˆ˜ì •í–ˆì—ˆìŒ
					if (gameMode === 'single' || isHost) {
						if (isOutOfBoard(stone)) {
							removeStone(stone);
						}
					}
				}
			});

			requestAnimationFrame(gameLoop);
		}

        function isOutOfBoard(stone) {
            return stone.x < 0 || stone.x > boardWidth || 
                   stone.y < 0 || stone.y > boardHeight;
        }

        function removeStone(stone) {
            if (!stone.active) return;
            stone.active = false;
            stone.element.classList.add('removed');

            if (stone.color !== currentTurnColor) {
                playSound('success-sound');
            }
            
            if (gameMode === 'multi' && roomRef && isHost) {
                roomRef.child('removedStones').child(stone.id).set(true);
            }
            
            setTimeout(() => {
                if (stone.element.parentNode) {
              
                }
                updateHeaderUI();
                checkWinCondition();
            }, 400);
        }
        
        function checkWinCondition() {
            if (stones.length === 0) return; // ëŒì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì¢…ë£Œ
            const whiteStonesLeft = stones.filter(s => s.color === 'white' && s.active).length;
            const blackStonesLeft = stones.filter(s => s.color === 'black' && s.active).length;

            if (whiteStonesLeft === 0 && blackStonesLeft > 0) {
                showGameOver('black');
            } else if (blackStonesLeft === 0 && whiteStonesLeft > 0) {
                showGameOver('white');
            }
        }
        
       function aiMove() {
            if (isGameOver || !canShoot) return;
            
            const aiStones = stones.filter(s => s.color === opponentColor && s.active);
            const targetStones = stones.filter(s => s.color === myColor && s.active);
            
            if (aiStones.length === 0 || targetStones.length === 0) return;

            canShoot = false;
            
            setTimeout(() => {
                if (isGameOver) return;
                
                let shooter, target;
                let randomOffset, aiPower;

                // --- AI ë‚œì´ë„ë³„ ë¡œì§ ë¶„ê¸° ---
                if (aiDifficulty === 'hard') {
                    // [ê³ ìˆ˜ AI]: ê°€ì¥ìë¦¬ì— ê°€ì¥ ê°€ê¹Œìš´ ìƒëŒ€ ëŒì„ ìµœìš°ì„ ìœ¼ë¡œ ë…¸ë¦½ë‹ˆë‹¤.
                    let bestTarget = null;
                    let minDistanceToEdge = Infinity;

                    targetStones.forEach(t => {
                        const distLeft = t.x;
                        const distRight = boardWidth - t.x;
                        const distTop = t.y;
                        const distBottom = boardHeight - t.y;
                        const currentMin = Math.min(distLeft, distRight, distTop, distBottom);
                        
                        if (currentMin < minDistanceToEdge) {
                            minDistanceToEdge = currentMin;
                            bestTarget = t;
                        }
                    });
                    target = bestTarget || targetStones[0]; // ë§Œì•½ ê³„ì‚° ì‹¤íŒ¨ ì‹œ ì²« ë²ˆì§¸ ëŒì„ íƒ€ê²Ÿìœ¼ë¡œ

                    // íƒ€ê²Ÿì„ ì¹˜ê¸° ê°€ì¥ ì¢‹ì€ ë‚´ ëŒì„ ì„ íƒí•©ë‹ˆë‹¤ (ê°€ì¥ ê°€ê¹Œìš´ ëŒ).
                    let bestShooter = null;
                    let minDistanceToTarget = Infinity;
                    aiStones.forEach(s => {
                        const dx = target.x - s.x;
                        const dy = target.y - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < minDistanceToTarget) {
                            minDistanceToTarget = dist;
                            bestShooter = s;
                        }
                    });
                    shooter = bestShooter || aiStones[0];

                    // ì •í™•ë„ì™€ íŒŒì›Œë¥¼ ëŒ€í­ ìƒí–¥í•©ë‹ˆë‹¤.
                    randomOffset = (Math.random() - 0.5) * 0.04; // ê±°ì˜ ì™„ë²½í•œ ì¡°ì¤€
                    aiPower = 10 + Math.random() * 8;         // íŒŒì›Œ 10 ~ 18 (ì‚¬ëŒì˜ ê°•í•œ ìƒ·ê³¼ ìœ ì‚¬)

                } else {
                    // [ì´ˆë³´ & ì¤‘ìˆ˜ AI]: ê¸°ì¡´ì²˜ëŸ¼ ëœë¤ìœ¼ë¡œ ëŒì„ ì„ íƒí•©ë‹ˆë‹¤.
                    shooter = aiStones[Math.floor(Math.random() * aiStones.length)];
                    target = targetStones[Math.floor(Math.random() * targetStones.length)];

                    if (aiDifficulty === 'easy') {
                        // [ì´ˆë³´]: ë¶€ì •í™•í•˜ì§€ë§Œ ê°€ë” ê°•í•œ ìƒ·
                        randomOffset = (Math.random() - 0.5) * 0.7; 
                        aiPower = 4 + Math.random() * 5;         // íŒŒì›Œ 4 ~ 9
                    } else { // medium
                        // [ì¤‘ìˆ˜]: ì¢€ ë” ì •í™•í•˜ê³  ê°•í•œ ìƒ·
                        randomOffset = (Math.random() - 0.5) * 0.25; 
                        aiPower = 7 + Math.random() * 5;          // íŒŒì›Œ 7 ~ 12
                    }
                }
                
                const dx = target.x - shooter.x;
                const dy = target.y - shooter.y;
                const angle = Math.atan2(dy, dx);
                
                const finalAngle = angle + randomOffset;
                
                const force = {
                    x: Math.cos(finalAngle) * aiPower,
                    y: Math.sin(finalAngle) * aiPower
                };

                shooter.vx += force.x / shooter.mass;
                shooter.vy += force.y / shooter.mass;
                hasShotThisTurn = true;
            }, 500); // AIê°€ ìƒê°í•˜ëŠ” ì‹œê°„
        }

        function checkTurn() {
            isMyTurn = (currentTurnColor === myColor);
            updateHeaderUI();
            
            if (gameMode === 'single' && !isMyTurn && !isGameOver) {
                setTimeout(aiMove, 500);
            }
        }
        
        function checkMovementEnd() {
            if (!hasShotThisTurn || isDragging || isGameOver) return;
            if (gameMode === 'multi' && !isHost) return;

            clearTimeout(movementCheckTimeout);

            const isMoving = stones.some(s => {
                if (!s.active) return false;
                const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
                return speed > MIN_SPEED;
            });

            if (isMoving) return;

            movementCheckTimeout = setTimeout(() => {
                endTurn();
            }, 300);

            hasShotThisTurn = false;
        }

        function hostBroadcastGameState() {
            if (!isHost || isGameOver || !roomRef) return;

            const gameState = stones
                .filter(s => s.active)
                .map(s => ({
                    id: s.id,
                    x_norm: s.x / boardWidth,
                    y_norm: s.y / boardHeight,
                    vx: s.vx, 
                    vy: s.vy
                }));

            roomRef.child('gameStateSync').set(gameState);
        }

        function endTurn() {
            currentTurnColor = (currentTurnColor === 'white') ? 'black' : 'white';
            hasShotThisTurn = false;
            canShoot = true; 

            if (gameMode === 'single') {
                checkTurn();
            } else if (gameMode === 'multi' && roomRef && isHost) {
                const finalStoneState = stones
                    .filter(s => s.active)
                    .map(s => ({
                        id: s.id, x: s.x, y: s.y, vx: s.vx, vy: s.vy
                    }));
                roomRef.update({ 
                    currentTurn: currentTurnColor,
                    stoneState: finalStoneState 
                });
            }
        }
        
        function setupInputHandlers() {
            const handleStart = (e) => {
                if (isGameOver || !canShoot || !isMyTurn) {
                    e.preventDefault();
                    return;
                }

                if (!isFirstTurn) {
                    const isMoving = stones.some(s => {
                        if (!s.active) return false;
                        return Math.sqrt(s.vx * s.vx + s.vy * s.vy) > MIN_SPEED;
                    });
                    if (isMoving) {
                        e.preventDefault();
                        return;
                    }
                }
                
                const pos = getEventPosition(e);
                const clickedStone = stones.find(s => {
                    if (!s.active || s.color !== myColor) return false;
                    const dx = s.x - pos.x;
                    const dy = s.y - pos.y;
                    return Math.sqrt(dx * dx + dy * dy) < s.radius;
                });
                
                if (clickedStone) {
                    e.preventDefault();
                    isDragging = true;
                    selectedStone = clickedStone;
                    dragStartPos = pos;
                    selectedStone.element.classList.add('selected');
                    powerIndicator.style.display = 'block';
                    selectedStone.vx = 0;
                    selectedStone.vy = 0;
                }
            };

            const handleMove = (e) => {
                if (!isDragging || !selectedStone) return;
                e.preventDefault();
                
                const pos = getEventPosition(e);
                const stonePos = { x: selectedStone.x, y: selectedStone.y };
                const dx = stonePos.x - pos.x;
                const dy = stonePos.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = boardWidth * 0.35;
                const clampedDistance = Math.min(distance, maxDistance);
                
                const power = clampedDistance / maxDistance;
                powerFill.style.width = `${power * 100}%`;
                
                trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
                
                const angle = Math.atan2(dy, dx);
                const lineLength = clampedDistance * 2;
                const endX = stonePos.x + Math.cos(angle) * lineLength;
                const endY = stonePos.y + Math.sin(angle) * lineLength;
                
                trajectoryCtx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                trajectoryCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                trajectoryCtx.lineWidth = 5;
                trajectoryCtx.lineCap = 'round';
                
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(stonePos.x, stonePos.y);
                trajectoryCtx.lineTo(endX, endY);
                trajectoryCtx.stroke();
                
                const arrowSize = 15;
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(endX, endY);
                trajectoryCtx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                trajectoryCtx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                trajectoryCtx.closePath();
                trajectoryCtx.fill();
            };

            const handleEnd = (e) => {
                if (!isDragging || !selectedStone) return;
                e.preventDefault();
                
                const rect = gameBoard.getBoundingClientRect();
                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                const pos = { x: clientX - rect.left, y: clientY - rect.top };

                const stonePos = { x: selectedStone.x, y: selectedStone.y };
                const dx = stonePos.x - pos.x;
                const dy = stonePos.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    const maxDistance = boardWidth * 0.5;
                    const clampedDistance = Math.min(distance, maxDistance);
                    const normalizedPower = clampedDistance / maxDistance;
                    
                    const basePower = 20;
                    const forceMagnitude = basePower * Math.pow(normalizedPower, 0.8);
                    
                    const angle = Math.atan2(dy, dx);
                    const force = {
                        x: Math.cos(angle) * forceMagnitude,
                        y: Math.sin(angle) * forceMagnitude
                    };
                    
                    selectedStone.vx += force.x / selectedStone.mass;
                    selectedStone.vy += force.y / selectedStone.mass;
                    
                    playSound('shoot-sound');
                    hasShotThisTurn = true;
                    canShoot = false;
                    isFirstTurn = false;
                    
                    if (gameMode === 'multi' && roomRef) { 
                        roomRef.child('lastMove').set({
                            stoneId: selectedStone.id,
                            forceX: force.x,
                            forceY: force.y,
                            playerId: myPlayerId,
                            timestamp: Date.now()
                        });
                    }
                }
                cleanup();
            };

            const cleanup = () => {
                isDragging = false;
                if (selectedStone) {
                    selectedStone.element.classList.remove('selected');
                }
                selectedStone = null;
                powerIndicator.style.display = 'none';
                powerFill.style.width = '0%';
                trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
            };

            gameBoard.addEventListener('mousedown', handleStart);
            gameBoard.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
            document.addEventListener('touchcancel', handleEnd);
        }

        function getEventPosition(e) {
            const rect = gameBoard.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

      function joinMultiplayerGame(roomId) {
            waitingOverlay.innerHTML = `<div class="modal-content"><div class="modal-body"><p style="margin-bottom: 20px; font-size: 1.3em;">ê²Œì„ì— ì°¸ê°€í•˜ëŠ” ì¤‘...</p><div class="spinner"></div></div></div>`;
            waitingOverlay.style.display = 'flex';

            roomRef = database.ref('rooms').child(roomId);
            
            roomRef.once('value', snapshot => {
                if (!snapshot.exists()) {
                    alert('ê²Œì„ ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    window.location.href = 'ëŒ€ê¸°ì‹¤.html';
                    return;
                }

                currentRoomData = snapshot.val();
                
                if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                    alert('ì°¸ê°€ì ëª…ë‹¨ì— ì—†ìŠµë‹ˆë‹¤. ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
                    window.location.href = 'ëŒ€ê¸°ì‹¤.html';
                    return;
                }

                // --- ë¡œì§ ê°„ì†Œí™” ---
                const playerIds = Object.keys(currentRoomData.players);
                const hasAI = playerIds.includes('ai_player');
                
                gameMode = hasAI ? 'single' : 'multi';
                isHost = currentRoomData.hostId === myPlayerId;
                myColor = isHost ? 'white' : 'black';
                opponentColor = isHost ? 'black' : 'white';

                // í”Œë ˆì´ì–´ ì •ë³´ ì„¤ì •
                const hostData = currentRoomData.players[currentRoomData.hostId];
                const guestId = playerIds.find(id => id !== currentRoomData.hostId && id !== 'ai_player');
                const guestData = guestId ? currentRoomData.players[guestId] : (hasAI ? currentRoomData.players['ai_player'] : null);
                
                player1Info = { nickname: hostData.nickname, avatar: hostData.avatar };
                player2Info = guestData ? { nickname: guestData.nickname, avatar: guestData.avatar } : { nickname: 'ìƒëŒ€ë°©', avatar: 'â“' };
                
                // onDisconnect ì„¤ì •
                if(isHost) {
                    roomRef.onDisconnect().remove();
                } else {
                    roomRef.child('players/' + myPlayerId).onDisconnect().remove();
                }

                listenToMultiplayerEvents();
                waitingOverlay.style.display = 'none';
                showPlacementModal();
            });
        }

        function listenToMultiplayerEvents() {
            roomRef.on('value', snapshot => {
                currentRoomData = snapshot.val();
            });

            roomRef.child('gameStateSync').on('value', snapshot => {
				if (isHost || !snapshot.exists() || !stones.length) return;
				const serverState = snapshot.val();
				serverState.forEach(s_data => {
					const stone = stones.find(s => s.id === s_data.id);
					if (stone && stone.active) {
						// ìœ„ì¹˜ë¥¼ ì§ì ‘ ë°”ê¾¸ëŠ” ëŒ€ì‹ , ëª©í‘œ ìœ„ì¹˜(target)ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤.
						stone.targetX = s_data.x_norm * boardWidth;
						stone.targetY = s_data.y_norm * boardHeight;
						// ì†ë„ëŠ” ì—¬ì „íˆ ì§ì ‘ ë™ê¸°í™”í•©ë‹ˆë‹¤.
						stone.vx = s_data.vx;
						stone.vy = s_data.vy;
					}
				});
			});
            /*
            roomRef.child('stoneState').on('value', snapshot => {
                if (!snapshot.exists() || isHost || !stones.length) return;
                const stateData = snapshot.val();
                stateData.forEach(s_data => {
                    const stone = stones.find(s => s.id === s_data.id);
                    if (stone && stone.active) {
                        stone.x = s_data.x;
                        stone.y = s_data.y;
                        stone.vx = s_data.vx;
                        stone.vy = s_data.vy;
                    }
                });
            });
            */

            roomRef.child('currentTurn').on('value', snapshot => {
                if (!snapshot.exists()) return;
                const newTurnColor = snapshot.val();
                currentTurnColor = newTurnColor;
                isMyTurn = (currentTurnColor === myColor);
                canShoot = isMyTurn;
                updateHeaderUI();
            });

            roomRef.child('lastMove').on('value', snapshot => {
                if (!snapshot.exists() || !isHost) return;
                const move = snapshot.val();
                if (move && move.playerId && move.playerId !== myPlayerId) {
                    const stone = stones.find(s => s.id === move.stoneId);
                    if (stone && stone.active) {
                        const force = { x: move.forceX, y: move.forceY };
                        stone.vx += force.x / stone.mass;
                        stone.vy += force.y / stone.mass;
                        hasShotThisTurn = true;
                        canShoot = false;
                    }
                }
            });

            roomRef.child('removedStones').on('child_added', snapshot => {
                if (isHost) return;
                const stoneId = snapshot.key;
                const stone = stones.find(s => s.id === stoneId);
                if (stone && stone.active) {
                    removeStone(stone);
                }
            });

            roomRef.child('gameOver').on('value', snapshot => {
                if (!snapshot.exists()) return;
                const result = snapshot.val();
                if (result && result.winner) {
                    showGameOver(result.winner);
                }
            });

            // players ë¦¬ìŠ¤ë„ˆë¥¼ í•¨ìˆ˜ ì™¸ë¶€ì—ì„œ ì •ì˜í•˜ì—¬ ëª…í™•í•˜ê²Œ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
			const onPlayerChange = function(snapshot) {
				if (!snapshot.exists()) {
					return;
				}
				const playerCount = Object.keys(snapshot.val()).length;

				if (playerCount < 2) {
					// ì´ ë¦¬ìŠ¤ë„ˆì˜ ëª©ì ì€ ìƒëŒ€ë°©ì´ ë‚˜ê°„ ê²ƒì„ ê°ì§€í•˜ëŠ” ê²ƒì´ë¯€ë¡œ, isGameOver ìƒíƒœë¥¼ ì—¬ê¸°ì„œ í™•ì¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
					// isGameLive ìƒíƒœì— ë”°ë¼ ë‹¤ë¥¸ ì²˜ë¦¬ë¥¼ í•©ë‹ˆë‹¤.
					if (isGameLive) {
						// Case 1: ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ì—ˆì„ ë•Œ -> ìŠ¹ë¦¬ ì²˜ë¦¬
						if (isGameOver) return; // ì´ë¯¸ ë‹¤ë¥¸ ì´ìœ ë¡œ ê²Œì„ì´ ëë‚¬ìœ¼ë©´ ë¬´ì‹œ
						isGameOver = true;
						roomRef.child('players').off('value', onPlayerChange); // ì´ë¦„ìœ¼ë¡œ ë¦¬ìŠ¤ë„ˆ ì œê±°
						alert('ìƒëŒ€ë°©ì´ ë‚˜ê°€ì„œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! í™•ì¸ì„ ëˆ„ë¥´ë©´ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
						window.location.href = 'ëŒ€ê¸°ì‹¤.html';
					} else {
						// Case 2: ê²Œì„ ì‹œì‘ ì „(ì¤€ë¹„ ë‹¨ê³„)ì´ì—ˆì„ ë•Œ -> ê²Œì„ ë¬´íš¨ ì²˜ë¦¬
						roomRef.child('players').off('value', onPlayerChange); // ì´ë¦„ìœ¼ë¡œ ë¦¬ìŠ¤ë„ˆ ì œê±°
						alert('ìƒëŒ€ë°©ì´ ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤. ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
						window.location.href = 'ëŒ€ê¸°ì‹¤.html';
					}
				}
			};

			// listenToMultiplayerEvents í•¨ìˆ˜ ì•ˆì—ì„œëŠ” ì´ í•¨ìˆ˜ë¥¼ ë“±ë¡ë§Œ í•©ë‹ˆë‹¤.
			roomRef.child('players').on('value', onPlayerChange);

            // [ìˆ˜ì •] 'ë‹¤ì‹œí•˜ê¸°' ìš”ì²­ ë¦¬ìŠ¤ë„ˆ
			roomRef.child('rematchRequests').on('value', snapshot => {
                // [ë²„ê·¸ ìˆ˜ì •] ê²Œì„ì˜¤ë²„ ëª¨ë‹¬ì´ ë‹«í˜€ìˆìœ¼ë©´(ê²Œì„ ì‹œì‘ ì „) ì‹¤í–‰ ì•ˆ í•¨
				if (!snapshot.exists() || !currentRoomData || !currentRoomData.players || !gameOverOverlay.style.display) return;

				const requests = snapshot.val();
				const requestCount = Object.keys(requests).length;
				const playerCount = Object.keys(currentRoomData.players).length;

				if (requestCount === playerCount) {
					if (isHost) {
						roomRef.update({
							gameState: 'restarting',
							rematchRequests: null,
							gameOver: null,
							lastMove: null,
							removedStones: null,
							stoneState: null,
							currentTurn: 'white',
							placementChoices: null
						});
					}
				}
			});

            // [ìˆ˜ì •] 'restarting' ì‹ í˜¸ ê°ì§€ (ìƒˆë¡œê³ ì¹¨ ì œê±°)
		    roomRef.child('gameState').on('value', snapshot => {
			    if (snapshot.val() === 'restarting') {
                    // [ë²„ê·¸ ìˆ˜ì •] location.reload() ëŒ€ì‹  ìƒíƒœ ì´ˆê¸°í™” í•¨ìˆ˜ í˜¸ì¶œ
                    handleGameRestart();
			    }
		    });


        }
        
        function updateHeaderUI() {
            const header = document.getElementById('game-header');
            if (!header || !player1Info || !player2Info) return;
            
            const p1Active = (currentTurnColor === 'white');
            const p2Active = (currentTurnColor === 'black');
            
            const p1Count = stones.filter(s => s.color === 'white' && s.active).length;
            const p2Count = stones.filter(s => s.color === 'black' && s.active).length;

            // âœ¨ [ìˆ˜ì •] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸(ID), ì´ë¯¸ì§€, ì´ëª¨ì§€ ìˆœìœ¼ë¡œ í™•ì¸ (P1)
            const avatarSet1 = AVATAR_SETS[player1Info.avatar];
            let p1Avatar = '';
            if (avatarSet1) {
                p1Avatar = `<img src="${avatarSet1.front}" alt="avatar">`;
            } else if (player1Info.avatar && (player1Info.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(player1Info.avatar))) {
                p1Avatar = `<img src="${player1Info.avatar}" alt="avatar">`;
            } else {
                p1Avatar = escapeHTML(player1Info.avatar); // ì´ëª¨ì§€
            }
            
            // âœ¨ [ìˆ˜ì •] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸(ID), ì´ë¯¸ì§€, ì´ëª¨ì§€ ìˆœìœ¼ë¡œ í™•ì¸ (P2)
            const avatarSet2 = AVATAR_SETS[player2Info.avatar];
            let p2Avatar = '';
            if (avatarSet2) {
                p2Avatar = `<img src="${avatarSet2.front}" alt="avatar">`;
            } else if (player2Info.avatar && (player2Info.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(player2Info.avatar))) {
                p2Avatar = `<img src="${player2Info.avatar}" alt="avatar">`;
            } else {
                p2Avatar = escapeHTML(player2Info.avatar); // ì´ëª¨ì§€
            }

            header.innerHTML = `
                <div class="player-info ${p1Active ? 'my-turn' : ''}">
                    <div class="avatar">${p1Avatar}</div>
                    <div class="info-text">
                        <div class="nickname">${player1Info.nickname}</div>
                        <div class="stone-count">âšª ${p1Count}ê°œ</div>
                    </div>
                </div>
                <div class="player-info ${p2Active ? 'my-turn' : ''}">
                    <div class="avatar">${p2Avatar}</div>
                    <div class="info-text">
                        <div class="nickname">${player2Info.nickname}</div>
                        <div class="stone-count">âš« ${p2Count}ê°œ</div>
                    </div>
                </div>
            `;
        }

        function showGameOver(winner) {
            if (isGameOver) return;
            isGameOver = true;

            const iWon = (winner === myColor);
            const resultText = iWon ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ˜¢ íŒ¨ë°°...';
            playSound(iWon ? 'win-sound' : 'loss-sound');

            if (gameMode === 'multi' && roomRef && isHost) {
                roomRef.update({ gameOver: { winner: winner, timestamp: Date.now() } });
            }

            if (gameMode === 'single' || (gameMode === 'multi' && !myPlayerId.startsWith('guest_'))) {
                updatePlayerStats(iWon);
            }

            gameOverOverlay.innerHTML = `
                <div class="modal-content">
                    <div id="game-over-message">${resultText}</div>
                    <div class="modal-buttons">
                        <button id="rematch-btn" class="menu-btn primary">ë‹¤ì‹œ í•˜ê¸°</button>
                        <button id="to-lobby-btn" class="menu-btn secondary">ëŒ€ê¸°ì‹¤ë¡œ</button>
                    </div>
                </div>
            `;
            gameOverOverlay.style.display = 'flex';

            const rematchBtn = document.getElementById('rematch-btn');
			rematchBtn.addEventListener('click', () => {
                // [ë²„ê·¸ ìˆ˜ì •] ì‹±ê¸€/ë©€í‹° ëª¨ë‘ 'rematchRequests'ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í†µì¼
                // (location.reload()ëŠ” ë°©ì„ í„°íŠ¸ë¦¼)
                
			    rematchBtn.disabled = true;
			    rematchBtn.textContent = 'ìƒëŒ€ë°© ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
                
                if (gameMode === 'multi' && roomRef) {
				    // ë©€í‹°í”Œë ˆì´: Firebaseì— ì¬ì‹œì‘ ìš”ì²­
				    roomRef.child('rematchRequests/' + myPlayerId).set(true);
                } else if (gameMode === 'single') {
                    // ì‹±ê¸€í”Œë ˆì´: 0.5ì´ˆ í›„ ìŠ¤ìŠ¤ë¡œ ì¬ì‹œì‘ (AIëŠ” í•­ìƒ ë™ì˜)
                    setTimeout(() => {
                        // 'restarting' ì‹ í˜¸ë¥¼ ìŠ¤ìŠ¤ë¡œ ê°ì§€í•˜ë„ë¡ ë¡œì§ì„ ë‹¨ìˆœí™”
                        handleGameRestart();
                    }, 500);
                }
			});
            document.getElementById('to-lobby-btn').addEventListener('click', cleanupAndExit);
            document.getElementById('to-main-btn').addEventListener('click', () => {
                sessionStorage.setItem('returnFromGame', 'true');
                window.location.href = 'index.html';
            });
        }

        function updatePlayerStats(won) {
            if (!myPlayerId || myPlayerId.startsWith('guest_')) return;

            const userRef = playersStatsRef.child(myPlayerId);

            userRef.transaction(userData => {
                if (userData) {
                    // --- âœ¨ ì•ˆì •ì„± ê°•í™”: í•„ìˆ˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì±„ì›Œì¤ë‹ˆë‹¤ ---
                    if (!userData.profile) { userData.profile = {}; }
                    const profile = userData.profile;
                    profile.level = profile.level || 1;
                    profile.createdAt = profile.createdAt || firebase.database.ServerValue.TIMESTAMP;
                    profile.exp = profile.exp || 0;
                    profile.points = profile.points || 0;
                    
                    let expGained = 0;
                    let pointsGained = 0;

                    if (gameMode === 'single') {
                        expGained = won ? 60 : 10;
                        pointsGained = won ? 100 : 20;
                    } else { // 'multi'
                        expGained = won ? 120 : 30;
                        pointsGained = won ? 200 : 100;
                    }

                    profile.exp += expGained;
                    profile.points += pointsGained;

                    // --- gameStats ê²½ë¡œ ì²˜ë¦¬ ---
                    if (!userData.gameStats) { userData.gameStats = {}; }
                    if (!userData.gameStats.alkkagi) {
                        userData.gameStats.alkkagi = { wins: 0, losses: 0, plays: 0 };
                    }
                    
                    const alkkagiStats = userData.gameStats.alkkagi;
                    if (won) {
                        alkkagiStats.wins = (alkkagiStats.wins || 0) + 1;
                    } else {
                        alkkagiStats.losses = (alkkagiStats.losses || 0) + 1;
                    }
                    alkkagiStats.plays = (alkkagiStats.plays || 0) + 1;
                }
                return userData;
            });
        }
// [ì‹ ê·œ] 'ë‹¤ì‹œí•˜ê¸°' (ìƒˆë¡œê³ ì¹¨ ëŒ€ì²´) í•¨ìˆ˜
        function handleGameRestart() {
            console.log("ê²Œì„ ì¬ì‹œì‘ ì¤‘...");
            
            // 1. ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            isGameOver = false;
            isGameLive = false;
            canShoot = true;
            hasShotThisTurn = false;
            isFirstTurn = true;
            currentTurnColor = 'white'; // [ìˆ˜ì •] í‘ëŒ(black) -> ë°±ëŒ(white) ì„ ê³µ
            
            // 2. ì˜¤ë²„ë ˆì´ ë‹«ê¸°
            gameOverOverlay.style.display = 'none';
            gameOverOverlay.innerHTML = ''; // ëª¨ë‹¬ ë‚´ìš© ë¹„ìš°ê¸°
            
            // 3. (ë©€í‹°) ë°©ì¥ì´ë©´ restarting ìƒíƒœë¥¼ nullë¡œ ë˜ëŒë¦¼
            if (gameMode === 'multi' && isHost && roomRef) {
                roomRef.child('gameState').set(null);
            }

            // 4. ë°°ì¹˜ ì„ íƒ ëª¨ë‹¬ë¶€í„° ë‹¤ì‹œ ì‹œì‘
            showPlacementModal();
        }
        
        function cleanupAndExit() {
            if (roomRef) {
                // ë°©ì¥ì¼ ê²½ìš°ì—ë§Œ ë°©ì„ ì‚­ì œí•©ë‹ˆë‹¤ (AI ëª¨ë“œì—ì„œëŠ” í•­ìƒ ë°©ì¥ì„).
                if (isHost) {
                    roomRef.remove();
                }
                roomRef.off(); // ëª¨ë“  ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
            }
            window.location.href = 'ëŒ€ê¸°ì‹¤.html';
        }

        initialize();
    });
    </script>

    <audio id="game-start-sound" src="https://blog.kakaocdn.net/dna/vs7DN/dJMb9WFpvRs/AAAAAAAAAAAAAAAAAAAAAHJf1oqbiChuQiMUS_vcbEl2K6eaA6zzuosqQWk6d5E5/%EA%B2%8C%EC%9E%84%EC%8B%9C%EC%9E%91.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=EaapSJcpcP5OlE4ibx8C9NOU%2FkI%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="shoot-sound" src="https://blog.kakaocdn.net/dna/u8HMx/dJMb9OAFJEJ/AAAAAAAAAAAAAAAAAAAAAIqs8CjD3Mo8q0lPZ4p1BuoAVpWIP8fBfafJry8rMXni/%EC%99%8C%EA%B5%B4%EB%A6%AC%EB%8A%94%EC%86%8C%EB%A6%AC.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=NnUO7jp%2B7JkU35w00W9cS%2FB266M%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="success-sound" src="https://blog.kakaocdn.net/dna/crLSSK/dJMb8Y4jJZ6/AAAAAAAAAAAAAAAAAAAAAHSoWfFNw21Plu9ufn_jnmod1cp9rUDWubdEaHmSdsC0/%EC%95%8C%EA%B9%8C%EA%B8%B0%EC%84%B1%EA%B3%B5.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=mkf47bHt8yFioqWm6JBr8yiLKr0%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="win-sound" src="https://blog.kakaocdn.net/dna/kC4is/dJMb8WZJowA/AAAAAAAAAAAAAAAAAAAAAIQeZhVDJf0ZGAWyyMr_hsc6TMe3BFUVXd0FNTl5VDcY/%EA%B2%8C%EC%9E%84%EC%8A%B9%EB%A6%AC.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=qZKwGj5NQeAFNrOvCPAMXc6aX9I%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="loss-sound" src="https://blog.kakaocdn.net/dna/Zqr4u/dJMb9V0NWlD/AAAAAAAAAAAAAAAAAAAAANQFEr99iVFS25T5ZW3Q2dixeZXsbUzh7OWB40uYQMu9/%EC%95%8C%EA%B9%8C%EA%B8%B0%ED%8C%A8%EB%B0%B0.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=2xNnbSadPzs2ZZi1BssfyCye8jI%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>

<div id="ai-difficulty-modal" class="overlay" style="display: none;">
    <div class="modal-content" style="background: #4a5a6a; max-width: 380px;">
        <div style="padding: 25px;">
            <h2 style="font-size: 1.8em; margin-bottom: 25px;">AI ë‚œì´ë„ì„ íƒ</h2>
            <div class="modal-buttons">
                <button class="menu-btn primary" data-difficulty="easy" style="background-color: #4CAF50;">ì´ˆë³´</button>
                <button class="menu-btn primary" data-difficulty="medium" style="background-color: #FFC107; color: #333;">ì¤‘ìˆ˜</button>
                <button class="menu-btn primary" data-difficulty="hard" style="background-color: #F44336;">ê³ ìˆ˜</button>
            </div>
        </div>
    </div>
</div>

<div id="confirm-exit-modal" class="overlay" style="display: none;">
    <div class="modal-content" style="background: #4a5a6a; max-width: 350px;">
        <div style="padding: 30px 20px 20px; text-align: center;">
            <h3 style="font-size: 1.4em; margin-bottom: 15px;">ì •ë§ ê²Œì„ì—ì„œ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?</h3>
            <p style="font-size: 0.9em; color: #ccc;">ê²Œì„ì€ íŒ¨ë°°ì²˜ë¦¬ ë©ë‹ˆë‹¤.</p>
        </div>
        <div style="display: flex; gap: 10px; padding: 15px; background-color: #3d4a5a; border-top: 1px solid #667a99;">
            <button id="exit-cancel-btn" class="menu-btn secondary" style="background-color: #78909c;">ì·¨ì†Œ</button>
            <button id="exit-confirm-btn" class="menu-btn primary" style="background-color: var(--danger-color, #e53935);">í™•ì¸</button>
        </div>
    </div>
</div>

<div id="placement-modal" class="overlay" style="display: none;">
    <div class="modal-content" style="background: #5a4a42; max-width: 420px;">
        <div style="padding: 25px;">
            <h2 style="font-size: 1.8em; margin-bottom: 25px;">ë°°ì¹˜ ìŠ¤íƒ€ì¼ì„ íƒ</h2>
            <div id="style-options-container" style="display: flex; gap: 20px; justify-content: center;">
    <div class="style-option" data-style="style1">
        <div class="preview-board">
            <div class="preview-stone white" style="top: 20%; left: 10%;"></div>
            <div class="preview-stone white" style="top: 20%; left: 30%;"></div>
            <div class="preview-stone white" style="top: 20%; left: 50%;"></div>
            <div class="preview-stone white" style="top: 20%; left: 70%;"></div>
            <div class="preview-stone white" style="top: 20%; left: 90%;"></div>
        </div>
        <h4>ê¸°ë³¸ ë°°ì¹˜</h4>
    </div>

    <div class="style-option" data-style="style2">
        <div class="preview-board">
            <div class="preview-stone white" style="top: 15%; left: 15%;"></div>
            <div class="preview-stone white" style="top: 15%; left: 50%;"></div>
            <div class="preview-stone white" style="top: 15%; left: 85%;"></div>
            <div class="preview-stone white" style="top: 35%; left: 35%;"></div>
            <div class="preview-stone white" style="top: 35%; left: 65%;"></div>
        </div>
        <h4>ìˆ˜ë¹„í˜• ë°°ì¹˜</h4>
    </div>
</div>
            <p id="placement-waiting-text" style="margin-top: 20px; font-size: 1.em; color: var(--accent-color); display: none;">ìƒëŒ€ë°©ì´ ë°°ì¹˜ ìŠ¤íƒ€ì¼ì„ ì„ íƒ ì¤‘ì…ë‹ˆë‹¤...</p>
        </div>
    </div>
</div>

</body>
</html>
