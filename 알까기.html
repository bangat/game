<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>알까기</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #3d2f2b;
            --board-color: #e4b476;
            --border-color: #6a4a3a;
            --stone-white: #f5f5f5;
            --stone-black: #333;
            --shadow-color: rgba(0,0,0,0.2);
            --primary-color: #8d6e63;
            --accent-color: #ffab40;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: none;
        }
        .view {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .hidden { display: none !important; }

        .menu-btn {
            width: 90%; max-width: 320px; padding: 15px;
            font-size: 1.5em; font-weight: 700;
            font-family: 'GmarketSans', sans-serif;
            border-radius: 12px; border: none; cursor: pointer;
            margin: 10px 0; box-shadow: 0 5px 10px var(--shadow-color);
            transition: all 0.2s ease-out;
        }
        .menu-btn:active { transform: scale(0.97); }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #eee; color: #333; }
        .main-title {
            font-size: 3.5em; font-weight: 700; color: white;
            margin-bottom: 30px; text-shadow: 3px 3px 5px var(--shadow-color);
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: none; flex-direction: column;
        }
        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-between; align-items: center;
            padding: 15px 20px; background-color: rgba(0,0,0,0.3);
            gap: 20px;
        }
        .player-info {
            display: flex; flex-direction: row;
            align-items: center; gap: 12px; padding: 10px 15px;
            border-radius: 12px; transition: all 0.3s ease;
            background-color: rgba(255,255,255,0.1);
            min-width: 140px;
        }
        .player-info.my-turn {
            background-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 171, 64, 0.5);
        }
        .player-info.my-turn .nickname { color: black; }
        .player-info .avatar { font-size: 2em; }
        .player-info .avatar img {
            width: 40px; height: 40px;
            object-fit: contain; border-radius: 50%;
        }
        .player-info .nickname {
            font-weight: 700; font-size: 1em;
        }
        .player-info .stone-count {
            font-size: 0.85em; opacity: 0.9;
        }
        .player-info .info-text {
            display: flex; flex-direction: column; align-items: flex-start;
        }
        
        #game-container {
            width: 100%; flex-grow: 1;
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 20px 10px;
        }
        #game-board {
            position: relative; background-color: var(--board-color);
            border: 6px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 8px;
            background-image:
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
        }

        .stone {
            position: absolute; border-radius: 50%;
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 4px 8px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-weight: 700; transition: transform 0.1s ease;
            cursor: grab;
        }
        .stone:active { cursor: grabbing; }
        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #f5f5f5 50%, #e0e0e0);
        }
        .stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #333 50%, #222);
        }
        .stone.selected {
            transform: scale(1.15);
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 0 20px rgba(255, 171, 64, 0.8),
                0 4px 12px rgba(0,0,0,0.5);
        }
        .stone.removed {
            transition: all 0.4s ease;
            transform: scale(0);
            opacity: 0;
        }
        
        #power-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 300px;
            height: 30px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 15px;
            overflow: hidden;
            display: none;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #power-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.05s linear;
            border-radius: 13px;
        }

        #trajectory-canvas {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            opacity: 0.85;
        }

        .overlay {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 200; text-align: center;
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 40px;
            border-radius: 25px;
            width: 90%; max-width: 380px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #game-over-message {
            font-size: 2.5em; font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .modal-buttons {
            display: flex; flex-direction: column;
            gap: 12px; align-items: center; margin-top: 25px;
        }
        #countdown-number {
            font-size: 8em; font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 30px rgba(255, 171, 64, 0.8);
            animation: countdown-pop 1s ease-in-out;
        }
        @keyframes countdown-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        .spinner { 
            margin: 20px auto; 
            border: 4px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; 
            border-top: 4px solid white; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        /* ▼▼▼▼▼ 아래 스타일을 새로 추가하세요 ▼▼▼▼▼ */
.style-option {
    border: 3px solid transparent;
    border-radius: 12px;
    padding: 15px;
    background-color: rgba(0,0,0,0.2);
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}
.style-option:hover {
    border-color: var(--accent-color);
    background-color: rgba(0,0,0,0.3);
}
.style-option.selected { /* 자바스크립트에서 선택 시 추가할 클래스 */
    border-color: var(--accent-color);
    box-shadow: 0 0 15px var(--accent-color);
}
.style-option h4 {
    margin-top: 10px;
    font-size: 1em;
}
.preview-board {
    width: 120px;
    height: 70px;
    background-color: var(--board-color);
    border-radius: 6px;
    position: relative;
}
.preview-stone {
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
}
.preview-stone.white { background-color: var(--stone-white); }
.preview-stone.black { background-color: var(--stone-black); }
/* ▲▲▲▲▲ 코드 추가 종료 ▲▲▲▲▲ */

    </style>
</head>
<body>
    <div id="start-menu" class="view">
        <h1 class="main-title">알까기</h1>
        <button id="single-player-btn" class="menu-btn secondary">혼자 하기 (vs AI)</button>
        <button id="multiplayer-btn" class="menu-btn primary">같이 하기</button>
        <button id="back-to-index-btn" class="menu-btn secondary">메인으로</button>
    </div>

    <div id="game-wrapper" class="view">
        <div id="game-header"></div>
        <div id="game-container">
            <div id="game-board">
                <canvas id="trajectory-canvas"></canvas>
            </div>
            <div id="power-indicator">
                <div id="power-fill"></div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="waiting-overlay" class="overlay" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
    

        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
            authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
            projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app",
            messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const playersStatsRef = database.ref('users');

        const startMenu = document.getElementById('start-menu');
        const gameWrapper = document.getElementById('game-wrapper');
        const gameContainer = document.getElementById('game-container');
        const gameBoard = document.getElementById('game-board');
        const trajectoryCanvas = document.getElementById('trajectory-canvas');
        const trajectoryCtx = trajectoryCanvas.getContext('2d');
        const powerIndicator = document.getElementById('power-indicator');
        const powerFill = document.getElementById('power-fill');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const waitingOverlay = document.getElementById('waiting-overlay');
        
        const { Engine, Render, Runner, World, Bodies, Body, Vector, Events } = Matter;

        let myPlayerId, myNickname, myAvatar;
        let engine, runner;
        let gameMode = null;
        let stones = [];
        let myColor = 'white';
        let opponentColor = 'black';
        let currentTurnColor = 'white'; // 색깔로 턴 관리
        let isMyTurn = false;
        let isDragging = false;
        let selectedStone = null;
        let isGameOver = false;
        let boardWidth = 0, boardHeight = 0;
        let roomRef = null;
        let currentRoomData = null; // 추가
        let dragStartPos = null;
        let isHost = false;
        let canShoot = true; // 발사 가능 여부
        let hasShotThisTurn = false; // 이번 턴에 발사했는지 여부
        let isFirstTurn = true;

        function playSound(id) {
            const sound = document.getElementById(id);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {}); // 사용자가 상호작용하기 전에 재생 시도 시 발생하는 오류 방지
            }
        }

        let opponentInfo = { id: 'ai', nickname: 'AI', avatar: '🤖' };
        let player1Info = null;
        let player2Info = null;

        function initialize() {
            myPlayerId = localStorage.getItem('myPlayerId');
            if (!myPlayerId) {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
                return;
            }
            myNickname = localStorage.getItem('userNickname') || 'Player';
            myAvatar = localStorage.getItem('userAvatar') || '😊';

            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            
            if (roomId) {
                startMenu.style.display = 'none';
                joinMultiplayerGame(roomId);
            } else {
                document.getElementById('single-player-btn').addEventListener('click', () => startCountdown('single'));
                document.getElementById('multiplayer-btn').addEventListener('click', () => { 
                    window.location.href = '대기실.html'; 
                });
                document.getElementById('back-to-index-btn').addEventListener('click', () => { 
                    window.location.href = 'index.html'; 
                });
            }
        }

        function startCountdown(mode) {
            gameMode = mode;
            startMenu.style.display = 'none';
            waitingOverlay.innerHTML = `<div id="countdown-number">3</div>`;
            waitingOverlay.style.display = 'flex';
            let count = 3;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    waitingOverlay.innerHTML = `<div id="countdown-number">${count}</div>`;
                } else {
                    clearInterval(interval);
                    playSound('game-start-sound');
                    waitingOverlay.style.display = 'none';
                    // 게임 설정 대신 배치 모달을 띄웁니다.
                    showPlacementModal();
                }
            }, 1000);
        }


// ▼▼▼▼▼ 아래 함수를 새로 추가하세요 ▼▼▼▼▼
function showPlacementModal() {
    const modal = document.getElementById('placement-modal');
    const options = modal.querySelectorAll('.style-option');
    const waitingText = document.getElementById('placement-waiting-text');
    modal.style.display = 'flex';
    
    // 싱글플레이 모드
    if (gameMode === 'single') {
        options.forEach(opt => {
            opt.addEventListener('click', () => {
                const selectedStyle = opt.dataset.style;
                modal.style.display = 'none';
                setupSinglePlayerGame(selectedStyle);
            });
        });
        return;
    }

    // --- 멀티플레이 모드 ---
    // Firebase에 선택 정보를 기록할 경로를 초기화 (방장만)
    if (isHost) {
        roomRef.child('placementChoices').set(null);
    }
    
    // 1. 내가 스타일을 선택했을 때의 로직
    options.forEach(opt => {
        opt.addEventListener('click', function onStyleClick() {
            const selectedStyle = this.dataset.style;
            
            // 시각적으로 선택되었음을 표시
            options.forEach(o => o.classList.remove('selected'));
            this.classList.add('selected');
            
            // 한번 선택하면 다시 선택 못하게 막고, 대기 텍스트 표시
            options.forEach(o => o.style.pointerEvents = 'none');
            waitingText.textContent = '상대방의 선택을 기다리는 중...';
            waitingText.style.display = 'block';

            // Firebase에 나의 선택을 기록
            roomRef.child('placementChoices').child(myPlayerId).set(selectedStyle);
        });
    });

    // 2. 두 명 모두 선택을 완료했는지 감지하는 리스너
    roomRef.child('placementChoices').on('value', function onBothChosen(snapshot) {
        if (!snapshot.exists()) return;

        const choices = snapshot.val();
        const playerCount = Object.keys(currentRoomData.players).length;
        
        // 두 명의 선택이 모두 기록되었으면 게임 시작
        if (Object.keys(choices).length === playerCount) {
            roomRef.child('placementChoices').off('value', onBothChosen); // 리스너 정리
            
            const hostChoice = choices[currentRoomData.hostId];
            const guestId = Object.keys(currentRoomData.players).find(id => id !== currentRoomData.hostId);
            const guestChoice = choices[guestId];
            
            modal.style.display = 'none';
            // 방장은 흰 돌(hostChoice), 게스트는 검은 돌(guestChoice) 스타일로 게임 시작
            setupMultiplayerGame(hostChoice, guestChoice);
        }
    });
}

        

        // ▼▼▼▼▼ 아래 함수를 새로 추가하세요 ▼▼▼▼▼
function placeStones(whiteStyle, blackStyle) {
    const stoneSize = boardWidth / 14;
    stones = [];
    gameBoard.querySelectorAll('.stone').forEach(el => el.remove());

    // --- 흰색 돌 배치 (whiteStyle 기준) ---
    if (whiteStyle === 'style1') {
        for (let i = 0; i < 8; i++) {
            const x = boardWidth * 0.5 + (i - 3.5) * stoneSize * 1.2;
            createStone(x, boardHeight * 0.15, stoneSize, 'white', `white${i}`);
        }
    } else if (whiteStyle === 'style2') {
        for (let i = 0; i < 5; i++) {
            createStone(boardWidth * 0.5 + (i - 2) * stoneSize * 1.5, boardHeight * 0.1, stoneSize, 'white', `white${i}`);
        }
        for (let i = 0; i < 3; i++) {
            createStone(boardWidth * 0.5 + (i - 1) * stoneSize * 1.8, boardHeight * 0.25, stoneSize, 'white', `white${i + 5}`);
        }
    }

    // --- 검은색 돌 배치 (blackStyle 기준) ---
    if (blackStyle === 'style1') {
        for (let i = 0; i < 8; i++) {
            const x = boardWidth * 0.5 + (i - 3.5) * stoneSize * 1.2;
            createStone(x, boardHeight * 0.85, stoneSize, 'black', `black${i}`);
        }
    } else if (blackStyle === 'style2') {
        for (let i = 0; i < 5; i++) {
            createStone(boardWidth * 0.5 + (i - 2) * stoneSize * 1.5, boardHeight * 0.9, stoneSize, 'black', `black${i}`);
        }
        for (let i = 0; i < 3; i++) {
            createStone(boardWidth * 0.5 + (i - 1) * stoneSize * 1.8, boardHeight * 0.75, stoneSize, 'black', `black${i + 5}`);
        }
    }
}


       function setupGame() {
            isGameOver = false;
            canShoot = true;
            hasShotThisTurn = false;
            gameWrapper.style.display = 'flex';
            
            const containerW = gameContainer.clientWidth;
            const containerH = gameContainer.clientHeight;
            boardWidth = Math.min(containerW * 0.92, 400);
            // 바둑판 세로 길이를 줄이고 상하 여백을 확보하도록 수정
            boardHeight = Math.min(containerH * 0.75, boardWidth * 1.4); 
            
            gameBoard.style.width = `${boardWidth}px`;
            gameBoard.style.height = `${boardHeight}px`;
            gameBoard.style.backgroundSize = `${boardWidth / 10}px ${boardWidth / 10}px`;
            
            trajectoryCanvas.width = boardWidth;
            trajectoryCanvas.height = boardHeight;
            trajectoryCanvas.style.width = `${boardWidth}px`;
            trajectoryCanvas.style.height = `${boardHeight}px`;
            
            gameBoard.innerHTML = '';
            gameBoard.appendChild(trajectoryCanvas);

            engine = Engine.create({ gravity: { x: 0, y: 0 } });
            runner = Runner.create();
            
            // 돌 배열만 초기화하고, 실제 생성은 placeStones() 함수로 이동했습니다.
            stones = [];
            
            // ★★★★★ 이곳에 있던 돌 자동 생성 for 루프가 삭제되었습니다. ★★★★★

            Runner.run(runner, engine);
            if (gameMode === 'multi' && isHost) {
                setInterval(hostBroadcastGameState, 1);
            }
            requestAnimationFrame(gameLoop);
            
            Events.on(engine, 'afterUpdate', checkMovementEnd);
            
            setupInputHandlers();
        }
        
function setupSinglePlayerGame(style) {
    setupGame();
    // 싱글 플레이에서는 AI도 나의 선택을 따라오도록 두 스타일 모두 동일하게 전달
    placeStones(style, style);
    myColor = 'white';
    opponentColor = 'black';
    currentTurnColor = 'white';
    isMyTurn = true;
    player1Info = { nickname: myNickname, avatar: myAvatar };
    player2Info = { nickname: 'AI', avatar: '🤖' };
    updateHeaderUI();
}

function setupMultiplayerGame(whiteStyle, blackStyle) {
    setupGame();
    // 이제 흰 돌과 검은 돌의 스타일을 각각 전달
    placeStones(whiteStyle, blackStyle);
    currentTurnColor = 'white';
    isMyTurn = (currentTurnColor === myColor);
    canShoot = true;
    updateHeaderUI();
}

        function createStone(x, y, radius, color, id) {
            const body = Bodies.circle(x, y, radius / 2, {
                restitution: 0.9,
                friction: 0.0005,
                frictionAir: 0.015,
                density: 0.025,
                mass: 2.5,
                label: id,
                inertia: Infinity
            });
            World.add(engine.world, body);

            const element = document.createElement('div');
            element.className = `stone ${color}`;
            element.id = id;
            element.style.width = `${radius}px`;
            element.style.height = `${radius}px`;
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';
            gameBoard.appendChild(element);

            stones.push({ id, body, element, color, active: true });
        }

        function gameLoop() {
            if (isGameOver) return;
            
            stones.forEach(stone => {
                if (stone.active) {
                    const x = stone.body.position.x - stone.body.circleRadius;
                    const y = stone.body.position.y - stone.body.circleRadius;
                    stone.element.style.transform = `translate(${x}px, ${y}px)`;
                    
                    if (isOutOfBoard(stone.body.position)) {
                        removeStone(stone);
                    }
                }
            });
            
            requestAnimationFrame(gameLoop);
        }


        function isOutOfBoard(pos) {
            return pos.x < 0 || pos.x > boardWidth || 
                   pos.y < 0 || pos.y > boardHeight;
        }

        function removeStone(stone) {
            if (!stone.active) return;
            stone.active = false;
            stone.element.classList.add('removed');
            World.remove(engine.world, stone.body);

            if (stone.color !== currentTurnColor) {
                playSound('success-sound');
            }
            
            if (gameMode === 'multi' && roomRef && isHost) {
                roomRef.child('removedStones').child(stone.id).set(true);
            }
            
            setTimeout(() => {
                if (stone.element.parentNode) {
                    stone.element.remove();
                }
                checkWinCondition();
            }, 400);
        }
        
        function checkWinCondition() {
            const whiteStonesLeft = stones.filter(s => s.color === 'white' && s.active).length;
            const blackStonesLeft = stones.filter(s => s.color === 'black' && s.active).length;

            if (whiteStonesLeft === 0 && blackStonesLeft > 0) {
                showGameOver('black');
            } else if (blackStonesLeft === 0 && whiteStonesLeft > 0) {
                showGameOver('white');
            }
        }
        
        function aiMove() {
            if (isGameOver || !canShoot) return;
            
            const aiStones = stones.filter(s => s.color === opponentColor && s.active);
            const targetStones = stones.filter(s => s.color === myColor && s.active);
            
            if (aiStones.length === 0 || targetStones.length === 0) return;

            canShoot = false;
            
            setTimeout(() => {
                if (isGameOver) return;
                
                const shooter = aiStones[Math.floor(Math.random() * aiStones.length)];
                const target = targetStones[Math.floor(Math.random() * targetStones.length)];
                
                const dx = target.body.position.x - shooter.body.position.x;
                const dy = target.body.position.y - shooter.body.position.y;
                const angle = Math.atan2(dy, dx);
                
                const randomOffset = (Math.random() - 0.5) * 0.5;
                const finalAngle = angle + randomOffset;
                
                const aiPower = 0.025 + Math.random() * 0.02;
                const force = {
                    x: Math.cos(finalAngle) * aiPower,
                    y: Math.sin(finalAngle) * aiPower
                };

                Body.applyForce(shooter.body, shooter.body.position, force);
                hasShotThisTurn = true;
            }, 500);
        }

        function checkTurn() {
            isMyTurn = (currentTurnColor === myColor);
            updateHeaderUI();
            
            if (gameMode === 'single' && !isMyTurn && !isGameOver) {
                setTimeout(aiMove, 500);
            }
        }
        
        let movementCheckTimeout = null;

  function checkMovementEnd() {
    if (!hasShotThisTurn || isDragging || isGameOver) return;
    
    // [추가] 멀티플레이 모드에서는 방장(isHost)만 턴 종료를 판정합니다.
    if (gameMode === 'multi' && !isHost) {
        return;
    }

            clearTimeout(movementCheckTimeout);

            const isMoving = stones.some(s => {
                if (!s.active) return false;
                const speed = Math.sqrt(
                    s.body.velocity.x * s.body.velocity.x +
                    s.body.velocity.y * s.body.velocity.y
                );
                return speed > 0.1;
            });

            if (isMoving) {
                return;
            }

            movementCheckTimeout = setTimeout(() => {
                const whiteStonesLeft = stones.filter(s => s.color === 'white' && s.active).length;
                const blackStonesLeft = stones.filter(s => s.color === 'black' && s.active).length;

                if (whiteStonesLeft === 0 && blackStonesLeft > 0) {
                    showGameOver('black');
                } else if (blackStonesLeft === 0 && whiteStonesLeft > 0) {
                    showGameOver('white');
                } else {
                    endTurn();
                }
            }, 300);

            hasShotThisTurn = false;
        }

        function hostBroadcastGameState() {
    // 방장이 아니거나, 게임이 끝났거나, 방이 없으면 실행하지 않음
    if (!isHost || isGameOver || !roomRef) return;

    // 현재 살아있는 모든 돌의 위치 정보를 수집
     const gameState = stones
        .filter(s => s.active)
        .map(s => ({
            id: s.id,
            // ▼▼▼▼▼ 여기를 수정하세요 ▼▼▼▼▼
            x_norm: s.body.position.x / boardWidth,   // 너비에 대한 비율
            y_norm: s.body.position.y / boardHeight,  // 높이에 대한 비율
            // ▲▲▲▲▲ 수정 종료 ▲▲▲▲▲
            vx: s.body.velocity.x, 
            vy: s.body.velocity.y
        }));

    // 'gameStateSync' 라는 경로에 주기적으로 덮어쓰기
    roomRef.child('gameStateSync').set(gameState);
}


// 1. endTurn() 함수 전체를 아래 코드로 교체하세요.
function endTurn() {
    console.log('🔄 턴 종료! 현재 턴:', currentTurnColor);

    currentTurnColor = (currentTurnColor === 'white') ? 'black' : 'white';
    console.log('✅ 다음 턴:', currentTurnColor);
    
    hasShotThisTurn = false;
    canShoot = true; 

    if (gameMode === 'single') {
        checkTurn();
    } else if (gameMode === 'multi' && roomRef && isHost) {
        // ▼▼▼▼▼ 수정된 부분 시작 ▼▼▼▼▼
        // 모든 활성 돌의 최종 상태(ID, 위치, 속도)를 수집합니다.
        const finalStoneState = stones
            .filter(s => s.active) // 살아있는 돌만 대상으로 합니다.
            .map(s => ({
                id: s.id,
                x: s.body.position.x,
                y: s.body.position.y,
                vx: s.body.velocity.x,
                vy: s.body.velocity.y
            }));

        // 턴 정보와 함께 '돌의 최종 상태'를 데이터베이스에 업데이트합니다.
        roomRef.update({ 
            currentTurn: currentTurnColor,
            stoneState: finalStoneState 
        });
        // ▲▲▲▲▲ 수정된 부분 종료 ▲▲▲▲▲
    }
}
        
        function setupInputHandlers() {
            const handleStart = (e) => {
                if (isGameOver || !canShoot || !isMyTurn) {
                    e.preventDefault();
                    return;
                }

    if (!isFirstTurn) { // 첫 턴이 아닐 때만 움직임을 체크합니다.
        const isMoving = stones.some(s => {
            if (!s.active) return false;
            const speed = Math.sqrt(
                s.body.velocity.x * s.body.velocity.x + 
                s.body.velocity.y * s.body.velocity.y
            );
            return speed > 0.05;
        });
        
        if (isMoving) {
            e.preventDefault();
            return;
        }
    }
                
                const pos = getEventPosition(e);
                const clickedStone = stones.find(s => {
                    if (!s.active || s.color !== myColor) return false;
                    const dx = s.body.position.x - pos.x;
                    const dy = s.body.position.y - pos.y;
                    return Math.sqrt(dx * dx + dy * dy) < s.body.circleRadius;
                });
                
                if (clickedStone) {
                    e.preventDefault();
                    isDragging = true;
                    selectedStone = clickedStone;
                    dragStartPos = pos;
                    selectedStone.element.classList.add('selected');
                    powerIndicator.style.display = 'block';
                    Body.setVelocity(selectedStone.body, { x: 0, y: 0 });
                }
            };

            const handleMove = (e) => {
            if (!isDragging || !selectedStone) return;
            e.preventDefault();
            
            const pos = getEventPosition(e);
            const stonePos = selectedStone.body.position;
            const dx = stonePos.x - pos.x;
            const dy = stonePos.y - pos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = boardWidth * 0.35;
            const clampedDistance = Math.min(distance, maxDistance);
            
            const power = clampedDistance / maxDistance;
            powerFill.style.width = `${power * 100}%`;
            
            trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
            
            const angle = Math.atan2(dy, dx);
            const lineLength = clampedDistance * 2;
            const endX = stonePos.x + Math.cos(angle) * lineLength;
            const endY = stonePos.y + Math.sin(angle) * lineLength;
            
            // 1. [기존] 직접적인 궤적 (붉은색 화살표)
            trajectoryCtx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
            trajectoryCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
            trajectoryCtx.lineWidth = 5;
            trajectoryCtx.lineCap = 'round';
            
            trajectoryCtx.beginPath();
            trajectoryCtx.moveTo(stonePos.x, stonePos.y);
            trajectoryCtx.lineTo(endX, endY);
            trajectoryCtx.stroke();
            
            const arrowSize = 15;
            trajectoryCtx.beginPath();
            trajectoryCtx.moveTo(endX, endY);
            trajectoryCtx.lineTo(
                endX - arrowSize * Math.cos(angle - Math.PI / 6),
                endY - arrowSize * Math.sin(angle - Math.PI / 6)
            );
            trajectoryCtx.lineTo(
                endX - arrowSize * Math.cos(angle + Math.PI / 6),
                endY - arrowSize * Math.sin(angle + Math.PI / 6)
            );
            trajectoryCtx.closePath();
            trajectoryCtx.fill();

            // 2. [추가] 튕겨나갈 궤적 예측 (초록색 점선)
            drawRicochetPrediction(stonePos, angle);
        };

        // [추가] 튕겨나갈 궤적을 그리는 함수
        function drawRicochetPrediction(startPos, shootAngle) {
            const rayLength = boardWidth * 2;
            let closestCollision = { dist: Infinity, point: null, targetStone: null };

            // 모든 돌을 순회하며 가장 먼저 충돌할 돌을 찾음
            stones.forEach(targetStone => {
                if (!targetStone.active || targetStone.id === selectedStone.id) return;

                const distToStone = Vector.magnitude(Vector.sub(targetStone.body.position, startPos));
                const totalRadius = selectedStone.body.circleRadius + targetStone.body.circleRadius;

                const rayDir = { x: Math.cos(shootAngle), y: Math.sin(shootAngle) };
                const oc = Vector.sub(targetStone.body.position, startPos);
                const l2oc = Vector.dot(oc, oc);
                const tca = Vector.dot(oc, rayDir);
                if (tca < 0) return; // 돌이 뒤에 있으면 무시

                const d2 = l2oc - tca * tca;
                if (d2 > totalRadius * totalRadius) return; // 빗나감

                const thc = Math.sqrt(totalRadius * totalRadius - d2);
                const t0 = tca - thc;

                if (t0 < closestCollision.dist && t0 > 0) {
                    closestCollision.dist = t0;
                    closestCollision.point = Vector.add(startPos, Vector.mult(rayDir, t0));
                    closestCollision.targetStone = targetStone;
                }
            });

            // 충돌 지점을 찾았으면 반사 궤적을 그림
            if (closestCollision.targetStone) {
                const collisionPoint = closestCollision.point;
                const incidentVec = { x: Math.cos(shootAngle), y: Math.sin(shootAngle) };
                
                // 충돌 지점에서의 법선 벡터 (두 돌의 중심을 잇는 선)
                const normalVec = Vector.normalise(Vector.sub(collisionPoint, closestCollision.targetStone.body.position));

                // 반사 벡터 계산 (v' = v - 2 * (v . n) * n)
                const dot = Vector.dot(incidentVec, normalVec);
                const reflectVec = Vector.sub(incidentVec, Vector.mult(normalVec, 2 * dot));

                // 초록색 점선으로 그리기
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(collisionPoint.x, collisionPoint.y);
                trajectoryCtx.lineTo(
                    collisionPoint.x + reflectVec.x * 200,
                    collisionPoint.y + reflectVec.y * 200
                );
                trajectoryCtx.strokeStyle = 'rgba(30, 200, 100, 0.9)';
                trajectoryCtx.lineWidth = 4;
                trajectoryCtx.setLineDash([10, 10]); // 점선 설정
                trajectoryCtx.stroke();
                trajectoryCtx.setLineDash([]); // 점선 설정 해제
            }
        }

            const handleEnd = (e) => {
    if (!isDragging || !selectedStone) return;
    e.preventDefault();
    
    // [수정] 터치 종료 시 올바른 좌표를 얻도록 수정
    const rect = gameBoard.getBoundingClientRect();
    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
    const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
    const pos = {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
    // [수정 끝]

    const stonePos = selectedStone.body.position;
    const dx = stonePos.x - pos.x;
    const dy = stonePos.y - pos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 5) {
        const maxDistance = boardWidth * 0.5;
        const clampedDistance = Math.min(distance, maxDistance);
        const normalizedPower = clampedDistance / maxDistance;
        
        const basePower = 0.072;
        const forceMagnitude = basePower * Math.pow(normalizedPower, 0.8);
        
        const angle = Math.atan2(dy, dx);
        const force = {
            x: Math.cos(angle) * forceMagnitude,
            y: Math.sin(angle) * forceMagnitude
        };

        Body.applyForce(selectedStone.body, selectedStone.body.position, force);
        playSound('shoot-sound');
        hasShotThisTurn = true;
        canShoot = false;
        isFirstTurn = false;
        
        // ▼▼▼▼▼ 여기를 수정하세요 ▼▼▼▼▼
        // [수정] isHost 체크를 제거하여, 모든 플레이어가 자신의 움직임을 전송하도록 변경
        if (gameMode === 'multi' && roomRef) { 
            roomRef.child('lastMove').set({
                stoneId: selectedStone.id,
                forceX: force.x,
                forceY: force.y,
                playerId: myPlayerId, // [추가] 누가 쐈는지 식별하기 위한 ID 추가
                timestamp: Date.now()
            });
        }
        // ▲▲▲▲▲ 수정 종료 ▲▲▲▲▲
    }

    cleanup();
};

            const cleanup = () => {
                isDragging = false;
                dragStartPos = null;
                if (selectedStone) {
                    selectedStone.element.classList.remove('selected');
                }
                selectedStone = null;
                powerIndicator.style.display = 'none';
                powerFill.style.width = '0%';
                trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
            };

            gameBoard.addEventListener('mousedown', handleStart);
            gameBoard.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
            document.addEventListener('touchcancel', handleEnd);
        }

        function getEventPosition(e) {
            const rect = gameBoard.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // ▼▼▼▼▼ 아래 함수 전체를 새로 추가하세요 ▼▼▼▼▼
        function listenToMultiplayerEvents() {
            roomRef.on('value', snapshot => {
                currentRoomData = snapshot.val();
            });

            roomRef.child('gameStateSync').on('value', snapshot => {
                if (isHost || !snapshot.exists()) return;
                const serverState = snapshot.val();
                serverState.forEach(s_data => {
                    const stone = stones.find(s => s.id === s_data.id);
                    if (stone && stone.active) {
                        const newX = s_data.x_norm * boardWidth;
                        const newY = s_data.y_norm * boardHeight;
                        Body.setPosition(stone.body, { x: newX, y: newY });
                        Body.setVelocity(stone.body, { x: s_data.vx, y: s_data.vy });
                    }
                });
            });

            roomRef.child('stoneState').on('value', snapshot => {
                if (!snapshot.exists() || isHost) return;
                const stateData = snapshot.val();
                stateData.forEach(s_data => {
                    const stone = stones.find(s => s.id === s_data.id);
                    if (stone && stone.active) {
                        Body.setPosition(stone.body, { x: s_data.x, y: s_data.y });
                        Body.setVelocity(stone.body, { x: s_data.vx, y: s_data.vy });
                    }
                });
            });

            roomRef.child('currentTurn').on('value', snapshot => {
                if (!snapshot.exists()) return;
                const newTurnColor = snapshot.val();
                currentTurnColor = newTurnColor;
                isMyTurn = (currentTurnColor === myColor);
                canShoot = isMyTurn;
                updateHeaderUI();
            });

            roomRef.child('lastMove').on('value', snapshot => {
                if (!snapshot.exists() || isHost) return;
                const move = snapshot.val();
                if (move && move.playerId && move.playerId !== myPlayerId) {
                    const stone = stones.find(s => s.id === move.stoneId);
                    if (stone && stone.active) {
                        const force = { x: move.forceX, y: move.forceY };
                        Body.applyForce(stone.body, stone.body.position, force);
                        hasShotThisTurn = true;
                        canShoot = false;
                    }
                }
            });

            roomRef.child('removedStones').on('child_added', snapshot => {
                if (isHost) return;
                const stoneId = snapshot.key;
                const stone = stones.find(s => s.id === stoneId);
                if (stone && stone.active) {
                    removeStone(stone);
                }
            });

            roomRef.child('gameOver').on('value', snapshot => {
                if (!snapshot.exists()) return;
                const result = snapshot.val();
                if (result && result.winner) {
                    showGameOver(result.winner);
                }
            });

            roomRef.child('players').on('value', snapshot => {
                if (!snapshot.exists() || Object.keys(snapshot.val()).length < 2) {
                    if (!isGameOver) {
                        alert('상대방이 게임을 나갔습니다.');
                        window.location.href = 'index.html';
                    }
                }
            });

            // '다시하기' 요청을 감지하는 리스너
            roomRef.child('rematchRequests').on('value', snapshot => {
                if (!snapshot.exists() || !currentRoomData) return;
                const requests = snapshot.val();
                const requestCount = Object.keys(requests).length;
                const playerCount = Object.keys(currentRoomData.players).length;
                if (requestCount === playerCount) {
                    if (isHost) {
                        roomRef.update({
                            gameState: 'restarting',
                            rematchRequests: null, gameOver: null, lastMove: null,
                            placementStyle: null, placementChoices: null, removedStones: null,
                            stoneState: null, currentTurn: 'white'
                        });
                    }
                }
            });

            // 게임 재시작 신호를 감지하는 리스너
            roomRef.child('gameState').on('value', snapshot => {
                if (snapshot.val() === 'restarting') {
                    location.reload();
                }
            });
        }
// ▲▲▲▲▲ 코드 추가 종료 ▲▲▲▲▲


        function joinMultiplayerGame(roomId) {
            waitingOverlay.innerHTML = `<div class="modal-content"><div class="modal-body"><p style="margin-bottom: 20px; font-size: 1.3em;">게임에 참가하는 중...</p><div class="spinner"></div></div></div>`;
            waitingOverlay.style.display = 'flex';
            
            const gameRoomsRef = database.ref('memoryGameRooms');
            roomRef = gameRoomsRef.child(roomId);
            
            roomRef.once('value', snapshot => {
                if (!snapshot.exists()) {
                    alert('게임 방을 찾을 수 없습니다.');
                    window.location.href = '대기실.html';
                    return;
                }
                
                const roomData = snapshot.val();
                currentRoomData = roomData; // currentRoomData를 여기서 먼저 할당
                const players = Object.keys(roomData.players);
                
                isHost = (roomData.hostId === myPlayerId);
                myColor = isHost ? 'white' : 'black';
                opponentColor = isHost ? 'black' : 'white';
                
                const opponentId = players.find(id => id !== myPlayerId);
                if(opponentId) { // 상대방이 있을 때만 정보 설정
                    const opponentData = roomData.players[opponentId];
                    player1Info = isHost ? { nickname: myNickname, avatar: myAvatar } : { nickname: opponentData.nickname, avatar: opponentData.avatar };
                    player2Info = isHost ? { nickname: opponentData.nickname, avatar: opponentData.avatar } : { nickname: myNickname, avatar: myAvatar };
                } else { // 상대방이 아직 없을 경우 (오류 방지)
                     player1Info = { nickname: myNickname, avatar: myAvatar };
                     player2Info = { nickname: '대기중...', avatar: '❓' };
                }

                roomRef.child('players/' + myPlayerId).onDisconnect().remove();
                
                if (isHost) {
                     // 재시작 후를 대비해 gameState를 waiting으로 초기화
                    roomRef.update({ currentTurn: 'white', gameState: 'waiting' });
                }
                
                listenToMultiplayerEvents(); // 이벤트 리스너 함수 호출
                startCountdown('multi');
            });
        }

        function listenToMultiplayerEvents() {
            roomRef.on('value', snapshot => {
                currentRoomData = snapshot.val();
            });

                // 게스트가 방장의 '좌표 방송'을 수신하는 리스너
     roomRef.child('gameStateSync').on('value', snapshot => {
        // 방장이거나, 데이터가 없으면 실행하지 않음
        if (isHost || !snapshot.exists()) return;

        const serverState = snapshot.val();
        serverState.forEach(s_data => {
            const stone = stones.find(s => s.id === s_data.id);
            if (stone && stone.active) {
                // ▼▼▼▼▼ 여기를 수정하세요 ▼▼▼▼▼
                // 받은 비율 값에 나의 보드 크기를 곱해서 실제 위치를 계산합니다.
                const newX = s_data.x_norm * boardWidth;
                const newY = s_data.y_norm * boardHeight;

                // 물리 엔진을 직접 건드려 방장의 위치/속도와 강제로 동기화
                Body.setPosition(stone.body, { x: newX, y: newY });
                Body.setVelocity(stone.body, { x: s_data.vx, y: s_data.vy });
                // ▲▲▲▲▲ 수정 종료 ▲▲▲▲▲
            }
        });
    });



     // 턴 종료 시 방장이 보낸 최종 돌 상태를 수신하여 동기화하는 리스너입니다.
    roomRef.child('stoneState').on('value', snapshot => {
        // 방장이거나, 데이터가 없으면 실행하지 않습니다.
        if (!snapshot.exists() || isHost) return;
        
        const stateData = snapshot.val();
        stateData.forEach(s_data => {
            const stone = stones.find(s => s.id === s_data.id);
            if (stone && stone.active) {
                // 물리 엔진 객체의 위치와 속도를 방장이 보낸 값으로 강제 설정하여
                // 동기화 오류를 바로잡습니다.
                Body.setPosition(stone.body, { x: s_data.x, y: s_data.y });
                Body.setVelocity(stone.body, { x: s_data.vx, y: s_data.vy });
            }
        });
    });

           roomRef.child('currentTurn').on('value', snapshot => {
    if (!snapshot.exists()) return;
    const newTurnColor = snapshot.val();
    currentTurnColor = newTurnColor;
    isMyTurn = (currentTurnColor === myColor);

    canShoot = isMyTurn; // 내 턴일 때만 발사 가능하도록 명확하게 변경합니다.

    updateHeaderUI();
});

            roomRef.child('lastMove').on('value', snapshot => {
        if (!snapshot.exists() || !isHost) return; // 방장이 아니면 무시

        const move = snapshot.val();
        // 게스트가 보낸 움직임 정보를 받아서 방장의 물리 엔진에만 적용
        if (move && move.playerId && move.playerId !== myPlayerId) {
            const stone = stones.find(s => s.id === move.stoneId);
            if (stone && stone.active) {
                const force = { x: move.forceX, y: move.forceY };
                Body.applyForce(stone.body, stone.body.position, force);
                hasShotThisTurn = true;
                canShoot = false;
            }
        }
    });

            roomRef.child('removedStones').on('child_added', snapshot => {
                if (isHost) return;
                
                const stoneId = snapshot.key;
                const stone = stones.find(s => s.id === stoneId);
                if (stone && stone.active) {
                    removeStone(stone);
                }
            });

            roomRef.child('gameOver').on('value', snapshot => {
                if (!snapshot.exists()) return;
                const result = snapshot.val();
                if (result && result.winner) {
                    showGameOver(result.winner);
                }
            });

            roomRef.child('players').on('value', snapshot => {
                if (!snapshot.exists() || Object.keys(snapshot.val()).length < 2) {
                    if (!isGameOver) {
                        alert('상대방이 게임을 나갔습니다.');
                        window.location.href = 'index.html';
                    }
                }
            });
        }

        function updateHeaderUI() {
            const header = document.getElementById('game-header');
            header.innerHTML = '';

            const p1 = player1Info || { nickname: myNickname, avatar: myAvatar };
            const p2 = player2Info || opponentInfo;
            
            const p1Color = (gameMode === 'single' || isHost) ? 'white' : 'black';
            const p2Color = (gameMode === 'single' || isHost) ? 'black' : 'white';

      // P1은 항상 흰색, P2는 항상 검은색입니다.
    const p1Active = (currentTurnColor === 'white');
    const p2Active = (currentTurnColor === 'black');
            
            const p1Count = stones.filter(s => s.color === 'white' && s.active).length;
            const p2Count = stones.filter(s => s.color === 'black' && s.active).length;

            const avatarHTML1 = p1.avatar.startsWith('http') ? `<img src="${p1.avatar}" alt="avatar">` : p1.avatar;
            const avatarHTML2 = p2.avatar.startsWith('http') ? `<img src="${p2.avatar}" alt="avatar">` : p2.avatar;

            header.innerHTML = `
                <div class="player-info ${p1Active ? 'my-turn' : ''}">
                    <div class="avatar">${avatarHTML1}</div>
                    <div class="info-text">
                        <div class="nickname">${p1.nickname}</div>
                        <div class="stone-count">⚪ ${p1Count}개</div>
                    </div>
                </div>
                <div class="player-info ${p2Active ? 'my-turn' : ''}">
                    <div class="avatar">${avatarHTML2}</div>
                    <div class="info-text">
                        <div class="nickname">${p2.nickname}</div>
                        <div class="stone-count">⚫ ${p2Count}개</div>
                    </div>
                </div>
            `;
        }


        function showGameOver(winner) {
            if (isGameOver) return;
            isGameOver = true;

            const iWon = (winner === myColor);
            const resultText = iWon ? '🎉 승리!' : '😢 패배...';

            if (iWon) {
        playSound('win-sound');
    } else {
        playSound('loss-sound');
    }

            if (gameMode === 'multi' && roomRef && isHost) {
                roomRef.update({ 
                    gameOver: { 
                        winner: winner, 
                        timestamp: Date.now() 
                    } 
                });
            }

            if (gameMode === 'single' || (gameMode === 'multi' && !myPlayerId.startsWith('guest_'))) {
                updatePlayerStats(iWon);
            }

            gameOverOverlay.innerHTML = `
                <div class="modal-content">
                    <div id="game-over-message">${resultText}</div>
                    <div class="modal-buttons">
                        <button id="rematch-btn" class="menu-btn primary">다시 하기</button>
                        <button id="to-lobby-btn" class="menu-btn secondary">대기실로</button>
                        <button id="to-main-btn" class="menu-btn secondary">메인으로</button>
                    </div>
                </div>
            `;
            gameOverOverlay.style.display = 'flex';

            document.getElementById('rematch-btn').addEventListener('click', () => {
                location.reload();
            });
            document.getElementById('to-lobby-btn').addEventListener('click', () => {
                window.location.href = '대기실.html';
            });
            document.getElementById('to-main-btn').addEventListener('click', () => {
                sessionStorage.setItem('returnFromGame', 'true');
                window.location.href = 'index.html';
            });
        }

        function updatePlayerStats(won) {
            if (myPlayerId.startsWith('guest_')) return;

            playersStatsRef.child(myPlayerId).once('value', snapshot => {
                if (!snapshot.exists()) return;

                const userData = snapshot.val();
                const stats = userData.stats || {};
                
                if (!stats.alkkagi) {
                    stats.alkkagi = { wins: 0, losses: 0 };
                }

                if (won) {
                    stats.alkkagi.wins = (stats.alkkagi.wins || 0) + 1;
                    const newExp = (userData.exp || 0) + 50;
                    playersStatsRef.child(myPlayerId).update({ 
                        stats: stats,
                        exp: newExp
                    });
                } else {
                    stats.alkkagi.losses = (stats.alkkagi.losses || 0) + 1;
                    const newExp = (userData.exp || 0) + 10;
                    playersStatsRef.child(myPlayerId).update({ 
                        stats: stats,
                        exp: newExp
                    });
                }
            });
        }

        initialize();
    });
    </script>

    <audio id="game-start-sound" src="https://blog.kakaocdn.net/dna/vs7DN/dJMb9WFpvRs/AAAAAAAAAAAAAAAAAAAAAHJf1oqbiChuQiMUS_vcbEl2K6eaA6zzuosqQWk6d5E5/%EA%B2%8C%EC%9E%84%EC%8B%9C%EC%9E%91.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=EaapSJcpcP5OlE4ibx8C9NOU%2FkI%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="shoot-sound" src="https://blog.kakaocdn.net/dna/u8HMx/dJMb9OAFJEJ/AAAAAAAAAAAAAAAAAAAAAIqs8CjD3Mo8q0lPZ4p1BuoAVpWIP8fBfafJry8rMXni/%EC%95%8C%EA%B5%B4%EB%A6%AC%EB%8A%94%EC%86%8C%EB%A6%AC.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=NnUO7jp%2B7JkU35w00W9cS%2FB266M%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="success-sound" src="https://blog.kakaocdn.net/dna/crLSSK/dJMb8Y4jJZ6/AAAAAAAAAAAAAAAAAAAAAHSoWfFNw21Plu9ufn_jnmod1cp9rUDWubdEaHmSdsC0/%EC%95%8C%EA%B9%8C%EA%B8%B0%EC%84%B1%EA%B3%B5.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=mkf47bHt8yFioqWm6JBr8yiLKr0%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="win-sound" src="https://blog.kakaocdn.net/dna/kC4is/dJMb8WZJowA/AAAAAAAAAAAAAAAAAAAAAIQeZhVDJf0ZGAWyyMr_hsc6TMe3BFUVXd0FNTl5VDcY/%EA%B2%8C%EC%9E%84%EC%8A%B9%EB%A6%AC.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=qZKwGj5NQeAFNrOvCPAMXc6aX9I%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
<audio id="loss-sound" src="https://blog.kakaocdn.net/dna/Zqr4u/dJMb9V0NWlD/AAAAAAAAAAAAAAAAAAAAANQFEr99iVFS25T5ZW3Q2dixeZXsbUzh7OWB40uYQMu9/%EC%95%8C%EA%B9%8C%EA%B8%B0%ED%8C%A8%EB%B0%B0.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=2xNnbSadPzs2ZZi1BssfyCye8jI%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>

<div id="placement-modal" class="overlay" style="display: none;">
    <div class="modal-content" style="background: #5a4a42; max-width: 420px;">
        <div style="padding: 25px;">
            <h2 style="font-size: 1.8em; margin-bottom: 25px;">배치 스타일선택</h2>
            <div id="style-options-container" style="display: flex; gap: 20px; justify-content: center;">
                
                <div class="style-option" data-style="style1">
                    <div class="preview-board">
                        <div class="preview-stone white" style="top: 20%; left: 10%;"></div>
                        <div class="preview-stone white" style="top: 20%; left: 30%;"></div>
                        <div class="preview-stone white" style="top: 20%; left: 50%;"></div>
                        <div class="preview-stone white" style="top: 20%; left: 70%;"></div>
                        <div class="preview-stone white" style="top: 20%; left: 90%;"></div>
                    </div>
                    <h4>기본 배치</h4>
                </div>

                <div class="style-option" data-style="style2">
                    <div class="preview-board">
                        <div class="preview-stone white" style="top: 15%; left: 10%;"></div>
                        <div class="preview-stone white" style="top: 15%; left: 30%;"></div>
                        <div class="preview-stone white" style="top: 15%; left: 50%;"></div>
                        <div class="preview-stone white" style="top: 15%; left: 70%;"></div>
                        <div class="preview-stone white" style="top: 15%; left: 90%;"></div>
                        <div class="preview-stone white" style="top: 35%; left: 25%;"></div>
                        <div class="preview-stone white" style="top: 35%; left: 50%;"></div>
                        <div class="preview-stone white" style="top: 35%; left: 75%;"></div>
                    </div>
                    <h4>수비형 배치</h4>
                </div>

            </div>
            <p id="placement-waiting-text" style="margin-top: 20px; font-size: 1em; color: var(--accent-color); display: none;">상대방이 배치 스타일을 선택 중입니다...</p>
        </div>
    </div>
</div>

</body>
</html>
