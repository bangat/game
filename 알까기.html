<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>알까기</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #3d2f2b;
            --board-color: #e4b476;
            --border-color: #6a4a3a;
            --stone-white: #f5f5f5;
            --stone-black: #333;
            --shadow-color: rgba(0,0,0,0.2);
            --primary-color: #8d6e63;
            --accent-color: #ffab40;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: none;
        }
        .view {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .hidden { display: none !important; }

        .menu-btn {
            width: 90%; max-width: 320px; padding: 15px;
            font-size: 1.5em; font-weight: 700;
            font-family: 'GmarketSans', sans-serif;
            border-radius: 12px; border: none; cursor: pointer;
            margin: 10px 0; box-shadow: 0 5px 10px var(--shadow-color);
            transition: all 0.2s ease-out;
        }
        .menu-btn:active { transform: scale(0.97); }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #eee; color: #333; }
        .main-title {
            font-size: 3.5em; font-weight: 700; color: white;
            margin-bottom: 30px; text-shadow: 3px 3px 5px var(--shadow-color);
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: none; flex-direction: column;
        }
        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-around; align-items: center;
            padding: 15px 10px; background-color: rgba(0,0,0,0.3);
        }
        .player-info {
            display: flex; flex-direction: column;
            align-items: center; padding: 8px 15px;
            border-radius: 12px; transition: all 0.3s ease;
            background-color: rgba(255,255,255,0.1);
        }
        .player-info.my-turn {
            background-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 171, 64, 0.5);
        }
        .player-info.my-turn .nickname { color: black; }
        .player-info .avatar { font-size: 2em; }
        .player-info .avatar img {
            width: 40px; height: 40px;
            object-fit: contain; border-radius: 50%;
        }
        .player-info .nickname {
            font-weight: 700; margin-top: 5px; font-size: 1em;
        }
        .player-info .stone-count {
            font-size: 0.85em; opacity: 0.9; margin-top: 3px;
        }
        
        #game-container {
            width: 100%; flex-grow: 1;
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 20px 10px;
        }
        #game-board {
            position: relative; background-color: var(--board-color);
            border: 6px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 8px;
            background-image:
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
        }

        .stone {
            position: absolute; border-radius: 50%;
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 4px 8px rgba(0,0,0,0.4);
            display: flex; justify-content: center; align-items: center;
            font-weight: 700; transition: transform 0.1s ease;
            cursor: grab;
        }
        .stone:active { cursor: grabbing; }
        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #f5f5f5 50%, #e0e0e0);
        }
        .stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #333 50%, #222);
        }
        .stone.selected {
            transform: scale(1.15);
            box-shadow: 
                inset 0 -4px 8px rgba(0,0,0,0.3),
                inset 0 4px 8px rgba(255,255,255,0.3),
                0 0 20px rgba(255, 171, 64, 0.8),
                0 4px 12px rgba(0,0,0,0.5);
        }
        .stone.removed {
            transition: all 0.4s ease;
            transform: scale(0);
            opacity: 0;
        }
        
        #power-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 300px;
            height: 30px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 15px;
            overflow: hidden;
            display: none;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #power-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.05s linear;
            border-radius: 13px;
        }

        #trajectory-canvas {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            opacity: 0.85;
        }

        .overlay {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 200; text-align: center;
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 40px;
            border-radius: 25px;
            width: 90%; max-width: 380px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #game-over-message {
            font-size: 2.5em; font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .modal-buttons {
            display: flex; flex-direction: column;
            gap: 12px; align-items: center; margin-top: 25px;
        }
        #countdown-number {
            font-size: 8em; font-weight: 700;
            color: var(--accent-color);
            text-shadow: 0 0 30px rgba(255, 171, 64, 0.8);
            animation: countdown-pop 1s ease-in-out;
        }
        @keyframes countdown-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        .spinner { 
            margin: 20px auto; 
            border: 4px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; 
            border-top: 4px solid white; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
    </style>
</head>
<body>
    <div id="start-menu" class="view">
        <h1 class="main-title">알까기</h1>
        <button id="single-player-btn" class="menu-btn secondary">혼자 하기 (vs AI)</button>
        <button id="multiplayer-btn" class="menu-btn primary">같이 하기</button>
        <button id="back-to-index-btn" class="menu-btn secondary">메인으로</button>
    </div>

    <div id="game-wrapper" class="view">
        <div id="game-header"></div>
        <div id="game-container">
            <div id="game-board">
                <canvas id="trajectory-canvas"></canvas>
            </div>
            <div id="power-indicator">
                <div id="power-fill"></div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    <div id="waiting-overlay" class="overlay" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
            authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
            projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app",
            messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const playersStatsRef = database.ref('users');

        const startMenu = document.getElementById('start-menu');
        const gameWrapper = document.getElementById('game-wrapper');
        const gameContainer = document.getElementById('game-container');
        const gameBoard = document.getElementById('game-board');
        const trajectoryCanvas = document.getElementById('trajectory-canvas');
        const trajectoryCtx = trajectoryCanvas.getContext('2d');
        const powerIndicator = document.getElementById('power-indicator');
        const powerFill = document.getElementById('power-fill');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const waitingOverlay = document.getElementById('waiting-overlay');
        
        const { Engine, Render, Runner, World, Bodies, Body, Vector, Events } = Matter;

        let myPlayerId, myNickname, myAvatar;
        let engine, runner;
        let gameMode = null;
        let stones = [];
        let myColor = 'white';
        let opponentColor = 'black';
        let currentTurn = 'white';
        let isMyTurn = false;
        let isDragging = false;
        let selectedStone = null;
        let isGameOver = false;
        let boardSize = 0;
        let boardWidth = 0, boardHeight = 0;
        let roomRef = null;
        let dragStartPos = null;
        
        let opponentInfo = { id: 'ai', nickname: 'AI', avatar: '🤖' };

        function initialize() {
            myPlayerId = localStorage.getItem('myPlayerId');
            if (!myPlayerId) {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
                return;
            }
            myNickname = localStorage.getItem('userNickname') || 'Player';
            myAvatar = localStorage.getItem('userAvatar') || '😊';

            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            
            if (roomId) {
                startMenu.style.display = 'none';
                joinMultiplayerGame(roomId);
            } else {
                document.getElementById('single-player-btn').addEventListener('click', () => startCountdown('single'));
                document.getElementById('multiplayer-btn').addEventListener('click', () => { 
                    window.location.href = '대기실.html'; 
                });
                document.getElementById('back-to-index-btn').addEventListener('click', () => { 
                    window.location.href = 'index.html'; 
                });
            }
        }

        function startCountdown(mode) {
            gameMode = mode;
            startMenu.style.display = 'none';
            waitingOverlay.innerHTML = `<div id="countdown-number">3</div>`;
            waitingOverlay.style.display = 'flex';
            let count = 3;
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    waitingOverlay.innerHTML = `<div id="countdown-number">${count}</div>`;
                } else {
                    clearInterval(interval);
                    waitingOverlay.style.display = 'none';
                    if (gameMode === 'single') {
                        setupSinglePlayerGame();
                    } else if (gameMode === 'multi') {
                        setupMultiplayerGame();
                    }
                }
            }, 1000);
        }
        
        function setupGame() {
            isGameOver = false;
            gameWrapper.style.display = 'flex';
            
            const containerW = gameContainer.clientWidth;
            const containerH = gameContainer.clientHeight;
            boardWidth = Math.min(containerW * 0.92, 400);
            boardHeight = Math.min(containerH * 0.85, boardWidth * 1.6);
            
            gameBoard.style.width = `${boardWidth}px`;
            gameBoard.style.height = `${boardHeight}px`;
            gameBoard.style.backgroundSize = `${boardWidth / 10}px ${boardWidth / 10}px`;
            
            trajectoryCanvas.width = boardWidth;
            trajectoryCanvas.height = boardHeight;
            trajectoryCanvas.style.width = `${boardWidth}px`;
            trajectoryCanvas.style.height = `${boardHeight}px`;
            
            gameBoard.innerHTML = '';
            gameBoard.appendChild(trajectoryCanvas);

            engine = Engine.create({ gravity: { x: 0, y: 0 } });
            runner = Runner.create();
            
            const stoneSize = boardWidth / 12;
            stones = [];
            
            const wallThickness = 100;
            const walls = [
                Bodies.rectangle(boardWidth / 2, -wallThickness / 2, boardWidth + wallThickness * 2, wallThickness, { isStatic: true, label: 'wall' }),
                Bodies.rectangle(boardWidth / 2, boardHeight + wallThickness / 2, boardWidth + wallThickness * 2, wallThickness, { isStatic: true, label: 'wall' }),
                Bodies.rectangle(-wallThickness / 2, boardHeight / 2, wallThickness, boardHeight + wallThickness * 2, { isStatic: true, label: 'wall' }),
                Bodies.rectangle(boardWidth + wallThickness / 2, boardHeight / 2, wallThickness, boardHeight + wallThickness * 2, { isStatic: true, label: 'wall' })
            ];
            World.add(engine.world, walls);
            
            for (let i = 0; i < 8; i++) {
                createStone(boardWidth * 0.5 + (i - 3.5) * stoneSize * 1.1, boardHeight * 0.12, stoneSize, 'white', `white${i}`);
                createStone(boardWidth * 0.5 + (i - 3.5) * stoneSize * 1.1, boardHeight * 0.88, stoneSize, 'black', `black${i}`);
            }

            Runner.run(runner, engine);
            requestAnimationFrame(gameLoop);
            
            Events.on(engine, 'afterUpdate', checkMovementEnd);
            
            setupInputHandlers();
        }
        
        function setupSinglePlayerGame() {
            setupGame();
            updateHeaderUI();
            checkTurn();
        }

        function setupMultiplayerGame() {
            setupGame();
            updateHeaderUI();
            checkTurn();
        }

        function createStone(x, y, radius, color, id) {
            const body = Bodies.circle(x, y, radius / 2, {
                restitution: 0.85,
                friction: 0.005,
                frictionAir: 0.02,
                density: 0.01,
                mass: 1,
                label: id,
                inertia: Infinity
            });
            World.add(engine.world, body);

            const element = document.createElement('div');
            element.className = `stone ${color}`;
            element.id = id;
            element.style.width = `${radius}px`;
            element.style.height = `${radius}px`;
            gameBoard.appendChild(element);

            stones.push({ id, body, element, color, active: true });
        }

        function gameLoop() {
            if (isGameOver) return;
            
            stones.forEach(stone => {
                if (stone.active) {
                    const x = stone.body.position.x - stone.body.circleRadius;
                    const y = stone.body.position.y - stone.body.circleRadius;
                    stone.element.style.transform = `translate(${x}px, ${y}px)`;
                    
                    if (isOutOfBoard(stone.body.position)) {
                        removeStone(stone);
                    }
                }
            });
            
            requestAnimationFrame(gameLoop);
        }

        function isOutOfBoard(pos) {
            return pos.x < 0 || pos.x > boardWidth || 
                   pos.y < 0 || pos.y > boardHeight;
        }

        function removeStone(stone) {
            if (!stone.active) return;
            stone.active = false;
            stone.element.classList.add('removed');
            World.remove(engine.world, stone.body);
            setTimeout(() => {
                if (stone.element.parentNode) {
                    stone.element.remove();
                }
            }, 400);
        }

        function checkTurn() {
            isMyTurn = currentTurn === myColor;
            if (gameMode === 'single' && !isMyTurn) {
                setTimeout(aiMove, 800);
            }
            updateHeaderUI();
        }

        let movementCheckTimeout;
        let isCheckingMovement = false;
        
        function checkMovementEnd() {
            if (isCheckingMovement) return;
            
            clearTimeout(movementCheckTimeout);
            movementCheckTimeout = setTimeout(() => {
                const isMoving = stones.some(s => {
                    if (!s.active) return false;
                    const speed = Math.sqrt(
                        s.body.velocity.x * s.body.velocity.x + 
                        s.body.velocity.y * s.body.velocity.y
                    );
                    return speed > 0.15;
                });
                
                if (!isMoving && !isDragging) {
                    isCheckingMovement = true;
                    
                    const whiteStonesLeft = stones.filter(s => s.color === 'white' && s.active).length;
                    const blackStonesLeft = stones.filter(s => s.color === 'black' && s.active).length;

                    if (whiteStonesLeft === 0) {
                        showGameOver('black');
                    } else if (blackStonesLeft === 0) {
                        showGameOver('white');
                    } else {
                        endTurn();
                    }
                    
                    setTimeout(() => { isCheckingMovement = false; }, 100);
                }
            }, 800);
        }

        function endTurn() {
            currentTurn = (currentTurn === 'white') ? 'black' : 'white';
            
            if (gameMode === 'multi' && roomRef && isHost) {
                roomRef.update({ currentTurn: currentTurn });
            }
            
            checkTurn();
        }
        
        function setupInputHandlers() {
            const handleStart = (e) => {
                if (!isMyTurn || isGameOver) return;
                
                const isMoving = stones.some(s => {
                    if (!s.active) return false;
                    const speed = Math.sqrt(
                        s.body.velocity.x * s.body.velocity.x + 
                        s.body.velocity.y * s.body.velocity.y
                    );
                    return speed > 0.1;
                });
                
                if (isMoving) return;
                
                const pos = getEventPosition(e);
                const clickedStone = stones.find(s => {
                    if (!s.active || s.color !== currentTurn) return false;
                    const dx = s.body.position.x - pos.x;
                    const dy = s.body.position.y - pos.y;
                    return Math.sqrt(dx * dx + dy * dy) < s.body.circleRadius;
                });
                
                if (clickedStone) {
                    e.preventDefault();
                    isDragging = true;
                    selectedStone = clickedStone;
                    dragStartPos = pos;
                    selectedStone.element.classList.add('selected');
                    powerIndicator.style.display = 'block';
                    Body.setVelocity(selectedStone.body, { x: 0, y: 0 });
                }
            };

            const handleMove = (e) => {
                if (!isDragging || !selectedStone) return;
                e.preventDefault();
                
                const pos = getEventPosition(e);
                const stonePos = selectedStone.body.position;
                const dx = stonePos.x - pos.x;
                const dy = stonePos.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = boardWidth * 0.4;
                const clampedDistance = Math.min(distance, maxDistance);
                
                const power = clampedDistance / maxDistance;
                powerFill.style.width = `${power * 100}%`;
                
                trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
                
                const angle = Math.atan2(dy, dx);
                const lineLength = clampedDistance * 2;
                const endX = stonePos.x + Math.cos(angle) * lineLength;
                const endY = stonePos.y + Math.sin(angle) * lineLength;
                
                trajectoryCtx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                trajectoryCtx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                trajectoryCtx.lineWidth = 5;
                trajectoryCtx.lineCap = 'round';
                
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(stonePos.x, stonePos.y);
                trajectoryCtx.lineTo(endX, endY);
                trajectoryCtx.stroke();
                
                const arrowSize = 15;
                trajectoryCtx.beginPath();
                trajectoryCtx.moveTo(endX, endY);
                trajectoryCtx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                trajectoryCtx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                trajectoryCtx.closePath();
                trajectoryCtx.fill();
            };

            const handleEnd = (e) => {
                if (!isDragging || !selectedStone) return;
                e.preventDefault();
                
                const pos = getEventPosition(e);
                const stonePos = selectedStone.body.position;
                const dx = stonePos.x - pos.x;
                const dy = stonePos.y - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    const maxDistance = boardWidth * 0.4;
                    const clampedDistance = Math.min(distance, maxDistance);
                    const forceMagnitude = 0.008;
                    const power = clampedDistance * forceMagnitude;
                    
                    const angle = Math.atan2(dy, dx);
                    const force = {
                        x: Math.cos(angle) * power,
                        y: Math.sin(angle) * power
                    };

                    Body.applyForce(selectedStone.body, selectedStone.body.position, force);
                    
                    if (gameMode === 'multi' && roomRef) {
                        roomRef.child('lastMove').set({
                            stoneId: selectedStone.id,
                            force: force,
                            timestamp: Date.now()
                        });
                    }
                }

                cleanup();
            };

            const cleanup = () => {
                isDragging = false;
                dragStartPos = null;
                if (selectedStone) {
                    selectedStone.element.classList.remove('selected');
                }
                selectedStone = null;
                powerIndicator.style.display = 'none';
                powerFill.style.width = '0%';
                trajectoryCtx.clearRect(0, 0, boardWidth, boardHeight);
            };

            gameBoard.addEventListener('mousedown', handleStart);
            gameBoard.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
            document.addEventListener('touchcancel', handleEnd);
        }

        function getEventPosition(e) {
            const rect = gameBoard.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function aiMove() {
            if (isGameOver || isDragging) return;
            
            const aiStones = stones.filter(s => s.color === opponentColor && s.active);
            const targetStones = stones.filter(s => s.color === myColor && s.active);
            
            if (aiStones.length === 0 || targetStones.length === 0) return;

            setTimeout(() => {
                const shooter = aiStones[Math.floor(Math.random() * aiStones.length)];
                const target = targetStones[Math.floor(Math.random() * targetStones.length)];
                
                const dx = target.body.position.x - shooter.body.position.x;
                const dy = target.body.position.y - shooter.body.position.y;
                const angle = Math.atan2(dy, dx);
                
                const randomOffset = (Math.random() - 0.5) * 0.3;
                const finalAngle = angle + randomOffset;
                
                const power = (0.005 + Math.random() * 0.004);
                const force = {
                    x: Math.cos(finalAngle) * power,
                    y: Math.sin(finalAngle) * power
                };

                Body.applyForce(shooter.body, shooter.body.position, force);
            }, 500);
        }

        function updateHeaderUI() {
            const p1Info = myColor === 'white' ? 
                {nick: myNickname, avatar: myAvatar} : opponentInfo;
            const p2Info = myColor === 'black' ? 
                {nick: myNickname, avatar: myAvatar} : opponentInfo;

            const p1Count = stones.filter(s => s.color === 'white' && s.active).length;
            const p2Count = stones.filter(s => s.color === 'black' && s.active).length;

            const getAvatarHTML = (avatar) => 
                avatar.startsWith('http') ? `<img src="${avatar}">` : avatar;
            
            document.getElementById('game-header').innerHTML = `
                <div class="player-info ${currentTurn === 'white' ? 'my-turn' : ''}">
                    <div class="avatar">${getAvatarHTML(p1Info.avatar)}</div>
                    <div class="nickname">${p1Info.nick}</div>
                    <div class="stone-count">🔵 ${p1Count}개</div>
                </div>
                <div class="player-info ${currentTurn === 'black' ? 'my-turn' : ''}">
                    <div class="avatar">${getAvatarHTML(p2Info.avatar)}</div>
                    <div class="nickname">${p2Info.nick}</div>
                    <div class="stone-count">⚫ ${p2Count}개</div>
                </div>
            `;
        }

        function showGameOver(winnerColor) {
            if (isGameOver) return;
            isGameOver = true;
            
            if (runner) Runner.stop(runner);
            if (engine) Engine.clear(engine);

            const isWinner = winnerColor === myColor;
            let message = isWinner ? "🎉 승리! 🎉" : "😢 패배";
            
            gameOverOverlay.innerHTML = `
                <div class="modal-content">
                    <h2 id="game-over-message">${message}</h2>
                    <div class="modal-buttons">
                        <button id="rematch-btn" class="menu-btn primary">다시 하기</button>
                        <button id="exit-btn" class="menu-btn secondary">나가기</button>
                    </div>
                </div>
            `;
            gameOverOverlay.style.display = 'flex';

            document.getElementById('rematch-btn').addEventListener('click', () => {
                gameOverOverlay.style.display = 'none';
                gameBoard.innerHTML = '';
                stones = [];
                startCountdown(gameMode);
            });
            
            document.getElementById('exit-btn').addEventListener('click', () => {
                window.location.href = 'index.html';
            });

            updatePlayerStats(isWinner);
        }

        async function updatePlayerStats(isWinner) {
            if (!myPlayerId || myPlayerId.startsWith('guest_') || gameMode !== 'single') return;
            
            const playerStatRef = playersStatsRef.child(myPlayerId);
            try {
                await playerStatRef.transaction(currentData => {
                    if (currentData) {
                        if (!currentData.stats) currentData.stats = {};
                        if (!currentData.stats.alkkagiGame) {
                            currentData.stats.alkkagiGame = { wins: 0, losses: 0 };
                        }
                        
                        if (isWinner) {
                            currentData.stats.alkkagiGame.wins = 
                                (currentData.stats.alkkagiGame.wins || 0) + 1;
                            currentData.exp = (currentData.exp || 0) + 30;
                        } else {
                            currentData.stats.alkkagiGame.losses = 
                                (currentData.stats.alkkagiGame.losses || 0) + 1;
                            currentData.exp = (currentData.exp || 0) + 10;
                        }

                        let level = currentData.level || 1;
                        let expForNextLevel = level * 100;
                        while (currentData.exp >= expForNextLevel) {
                            level++;
                            currentData.exp -= expForNextLevel;
                            expForNextLevel = level * 100;
                        }
                        currentData.level = level;
                    }
                    return currentData;
                });
            } catch (error) {
                console.error("전적 업데이트 실패:", error);
            }
        }
        
        function joinMultiplayerGame(roomId) {
            gameMode = 'multi';
            cleanupOldRoomState();
            
            const gameRoomsRef = database.ref('memoryGameRooms');
            roomRef = gameRoomsRef.child(roomId);
            
            roomRef.once('value', snapshot => {
                if (!snapshot.exists()) {
                    alert("방을 찾을 수 없습니다.");
                    window.location.href = '대기실.html';
                    return;
                }
                
                const roomData = snapshot.val();
                const players = roomData.players || {};
                const playerIds = Object.keys(players);
                
                if (playerIds.length < 2) {
                    alert("상대방을 기다리는 중입니다...");
                    waitingOverlay.innerHTML = `
                        <div class="modal-content">
                            <h2 id="game-over-message">상대방 대기 중...</h2>
                            <div class="spinner"></div>
                        </div>
                    `;
                    waitingOverlay.style.display = 'flex';
                    
                    const checkInterval = setInterval(() => {
                        roomRef.once('value', snap => {
                            const data = snap.val();
                            if (data && data.players && Object.keys(data.players).length >= 2) {
                                clearInterval(checkInterval);
                                waitingOverlay.style.display = 'none';
                                setupMultiplayerGameData(data);
                            }
                        });
                    }, 1000);
                    return;
                }
                
                setupMultiplayerGameData(roomData);
            });
        }

        function setupMultiplayerGameData(roomData) {
            const players = roomData.players || {};
            const playerIds = Object.keys(players);
            
            myColor = roomData.hostId === myPlayerId ? 'white' : 'black';
            opponentColor = myColor === 'white' ? 'black' : 'white';
            
            const opponentId = playerIds.find(p => p !== myPlayerId);
            if (opponentId && players[opponentId]) {
                opponentInfo = {
                    id: opponentId,
                    nickname: players[opponentId].nickname,
                    avatar: players[opponentId].avatar
                };
            }
            
            if (roomData.hostId === myPlayerId) {
                roomRef.update({ 
                    currentTurn: 'white',
                    gameState: 'waiting'
                });
            }
            
            startCountdown('multi');
            listenToRoomChanges();
        }

        function cleanupOldRoomState() {
            if (roomRef) {
                roomRef.off();
                roomRef = null;
            }
        }

        function listenToRoomChanges() {
            if (!roomRef) return;
            
            roomRef.on('value', snapshot => {
                const roomData = snapshot.val();
                if (!roomData) {
                    alert("방이 종료되었습니다.");
                    window.location.href = 'index.html';
                    return;
                }
                
                if (roomData.gameState === 'ended') {
                    if (roomData.winner) {
                        showGameOver(roomData.winner);
                    }
                }
                
                if (roomData.currentTurn) {
                    currentTurn = roomData.currentTurn;
                    checkTurn();
                }
                
                if (roomData.lastMove && roomData.lastMove.timestamp > (window.lastMoveTime || 0)) {
                    window.lastMoveTime = roomData.lastMove.timestamp;
                    const move = roomData.lastMove;
                    const stone = stones.find(s => s.id === move.stoneId);
                    if (stone && stone.active) {
                        Body.applyForce(stone.body, stone.body.position, move.force);
                    }
                }
            });
        }

        initialize();
    });
    </script>
</body>
</html>
