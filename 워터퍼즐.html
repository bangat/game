<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>ÏõåÌÑ∞ ÌçºÏ¶ê</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
        }

        :root {
            --bg-color: #fffbeb;
            --panel-bg: #ffffff;
            --panel-border: #f0ead2;
            --panel-shadow: #e4dccf;
            --text-color-dark: #574141;
            --primary-color: #ff6b6b;
            --secondary-color: #4ecdc4;
            --accent-color: #ffd93d;
            --danger-color: #f76363;
            --glass-border: #a99b79;
            --glass-shadow: rgba(80, 57, 19, 0.16);
            --font-main: 'GmarketSans', sans-serif;
            --grid-gap: 10px;
            --bottle-width: 80px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            min-height: 100svh;
            overflow: hidden;
            overscroll-behavior: none;
            background: radial-gradient(circle at top, #fff7d7 0%, var(--bg-color) 60%);
            color: var(--text-color-dark);
            font-family: var(--font-main);
            touch-action: manipulation;
        }

        #app {
            width: 100%;
            height: 100%;
            min-height: 100dvh;
            max-width: 900px;
            margin: 0 auto;
            padding: calc(10px + env(safe-area-inset-top)) calc(10px + env(safe-area-inset-right)) calc(10px + env(safe-area-inset-bottom)) calc(10px + env(safe-area-inset-left));
            display: flex;
            flex-direction: column;
            gap: 8px;
            overscroll-behavior: none;
        }

        .top-bar {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 8px;
        }

        .title {
            text-align: center;
            font-size: clamp(1rem, 3.8vw, 1.35rem);
            font-weight: 700;
            letter-spacing: 0.01em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn {
            border: none;
            border-radius: 12px;
            padding: 9px 10px;
            font-size: clamp(0.78rem, 2.7vw, 0.92rem);
            font-family: var(--font-main);
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            border-bottom: 4px solid rgba(0, 0, 0, 0.18);
            transition: transform 0.08s ease;
            min-height: 40px;
            white-space: nowrap;
        }

        .btn:active {
            transform: translateY(2px);
            border-bottom-width: 2px;
        }

        .btn.primary { background: var(--primary-color); }
        .btn.secondary { background: var(--secondary-color); }
        .btn.warn { background: var(--danger-color); }

        .hidden {
            display: none !important;
        }

        .start-overlay {
            position: fixed;
            inset: 0;
            background: rgba(44, 37, 20, 0.46);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 90;
            padding: 14px;
        }

        .start-card {
            width: min(460px, 100%);
            background: #fffdf6;
            border: 3px solid var(--panel-border);
            border-radius: 16px;
            box-shadow: 0 8px 0 var(--panel-shadow);
            padding: 14px 12px;
            display: grid;
            gap: 10px;
            text-align: center;
        }

        .start-title {
            font-size: clamp(1rem, 3.8vw, 1.2rem);
            font-weight: 700;
        }

        .start-desc {
            font-size: clamp(0.8rem, 2.8vw, 0.9rem);
            color: #6f5a34;
            min-height: 1.1em;
        }

        .start-diff-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 7px;
        }

        .start-diff-btn {
            border: none;
            border-radius: 10px;
            padding: 8px 5px;
            font-family: var(--font-main);
            font-weight: 700;
            color: var(--text-color-dark);
            background: #f5f0dd;
            border-bottom: 3px solid #d5ccb2;
            min-height: 36px;
            cursor: pointer;
        }

        .start-diff-btn.active {
            background: var(--accent-color);
            border-bottom-color: #d5ab24;
        }

        .countdown-number {
            font-size: clamp(2.2rem, 14vw, 4.6rem);
            font-weight: 700;
            line-height: 1;
            color: #f76363;
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.14);
            min-height: 1em;
        }

        .multi-hud {
            background: var(--panel-bg);
            border: 3px solid var(--panel-border);
            border-radius: 14px;
            padding: 8px;
            box-shadow: 0 4px 0 var(--panel-shadow);
            display: grid;
            gap: 6px;
        }

        .multi-hud-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            font-size: clamp(0.74rem, 2.5vw, 0.86rem);
            font-weight: 700;
        }

        .player-strip {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
        }

        .player-card {
            border: 2px solid #e9e1c7;
            border-radius: 10px;
            background: #fffdf5;
            padding: 6px;
            display: grid;
            grid-template-columns: 34px 1fr;
            gap: 6px;
            min-height: 52px;
        }

        .player-card.me {
            border-color: #5ec2ba;
            background: #effaf8;
        }

        .player-avatar {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 2px solid #d8ceb2;
            background: #f4ecd4;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            font-size: 1.05rem;
            font-weight: 700;
        }

        .player-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .player-meta {
            min-width: 0;
        }

        .player-name {
            font-size: 0.78rem;
            font-weight: 700;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-sub {
            margin-top: 2px;
            font-size: 0.7rem;
            color: #6f5a34;
            display: flex;
            justify-content: space-between;
            gap: 4px;
            white-space: nowrap;
        }

        .multi-rank {
            display: none;
        }

        .rank-row {
            background: #fbf6e6;
            border: 1px solid #e7ddc2;
            border-radius: 8px;
            padding: 4px 6px;
            font-size: 0.72rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }

        .rank-row strong {
            font-size: 0.76rem;
        }

        .difficulty-wrap {
            background: var(--panel-bg);
            border: 3px solid var(--panel-border);
            border-radius: 14px;
            padding: 7px;
            box-shadow: 0 4px 0 var(--panel-shadow);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 7px;
        }

        .difficulty-btn {
            border: none;
            border-radius: 10px;
            padding: 8px 6px;
            font-size: clamp(0.82rem, 2.8vw, 0.92rem);
            font-family: var(--font-main);
            font-weight: 700;
            color: var(--text-color-dark);
            background: #f8f3df;
            border-bottom: 3px solid #d8d0b8;
            min-height: 38px;
            cursor: pointer;
            position: relative;
        }

        .difficulty-btn.active {
            background: var(--accent-color);
            border-bottom-color: #d5ab24;
        }

        .difficulty-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }

        .difficulty-btn.locked::after {
            content: 'üîí';
            position: absolute;
            top: 4px;
            right: 6px;
            font-size: 0.68rem;
        }

        .campaign-wrap {
            background: var(--panel-bg);
            border: 3px solid var(--panel-border);
            border-radius: 14px;
            padding: 9px 10px;
            box-shadow: 0 4px 0 var(--panel-shadow);
        }

        .campaign-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.84rem;
            font-weight: 700;
        }

        .progress-track {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: #ece4c7;
            overflow: hidden;
        }

        #campaign-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #67d2ca 0%, #3db8ad 100%);
            transition: width 0.25s ease;
        }

        .stats {
            background: var(--panel-bg);
            border: 3px solid var(--panel-border);
            border-radius: 14px;
            padding: 9px 8px;
            box-shadow: 0 4px 0 var(--panel-shadow);
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 4px;
            text-align: center;
            font-size: clamp(0.72rem, 2.5vw, 0.86rem);
        }

        .stat-value {
            margin-top: 3px;
            font-size: clamp(0.82rem, 3vw, 1rem);
            font-weight: 700;
            line-height: 1.2;
        }

        .message {
            min-height: 20px;
            text-align: center;
            font-size: clamp(0.78rem, 2.7vw, 0.9rem);
            font-weight: 700;
            color: #7a5c2f;
        }

        .message.win {
            color: #1f8f6a;
        }

        .message.warn {
            color: var(--danger-color);
        }

        .board-panel {
            flex: 1;
            background:
                radial-gradient(circle at 20% 16%, rgba(255, 255, 255, 0.85) 0%, rgba(255, 255, 255, 0) 60%),
                linear-gradient(180deg, #fffdf6 0%, #f9f5e7 100%);
            border: 3px solid var(--panel-border);
            border-radius: 16px;
            box-shadow: 0 6px 0 var(--panel-shadow);
            padding: 8px;
            overflow: hidden;
            min-height: 0;
            overscroll-behavior: none;
        }

        #board {
            --cols: 3;
            display: grid;
            grid-template-columns: repeat(var(--cols), minmax(0, 1fr));
            gap: var(--grid-gap);
            align-content: start;
            justify-items: center;
            width: 100%;
            height: 100%;
        }

        .bottle {
            width: min(100%, var(--bottle-width));
            min-width: 0;
            aspect-ratio: 0.5 / 1;
            border: 3px solid var(--glass-border);
            border-radius: 17px 17px 12px 12px;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.95) 0%, rgba(245, 236, 212, 0.82) 42%, rgba(236, 224, 194, 0.95) 100%);
            box-shadow:
                inset 0 0 0 2px rgba(255, 255, 255, 0.72),
                inset 0 -6px 12px rgba(255, 255, 255, 0.28),
                0 2px 0 rgba(0, 0, 0, 0.06),
                0 7px 12px var(--glass-shadow);
            padding: 15px 5px 5px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 3px;
            cursor: pointer;
            position: relative;
            transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease;
            overflow: visible;
        }

        .bottle::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            width: 50%;
            height: 12px;
            transform: translateX(-50%);
            border: 3px solid var(--glass-border);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            background: linear-gradient(180deg, #fffefb 0%, #f0e6ca 100%);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.72);
        }

        .bottle::after {
            content: '';
            position: absolute;
            left: 7px;
            top: 10px;
            width: 20%;
            height: calc(100% - 16px);
            border-radius: 14px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.78) 0%, rgba(255, 255, 255, 0.12) 100%);
            pointer-events: none;
        }

        .bottle.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.2);
            transform: translateY(-2px);
        }

        .bottle.shake {
            animation: shake 0.25s linear;
        }

        .slot {
            flex: 1;
            border-radius: 7px;
            background:
                linear-gradient(180deg, rgba(255, 255, 255, 0.38) 0%, rgba(233, 223, 191, 0.9) 100%);
            border: 1px solid rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }

        .slot.fill {
            border: none;
            box-shadow:
                inset 0 2px 0 rgba(255, 255, 255, 0.48),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .slot.fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 28%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0.02) 100%);
            pointer-events: none;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-3px); }
            40% { transform: translateX(3px); }
            60% { transform: translateX(-2px); }
            80% { transform: translateX(2px); }
        }

        .actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 7px;
        }

        .actions .btn {
            font-size: clamp(0.73rem, 2.55vw, 0.88rem);
            min-height: 38px;
            padding: 8px 6px;
        }

        @media (max-width: 430px) and (pointer: coarse) {
            #app {
                padding: calc(7px + env(safe-area-inset-top)) calc(7px + env(safe-area-inset-right)) calc(7px + env(safe-area-inset-bottom)) calc(7px + env(safe-area-inset-left));
                gap: 5px;
            }
            .top-bar { gap: 6px; }
            .title { font-size: clamp(0.88rem, 3.4vw, 1.08rem); }
            .btn {
                border-radius: 10px;
                padding: 6px 8px;
                min-height: 34px;
                border-bottom-width: 3px;
                font-size: clamp(0.72rem, 2.8vw, 0.84rem);
            }
            .multi-hud,
            .difficulty-wrap,
            .campaign-wrap,
            .stats {
                border-width: 2px;
                border-radius: 11px;
                box-shadow: 0 3px 0 var(--panel-shadow);
            }
            .multi-hud { padding: 6px; gap: 4px; }
            .player-card {
                min-height: 44px;
                padding: 4px;
                grid-template-columns: 28px 1fr;
                gap: 4px;
            }
            .player-avatar { width: 28px; height: 28px; }
            .player-name { font-size: 0.7rem; }
            .player-sub { font-size: 0.62rem; margin-top: 1px; }
            .difficulty-wrap { padding: 5px; gap: 5px; }
            .difficulty-btn {
                min-height: 32px;
                padding: 6px 4px;
                border-bottom-width: 2px;
                font-size: clamp(0.7rem, 2.7vw, 0.82rem);
            }
            .campaign-wrap { padding: 6px 8px; }
            .campaign-head {
                margin-bottom: 4px;
                font-size: 0.74rem;
            }
            .progress-track { height: 8px; }
            .stats {
                padding: 6px;
                gap: 2px;
                font-size: clamp(0.62rem, 2.2vw, 0.74rem);
            }
            .stat-value {
                margin-top: 1px;
                font-size: clamp(0.72rem, 2.7vw, 0.86rem);
            }
            .message {
                min-height: 14px;
                font-size: clamp(0.68rem, 2.4vw, 0.78rem);
            }
            .board-panel {
                border-width: 2px;
                border-radius: 12px;
                padding: 6px;
                box-shadow: 0 4px 0 var(--panel-shadow);
            }
            .actions { gap: 5px; }
            .actions .btn {
                min-height: 33px;
                padding: 6px 4px;
                font-size: clamp(0.68rem, 2.4vw, 0.8rem);
            }
        }

        @media (max-width: 370px) {
            #app { padding-left: 8px; padding-right: 8px; }
            :root { --grid-gap: 8px; }
            .board-panel { padding: 7px; }
            .player-card { min-height: 49px; padding: 5px; }
            .player-avatar { width: 30px; height: 30px; }
            .player-name { font-size: 0.72rem; }
            .player-sub { font-size: 0.66rem; }
            .bottle { border-width: 2.5px; padding-top: 13px; }
            .bottle::before { border-width: 2.5px; top: -9px; height: 11px; }
            .slot { border-radius: 6px; }
        }

        @media (min-width: 700px) {
            .board-panel { padding: 10px; }
            .bottle { border-width: 4px; }
            .bottle::before { border-width: 4px; }
        }

        @media (max-height: 760px) {
            #app { gap: 6px; }
            .campaign-wrap, .stats { padding-top: 7px; padding-bottom: 7px; }
            .multi-hud { padding-top: 6px; padding-bottom: 6px; }
            .message { min-height: 16px; }
            .actions .btn { min-height: 35px; padding-top: 6px; padding-bottom: 6px; }
        }

        @media (min-width: 640px) {
            .player-strip {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="top-bar">
            <button class="btn secondary" id="back-btn">ÎåÄÍ∏∞Ïã§</button>
            <div class="title">üß™ ÏõåÌÑ∞ ÌçºÏ¶ê</div>
            <button class="btn primary" id="new-btn">ÏÉà Í≤åÏûÑ</button>
        </div>

        <div id="multi-hud" class="multi-hud hidden">
            <div class="multi-hud-head">
                <span id="multi-mode-text">Î©ÄÌã∞ Î†àÏù¥Ïä§</span>
                <span id="multi-round-text">R0</span>
            </div>
            <div id="player-strip" class="player-strip"></div>
            <div id="multi-rank" class="multi-rank"></div>
        </div>

        <div class="difficulty-wrap">
            <button class="difficulty-btn active" data-diff="easy">Ï¥àÍ∏â</button>
            <button class="difficulty-btn" data-diff="normal">Ï§ëÍ∏â</button>
            <button class="difficulty-btn" data-diff="hard">Í≥†Í∏â</button>
        </div>

        <div class="campaign-wrap">
            <div class="campaign-head">
                <span id="campaign-text">Ï¥àÍ∏â 1/5</span>
                <span id="campaign-percent">0%</span>
            </div>
            <div class="progress-track">
                <div id="campaign-fill"></div>
            </div>
        </div>

        <div class="stats">
            <div>
                ÎÇúÏù¥ÎèÑ
                <div id="difficulty-label" class="stat-value">Ï¥àÍ∏â</div>
            </div>
            <div>
                Îã®Í≥Ñ
                <div id="stage-label" class="stat-value">1/5</div>
            </div>
            <div>
                Ïù¥Îèô ÌöüÏàò
                <div id="move-count" class="stat-value">0</div>
            </div>
            <div>
                ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ
                <div id="time-text" class="stat-value">00:00</div>
            </div>
        </div>

        <div id="message" class="message"></div>

        <div class="board-panel">
            <div id="board"></div>
        </div>

        <div class="actions">
            <button class="btn secondary" id="undo-btn">ÎêòÎèåÎ¶¨Í∏∞</button>
            <button class="btn warn" id="reset-btn">Ï≤òÏùåÎ∂ÄÌÑ∞</button>
        </div>
    </div>

    <div id="start-overlay" class="start-overlay hidden">
        <div class="start-card">
            <div id="start-title" class="start-title">ÎùºÏö¥Îìú Ï§ÄÎπÑ</div>
            <div id="start-desc" class="start-desc"></div>
            <div id="start-diff-grid" class="start-diff-grid">
                <button class="start-diff-btn active" data-diff="easy">Ï¥àÍ∏â</button>
                <button class="start-diff-btn" data-diff="normal">Ï§ëÍ∏â</button>
                <button class="start-diff-btn" data-diff="hard">Í≥†Í∏â</button>
            </div>
            <button id="start-go-btn" class="btn primary">ÎùºÏö¥Îìú ÏãúÏûë</button>
            <div id="countdown-number" class="countdown-number hidden">3</div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script>
        const CAPACITY = 4;
        const COLORS = [
            '#ff6b6b', '#4ecdc4', '#ffd93d', '#5f6cf8', '#8d6e63',
            '#ff8fab', '#7bd389', '#9b5de5', '#f8961e', '#2a9d8f'
        ];
        const PROGRESS_KEY = 'waterSortCampaignProgressV2';
        const DIFF_ORDER = ['easy', 'normal', 'hard'];
        const MAX_MULTI_PLAYERS = 4;
        const MULTI_GAME_KEY = 'waterPuzzle';
        const MULTI_RANK_POINTS = [10, 6, 4, 2];
        const MULTI_PROGRESS_INTERVAL_MS = 240;
        const roomIdFromUrl = new URLSearchParams(location.search).get('roomId');
        const isMultiplayerMode = !!roomIdFromUrl;

        const DIFFICULTY_META = {
            easy: { label: 'Ï¥àÍ∏â', colorCount: 4 },
            normal: { label: 'Ï§ëÍ∏â', colorCount: 5 },
            hard: { label: 'Í≥†Í∏â', colorCount: 6 }
        };
        const EMPTY_TUBES_BY_DIFF = {
            easy: 0,
            normal: 1,
            hard: 1
        };
        const SOLVABLE_BRANCH_RANGE_BY_DIFF = {
            normal: { min: 3, max: 4 },
            hard: { min: 1, max: 2 }
        };
        const OPENING_MOVE_RANGE_BY_DIFF = {
            easy: { min: 2, max: 4 },
            normal: { min: 5, max: 7 },
            hard: { min: 6, max: 8 }
        };
        const ROUND_TIME_LIMIT_BY_DIFF = {
            easy: 30,
            normal: 60,
            hard: 90
        };
        const UNDO_LIMIT_BY_DIFF = {
            easy: 3,
            normal: 2,
            hard: 1
        };
        const SFX_FILES = {
            select: 'Î¥ÑÎ≤ÑÎß®ÏÇ¨Ïö¥Îìú/Î≤ÑÌäºÌÅ¥Î¶≠.mp3',
            move: 'Î¥ÑÎ≤ÑÎß®ÏÇ¨Ïö¥Îìú/Ìå°Ïù¥ÏÉùÏÑ±.mp3',
            blocked: 'Î¥ÑÎ≤ÑÎß®ÏÇ¨Ïö¥Îìú/ÏÇ¨Ï≤úÏÑ±ÌãÄÎ¶º.mp3'
        };
        const sfxCache = new Map();

        // Ïà´Ïûê Í∞í: Î∞îÎã• -> Íº≠ÎåÄÍ∏∞ ÏàúÏÑú. ÏÉâÏÉÅ Îß§Ìïë/Î≥ë ÏàúÏÑú ÎûúÎç§ÌôîÌï¥ÎèÑ Ìï¥Îãµ Ï°¥Ïû¨.
        const LEVEL_PACKS = {
            easy: [
                [[3, 2, 3, 1], [1, 2, 1, 2], [1, 3, 0, 0], [2, 0, 0, 3], [], []],
                [[], [2, 2, 0, 3], [2, 0, 3, 3], [], [0, 1, 1, 1], [2, 0, 3, 1]],
                [[2, 0, 3, 1], [], [3, 1, 3, 2], [2, 0, 1, 2], [], [3, 1, 0, 0]],
                [[2, 2, 1, 2], [3, 1, 3, 0], [], [], [0, 1, 3, 0], [1, 3, 2, 0]],
                [[1, 2, 2, 1], [], [0, 2, 1, 3], [], [0, 1, 3, 2], [3, 0, 0, 3]]
            ],
            normal: [
                [[3, 3, 2, 1], [4, 0, 3, 1], [1, 2, 3, 4], [], [], [2, 4, 2, 1], [0, 0, 4, 0]],
                [[2, 0, 0, 1], [2, 4, 1, 3], [], [4, 1, 4, 3], [1, 0, 4, 2], [], [0, 3, 3, 2]],
                [[3, 2, 4, 3], [], [2, 3, 0, 0], [], [1, 1, 4, 4], [4, 0, 3, 2], [2, 1, 0, 1]],
                [[3, 1, 0, 1], [3, 2, 3, 4], [2, 4, 4, 0], [], [], [3, 4, 1, 2], [1, 2, 0, 0]],
                [[], [], [2, 3, 0, 0], [1, 2, 1, 2], [4, 3, 3, 0], [4, 4, 4, 2], [1, 0, 1, 3]]
            ],
            hard: [
                [[1, 1, 1, 0], [4, 5, 0, 0], [4, 2, 0, 2], [], [], [2, 1, 3, 3], [4, 5, 2, 5], [3, 5, 4, 3]],
                [[], [1, 5, 0, 1], [0, 5, 4, 3], [4, 4, 3, 5], [5, 2, 3, 1], [2, 2, 0, 3], [2, 0, 4, 1], []],
                [[5, 1, 4, 1], [], [0, 2, 0, 3], [2, 3, 4, 0], [1, 0, 5, 1], [], [5, 4, 2, 2], [4, 3, 3, 5]],
                [[], [0, 0, 1, 3], [5, 5, 1, 2], [2, 4, 5, 1], [2, 4, 4, 3], [5, 3, 3, 4], [0, 2, 1, 0], []],
                [[], [1, 2, 0, 3], [2, 3, 1, 4], [1, 3, 2, 4], [0, 1, 0, 4], [0, 5, 4, 2], [5, 3, 5, 5], []]
            ]
        };

        const boardEl = document.getElementById('board');
        const boardPanelEl = document.querySelector('.board-panel');
        const campaignWrapEl = document.querySelector('.campaign-wrap');
        const messageEl = document.getElementById('message');
        const moveCountEl = document.getElementById('move-count');
        const timeTextEl = document.getElementById('time-text');
        const diffLabelEl = document.getElementById('difficulty-label');
        const stageLabelEl = document.getElementById('stage-label');
        const campaignTextEl = document.getElementById('campaign-text');
        const campaignPercentEl = document.getElementById('campaign-percent');
        const campaignFillEl = document.getElementById('campaign-fill');
        const multiHudEl = document.getElementById('multi-hud');
        const multiModeTextEl = document.getElementById('multi-mode-text');
        const multiRoundTextEl = document.getElementById('multi-round-text');
        const playerStripEl = document.getElementById('player-strip');
        const multiRankEl = document.getElementById('multi-rank');
        const startOverlayEl = document.getElementById('start-overlay');
        const startTitleEl = document.getElementById('start-title');
        const startDescEl = document.getElementById('start-desc');
        const startDiffGridEl = document.getElementById('start-diff-grid');
        const startDiffButtons = Array.from(document.querySelectorAll('.start-diff-btn'));
        const startGoBtnEl = document.getElementById('start-go-btn');
        const countdownNumberEl = document.getElementById('countdown-number');
        const backBtn = document.getElementById('back-btn');
        const newBtn = document.getElementById('new-btn');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const difficultyButtons = Array.from(document.querySelectorAll('.difficulty-btn'));

        let difficulty = 'easy';
        let activeStageIndex = 0;
        let lastSelectedTemplate = null;

        let state = [];
        let initialState = [];
        let selectedIdx = -1;
        let moveCount = 0;
        let pouredCount = 0;
        let undoUsed = 0;
        let history = [];
        let solved = false;
        let startTime = 0;
        let roundTimeLimitSec = ROUND_TIME_LIMIT_BY_DIFF.easy;
        let roundDeadlineMs = 0;
        let timerId = null;
        let shakeTimer = null;
        let autoNextTimer = null;
        let resizeRaf = 0;

        let campaignProgress = loadCampaignProgress();
        let db = null;
        let auth = null;
        let roomRef = null;
        let roomDataCache = null;
        let multiState = null;
        let myUid = '';
        let myNick = 'User';
        let myAvatar = 'üôÇ';
        let isHost = false;
        let activeRoundToken = '';
        let finalizedRoundToken = '';
        let multiSolvedSubmitted = false;
        let multiLastProgressAt = 0;
        let countdownIntervalId = null;
        let countdownRoundToken = '';
        let promotedPlayingToken = '';
        const solvableTemplatePoolByDiff = {};

        function defaultCampaignProgress() {
            return {
                unlockedTier: 0,
                stageByDiff: { easy: 0, normal: 0, hard: 0 },
                allCleared: false
            };
        }

        function loadCampaignProgress() {
            try {
                const raw = localStorage.getItem(PROGRESS_KEY);
                if (!raw) return defaultCampaignProgress();
                const parsed = JSON.parse(raw);
                const base = defaultCampaignProgress();
                if (typeof parsed.unlockedTier === 'number') base.unlockedTier = Math.min(2, Math.max(0, parsed.unlockedTier));
                if (parsed.stageByDiff && typeof parsed.stageByDiff === 'object') {
                    DIFF_ORDER.forEach(diffKey => {
                        const max = LEVEL_PACKS[diffKey].length - 1;
                        const val = Number(parsed.stageByDiff[diffKey]);
                        base.stageByDiff[diffKey] = Number.isFinite(val) ? Math.min(max, Math.max(0, Math.floor(val))) : 0;
                    });
                }
                base.allCleared = !!parsed.allCleared;
                return base;
            } catch (e) {
                return defaultCampaignProgress();
            }
        }

        function saveCampaignProgress() {
            localStorage.setItem(PROGRESS_KEY, JSON.stringify(campaignProgress));
        }

        function cloneState(src) {
            return src.map(tube => tube.slice());
        }

        function normalizeTubeFromAny(tubeLike) {
            const src = Array.isArray(tubeLike)
                ? tubeLike
                : (tubeLike && typeof tubeLike === 'object'
                    ? Object.keys(tubeLike).sort((a, b) => Number(a) - Number(b)).map(k => tubeLike[k])
                    : []);
            return src
                .map(v => Number(v))
                .filter(v => Number.isFinite(v) && v >= 0)
                .slice(0, CAPACITY);
        }

        function serializePuzzleForDb(puzzle) {
            return puzzle.map(tube => {
                const fixed = new Array(CAPACITY).fill(-1);
                const src = normalizeTubeFromAny(tube);
                for (let i = 0; i < src.length; i++) fixed[i] = src[i];
                return fixed;
            });
        }

        function deserializePuzzleFromDb(rawPuzzle) {
            const list = Array.isArray(rawPuzzle)
                ? rawPuzzle
                : (rawPuzzle && typeof rawPuzzle === 'object'
                    ? Object.keys(rawPuzzle).sort((a, b) => Number(a) - Number(b)).map(k => rawPuzzle[k])
                    : []);
            return list.map(tube => normalizeTubeFromAny(tube));
        }

        function shuffleInPlace(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function topColor(tube) {
            return tube.length ? tube[tube.length - 1] : -1;
        }

        function topRunCount(tube) {
            if (!tube.length) return 0;
            const color = topColor(tube);
            let count = 1;
            for (let i = tube.length - 2; i >= 0; i--) {
                if (tube[i] !== color) break;
                count++;
            }
            return count;
        }

        function canPour(fromIdx, toIdx, nowState = state) {
            if (fromIdx === toIdx) return false;
            const fromTube = nowState[fromIdx];
            const toTube = nowState[toIdx];
            if (!fromTube || !toTube || fromTube.length === 0 || toTube.length >= CAPACITY) return false;
            const sourceColor = topColor(fromTube);
            const targetColor = topColor(toTube);
            if (targetColor !== -1 && sourceColor !== targetColor) return false;
            return true;
        }

        function pour(fromIdx, toIdx) {
            if (!canPour(fromIdx, toIdx)) return 0;
            const fromTube = state[fromIdx];
            const toTube = state[toIdx];
            const amount = Math.min(topRunCount(fromTube), CAPACITY - toTube.length);
            for (let i = 0; i < amount; i++) {
                toTube.push(fromTube.pop());
            }
            return amount;
        }

        function isTubeComplete(tube) {
            if (tube.length === 0) return true;
            if (tube.length !== CAPACITY) return false;
            return tube.every(color => color === tube[0]);
        }

        function checkWin(nowState = state) {
            return nowState.every(isTubeComplete);
        }

        function hasAnyMove(nowState = state) {
            for (let i = 0; i < nowState.length; i++) {
                for (let j = 0; j < nowState.length; j++) {
                    if (canPour(i, j, nowState)) return true;
                }
            }
            return false;
        }

        function countPossibleMoves(nowState = state) {
            let count = 0;
            for (let i = 0; i < nowState.length; i++) {
                for (let j = 0; j < nowState.length; j++) {
                    if (canPour(i, j, nowState)) count++;
                }
            }
            return count;
        }

        function formatTime(seconds) {
            const m = String(Math.floor(seconds / 60)).padStart(2, '0');
            const s = String(seconds % 60).padStart(2, '0');
            return `${m}:${s}`;
        }

        function computeCompletionPercent(nowState = state) {
            const completeCount = nowState.filter(tube => tube.length === CAPACITY && tube.every(c => c === tube[0])).length;
            const totalTargets = Math.max(1, DIFFICULTY_META[difficulty].colorCount);
            return Math.max(0, Math.min(100, Math.round((completeCount / totalTargets) * 100)));
        }

        function looksLikeImagePath(value) {
            if (typeof value !== 'string' || !value.trim()) return false;
            return /^https?:\/\//i.test(value)
                || /[\\/]/.test(value)
                || /\.(png|jpe?g|gif|webp|svg)$/i.test(value);
        }

        function escapeHtml(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/[&<>"']/g, ch => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            }[ch]));
        }

        function getParticipantIds(playersObj = {}) {
            const ids = Object.keys(playersObj);
            ids.sort((a, b) => {
                const pa = playersObj[a] || {};
                const pb = playersObj[b] || {};
                if (!!pa.isHost !== !!pb.isHost) return pa.isHost ? -1 : 1;
                return a.localeCompare(b);
            });
            return ids.slice(0, MAX_MULTI_PLAYERS);
        }

        function toParticipantMap(ids) {
            const map = {};
            ids.forEach(uid => { map[uid] = true; });
            return map;
        }

        function hasSameParticipants(existingMap, ids) {
            const currentIds = Object.keys(existingMap || {}).sort();
            const nextIds = [...ids].sort();
            if (currentIds.length !== nextIds.length) return false;
            return currentIds.every((uid, idx) => uid === nextIds[idx]);
        }

        function getRoundControllerUid(source = multiState) {
            const state = source || {};
            if (state.round >= 1 && state.chooserUid) return state.chooserUid;
            return (roomDataCache && roomDataCache.hostId) || '';
        }

        function canCurrentUserControlRound(source = multiState) {
            const controllerUid = getRoundControllerUid(source);
            return !!myUid && controllerUid === myUid;
        }

        function getRoundControllerNickname(playersObj, source = multiState) {
            const players = playersObj || ((roomDataCache && roomDataCache.players) || {});
            const controllerUid = getRoundControllerUid(source);
            if (!controllerUid) return '';
            return (players[controllerUid] && players[controllerUid].nickname) || '';
        }

        function getRoundTimeLimitSec(diffKey = difficulty) {
            return Number(ROUND_TIME_LIMIT_BY_DIFF[diffKey] || 60);
        }

        function getUndoLimit(diffKey = difficulty) {
            return Number(UNDO_LIMIT_BY_DIFF[diffKey] || 1);
        }

        function getStageCount(diffKey) {
            return LEVEL_PACKS[diffKey].length;
        }

        function getTotalStageCount() {
            return DIFF_ORDER.reduce((acc, diffKey) => acc + getStageCount(diffKey), 0);
        }

        function getClearedStageCount() {
            if (campaignProgress.allCleared) return getTotalStageCount();

            let cleared = 0;
            const unlocked = campaignProgress.unlockedTier;

            DIFF_ORDER.forEach((diffKey, idx) => {
                if (idx < unlocked) {
                    cleared += getStageCount(diffKey);
                } else if (idx === unlocked) {
                    cleared += campaignProgress.stageByDiff[diffKey];
                }
            });
            return cleared;
        }

        function updateDifficultyButtons() {
            if (isMultiplayerMode) {
                const canControl = canCurrentUserControlRound();
                const isLockedByStatus = !!(multiState && (multiState.status === 'playing' || multiState.status === 'starting'));
                difficultyButtons.forEach(btn => {
                    btn.disabled = !canControl || isLockedByStatus;
                    btn.classList.remove('locked');
                    btn.classList.toggle('active', btn.dataset.diff === difficulty);
                });
                syncStartDiffButtons();
                return;
            }

            difficultyButtons.forEach(btn => {
                const idx = DIFF_ORDER.indexOf(btn.dataset.diff);
                const locked = idx > campaignProgress.unlockedTier;
                btn.disabled = locked;
                btn.classList.toggle('locked', locked);
                btn.classList.toggle('active', btn.dataset.diff === difficulty);
            });
            syncStartDiffButtons();
        }

        function updateNewButtonLabel() {
            if (!isMultiplayerMode) {
                newBtn.disabled = false;
                newBtn.textContent = 'ÏÉà Í≤åÏûÑ';
                return;
            }
            const canControl = canCurrentUserControlRound();
            const controllerName = getRoundControllerNickname();
            if (canControl) {
                newBtn.disabled = !!(multiState && (multiState.status === 'playing' || multiState.status === 'starting'));
                newBtn.textContent = (multiState && multiState.status === 'playing') ? 'ÎùºÏö¥Îìú Ïû¨ÏãúÏûë' : 'ÏÉà ÎùºÏö¥Îìú';
            } else {
                newBtn.disabled = true;
                newBtn.textContent = controllerName ? `${controllerName} ÏãúÏûë ÎåÄÍ∏∞` : 'ÏãúÏûë ÎåÄÍ∏∞';
            }
        }

        function updateCampaignUI() {
            if (isMultiplayerMode) {
                campaignWrapEl.classList.add('hidden');
                updateDifficultyButtons();
                return;
            }
            campaignWrapEl.classList.remove('hidden');
            const total = getTotalStageCount();
            const cleared = getClearedStageCount();
            const pct = Math.round((cleared / total) * 100);

            campaignFillEl.style.width = `${pct}%`;
            campaignPercentEl.textContent = `${pct}%`;
            campaignTextEl.textContent = `${DIFFICULTY_META[difficulty].label} ${activeStageIndex + 1}/${getStageCount(difficulty)}`;
            updateDifficultyButtons();
        }

        function updateStats() {
            moveCountEl.textContent = String(moveCount);
            diffLabelEl.textContent = DIFFICULTY_META[difficulty].label;
            stageLabelEl.textContent = isMultiplayerMode
                ? `R${(multiState && multiState.round) || 0}`
                : `${activeStageIndex + 1}/${getStageCount(difficulty)}`;
            const undoLimit = getUndoLimit();
            const undoRemain = Math.max(0, undoLimit - undoUsed);
            const canUndo = history.length > 0 && undoRemain > 0 && !solved;
            undoBtn.textContent = `ÎêòÎèåÎ¶¨Í∏∞ ${undoRemain}`;
            undoBtn.disabled = !canUndo;
            undoBtn.style.opacity = canUndo ? '1' : '0.6';
            updateCampaignUI();
            updateNewButtonLabel();
        }

        function tickTime() {
            if (solved) return;
            const remainSec = Math.max(0, Math.ceil((roundDeadlineMs - Date.now()) / 1000));
            timeTextEl.textContent = formatTime(remainSec);
            if (remainSec <= 0) {
                handleRoundTimeout();
            }
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            tickTime();
            timerId = setInterval(tickTime, 1000);
        }

        function setMessage(text, kind = '') {
            messageEl.textContent = text;
            messageEl.classList.remove('win', 'warn');
            if (kind) messageEl.classList.add(kind);
        }

        function syncStartDiffButtons() {
            const canControl = canCurrentUserControlRound();
            const lockedByStatus = !!(multiState && (multiState.status === 'playing' || multiState.status === 'starting'));
            startDiffButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.diff === difficulty);
                btn.disabled = isMultiplayerMode && (!canControl || lockedByStatus);
            });
        }

        function hideStartOverlay() {
            startOverlayEl.classList.add('hidden');
            startDiffGridEl.classList.remove('hidden');
            startGoBtnEl.classList.remove('hidden');
            countdownNumberEl.classList.add('hidden');
            if (countdownIntervalId) {
                clearInterval(countdownIntervalId);
                countdownIntervalId = null;
            }
            countdownRoundToken = '';
        }

        function showWaitingOverlay() {
            if (!isMultiplayerMode) return;
            const controllerName = getRoundControllerNickname();
            const canControl = canCurrentUserControlRound();
            startOverlayEl.classList.remove('hidden');
            startTitleEl.textContent = 'ÎùºÏö¥Îìú Ï§ÄÎπÑ';
            startDescEl.textContent = canControl
                ? 'ÎÇúÏù¥ÎèÑÎ•º ÏÑ†ÌÉùÌïòÍ≥† ÏãúÏûë Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.'
                : `${controllerName || 'ÏßÄÏ†ïÎêú ÌîåÎ†àÏù¥Ïñ¥'}Í∞Ä ÎÇúÏù¥ÎèÑÎ•º Í≥†Î•¥Í≥† ÏãúÏûëÌï©ÎãàÎã§.`;
            startDiffGridEl.classList.remove('hidden');
            countdownNumberEl.classList.add('hidden');
            startGoBtnEl.classList.toggle('hidden', !canControl);
            startGoBtnEl.disabled = !canControl;
            syncStartDiffButtons();
        }

        function showCountdownOverlay(water) {
            if (!isMultiplayerMode || !water) return;
            startOverlayEl.classList.remove('hidden');
            startTitleEl.textContent = `${DIFFICULTY_META[difficulty].label} ÎùºÏö¥Îìú ÏãúÏûë`;
            startDescEl.textContent = 'Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎèôÏãúÏóê ÏãúÏûëÌï©ÎãàÎã§.';
            startDiffGridEl.classList.add('hidden');
            startGoBtnEl.classList.add('hidden');
            countdownNumberEl.classList.remove('hidden');

            const startAt = Number(water.countdownStartAt || Date.now());
            const durationMs = Number(water.countdownDurationMs || 3000);

            const tick = () => {
                const remainMs = (startAt + durationMs) - Date.now();
                if (remainMs <= 0) countdownNumberEl.textContent = 'GO';
                else countdownNumberEl.textContent = String(Math.max(1, Math.ceil(remainMs / 1000)));

                if (isHost && remainMs <= 0 && promotedPlayingToken !== water.roundToken) {
                    promotedPlayingToken = water.roundToken;
                    roomRef.child(`gameData/${MULTI_GAME_KEY}/status`).transaction(v => (v === 'starting' ? 'playing' : v));
                    roomRef.child(`gameData/${MULTI_GAME_KEY}/updatedAt`).set(firebase.database.ServerValue.TIMESTAMP);
                }
            };

            if (countdownRoundToken !== water.roundToken) {
                if (countdownIntervalId) clearInterval(countdownIntervalId);
                countdownRoundToken = water.roundToken || '';
                countdownIntervalId = setInterval(tick, 120);
            }
            tick();
        }

        function playSfx(type, volume = 0.3) {
            const src = SFX_FILES[type];
            if (!src) return;
            let audio = sfxCache.get(type);
            if (!audio) {
                audio = new Audio(src);
                audio.preload = 'auto';
                sfxCache.set(type, audio);
            }
            audio.currentTime = 0;
            audio.volume = volume;
            audio.play().catch(() => {});
        }

        function getBoardInnerWidth() {
            if (!boardPanelEl) return Math.max(180, window.innerWidth - 16);
            const styles = window.getComputedStyle(boardPanelEl);
            const panelWidth = boardPanelEl.getBoundingClientRect().width;
            const paddingX = (parseFloat(styles.paddingLeft) || 0) + (parseFloat(styles.paddingRight) || 0);
            return Math.max(180, Math.floor(panelWidth - paddingX - 1));
        }

        function getBoardInnerHeight() {
            if (!boardPanelEl) {
                const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                return Math.max(120, Math.floor(vh * 0.44));
            }
            const styles = window.getComputedStyle(boardPanelEl);
            const panelHeight = boardPanelEl.getBoundingClientRect().height;
            const paddingY = (parseFloat(styles.paddingTop) || 0) + (parseFloat(styles.paddingBottom) || 0);
            return Math.max(120, Math.floor(panelHeight - paddingY - 1));
        }

        function computeAdaptiveLayout(count) {
            const tubeCount = Math.max(1, Number(count) || 1);
            const viewportWidth = Math.max(180, window.visualViewport ? window.visualViewport.width : window.innerWidth);
            const width = Math.max(180, Math.min(getBoardInnerWidth(), viewportWidth - 8));
            const height = getBoardInnerHeight();
            const gap = viewportWidth <= 350 ? 6 : viewportWidth <= 430 ? 8 : 10;
            const maxBottleWidth = viewportWidth <= 430 ? 74 : 92;
            const baseCols = tubeCount <= 6 ? 3 : tubeCount <= 8 ? 4 : 5;
            const maxCols = Math.max(2, Math.min(tubeCount, tubeCount <= 6 ? 4 : tubeCount <= 8 ? 5 : 6));

            let best = null;
            for (let cols = 2; cols <= maxCols; cols++) {
                const rows = Math.ceil(tubeCount / cols);
                const cellWidth = (width - gap * (cols - 1)) / cols;
                const rowHeight = (height - gap * (rows - 1)) / rows;
                if (cellWidth <= 0 || rowHeight <= 0) continue;

                const safeBottleHeight = Math.max(44, rowHeight - 12);
                const bottleWidth = Math.floor(Math.min(cellWidth, safeBottleHeight * 0.5, maxBottleWidth));
                if (bottleWidth <= 0) continue;

                const score = bottleWidth - (Math.abs(cols - baseCols) * 1.2);
                if (!best || score > best.score) {
                    best = { cols, gap, bottleWidth, score };
                }
            }

            if (!best) {
                const cols = Math.max(2, Math.min(baseCols, tubeCount));
                const fallbackCell = (width - gap * (cols - 1)) / cols;
                return {
                    cols,
                    gap,
                    bottleWidth: Math.max(22, Math.floor(Math.min(fallbackCell, maxBottleWidth)))
                };
            }

            return {
                cols: best.cols,
                gap: best.gap,
                bottleWidth: Math.max(22, best.bottleWidth)
            };
        }

        function renderBoard() {
            boardEl.dataset.diff = difficulty;
            const layout = computeAdaptiveLayout(state.length);
            boardEl.style.setProperty('--cols', String(layout.cols));
            boardEl.style.setProperty('--grid-gap', `${layout.gap}px`);
            boardEl.style.setProperty('--bottle-width', `${layout.bottleWidth}px`);
            boardEl.innerHTML = '';

            state.forEach((tube, idx) => {
                const bottleBtn = document.createElement('button');
                bottleBtn.type = 'button';
                bottleBtn.className = 'bottle';
                if (idx === selectedIdx) bottleBtn.classList.add('selected');
                bottleBtn.dataset.index = String(idx);

                for (let level = CAPACITY - 1; level >= 0; level--) {
                    const slot = document.createElement('div');
                    slot.className = 'slot';
                    if (tube[level] !== undefined) {
                        slot.classList.add('fill');
                        const color = COLORS[tube[level] % COLORS.length];
                        slot.style.background = `linear-gradient(180deg, rgba(255, 255, 255, 0.44) 0%, ${color} 40%, ${color} 100%)`;
                    }
                    bottleBtn.appendChild(slot);
                }

                bottleBtn.addEventListener('click', () => onBottleTap(idx));
                boardEl.appendChild(bottleBtn);
            });
        }

        function shakeBottle(idx) {
            const bottle = boardEl.querySelector(`.bottle[data-index="${idx}"]`);
            if (!bottle) return;
            bottle.classList.remove('shake');
            void bottle.offsetWidth;
            bottle.classList.add('shake');
            if (shakeTimer) clearTimeout(shakeTimer);
            shakeTimer = setTimeout(() => bottle.classList.remove('shake'), 260);
        }

        function onBottleTap(idx) {
            if (solved) return;

            if (selectedIdx === -1) {
                if (state[idx].length === 0) return;
                selectedIdx = idx;
                playSfx('select', 0.2);
                renderBoard();
                return;
            }

            if (selectedIdx === idx) {
                selectedIdx = -1;
                renderBoard();
                return;
            }

            if (!canPour(selectedIdx, idx)) {
                shakeBottle(idx);
                playSfx('blocked', 0.22);
                setMessage('Ïó¨Í∏∞Î°úÎäî ÏòÆÍ∏∏ Ïàò ÏóÜÏñ¥Ïöî.', 'warn');
                return;
            }

            history.push({
                state: cloneState(state),
                pouredCount
            });
            const moved = pour(selectedIdx, idx);
            selectedIdx = -1;

            if (moved <= 0) return;

            moveCount++;
            pouredCount += moved;
            playSfx('move', 0.24);
            updateStats();
            renderBoard();
            if (isMultiplayerMode) pushMultiplayerProgress(false);

            if (checkWin()) {
                handleRoundClear();
                return;
            }

            if (!hasAnyMove()) {
                if (!autoReshuffleIfDeadlocked()) {
                    setMessage('ÎßµÌòîÏñ¥Ïöî. "ÎêòÎèåÎ¶¨Í∏∞" ÎòêÎäî "Ï≤òÏùåÎ∂ÄÌÑ∞"Î•º ÎàåÎü¨Î≥¥ÏÑ∏Ïöî.', 'warn');
                }
            } else {
                setMessage('');
            }
        }

        function scheduleResponsiveRender() {
            if (!state.length) return;
            if (resizeRaf) cancelAnimationFrame(resizeRaf);
            resizeRaf = requestAnimationFrame(() => {
                resizeRaf = 0;
                renderBoard();
            });
        }

        function normalizeTemplateToTargetEmptyCount(rawTemplate, targetEmptyCount) {
            const source = Array.isArray(rawTemplate) ? rawTemplate : [];
            const nonEmpty = source
                .map(tube => normalizeTubeFromAny(tube))
                .filter(tube => tube.length > 0);
            const out = nonEmpty.map(tube => tube.slice());
            const safeTarget = Math.max(0, Number(targetEmptyCount || 0));
            for (let i = 0; i < safeTarget; i++) out.push([]);
            return out;
        }

        function encodeStateCanonical(nowState) {
            const tubes = nowState.map(tube => tube.join(','));
            tubes.sort();
            return tubes.join('|');
        }

        function pourOnState(nowState, fromIdx, toIdx) {
            if (!canPour(fromIdx, toIdx, nowState)) return null;
            const next = cloneState(nowState);
            const fromTube = next[fromIdx];
            const toTube = next[toIdx];
            const amount = Math.min(topRunCount(fromTube), CAPACITY - toTube.length);
            for (let i = 0; i < amount; i++) toTube.push(fromTube.pop());
            return next;
        }

        function isPuzzleSolvableBySearch(initialState, maxVisited = 160000) {
            if (checkWin(initialState)) return true;
            const seen = new Set();
            const stack = [{ board: cloneState(initialState), lastFrom: -1, lastTo: -1 }];

            while (stack.length) {
                const cur = stack.pop();
                const key = encodeStateCanonical(cur.board);
                if (seen.has(key)) continue;
                seen.add(key);
                if (seen.size > maxVisited) return false;
                if (checkWin(cur.board)) return true;

                for (let i = 0; i < cur.board.length; i++) {
                    for (let j = 0; j < cur.board.length; j++) {
                        if (!canPour(i, j, cur.board)) continue;
                        if (cur.lastFrom === j && cur.lastTo === i) continue;
                        const fromTube = cur.board[i];
                        const toTube = cur.board[j];
                        if (toTube.length === 0 && isTubeComplete(fromTube)) continue;
                        const next = pourOnState(cur.board, i, j);
                        if (!next) continue;
                        stack.push({ board: next, lastFrom: i, lastTo: j });
                    }
                }
            }
            return false;
        }

        function countSolvableOpeningBranches(puzzleState) {
            let count = 0;
            for (let i = 0; i < puzzleState.length; i++) {
                for (let j = 0; j < puzzleState.length; j++) {
                    if (!canPour(i, j, puzzleState)) continue;
                    const next = pourOnState(puzzleState, i, j);
                    if (!next) continue;
                    if (isPuzzleSolvableBySearch(next, 120000)) count++;
                }
            }
            return count;
        }

        // Convert a 1-empty solvable puzzle into a 0-empty solvable start.
        // We do a reversible reverse-split (amount < top run), so a valid solve path is preserved.
        function buildNoEmptyVariantFromOneEmpty(baseState) {
            const emptyIdx = baseState.findIndex(tube => tube.length === 0);
            if (emptyIdx < 0) return cloneState(baseState);
            const candidates = [];

            for (let fromIdx = 0; fromIdx < baseState.length; fromIdx++) {
                if (fromIdx === emptyIdx) continue;
                const src = baseState[fromIdx];
                const run = topRunCount(src);
                if (run < 2) continue;
                const maxAmount = Math.min(run - 1, CAPACITY);
                for (let amount = 1; amount <= maxAmount; amount++) {
                    const next = cloneState(baseState);
                    const fromTube = next[fromIdx];
                    const toTube = next[emptyIdx];
                    for (let i = 0; i < amount; i++) toTube.push(fromTube.pop());
                    if (next.some(tube => tube.length === 0)) continue;
                    if (!hasAnyMove(next)) continue;
                    candidates.push(next);
                }
            }

            if (!candidates.length) return null;
            return cloneState(candidates[Math.floor(Math.random() * candidates.length)]);
        }

        function getSolvableTemplatePool(diffKey) {
            if (solvableTemplatePoolByDiff[diffKey]) return solvableTemplatePoolByDiff[diffKey];
            const targetEmptyCount = Math.max(0, Number(EMPTY_TUBES_BY_DIFF[diffKey] || 0));
            const seedEmptyCount = targetEmptyCount === 0 ? 1 : targetEmptyCount;
            const templates = LEVEL_PACKS[diffKey] || [];
            const solvablePool = [];
            const filteredPool = [];
            const branchRange = SOLVABLE_BRANCH_RANGE_BY_DIFF[diffKey];

            templates.forEach((rawTemplate, sourceIndex) => {
                const candidate = normalizeTemplateToTargetEmptyCount(rawTemplate, seedEmptyCount);
                if (!hasAnyMove(candidate)) return;
                if (!isPuzzleSolvableBySearch(candidate)) return;
                if (targetEmptyCount === 0 && !buildNoEmptyVariantFromOneEmpty(candidate)) return;
                const entry = {
                    sourceIndex,
                    tubes: candidate
                };
                solvablePool.push(entry);

                if (!branchRange) {
                    filteredPool.push(entry);
                    return;
                }
                const branches = countSolvableOpeningBranches(candidate);
                if (branches >= branchRange.min && branches <= branchRange.max) {
                    filteredPool.push(entry);
                }
            });

            const pool = filteredPool.length ? filteredPool : solvablePool;

            if (!pool.length) {
                const fallbackRaw = templates[0] || [];
                pool.push({
                    sourceIndex: 0,
                    tubes: normalizeTemplateToTargetEmptyCount(fallbackRaw, seedEmptyCount)
                });
            }

            solvableTemplatePoolByDiff[diffKey] = pool;
            return pool;
        }

        function buildTemplateWithDifficultyEmptyTubes(diffKey, templateIndex) {
            const pool = getSolvableTemplatePool(diffKey);
            if (!pool.length) return [[]];
            const safeIndex = Number.isFinite(templateIndex)
                ? (Math.abs(Math.floor(templateIndex)) % pool.length)
                : Math.floor(Math.random() * pool.length);
            return cloneState(pool[safeIndex].tubes);
        }

        function isOpeningComplexityInRange(diffKey, puzzleState) {
            const range = OPENING_MOVE_RANGE_BY_DIFF[diffKey] || { min: 1, max: 999 };
            const moveCountAtStart = countPossibleMoves(puzzleState);
            return moveCountAtStart >= range.min && moveCountAtStart <= range.max;
        }

        function buildPuzzle(diffKey, templateIndex) {
            const targetEmptyCount = Math.max(0, Number(EMPTY_TUBES_BY_DIFF[diffKey] || 0));
            const colorCount = DIFFICULTY_META[diffKey].colorCount;

            for (let attempt = 0; attempt < 40; attempt++) {
                const base = buildTemplateWithDifficultyEmptyTubes(diffKey, templateIndex);
                const mapping = shuffleInPlace([...Array(colorCount).keys()]);
                let mapped = base.map(tube => tube.map(c => mapping[c]));
                shuffleInPlace(mapped);

                if (targetEmptyCount === 0) {
                    mapped = buildNoEmptyVariantFromOneEmpty(mapped);
                    if (!mapped) continue;
                }

                const emptyCount = mapped.filter(tube => tube.length === 0).length;
                if (emptyCount !== targetEmptyCount) continue;
                if (!hasAnyMove(mapped)) continue;
                if (!isOpeningComplexityInRange(diffKey, mapped)) continue;
                return mapped;
            }

            // fallback: ÏµúÏÜå Ï°∞Í±¥Îßå ÎßåÏ°±ÌïòÎäî ÏÉÅÌÉúÎ°ú Î∞òÌôò
            const fallback = buildTemplateWithDifficultyEmptyTubes(diffKey, templateIndex);
            shuffleInPlace(fallback);
            if (targetEmptyCount === 0) {
                const noEmpty = buildNoEmptyVariantFromOneEmpty(fallback);
                if (noEmpty) return noEmpty;
            }
            return fallback;
        }

        function applyPuzzle(nextState, options = {}) {
            if (autoNextTimer) {
                clearTimeout(autoNextTimer);
                autoNextTimer = null;
            }
            state = cloneState(nextState);
            initialState = cloneState(nextState);
            selectedIdx = -1;
            moveCount = 0;
            pouredCount = 0;
            if (!options.keepUndoUsed) undoUsed = 0;
            history = [];
            solved = false;
            startTime = Date.now();
            roundTimeLimitSec = getRoundTimeLimitSec(difficulty);
            roundDeadlineMs = Date.now() + (roundTimeLimitSec * 1000);
            updateStats();
            renderBoard();
            startTimer();
            if (!options.keepMessage) setMessage('');
            if (isMultiplayerMode) pushMultiplayerProgress(true);
        }

        function getRandomTemplateIndex(diffKey) {
            const templates = LEVEL_PACKS[diffKey];
            let idx = Math.floor(Math.random() * templates.length);
            if (templates.length > 1 && idx === lastSelectedTemplate) {
                idx = (idx + 1) % templates.length;
            }
            lastSelectedTemplate = idx;
            return idx;
        }

        function startSingleRound() {
            activeStageIndex = campaignProgress.stageByDiff[difficulty];
            const puzzle = buildPuzzle(difficulty, activeStageIndex);
            applyPuzzle(puzzle);
        }

        function startMultiplayerRound() {
            if (!isMultiplayerMode || !roomRef) return;
            if (!canCurrentUserControlRound()) {
                const controllerName = getRoundControllerNickname();
                setMessage(`${controllerName || 'ÏßÄÏ†ïÎêú ÌîåÎ†àÏù¥Ïñ¥'} Ï∞®Î°ÄÏûÖÎãàÎã§.`, 'warn');
                return;
            }
            const players = (roomDataCache && roomDataCache.players) || {};
            const participantIds = getParticipantIds(players);
            if (!participantIds.includes(myUid)) {
                setMessage('ÏõåÌÑ∞ÌçºÏ¶ê Î©ÄÌã∞Îäî ÏµúÎåÄ 4Î™ÖÏûÖÎãàÎã§.', 'warn');
                return;
            }
            const templateIndex = getRandomTemplateIndex(difficulty);
            const puzzle = buildPuzzle(difficulty, templateIndex);
            const encodedPuzzle = serializePuzzleForDb(puzzle);
            const scores = {};
            participantIds.forEach(uid => {
                scores[uid] = Number((multiState && multiState.scores && multiState.scores[uid]) || 0);
            });
            const progress = {};
            participantIds.forEach(uid => {
                const p = players[uid] || {};
                progress[uid] = {
                    nickname: p.nickname || '',
                    avatar: p.avatar || '',
                    moves: 0,
                    poured: 0,
                    progress: 0,
                    solved: false
                };
            });
            const round = Number((multiState && multiState.round) || 0) + 1;
            const roundToken = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
            const countdownStartAt = Date.now() + 150;
            roomRef.child(`gameData/${MULTI_GAME_KEY}`).set({
                version: 1,
                mode: 'race',
                status: 'starting',
                round,
                roundToken,
                difficulty,
                templateIndex,
                puzzle: encodedPuzzle,
                countdownStartAt,
                countdownDurationMs: 3000,
                participants: toParticipantMap(participantIds),
                progress,
                scores,
                chooserUid: getRoundControllerUid(),
                winnerUid: null,
                roundWinnerUid: null,
                roundPoints: null,
                timeExpired: false,
                timeLimitSec: getRoundTimeLimitSec(difficulty),
                startedAt: firebase.database.ServerValue.TIMESTAMP,
                updatedAt: firebase.database.ServerValue.TIMESTAMP
            });
            roomRef.child('status').set('playing');
        }

        function startCampaignRound() {
            if (isMultiplayerMode) {
                startMultiplayerRound();
                return;
            }
            startSingleRound();
        }

        function autoReshuffleIfDeadlocked() {
            if (solved || hasAnyMove()) return false;
            if (difficulty !== 'normal' && difficulty !== 'hard') return false;
            const templateIndex = Number.isFinite(activeStageIndex) ? activeStageIndex : 0;
            const regenerated = buildPuzzle(difficulty, templateIndex);
            if (!regenerated.length || !hasAnyMove(regenerated)) return false;
            applyPuzzle(regenerated, { keepMessage: true, keepUndoUsed: true });
            setMessage('ÎßâÌûò ÏÉÅÌÉúÎùº ÏûêÎèô Ïû¨Î∞∞ÏπòÌñàÏñ¥Ïöî. Í≥ÑÏÜç ÏßÑÌñâÌïòÏÑ∏Ïöî.', 'warn');
            return true;
        }

        function resetPuzzle() {
            if (!initialState.length) return;
            applyPuzzle(initialState, { keepMessage: true, keepUndoUsed: true });
            if (autoReshuffleIfDeadlocked()) return;
            const remain = Math.max(0, getUndoLimit() - undoUsed);
            setMessage(`ÌòÑÏû¨ ÎùºÏö¥ÎìúÎ•º Îã§Ïãú ÏãúÏûëÌñàÏñ¥Ïöî. ÎÇ®ÏùÄ ÎêòÎèåÎ¶¨Í∏∞ ${remain}Ìöå`);
        }

        function undoMove() {
            if (!history.length || solved) return;
            const limit = getUndoLimit();
            if (undoUsed >= limit) {
                setMessage(`Ïù¥ ÎÇúÏù¥ÎèÑÎäî ÎêòÎèåÎ¶¨Í∏∞ ${limit}ÌöåÍπåÏßÄ Í∞ÄÎä•Ìï©ÎãàÎã§.`, 'warn');
                updateStats();
                return;
            }
            const prev = history.pop();
            state = cloneState(prev.state);
            pouredCount = Number(prev.pouredCount || 0);
            selectedIdx = -1;
            moveCount = Math.max(0, moveCount - 1);
            undoUsed++;
            updateStats();
            renderBoard();
            if (isMultiplayerMode) pushMultiplayerProgress(true);
            if (autoReshuffleIfDeadlocked()) return;
            const remain = Math.max(0, limit - undoUsed);
            setMessage(`Î∞©Í∏à ÎêòÎèåÎ†∏Ïñ¥Ïöî. ÎÇ®ÏùÄ ÎêòÎèåÎ¶¨Í∏∞ ${remain}Ìöå`);
        }

        function advanceCampaignProgress() {
            const stageCount = getStageCount(difficulty);
            const tier = DIFF_ORDER.indexOf(difficulty);
            const now = campaignProgress.stageByDiff[difficulty];

            if (now < stageCount - 1) {
                campaignProgress.stageByDiff[difficulty] = now + 1;
                saveCampaignProgress();
                return { done: false, nextDiff: difficulty };
            }

            if (tier < DIFF_ORDER.length - 1) {
                campaignProgress.unlockedTier = Math.max(campaignProgress.unlockedTier, tier + 1);
                const nextDiff = DIFF_ORDER[tier + 1];
                difficulty = nextDiff;
                saveCampaignProgress();
                return { done: false, nextDiff };
            }

            campaignProgress.allCleared = true;
            saveCampaignProgress();
            return { done: true, nextDiff: difficulty };
        }

        function pushMultiplayerProgress(force, solvedEvent) {
            if (!isMultiplayerMode || !roomRef || !myUid || !multiState) return;
            if (multiState.status !== 'playing') return;
            if (multiState.participants && !multiState.participants[myUid]) return;
            const now = Date.now();
            if (!force && (now - multiLastProgressAt < MULTI_PROGRESS_INTERVAL_MS)) return;
            multiLastProgressAt = now;

            const payload = {
                nickname: myNick || 'User',
                avatar: myAvatar || 'üôÇ',
                moves: moveCount,
                poured: pouredCount,
                progress: computeCompletionPercent(),
                solved: !!solved,
                lastUpdate: firebase.database.ServerValue.TIMESTAMP
            };
            if (solvedEvent) payload.finishedAt = firebase.database.ServerValue.TIMESTAMP;
            roomRef.child(`gameData/${MULTI_GAME_KEY}/progress/${myUid}`).update(payload);
        }

        function submitSolvedToMultiplayer() {
            if (multiSolvedSubmitted || !isMultiplayerMode || !roomRef) return;
            multiSolvedSubmitted = true;
            pushMultiplayerProgress(true, true);
            roomRef.child(`gameData/${MULTI_GAME_KEY}/winnerUid`).transaction(current => current || myUid);
        }

        function handleRoundTimeout() {
            if (solved) return;
            solved = true;
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            }
            timeTextEl.textContent = '00:00';
            updateStats();

            if (isMultiplayerMode) {
                pushMultiplayerProgress(true, false);
                if (roomRef && myUid) {
                    roomRef.child(`gameData/${MULTI_GAME_KEY}/progress/${myUid}/timedOut`).set(true);
                    if (isHost) {
                        roomRef.child(`gameData/${MULTI_GAME_KEY}`).update({
                            timeExpired: true,
                            updatedAt: firebase.database.ServerValue.TIMESTAMP
                        });
                    }
                }
                setMessage('ÏãúÍ∞Ñ Ï¢ÖÎ£å! Í≤∞Í≥ºÎ•º ÏßëÍ≥ÑÌï©ÎãàÎã§...', 'warn');
                return;
            }

            setMessage('ÏãúÍ∞Ñ Ï¢ÖÎ£å! ÏÉà Í≤åÏûÑÏúºÎ°ú Îã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî.', 'warn');
        }

        function createAvatarElement(avatarValue) {
            const avatarEl = document.createElement('div');
            avatarEl.className = 'player-avatar';
            const avatar = avatarValue || 'üôÇ';
            if (looksLikeImagePath(avatar)) {
                const img = document.createElement('img');
                img.src = avatar;
                img.alt = 'avatar';
                img.onerror = () => { avatarEl.textContent = 'üôÇ'; };
                avatarEl.appendChild(img);
            } else {
                avatarEl.textContent = String(avatar).slice(0, 2);
            }
            return avatarEl;
        }

        function renderMultiHud(players, participantIds, water) {
            if (!isMultiplayerMode) return;
            multiHudEl.classList.remove('hidden');
            multiModeTextEl.textContent = isHost ? 'Î©ÄÌã∞ Î†àÏù¥Ïä§ ¬∑ Î∞©Ïû•' : 'Î©ÄÌã∞ Î†àÏù¥Ïä§';
            const roundLabel = water && water.round ? water.round : 0;
            multiRoundTextEl.textContent = `R${roundLabel} ¬∑ ${DIFFICULTY_META[difficulty].label}`;

            playerStripEl.innerHTML = '';
            participantIds.forEach(uid => {
                const p = players[uid] || {};
                const prog = (water && water.progress && water.progress[uid]) || {};
                const score = Number((water && water.scores && water.scores[uid]) || 0);
                const card = document.createElement('div');
                card.className = 'player-card';
                if (uid === myUid) card.classList.add('me');

                const avatarEl = createAvatarElement(prog.avatar || p.avatar);
                const meta = document.createElement('div');
                meta.className = 'player-meta';
                const nameEl = document.createElement('div');
                nameEl.className = 'player-name';
                nameEl.textContent = p.nickname || prog.nickname || 'Player';

                let statusText = 'ÎåÄÍ∏∞';
                if (water && water.status === 'playing') {
                    statusText = prog.solved ? 'ÏôÑÎ£å' : `${Number(prog.progress || 0)}%`;
                } else if (water && water.status === 'roundOver') {
                    statusText = uid === water.roundWinnerUid ? 'WIN' : (prog.solved ? 'ÏôÑÎ£å' : 'ÎØ∏ÏôÑÎ£å');
                }

                const sub = document.createElement('div');
                sub.className = 'player-sub';
                sub.innerHTML = `<span>${escapeHtml(statusText)}</span><span>${score}Ï†ê</span>`;
                meta.appendChild(nameEl);
                meta.appendChild(sub);
                card.appendChild(avatarEl);
                card.appendChild(meta);
                playerStripEl.appendChild(card);
            });

            multiRankEl.innerHTML = '';
        }

        function maybeFinalizeRoundByHost(participantIds, water) {
            if (!isHost || !water) return;
            if (water.status !== 'playing') return;
            if (!water.winnerUid && !water.timeExpired) return;
            if (water.roundToken && finalizedRoundToken === water.roundToken) return;
            if (water.roundToken) finalizedRoundToken = water.roundToken;

            const progress = water.progress || {};
            const ranked = participantIds
                .map(uid => ({
                    uid,
                    solved: !!(progress[uid] && progress[uid].solved),
                    finishedAt: Number((progress[uid] && progress[uid].finishedAt) || Number.MAX_SAFE_INTEGER),
                    moves: Number((progress[uid] && progress[uid].moves) || Number.MAX_SAFE_INTEGER),
                    prog: Number((progress[uid] && progress[uid].progress) || 0)
                }))
                .sort((a, b) => {
                    if (a.solved !== b.solved) return a.solved ? -1 : 1;
                    if (a.solved && b.solved) {
                        return a.finishedAt - b.finishedAt || a.moves - b.moves || a.uid.localeCompare(b.uid);
                    }
                    return b.prog - a.prog || a.moves - b.moves || a.uid.localeCompare(b.uid);
                });

            if (water.winnerUid) {
                ranked.sort((a, b) => {
                    if (a.uid === water.winnerUid) return -1;
                    if (b.uid === water.winnerUid) return 1;
                    if (a.solved !== b.solved) return a.solved ? -1 : 1;
                    if (a.solved && b.solved) return a.finishedAt - b.finishedAt || a.moves - b.moves || a.uid.localeCompare(b.uid);
                    return b.prog - a.prog || a.moves - b.moves || a.uid.localeCompare(b.uid);
                });
            }
            if (!ranked.length) return;

            const roundPoints = {};
            participantIds.forEach(uid => { roundPoints[uid] = 0; });
            ranked.forEach((item, idx) => {
                roundPoints[item.uid] = MULTI_RANK_POINTS[idx] || 1;
            });

            const nextScores = {};
            participantIds.forEach(uid => {
                nextScores[uid] = Number((water.scores && water.scores[uid]) || 0) + Number(roundPoints[uid] || 0);
            });

            const winnerUid = ranked[0].uid;
            const loserUid = ranked[ranked.length - 1].uid;

            roomRef.child(`gameData/${MULTI_GAME_KEY}`).update({
                status: 'roundOver',
                winnerUid,
                roundWinnerUid: winnerUid,
                chooserUid: loserUid,
                roundPoints,
                scores: nextScores,
                roundEndAt: firebase.database.ServerValue.TIMESTAMP,
                updatedAt: firebase.database.ServerValue.TIMESTAMP
            });
        }

        function normalizeMultiStateForHost(participantIds) {
            if (!isHost || !roomRef) return;
            const current = roomDataCache && roomDataCache.gameData && roomDataCache.gameData[MULTI_GAME_KEY];

            if (!current) {
                const initialScores = {};
                participantIds.forEach(uid => { initialScores[uid] = 0; });
                roomRef.child(`gameData/${MULTI_GAME_KEY}`).set({
                    version: 1,
                    mode: 'race',
                    status: 'waiting',
                    round: 0,
                    difficulty,
                    chooserUid: roomDataCache.hostId || '',
                    participants: toParticipantMap(participantIds),
                    scores: initialScores,
                    progress: {},
                    updatedAt: firebase.database.ServerValue.TIMESTAMP
                });
                return;
            }

            if (current.status === 'playing' || current.status === 'starting') return;

            const participantChanged = !hasSameParticipants(current.participants, participantIds);
            const nextScores = {};
            participantIds.forEach(uid => {
                nextScores[uid] = Number((current.scores && current.scores[uid]) || 0);
            });
            const scoreChanged = Object.keys(current.scores || {}).length !== participantIds.length;

            const chooserExists = !!(current.chooserUid && participantIds.includes(current.chooserUid));
            if (participantChanged || scoreChanged || !current.difficulty || !chooserExists) {
                roomRef.child(`gameData/${MULTI_GAME_KEY}`).update({
                    participants: toParticipantMap(participantIds),
                    scores: nextScores,
                    difficulty: current.difficulty || difficulty,
                    chooserUid: chooserExists ? current.chooserUid : (roomDataCache.hostId || ''),
                    updatedAt: firebase.database.ServerValue.TIMESTAMP
                });
            }
        }

        function onRoomSnapshot(snapshot) {
            if (!snapshot.exists()) {
                alert('Î∞©Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.');
                window.location.href = 'ÎåÄÍ∏∞Ïã§.html';
                return;
            }

            roomDataCache = snapshot.val() || {};
            const players = roomDataCache.players || {};
            isHost = roomDataCache.hostId === myUid;
            const participantIds = getParticipantIds(players);

            if (isHost) normalizeMultiStateForHost(participantIds);

            multiState = roomDataCache.gameData && roomDataCache.gameData[MULTI_GAME_KEY]
                ? roomDataCache.gameData[MULTI_GAME_KEY]
                : null;

            if (multiState && DIFFICULTY_META[multiState.difficulty]) {
                difficulty = multiState.difficulty;
            }

            renderMultiHud(players, participantIds, multiState);
            updateStats();

            if (!participantIds.includes(myUid)) {
                solved = true;
                hideStartOverlay();
                setMessage('ÏõåÌÑ∞ÌçºÏ¶ê Î©ÄÌã∞Îäî ÏµúÎåÄ 4Î™ÖÏûÖÎãàÎã§.', 'warn');
                return;
            }

            if (!multiState) {
                showWaitingOverlay();
                const controllerName = getRoundControllerNickname(players, multiState);
                setMessage(canCurrentUserControlRound(multiState)
                    ? 'ÎÇ¥ Ï∞®Î°ÄÏûÖÎãàÎã§. ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù ÌõÑ ÎùºÏö¥ÎìúÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî.'
                    : `${controllerName || 'ÏßÄÏ†ïÎêú ÌîåÎ†àÏù¥Ïñ¥'} Ï∞®Î°ÄÎ•º Í∏∞Îã§Î¶¨Îäî Ï§ëÏûÖÎãàÎã§.`);
                return;
            }

            if (multiState.status === 'starting') {
                showCountdownOverlay(multiState);
                setMessage('Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï§ë...');
                return;
            }

            if (multiState.status === 'playing') {
                hideStartOverlay();
                const syncedPuzzle = deserializePuzzleFromDb(multiState.puzzle);
                const syncedDiff = (multiState && DIFFICULTY_META[multiState.difficulty]) ? multiState.difficulty : difficulty;
                const expectedEmptyCount = Math.max(0, Number(EMPTY_TUBES_BY_DIFF[syncedDiff] || 0));
                const actualEmptyCount = syncedPuzzle.filter(t => t.length === 0).length;
                if (!syncedPuzzle.length || actualEmptyCount !== expectedEmptyCount || !hasAnyMove(syncedPuzzle)) {
                    setMessage('ÌçºÏ¶ê ÎèôÍ∏∞Ìôî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Î∞©Ïû•Ïù¥ ÎùºÏö¥ÎìúÎ•º Îã§Ïãú ÏãúÏûëÌï¥Ï£ºÏÑ∏Ïöî.', 'warn');
                    return;
                }
                if (multiState.roundToken && activeRoundToken !== multiState.roundToken) {
                    activeRoundToken = multiState.roundToken;
                    multiSolvedSubmitted = false;
                    finalizedRoundToken = '';
                    promotedPlayingToken = '';
                    activeStageIndex = Number(multiState.templateIndex || 0);
                    applyPuzzle(syncedPuzzle, { keepMessage: true });
                    setMessage(`ÎùºÏö¥Îìú ${multiState.round || 1} ÏãúÏûë! Î®ºÏ†Ä ÌÅ¥Î¶¨Ïñ¥ÌïòÏÑ∏Ïöî.`);
                } else if (!solved) {
                    pushMultiplayerProgress(false);
                }
                maybeFinalizeRoundByHost(participantIds, multiState);
                return;
            }

            if (multiState.status === 'roundOver') {
                solved = true;
                if (timerId) clearInterval(timerId);
                showWaitingOverlay();
                const winnerUid = multiState.roundWinnerUid || multiState.winnerUid;
                const winnerName = (players[winnerUid] && players[winnerUid].nickname) || 'ÌîåÎ†àÏù¥Ïñ¥';
                const myPoint = Number((multiState.roundPoints && multiState.roundPoints[myUid]) || 0);
                const kind = winnerUid === myUid ? 'win' : '';
                const chooserName = getRoundControllerNickname(players, multiState);
                setMessage(`${winnerName} ÏäπÎ¶¨! ÎÇ¥ ÎùºÏö¥Îìú Ï†êÏàò +${myPoint} | Îã§Ïùå ÏÑ†ÌÉù: ${chooserName || 'ÏßÄÏ†ï ÌîåÎ†àÏù¥Ïñ¥'}`, kind);
                return;
            }

            if (multiState.status === 'waiting') {
                showWaitingOverlay();
                const controllerName = getRoundControllerNickname(players, multiState);
                setMessage(canCurrentUserControlRound(multiState)
                    ? 'ÎÇ¥ Ï∞®Î°ÄÏûÖÎãàÎã§. ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù ÌõÑ ÎùºÏö¥ÎìúÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî.'
                    : `${controllerName || 'ÏßÄÏ†ïÎêú ÌîåÎ†àÏù¥Ïñ¥'} Ï∞®Î°ÄÎ•º Í∏∞Îã§Î¶¨Îäî Ï§ëÏûÖÎãàÎã§.`);
            }
        }

        async function initMultiplayer() {
            multiHudEl.classList.remove('hidden');
            campaignWrapEl.classList.add('hidden');
            updateStats();
            setMessage('Î©ÄÌã∞ ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...');

            if (!window.firebase) {
                setMessage('Firebase Î°úÎìú Ïã§Ìå®', 'warn');
                return;
            }

            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.firebasestorage.app",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            auth = firebase.auth();

            auth.onAuthStateChanged(async user => {
                if (!user) {
                    window.location.href = 'index.html';
                    return;
                }

                myUid = user.uid;
                myNick = localStorage.getItem('userNickname') || 'User';
                myAvatar = localStorage.getItem('userAvatar') || 'üôÇ';

                try {
                    const profileSnap = await db.ref(`users/${myUid}/profile`).once('value');
                    const profile = profileSnap.val() || {};
                    if (typeof profile.nickname === 'string' && profile.nickname.trim()) myNick = profile.nickname;
                    if (typeof profile.avatar === 'string' && profile.avatar.trim()) myAvatar = profile.avatar;
                } catch (e) {
                    // fallback to localStorage
                }

                roomRef = db.ref(`rooms/${roomIdFromUrl}`);
                const roomSnap = await roomRef.once('value');
                if (!roomSnap.exists()) {
                    alert('Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                    window.location.href = 'ÎåÄÍ∏∞Ïã§.html';
                    return;
                }

                const roomData = roomSnap.val() || {};
                const players = roomData.players || {};
                const joining = !players[myUid];
                const currentCount = Object.keys(players).length;
                if (joining && currentCount >= MAX_MULTI_PLAYERS) {
                    alert('ÏõåÌÑ∞ÌçºÏ¶ê Î©ÄÌã∞Îäî ÏµúÎåÄ 4Î™ÖÏûÖÎãàÎã§.');
                    window.location.href = 'ÎåÄÍ∏∞Ïã§.html';
                    return;
                }

                isHost = roomData.hostId === myUid;
                await roomRef.child(`players/${myUid}`).update({
                    nickname: myNick,
                    avatar: myAvatar,
                    isHost
                });
                roomRef.child(`players/${myUid}`).onDisconnect().remove();
                roomRef.on('value', onRoomSnapshot);
                setMessage('Î©ÄÌã∞ Î£∏ Ïó∞Í≤∞ ÏôÑÎ£å');
            });
        }

        async function leaveToLobby() {
            if (roomRef && myUid) {
                try {
                    roomRef.off('value', onRoomSnapshot);
                    await roomRef.child(`players/${myUid}`).remove();
                } catch (e) {
                    // ignore
                }
            }
            window.location.href = 'ÎåÄÍ∏∞Ïã§.html';
        }

        function handleRoundClear() {
            solved = true;
            if (timerId) clearInterval(timerId);
            const sec = Math.floor((Date.now() - startTime) / 1000);

            if (isMultiplayerMode) {
                submitSolvedToMultiplayer();
                setMessage(`ÌÅ¥Î¶¨Ïñ¥! ${moveCount}Ïàò ¬∑ ${formatTime(sec)} ¬∑ Í≤∞Í≥º ÏßëÍ≥Ñ Ï§ë...`, 'win');
                return;
            }

            const advance = advanceCampaignProgress();
            updateCampaignUI();

            if (advance.done) {
                setMessage(`üéâ Ï†ÑÏ≤¥ Îã®Í≥Ñ ÌÅ¥Î¶¨Ïñ¥! ${moveCount}Ïàò ¬∑ ${formatTime(sec)}`, 'win');
                return;
            }

            const nextStage = campaignProgress.stageByDiff[difficulty] + 1;
            setMessage(`ÌÅ¥Î¶¨Ïñ¥! ${moveCount}Ïàò ¬∑ ${formatTime(sec)} | 1.4Ï¥à ÌõÑ ${DIFFICULTY_META[difficulty].label} ${nextStage}/${getStageCount(difficulty)} Îã®Í≥Ñ`, 'win');
            autoNextTimer = setTimeout(() => {
                if (!solved) return;
                startSingleRound();
            }, 1400);
        }

        function setDifficulty(nextDiff) {
            if (!DIFFICULTY_META[nextDiff]) return;

            if (isMultiplayerMode) {
                if (!canCurrentUserControlRound()) {
                    const controllerName = getRoundControllerNickname();
                    setMessage(`${controllerName || 'ÏßÄÏ†ïÎêú ÌîåÎ†àÏù¥Ïñ¥'}Í∞Ä ÎÇúÏù¥ÎèÑÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.`, 'warn');
                    return;
                }
                if (multiState && (multiState.status === 'playing' || multiState.status === 'starting')) {
                    setMessage('ÎùºÏö¥Îìú Ï§ëÏóêÎäî ÎÇúÏù¥ÎèÑÎ•º Î∞îÍøÄ Ïàò ÏóÜÏäµÎãàÎã§.', 'warn');
                    return;
                }
                difficulty = nextDiff;
                updateStats();
                if (roomRef) {
                    roomRef.child(`gameData/${MULTI_GAME_KEY}/difficulty`).set(nextDiff);
                    roomRef.child(`gameData/${MULTI_GAME_KEY}/updatedAt`).set(firebase.database.ServerValue.TIMESTAMP);
                }
                return;
            }

            const tier = DIFF_ORDER.indexOf(nextDiff);
            if (tier > campaignProgress.unlockedTier) {
                setMessage(`${DIFFICULTY_META[nextDiff].label}ÏùÄ Ïù¥Ï†Ñ ÎÇúÏù¥ÎèÑ ÌÅ¥Î¶¨Ïñ¥ ÌõÑ Ïó¥Î†§Ïöî.`, 'warn');
                return;
            }
            difficulty = nextDiff;
            startSingleRound();
        }

        backBtn.addEventListener('click', () => {
            if (isMultiplayerMode) leaveToLobby();
            else window.location.href = 'ÎåÄÍ∏∞Ïã§.html';
        });
        newBtn.addEventListener('click', startCampaignRound);
        resetBtn.addEventListener('click', resetPuzzle);
        undoBtn.addEventListener('click', undoMove);

        difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.dataset.diff !== difficulty) setDifficulty(btn.dataset.diff);
            });
        });

        startDiffButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.dataset.diff !== difficulty) setDifficulty(btn.dataset.diff);
            });
        });

        startGoBtnEl.addEventListener('click', () => {
            if (!isMultiplayerMode) return;
            startMultiplayerRound();
        });

        const blockScrollInput = event => {
            if (event.cancelable) event.preventDefault();
        };
        document.addEventListener('touchmove', blockScrollInput, { passive: false });
        window.addEventListener('wheel', blockScrollInput, { passive: false });
        window.addEventListener('keydown', event => {
            const blocked = ['Space', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End'];
            if (!blocked.includes(event.code)) return;
            const tag = event.target && event.target.tagName ? event.target.tagName : '';
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
            if (event.cancelable) event.preventDefault();
        });

        window.addEventListener('resize', scheduleResponsiveRender);
        window.addEventListener('orientationchange', () => {
            setTimeout(scheduleResponsiveRender, 120);
        });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', scheduleResponsiveRender);
        }
        if ('ResizeObserver' in window && boardPanelEl) {
            const observer = new ResizeObserver(scheduleResponsiveRender);
            observer.observe(boardPanelEl);
        }

        if (isMultiplayerMode) {
            initMultiplayer();
        } else {
            difficulty = DIFF_ORDER[campaignProgress.unlockedTier] || 'easy';
            startSingleRound();
        }
    </script>
</body>
</html>
