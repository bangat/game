<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ì‚¬ì²œì„± (í˜¼ìí•˜ê¸°)</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        /* --- ê¸°ë³¸ ìŠ¤íƒ€ì¼ (ë©€í‹°í”Œë ˆì´ ë²„ì „ ê¸°ë°˜) --- */
        :root {
            --bg-color: #f0f0f0;
            --board-bg: #f8f9fa;
            --border-color: #cccccc;
            --tile-bg: #ffffff;
            --tile-bg-hover: #f0f0f0;
            --tile-selected-bg: #FFC84A;
            --tile-selected-border: #4A8DFF;
            --primary-color: #4A8DFF;
            --accent-color: #FFC84A;
            --text-color-dark: #333D4B;
            --text-color-light: #ffffff;
            --danger-color: #F76363;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: var(--text-color-dark);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
        }

        #game-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; background-color: #e9eef2; }
        
        /* [ë³€ê²½] ë©€í‹°í”Œë ˆì´ í—¤ë” -> í˜¼ìí•˜ê¸° ìƒíƒœì°½ */
        #game-status {
            flex-shrink: 0; display: flex; justify-content: space-around; align-items: center;
            padding: 15px; background-color: rgba(0,0,0,0.05); gap: 15px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.2em; font-weight: 700;
        }
        #score-display, #timer-display {
            background-color: rgba(255,255,255,0.7);
            padding: 10px 15px; border-radius: 12px;
            flex: 1; text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        /* [ì‚­ì œ] .player-info ê´€ë ¨ ìŠ¤íƒ€ì¼ ëª¨ë‘ ì œê±° */

        #game-container {
            width: 100%; flex-grow: 1; display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 5px;
        }
        #game-board {
            position: relative; background-color: var(--board-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            display: grid; /* JSì—ì„œ columns/rows ì„¤ì • */
            gap: 1px;
            padding: 2px;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }


        .tile {
            background-color: var(--tile-bg);
            border-radius: 5px;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.8em; /* JSì—ì„œ ì¡°ì ˆ */
            cursor: pointer;
            transition: background-color 0.15s, transform 0.15s, border-color 0.15s, box-shadow 0.15s;
            border: 1px solid transparent;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            aspect-ratio: 1 / 1;
        }
        .tile:hover { 
            background-color: var(--tile-bg-hover); 
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
        }
        .tile.selected {
            background-color: var(--tile-selected-bg);
            border-color: var(--tile-selected-border);
            transform: scale(1.08);
            box-shadow: 0 0 10px var(--tile-selected-border);
        }
        .tile.hidden { /* ë§¤ì¹­ë˜ì–´ ì‚¬ë¼ì§ˆ ë•Œ */
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            background-color: transparent !important;
            box-shadow: none;
            cursor: default;
        }
        .tile img { /* ì´ë¯¸ì§€ íƒ€ì¼ìš© */
             width: 75%; height: 75%; object-fit: contain;
             pointer-events: none;
        }

        /* --- ì˜¤ë²„ë ˆì´/ëª¨ë‹¬ ìŠ¤íƒ€ì¼ --- */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.7); }
        .modal-content { background: var(--bg-color); color: var(--text-color-dark); padding: 0; border-radius: 16px; width: 90%; max-width: 400px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); overflow: hidden; }
        .modal-header { background-color: var(--primary-color); color: white; padding: 15px; border-radius: 16px 16px 0 0; }
        .modal-header h2 { font-size: 1.6em; }
        .modal-body { padding: 25px; }
        .modal-buttons { display: flex; flex-direction: column; gap: 12px; align-items: center; margin-top: 25px; }
        .spinner { border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #countdown-number { font-size: 7em; font-weight: 700; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.7); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* [ì‚­ì œ] ê²Œì„ ì¢…ë£Œ ì ìˆ˜íŒ (score-board, score-row) ìŠ¤íƒ€ì¼ ì œê±° */
        
        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .menu-btn { width: 100%; padding: 15px; font-size: 1.1em; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; margin: 5px 0; }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #e9eff8; color: var(--text-color-dark); }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn:disabled { background-color: #ccc; color: #888; cursor: not-allowed; }

        /* [ì‚­ì œ] ë‚˜ê°€ê¸° í™•ì¸ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ ì œê±° */

        #path-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        /* [ì‹ ê·œ] ë³´ë“œ í”ë“¤ë¦¼ (Vibration) ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes board-shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(3px, 2px); }
            50% { transform: translate(-3px, -2px); }
            75% { transform: translate(2px, -3px); }
        }
        .board-shake {
            animation: board-shake 0.1s linear 20; /* 2ì´ˆê°„ í”ë“¤ë¦¼ */
        }

        .wipe-out { animation: wipe-up-out 0.4s ease-in forwards; }

        /* ------------------------- */
        /* == 8. ì‹ ê·œ: ê²Œì´ì§€ ë° ì½¤ë³´ (í—¤ë”) == */
        /* ------------------------- */
        .player-info .info-text {
            display: flex; flex-direction: column; 
            min-width: 0; flex-grow: 1;
            /* [ìˆ˜ì •] ì ìˆ˜ ëŒ€ì‹  ê²Œì´ì§€ê°€ ë“¤ì–´ê°€ë¯€ë¡œ ê°­ ì œê±° */
            gap: 2px; 
        }
        .player-info .nickname {
            font-weight: 700; font-size: 0.9em; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            /* [ì‹ ê·œ] ê²Œì´ì§€ë°”ë¥¼ ìœ„í•œ ê³µê°„ í™•ë³´ */
            margin-bottom: 2px;
        }
        /* [ì‚­ì œ] .player-info .score ìŠ¤íƒ€ì¼ ì œê±° (ê²Œì´ì§€ë¡œ ëŒ€ì²´) */
        /* .player-info .score { ... } */

        /* [ì‹ ê·œ] ê²Œì´ì§€ ë°” (í…Œë‘ë¦¬) */
        .gauge-bar {
            width: 100%;
            height: 12px;
            background-color: rgba(0,0,0,0.5); /* ê²€ì •ìƒ‰ í…Œë‘ë¦¬ ì—­í•  */
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            padding: 1px; /* ë‚´ë¶€ ê²Œì´ì§€ì™€ ê°„ê²© */
        }
        /* [ì‹ ê·œ] ê²Œì´ì§€ ë°” (ì±„ìš°ê¸°) */
        .gauge-fill {
            width: 0%; /* JSì—ì„œ ì¡°ì ˆ */
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
            border-radius: 3px;
            transition: width 0.3s ease-out;
        }

        /* [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ (í—¤ë”) */
        .combo-display {
            position: absolute;
            top: 2px; right: 5px;
            font-size: 1.1em;
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 0 0 5px rgba(0,0,0,0.7), 1px 1px 2px rgba(0,0,0,1);
            transition: transform 0.1s ease-out;
        }
        .combo-display.combo-active {
            transform: scale(1.2);
        }

        /* ------------------------- */
        /* == 9. ì‹ ê·œ: ì¸ê²Œì„ ì½¤ë³´/ê³µê²© íš¨ê³¼ == */
        /* ------------------------- */

        /* [ì‹ ê·œ] ë¨¹ë¬¼ ê³µê²© ì˜¤ë²„ë ˆì´ */
        #ink-splatter-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="rgba(0,0,0,0.85)" d="M256 0c-20.5 0-39.8 4-57.6 11.4 17.8 7.4 34.1 18.1 48.2 31.2 14.1-13.1 30.4-23.8 48.2-31.2C295.8 4 276.5 0 256 0zM128.4 64.3C104.7 78 85.3 95.8 71.4 116.8c15.8 14.8 34.6 26.6 55.4 34.4C140.9 120.5 147.2 87.8 128.4 64.3zM440.6 116.8C426.7 95.8 407.3 78 383.6 64.3 364.8 87.8 371.1 120.5 383.2 151.2 404 143.4 422.8 131.6 440.6 116.8zM256 128c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zM70 212.8c-12.8 22.8-21.6 48.3-25.6 75.2 27.2 1.6 53.3 8.4 76.4 19.8 1.4-25.2 8.6-49.3 20-70.6C113.3 232.9 90.5 221.7 70 212.8zM441.6 212.8c-20.5 8.9-43.3 20.1-70.8 24.4 11.4 21.3 18.6 45.4 20 70.6 23.1-11.4 49.2-18.2 76.4-19.8C463.2 261.1 454.4 235.6 441.6 212.8zM256 320c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48zM141.2 355.6c-18.9 16.4-34.9 36.3-46.8 58.8 17.5 4.3 35.8 6.6 54.8 6.6 23.5 0 45.8-3.4 66-9.6C197.6 391.2 168.6 374.3 141.2 355.6zM370.8 355.6c-27.4 18.7-56.4 35.6-74 55.8 20.2 6.2 42.5 9.6 66 9.6 19 0 37.3-2.3 54.8-6.6C405.7 391.9 389.7 372 370.8 355.6zM256 512c20.5 0 39.8-4 57.6-11.4-17.8-7.4-34.1-18.1-48.2-31.2-14.1 13.1-30.4 23.8-48.2 31.2C216.2 508 235.5 512 256 512z"/></svg>') no-repeat center center;
            background-size: cover;
            opacity: 0;
            pointer-events: none;
            z-index: 150;
            transition: opacity 0.3s ease-out;
        }
        #ink-splatter-overlay.active {
            opacity: 1;
        }

        /* [ì‹ ê·œ] ì½¤ë³´ í…ìŠ¤íŠ¸ (ì¸ê²Œì„) */
        #combo-text-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        .combo-text-popup {
            position: absolute;
            font-size: 1.8em;
            font-weight: 900;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: combo-fade-up 2s ease-out forwards;
        }
        @keyframes combo-fade-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-status">
            <div id="score-display">ì ìˆ˜: 0</div>
            <div id="timer-display">ì‹œê°„: 00:00</div>
        </div>
        <div id="game-container">
            <div id="game-board">
                </div>
            <canvas id="path-canvas"></canvas>
            <div id="combo-text-overlay"></div>
            <div id="ink-splatter-overlay"></div>
        </div>
    </div>

    <div id="game-over-overlay" class="overlay" style="display: none;">
    </div>
    
    <div id="info-overlay" class="overlay">
         <div class="spinner"></div>
         <p style="color: white; margin-top: 15px; font-size: 1.1em;">ê²Œì„ ì¤€ë¹„ ì¤‘...</p>
    </div>

    <audio id="tile-select-sound" src="./sounds/select.mp3" preload="auto"></audio>
    <audio id="tile-match-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì‚¬ì²œì„±ë§ì¶¤.mp3" preload="auto"></audio>
    <audio id="win-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/win.mp3" preload="auto"></audio>
    <audio id="junk-sound" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/ì •í¬ë„˜ì–´ì˜¬ë•Œ.mp3" preload="auto"></audio>
    <audio id="loss-sound-new" src="./ë´„ë²„ë§¨ì‚¬ìš´ë“œ/íŒ¨ë°°.mp3" preload="auto"></audio> <script>
        // [ì‚­ì œ] HTML Escape í•¨ìˆ˜ ì œê±° (ë¡œì»¬ ë°ì´í„° ì‚¬ìš©)

        // --- í—¬í¼ í•¨ìˆ˜: í¬ì†Œ ë°°ì—´ -> ì¼ë°˜ ë°°ì—´ (ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼) ---
        function getBoardArray(boardData, tileCount) {
            const newArray = new Array(tileCount).fill(null);
            if (boardData) {
                for (const key in boardData) {
                    const index = parseInt(key, 10);
                    if (!isNaN(index) && index >= 0 && index < tileCount) { 
                        newArray[index] = boardData[key];
                    }
                }
            }
            return newArray;
        }

        // --- í—¬í¼ í•¨ìˆ˜: ë°°ì—´ ì„ê¸° (ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- í—¬í¼ í•¨ìˆ˜: ë¹ˆ ì¹¸ ì°¾ê¸° (ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼) ---
        function findEmptySpots(boardArray) {
            const emptyIndices = [];
            boardArray.forEach((tile, index) => {
                if (tile === null) {
                    emptyIndices.push(index);
                }
            });
            return emptyIndices;
        }

        document.addEventListener('DOMContentLoaded', () => {
            // --- ê°œë°œì ë„êµ¬ ë°©ì§€ (ìœ ì§€) ---
             document.addEventListener('contextmenu', event => event.preventDefault());
             document.addEventListener('keydown', event => {
                 if (event.key === 'F12' ||
                   (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
                    (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                     event.preventDefault();
                 }
                 
             });
             // setInterval(() => { try { debugger; } catch (e) {} }, 1000); // (ë””ë²„ê¹… ì‹œ ì£¼ì„ ì²˜ë¦¬)

            // --- [ì‚­ì œ] Firebase ì„¤ì • ëª¨ë‘ ì œê±° ---

            // --- HTML ìš”ì†Œ ---
            const gameBoard = document.getElementById('game-board');
            const gameContainer = document.getElementById('game-container');
            const infoOverlay = document.getElementById('info-overlay');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const pathCanvas = document.getElementById('path-canvas');
            const ctx = pathCanvas.getContext('2d');
            // [ì¶”ê°€] í˜¼ìí•˜ê¸°ìš© UI ìš”ì†Œ
            const scoreDisplay = document.getElementById('score-display');
            const timerDisplay = document.getElementById('timer-display');
            // [ì‚­ì œ] ë©€í‹°í”Œë ˆì´ìš© UI ìš”ì†Œ (header, exit modal ë“±) ì œê±°

            // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ (ë¡œì»¬) ---
            let isGameLive = false, gameOverFlag = false;
            let selectedTileElement = null; // [ë³€ê²½] ë¡œì»¬ì—ì„œ ì„ íƒí•œ íƒ€ì¼ DOM ìš”ì†Œ
            let gameBoardArray = []; // [ì¶”ê°€] ë¡œì»¬ ê²Œì„ ë³´ë“œ ë°ì´í„°

            // [ì¶”ê°€] í˜¼ìí•˜ê¸°ìš© ìƒíƒœ
            let currentScore = 0;
            let gameTimer = 0; // ì´ˆ ë‹¨ìœ„
            let startTime = 0;
            let timerInterval = null;
            let isShuffling = false; // [ì‹ ê·œ] ì…”í”Œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
            
            // [ì‚­ì œ] myPlayerId, roomRef, currentRoomData, isHost ë“± ëª¨ë‘ ì œê±°

            // --- ìº”ë²„ìŠ¤ ì¢Œí‘œ ê³„ì‚°ìš© (ìœ ì§€) ---
            let currentTileSize = 0;
            let currentGapSize = 1; // CSSì˜ gap ê°’ê³¼ ì¼ì¹˜
            let currentExtraMargin = 0;

            // --- ê²Œì„ ì„¤ì • (ìœ ì§€) ---
            const BOARD_ROWS = 8;
            const BOARD_COLS = 5;
            const TILE_COUNT = BOARD_ROWS * BOARD_COLS;
            const TILE_ICONS = [
                'ğŸ¶', 'ğŸ´', 'ğŸƒ', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ§¸', 'ğŸ¨', 'ğŸ¯',
                'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸµ', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¤', 'ğŸ—ï¸',
                'ğŸ”', 'ğŸ•', 'ğŸŸ', 'ğŸŒ­', 'ğŸ¿', 'ğŸ', 'ğŸ¥“', 'ğŸ¥š', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ¥',
                'ğŸ»', 'ğŸ‹', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ‘', 'ğŸ¥', 'ğŸ¥¥', 'â›ï¸', 'ğŸ¥­',
                 './tiles/cake.png', './tiles/candy.png', './tiles/cherry.png', './tiles/donut.png',
                 './tiles/icecream.png', './tiles/lollipop.png', './tiles/pudding.png', './tiles/star.png'
             ]; // TILE_COUNT / 2 ê°œì˜ ê³ ìœ  ì•„ì´ì½˜ í•„ìš”

            // [ì‚­ì œ] AVATAR_SETS ì œê±°

            // --- ì‚¬ìš´ë“œ ì¬ìƒ í•¨ìˆ˜ (ìœ ì§€) ---
            function playSound(id) {
                try {
                    const sound = document.getElementById(id);
                    if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
                } catch(e) { console.warn("Sound play error:", e); }
            }

            // --- ì§„ë™ íš¨ê³¼ í•¨ìˆ˜ (ìœ ì§€) ---
            function playVibrationEffect() {
                if (navigator.vibrate) {
                    navigator.vibrate(100); 
                }
            }

            // [ì‚­ì œ] joinRoom(), listenToRoomChanges() ì œê±°

            // --- [ìœ ì§€] ì¬ê·€ ë°±íŠ¸ë˜í‚¹ í—¬í¼ (ë§µ ìƒì„±ìš©) ---
            function _generateBoardRecursive(board, tilesToPlace, depth = 0) {
                if (depth > TILE_COUNT * 2) return null;
                if (tilesToPlace.length === 0) return board;

                const tile = tilesToPlace[0];
                const emptyIndices = findEmptySpots(board);
                if (emptyIndices.length < 2) return null;

                const shuffledEmptyIndices = shuffleArray([...emptyIndices]);
                const pairs = [];
                for (let i = 0; i < shuffledEmptyIndices.length - 1; i++) {
                    const index1 = shuffledEmptyIndices[i];
                    const row1 = Math.floor(index1 / BOARD_COLS);
                    const col1 = index1 % BOARD_COLS;
                    for (let j = i + 1; j < shuffledEmptyIndices.length; j++) {
                        const index2 = shuffledEmptyIndices[j];
                        const row2 = Math.floor(index2 / BOARD_COLS);
                        const col2 = index2 % BOARD_COLS;
                        const distance = Math.abs(row1 - row2) + Math.abs(col1 - col2);
                        pairs.push({ index1, index2, distance });
                    }
                }
                pairs.sort((a, b) => a.distance - b.distance);

                for (const { index1, index2 } of pairs) {
                    if (findPath_BFS(board, index1, index2)) {
                        board[index1] = tile;
                        board[index2] = tile;
                        const remainingTiles = tilesToPlace.slice(1);
                        const result = _generateBoardRecursive(board, remainingTiles, depth + 1);
                        if (result) return result;
                        board[index1] = null;
                        board[index2] = null;
                    }
                }
                return null;
            }

            // --- [ì‹ ê·œ] ì…”í”Œ í—¬í¼ 1: ê°€ëŠ¥í•œ ëª¨ë“  ìˆ˜ í™•ì¸ ---
            function checkForAvailableMoves(boardArray) {
                const availableTiles = {}; // { 'ğŸ¶': [idx1, idx2], 'ğŸ±': [idx3] }

                // 1. í˜„ì¬ ë³´ë“œì— ë‚¨ì€ íƒ€ì¼ë“¤ì„ ì•„ì´ì½˜ë³„ë¡œ ê·¸ë£¹í™”
                boardArray.forEach((icon, index) => {
                    if (icon !== null) {
                        if (!availableTiles[icon]) {
                            availableTiles[icon] = [];
                        }
                        availableTiles[icon].push(index);
                    }
                });

                // 2. ê° ì•„ì´ì½˜ ê·¸ë£¹ì„ ìˆœíšŒ
                for (const icon in availableTiles) {
                    const indices = availableTiles[icon];
                    if (indices.length < 2) continue; // 1ê°œë§Œ ë‚¨ì€ íƒ€ì¼ì€ ë¬´ì‹œ

                    // 3. ëª¨ë“  ê°€ëŠ¥í•œ 'ìŒ'ì„ ë§Œë“¤ì–´ ê²½ë¡œ íƒìƒ‰ (ì¡°í•©)
                    for (let i = 0; i < indices.length - 1; i++) {
                        for (let j = i + 1; j < indices.length; j++) {
                            const index1 = indices[i];
                            const index2 = indices[j];
                            
                            // 4. ê²½ë¡œê°€ í•˜ë‚˜ë¼ë„ ë°œê²¬ë˜ë©´ ì¦‰ì‹œ true ë°˜í™˜
                            if (findPath_BFS(boardArray, index1, index2)) {
                                console.log(`[Move Check] Found: ${icon} at ${index1}, ${index2}`);
                                return true; // ê°€ëŠ¥í•œ ì›€ì§ì„ ë°œê²¬!
                            }
                        }
                    }
                }

                // 5. ëª¨ë“  ê²€ì‚¬ê°€ ëë‚  ë•Œê¹Œì§€ ê²½ë¡œë¥¼ ëª» ì°¾ìœ¼ë©´ false ë°˜í™˜
                console.log("[Move Check] No moves left.");
                return false; // ë§‰í˜!
            }

            // --- [ì‹ ê·œ] ì…”í”Œ í—¬í¼ 2: ë‚¨ì€ íƒ€ì¼ í©ë¿Œë¦¬ê¸° ---
            function shuffleRemainingTiles(boardArray) {
                const remainingTiles = [];
                
                // 1. í˜„ì¬ ë‚¨ì€ íƒ€ì¼ ì •ë³´ë§Œ ì¶”ì¶œ
                boardArray.forEach((icon) => {
                    if (icon !== null) {
                        remainingTiles.push(icon);
                    }
                });

                // 2. ë‚¨ì€ íƒ€ì¼ì´ 2ê°œ ë¯¸ë§Œì´ë©´, ë¹ˆ ë³´ë“œ ë°˜í™˜ (ê²Œì„ ì¢…ë£Œ ìœ ë„)
                if (remainingTiles.length < 2) {
                     return new Array(TILE_COUNT).fill(null);
                }
                
                const allIndices = Array.from({ length: TILE_COUNT }, (_, i) => i);

                let attempts = 0;
                // 4. í’€ ìˆ˜ ìˆëŠ” ë³´ë“œê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ 50íšŒ ì‹œë„ (ë¬´í•œë£¨í”„ ë°©ì§€)
                while (attempts < 50) {
                    const newBoard = new Array(TILE_COUNT).fill(null);
                    const shuffledTiles = shuffleArray([...remainingTiles]);
                    const shuffledIndices = shuffleArray([...allIndices]);
                    
                    // 5. ì„ì¸ ì¸ë±ìŠ¤ì— ì„ì¸ íƒ€ì¼ ë°°ì¹˜ (í©ë¿Œë¦¬ê¸°)
                    for (let i = 0; i < shuffledTiles.length; i++) {
                        newBoard[shuffledIndices[i]] = shuffledTiles[i];
                    }
                    
                    // 6. ì´ "í©ë¿Œë ¤ì§„" ìƒˆ ë³´ë“œê°€ í’€ ìˆ˜ ìˆëŠ”ì§€ ê²€ì‚¬
                    if (checkForAvailableMoves(newBoard)) {
                        console.log(`âœ… [Shuffle] ìƒˆ ë³´ë“œ(ë¶„ì‚°) ìƒì„± ì„±ê³µ! (ì‹œë„: ${attempts + 1})`);
                        return newBoard; // í’€ ìˆ˜ ìˆëŠ” ë³´ë“œ ë°˜í™˜!
                    }
                    
                    attempts++; // í’€ ìˆ˜ ì—†ìœ¼ë©´ ë‹¤ì‹œ ì‹œë„
                }

                // 7. 50íšŒ ì‹œë„ í›„ì—ë„ ì‹¤íŒ¨ ì‹œ
                console.error("ğŸ”¥ [Shuffle] 50íšŒ ì‹œë„í–ˆìœ¼ë‚˜ í’€ ìˆ˜ ìˆëŠ” ë¶„ì‚° ë³´ë“œ ìƒì„± ì‹¤íŒ¨.");
                // ê·¸ëƒ¥ ë§ˆì§€ë§‰ ì…”í”Œ ê²°ê³¼ë¥¼ ë°˜í™˜ (ê²Œì„ ì¢…ë£Œ ìœ ë„)
                const finalBoard = new Array(TILE_COUNT).fill(null);
                const shuffledTiles = shuffleArray([...remainingTiles]);
                const shuffledIndices = shuffleArray([...allIndices]);
                for (let i = 0; i < shuffledTiles.length; i++) {
                    finalBoard[shuffledIndices[i]] = shuffledTiles[i];
                }
                return finalBoard;
            }

            // --- [ì‹ ê·œ] ì…”í”Œ ë©”ì¸ í•¨ìˆ˜ (í˜¼ìí•˜ê¸° ë²„ì „) ---
            function checkAndShuffleIfNeeded(retryCount = 0) {
                if (isShuffling || !isGameLive) return; // ì…”í”Œ ì¤‘ì´ê±°ë‚˜ ê²Œì„ ì¢…ë£Œ ì‹œ ì¤‘ë‹¨

                const boardArray = gameBoardArray; // í˜„ì¬ ë¡œì»¬ ë³´ë“œ

                // 1. ê°€ëŠ¥í•œ ì›€ì§ì„ ê²€ì‚¬
                if (checkForAvailableMoves(boardArray)) {
                    console.log("[Solo Check] ì›€ì§ì„ ê°€ëŠ¥.");
                    return; // ë§‰íˆì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì¢…ë£Œ
                }

                // --- ë§‰í˜”ì„ ê²½ìš° ---
                isShuffling = true;
                console.log(`[Solo Shuffle] ë§‰í˜ ê°ì§€! (ì‹œë„: ${retryCount})`);

                // 2. ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ê²Œì„ ì¢…ë£Œ
                if (retryCount >= 2) { 
                    console.error("[Solo Shuffle] 2íšŒ ì…”í”Œ í›„ì—ë„ ë§‰í˜. ê²Œì„ ì˜¤ë²„.");
                    isGameLive = false;
                    gameOverFlag = true;
                    if (timerInterval) clearInterval(timerInterval);
                    playSound('loss-sound-new');
                    // "ê°•ì œ íŒ¨ë°°"ë¡œ ê²Œì„ ì¢…ë£Œ í™”ë©´ í‘œì‹œ
                    showGameOverScreen(true); 
                    return;
                }

                // 3. ì¬ë°°ì—´ UI í‘œì‹œ (ì˜¤ë²„ë ˆì´, í”ë“¤ë¦¼)
                infoOverlay.innerHTML = `<p style="color: white; font-size: 1.5em; font-weight: 700;">ğŸ² íƒ€ì¼ì„ ë‹¤ì‹œ ì„ê³  ìˆì–´ìš”! </p>`;
                infoOverlay.style.display = 'flex';
                gameBoard.classList.add('board-shake');
                playVibrationEffect();
playSound('junk-sound'); // [ìˆ˜ì •] 'shuffle' ëŒ€ì‹  'junk-sound' ì¬ìƒ
                // 4. (UI í‘œì‹œ ì‹œê°„ 2ì´ˆ) 2ì´ˆ ë’¤ì— ì‹¤ì œ ì…”í”Œ ì‹¤í–‰
                setTimeout(() => {
                    const newShuffledBoard = shuffleRemainingTiles(boardArray);
                    
                    gameBoardArray = newShuffledBoard; // ë¡œì»¬ ë³´ë“œ êµì²´
                    renderBoard(); // ìƒˆ ë³´ë“œë¡œ ë Œë”ë§

                    // 5. UI ìˆ¨ê¸°ê¸°
                    gameBoard.classList.remove('board-shake');
                    infoOverlay.style.display = 'none';
                    isShuffling = false; // í”Œë˜ê·¸ í•´ì œ

                    // 6. ì…”í”Œëœ ìƒˆ ë³´ë“œê°€ *ë˜* ë§‰í˜”ëŠ”ì§€ 0.5ì´ˆ ë’¤ ì¬ê·€ì ìœ¼ë¡œ ê²€ì‚¬
                    setTimeout(() => checkAndShuffleIfNeeded(retryCount + 1), 500);

                }, 2000); // 2ì´ˆê°„ "ì¬ë°°ì—´ ì¤‘" ë©”ì‹œì§€ í‘œì‹œ
            }

            // --- [ë³€ê²½] ì´ˆê¸°í™” í•¨ìˆ˜ (í˜¼ìí•˜ê¸°ìš©) ---
            function initialize() {
                // ë¡œë”© ì˜¤ë²„ë ˆì´ í‘œì‹œ
                infoOverlay.innerHTML = `<div class="spinner"></div><p style="color: white; margin-top: 15px; font-size: 1.1em;">í’€ ìˆ˜ ìˆëŠ” ë§µ ìƒì„± ì¤‘...</p>`;
                infoOverlay.style.display = 'flex';
                
                // ë§µ ìƒì„± (ë¹„ë™ê¸°ë¡œ ë³´ì´ê²Œ)
                setTimeout(() => {
                    startSoloGame();
                }, 50); // 0.05ì´ˆ ë”œë ˆì´
                
                // [ì‚­ì œ] ë’¤ë¡œê°€ê¸°/ë‚˜ê°€ê¸° ëª¨ë‹¬ ì´ë²¤íŠ¸ ì œê±°
            }

            // --- [ë³€ê²½] í˜¼ìí•˜ê¸° ê²Œì„ ì‹œì‘ í•¨ìˆ˜ ---
            function startSoloGame() {
                console.log("ì†”ë¡œ ê²Œì„ ë³´ë“œ ìƒì„± ì‹œì‘...");
                // ìƒíƒœ ì´ˆê¸°í™”
                gameOverFlag = false;
                isGameLive = false;
                isShuffling = false; // [ì‹ ê·œ] ì…”í”Œ í”Œë˜ê·¸ ë¦¬ì…‹
                currentScore = 0;
                gameTimer = 0;
                if (timerInterval) clearInterval(timerInterval);
                updateHeaderUI(); // ì ìˆ˜/ì‹œê°„ 0ìœ¼ë¡œ ë¦¬ì…‹
                selectedTileElement = null;

                // 1. íƒ€ì¼ ì¤€ë¹„
                const iconsNeeded = TILE_COUNT / 2;
                if (TILE_ICONS.length < iconsNeeded) {
                    alert("íƒ€ì¼ ì•„ì´ì½˜/ì´ë¯¸ì§€ ê°œìˆ˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                    return;
                }

                // 2. ë³´ë“œ ìƒì„± (ì—­ìˆœ ë°°ì¹˜)
                const board = createSolvableBoard(iconsNeeded);

                if (!board) {
                    console.error("ë³´ë“œ ìƒì„± ì‹¤íŒ¨!");
                    alert("ë§µ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
                    infoOverlay.innerHTML = `<p style="color: white;">ë§µ ìƒì„± ì‹¤íŒ¨!</p>`;
                    return;
                }

                gameBoardArray = board; // [ë³€ê²½] ë¡œì»¬ ë³€ìˆ˜ì— ë³´ë“œ ì €ì¥
                console.log("âœ… í’€ ìˆ˜ ìˆëŠ” ë³´ë“œ ìƒì„± ì™„ë£Œ!");

                // [ì‚­ì œ] Firebase ì—…ë°ì´íŠ¸ ë¡œì§ ì œê±°

                // 3. ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                startCountdown();
            }

            // --- [ìœ ì§€] í’€ì´ ê°€ëŠ¥ ë³´ë“œ ìƒì„± (ì—­ìˆœ ë°°ì¹˜) ---
            function createSolvableBoard(iconsNeeded) {
                const board = new Array(TILE_COUNT).fill(null);
                const selectedIcons = TILE_ICONS.slice(0, iconsNeeded);

                const tilePairs = [];
                selectedIcons.forEach(icon => {
                    tilePairs.push({ icon, placed: false });
                });
                shuffleArray(tilePairs);

                const placementOrder = [];
                for (const pair of tilePairs) {
                    const emptySpots = findEmptySpots(board);
                    if (emptySpots.length < 2) return null;

                    let placed = false;
                    shuffleArray(emptySpots); 

                    for (let i = 0; i < emptySpots.length && !placed; i++) {
                        for (let j = i + 1; j < emptySpots.length && !placed; j++) {
                            const pos1 = emptySpots[i];
                            const pos2 = emptySpots[j];
                            if (findPath_BFS(board, pos1, pos2)) {
                                board[pos1] = pair.icon;
                                board[pos2] = pair.icon;
                                placementOrder.push({ pos1, pos2, icon: pair.icon });
                                placed = true;
                            }
                        }
                    }
                    if (!placed) { // ì‹¤íŒ¨ ì‹œ ëœë¤ ë°°ì¹˜
                        const pos1 = emptySpots[0];
                        const pos2 = emptySpots[1];
                        board[pos1] = pair.icon;
                        board[pos2] = pair.icon;
                    }
                }
                console.log(`ğŸ“Š ë°°ì¹˜ ì™„ë£Œ: ${placementOrder.length}ê°œ ìŒ`);
                return board;
            }

            // --- [ë³€ê²½] ì¹´ìš´íŠ¸ë‹¤ìš´ í•¨ìˆ˜ (íƒ€ì´ë¨¸ ì‹œì‘ ì¶”ê°€) ---
            function startCountdown() {
                infoOverlay.style.display = 'flex';
                let count = 3;
                infoOverlay.innerHTML = `<div id="countdown-number">${count}</div>`;

                const interval = setInterval(() => {
                    count--;
                    const el = document.getElementById('countdown-number');
                    if (el) {
                        el.style.animation = 'none';
                        el.offsetHeight;
                        el.style.animation = '';
                        el.style.animationName = 'countdown-pop';
                        el.style.animationDuration = '1s';
                        el.textContent = count > 0 ? count : 'GO!';
                    }

                    if (count <= -1) { // GO! ë³´ì—¬ì£¼ê³  1ì´ˆ ë’¤
                        clearInterval(interval);
                        infoOverlay.style.display = 'none';
                        isGameLive = true;
                        renderBoard(); // ê²Œì„ ë³´ë“œ ë Œë”ë§
                        startTimer(); // [ì¶”ê°€] íƒ€ì´ë¨¸ ì‹œì‘

                        // [ì‹ ê·œ] ê²Œì„ ì‹œì‘ ì§í›„ ë§µì´ ë§‰í˜”ëŠ”ì§€ 0.5ì´ˆ ë’¤ ê²€ì‚¬
                        setTimeout(() => checkAndShuffleIfNeeded(0), 500); 
                    }
                }, 1000);
            }

            // --- [ì¶”ê°€] í˜¼ìí•˜ê¸° íƒ€ì´ë¨¸ í•¨ìˆ˜ ---
            function startTimer() {
                if (timerInterval) clearInterval(timerInterval);
                gameTimer = 0;
                startTime = Date.now();
                
                timerInterval = setInterval(() => {
                    if (!isGameLive) {
                        clearInterval(timerInterval);
                        return;
                    }
                    
                    // í˜„ì¬ ì‹œê°„(ì´ˆ) ê³„ì‚°
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    gameTimer = elapsed; // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                    
                    updateHeaderUI(); // í—¤ë” UI (ì‹œê°„ í‘œì‹œ) ì—…ë°ì´íŠ¸
                }, 1000);
            }

            // --- [ë³€ê²½] ê²Œì„íŒ ë Œë”ë§ (ë¡œì»¬ ë°ì´í„° ì‚¬ìš©) ---
            function renderBoard() {
                // [ë³€ê²½] currentRoomData -> gameBoardArray
                if (!gameBoardArray || gameBoardArray.length === 0) {
                     console.warn("renderBoard í˜¸ì¶œë˜ì—ˆìœ¼ë‚˜ ë¡œì»¬ board ë°ì´í„° ì—†ìŒ");
                     gameBoard.innerHTML = '<p style="color: #555;">ë³´ë“œ ë°ì´í„° ë¡œë”© ì¤‘...</p>';
                     return;
                 }
                 
                 // [ë³€ê²½] boardDataë¥¼ ë¡œì»¬ì—ì„œ ê°€ì ¸ì˜´
                 const boardData = gameBoardArray;
                 const boardArray = getBoardArray(boardData, TILE_COUNT);

                 // (ì´í•˜ ë³´ë“œ í¬ê¸° ê³„ì‚° ë¡œì§ì€ ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼)
                 const containerW = gameContainer.clientWidth;
                 const containerH = gameContainer.clientHeight;
                 const maxBoardW = containerW * 0.98;
                 const maxBoardH = containerH * 0.98;

                 let boardSizeW, boardSizeH;
                 const cellAspectRatio = 1;
                 const boardAspectRatio = (BOARD_COLS * cellAspectRatio) / BOARD_ROWS;

                 if (maxBoardW / boardAspectRatio < maxBoardH) {
                     boardSizeW = maxBoardW;
                     boardSizeH = maxBoardW / boardAspectRatio;
                 } else {
                     boardSizeH = maxBoardH;
                     boardSizeW = maxBoardH * boardAspectRatio;
                 }

                 gameBoard.style.width = `${boardSizeW}px`;
                 gameBoard.style.height = `${boardSizeH}px`;
                 gameBoard.style.gridTemplateColumns = `repeat(${BOARD_COLS}, 1fr)`;
                 gameBoard.style.gridTemplateRows = `repeat(${BOARD_ROWS}, 1fr)`;

                 currentGapSize = 1; // CSS ê°’
                 currentTileSize = (boardSizeW - (BOARD_COLS - 1) * currentGapSize - 4) / BOARD_COLS; // 4ëŠ” padding (2*2)

                 // (ì´í•˜ íƒ€ì¼ DOM ìƒì„± ë° ì—…ë°ì´íŠ¸ ë¡œì§ì€ ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼)
                 const existingTiles = new Map();
                 gameBoard.querySelectorAll('.tile').forEach(tile => {
                     existingTiles.set(parseInt(tile.dataset.index, 10), tile);
                 });

                 const fragment = document.createDocumentFragment();

                boardArray.forEach((tileIcon, index) => {
                    let tileEl = existingTiles.get(index);
                    const isEmpty = tileIcon === null;

                    if (!tileEl) {
                        tileEl = document.createElement('div');
                        tileEl.className = 'tile';
                        tileEl.dataset.index = index;
                        fragment.appendChild(tileEl);
                    }

                    tileEl.classList.toggle('hidden', isEmpty);

                    if (!isEmpty) {
                         const isImage = tileIcon.startsWith('.') || tileIcon.startsWith('http') || tileIcon.includes('/');
                         const currentContent = tileEl.firstChild;

                         if (isImage) {
                             if (!currentContent || currentContent.tagName !== 'IMG' || !currentContent.src.endsWith(tileIcon)) {
                                 tileEl.innerHTML = `<img src="${tileIcon}" alt="tile">`;
                             }
                         } else {
                             if (!currentContent || currentContent.nodeType !== Node.TEXT_NODE || currentContent.textContent !== tileIcon) {
                                 tileEl.textContent = tileIcon;
                             }
                             tileEl.style.fontSize = `${currentTileSize * 0.55}px`;
                         }
                         
                         // [ë³€ê²½] í´ë¦­ ë¦¬ìŠ¤ë„ˆë¥¼ isGameLiveë§Œ ì²´í¬í•˜ë„ë¡ (ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼)
                         if (isGameLive && !tileEl.onclick) {
                             tileEl.onclick = handleTileClick;
                         } else if (!isGameLive && tileEl.onclick) {
                             tileEl.onclick = null;
                         }
                    } else {
                        tileEl.innerHTML = '';
                        tileEl.onclick = null;
                    }
                    existingTiles.delete(index);
                });

                 existingTiles.forEach(tile => tile.remove());
                 gameBoard.appendChild(fragment);

                // (ì´í•˜ ìº”ë²„ìŠ¤ í¬ê¸°/ìœ„ì¹˜ ì¡°ì ˆ ë¡œì§ì€ ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼)
                 const boardStyle = window.getComputedStyle(gameBoard);
                 const boardPaddingLeft = parseFloat(boardStyle.paddingLeft) || 0;
                 const boardPaddingTop = parseFloat(boardStyle.paddingTop) || 0;
                 const boardBorderLeft = parseFloat(boardStyle.borderLeftWidth) || 0;
                 const boardBorderTop = parseFloat(boardStyle.borderTopWidth) || 0;

                currentExtraMargin = currentTileSize + currentGapSize; 

                const innerWidth = gameBoard.clientWidth - (boardPaddingLeft * 2) - (boardBorderLeft * 2);
                const innerHeight = gameBoard.clientHeight - (boardPaddingTop * 2) - (boardBorderTop * 2);

                const canvasWidth = innerWidth + currentExtraMargin * 2;
                const canvasHeight = innerHeight + currentExtraMargin * 2;

                pathCanvas.style.position = 'absolute';
                pathCanvas.style.left = `${gameBoard.offsetLeft + boardBorderLeft + boardPaddingLeft - currentExtraMargin}px`;
                pathCanvas.style.top = `${gameBoard.offsetTop + boardBorderTop + boardPaddingTop - currentExtraMargin}px`;

                pathCanvas.width = canvasWidth; 
                pathCanvas.height = canvasHeight;
                pathCanvas.style.width = `${canvasWidth}px`;
                pathCanvas.style.height = `${canvasHeight}px`;
            }

            // --- [ë³€ê²½] íƒ€ì¼ í´ë¦­ ì²˜ë¦¬ (ë¡œì»¬) ---
            function handleTileClick(event) {
                if (!isGameLive || isShuffling) return; // [ìˆ˜ì •] ì…”í”Œ ì¤‘ í´ë¦­ ë°©ì§€

                const clickedEl = event.currentTarget;
                const clickedIndex = parseInt(clickedEl.dataset.index, 10);
                // [ë³€ê²½] ë¡œì»¬ ë³´ë“œì—ì„œ ì•„ì´ì½˜ ì¡°íšŒ
                const clickedIcon = gameBoardArray[clickedIndex];

                if (clickedIcon === null || clickedEl.classList.contains('hidden')) return;

                playSound('tile-select-sound');

                // 1. ì„ íƒëœ íƒ€ì¼ì´ ì—†ìŒ (ì²« ë²ˆì§¸ í´ë¦­)
                if (!selectedTileElement) {
                    selectedTileElement = clickedEl;
                    clickedEl.classList.add('selected');
                    return;
                }

                // 2. ì´ë¯¸ ì„ íƒëœ íƒ€ì¼ì„ ë‹¤ì‹œ í´ë¦­ (ì„ íƒ ì·¨ì†Œ)
                if (selectedTileElement === clickedEl) {
                    selectedTileElement.classList.remove('selected');
                    selectedTileElement = null;
                    return;
                }

                // 3. ë‘ ë²ˆì§¸ íƒ€ì¼ í´ë¦­
                const firstIndex = parseInt(selectedTileElement.dataset.index, 10);
                // [ë³€ê²½] ë¡œì»¬ ë³´ë“œì—ì„œ ì•„ì´ì½˜ ì¡°íšŒ
                const firstIcon = gameBoardArray[firstIndex];

                // 3-1. ì•„ì´ì½˜ì´ ê°™ì€ì§€ í™•ì¸
                if (firstIcon === clickedIcon) {
                    // 3-2. ê²½ë¡œ íƒìƒ‰ (ë¡œì»¬ ë³´ë“œ ì‚¬ìš©)
                    const path = findPath_BFS(gameBoardArray, firstIndex, clickedIndex);

                    if (path) {
                        // ë§¤ì¹­ ì„±ê³µ!
                        drawAnimatedPath(path); // ê²½ë¡œ ê·¸ë¦¬ê¸°
                        playSound('tile-match-sound-new');

                        // [ë³€ê²½] ë¡œì»¬ ë³´ë“œì—ì„œ íƒ€ì¼ ì¦‰ì‹œ ì œê±°
                        gameBoardArray[firstIndex] = null;
                        gameBoardArray[clickedIndex] = null;

                        // [ë³€ê²½] UIì—ì„œ íƒ€ì¼ ì¦‰ì‹œ ìˆ¨ê¸°ê¸°
                        selectedTileElement.classList.add('hidden');
                        clickedEl.classList.add('hidden');

                        // [ë³€ê²½] ë¡œì»¬ ì ìˆ˜ ì—…ë°ì´íŠ¸
                        currentScore++;
                        updateHeaderUI();

                        // [ë³€ê²½] ë¡œì»¬ ì„ íƒ ì´ˆê¸°í™”
                        selectedTileElement.classList.remove('selected');
                        selectedTileElement = null;
                        
                        // [ì¶”ê°€] ê²Œì„ ì¢…ë£Œ í™•ì¸
                        checkGameEnd();

                        // [ì‹ ê·œ] íƒ€ì¼ì„ ë§ì¶˜ í›„, ê²Œì„ì´ ì•ˆ ëë‚¬ë‹¤ë©´ 0.1ì´ˆ ë’¤ ë§µ ê²€ì‚¬
                        if (isGameLive) {
                            setTimeout(() => checkAndShuffleIfNeeded(0), 100);
                        }

                    } else {
                        // ê²½ë¡œ ì—†ìŒ -> ë‘ ë²ˆì§¸ íƒ€ì¼ì„ ìƒˆ ì„ íƒìœ¼ë¡œ
                        selectedTileElement.classList.remove('selected');
                        selectedTileElement = clickedEl;
                        clickedEl.classList.add('selected');
                        playVibrationEffect(); // [ì¶”ê°€] ì‹¤íŒ¨ ì‹œ ì§„ë™
                    }
                } else {
                    // ì•„ì´ì½˜ ë‹¤ë¦„ -> ë‘ ë²ˆì§¸ íƒ€ì¼ì„ ìƒˆ ì„ íƒìœ¼ë¡œ
                    selectedTileElement.classList.remove('selected');
                    selectedTileElement = clickedEl;
                    clickedEl.classList.add('selected');
                }
                
                // [ì‚­ì œ] Firebase (selectedTiles, attemptTileRemoval) ê´€ë ¨ ë¡œì§ ëª¨ë‘ ì œê±°
            }

            // [ì‚­ì œ] updateMySelection() í•¨ìˆ˜ ì œê±°

            // --- [ìœ ì§€] ê²½ë¡œ íƒìƒ‰ (BFS) í•¨ìˆ˜ ---
            // (ë©€í‹°í”Œë ˆì´ ë²„ì „ê³¼ ë™ì¼)
            function findPath_BFS(board, startIndex, endIndex) {
                const V_ROWS = BOARD_ROWS + 2;
                const V_COLS = BOARD_COLS + 2;
                const virtualBoard = Array(V_ROWS * V_COLS).fill(null);

                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        const boardIndex = r * BOARD_COLS + c;
                        const virtualIndex = (r + 1) * V_COLS + (c + 1);
                        if (board[boardIndex] !== null) {
                            virtualBoard[virtualIndex] = 1; // íƒ€ì¼ ìˆìŒ
                        }
                    }
                }

                const startR = Math.floor(startIndex / BOARD_COLS) + 1;
                const startC = startIndex % BOARD_COLS + 1;
                const vStartIndex = startR * V_COLS + startC;

                const endR = Math.floor(endIndex / BOARD_COLS) + 1;
                const endC = endIndex % BOARD_COLS + 1;
                const vEndIndex = endR * V_COLS + endC;

                const queue = [{ i: vStartIndex, t: 0, d: 0, p: null }];
                const visited = Array(V_ROWS * V_COLS).fill(null);
                visited[vStartIndex] = { t: 0, p: -1 }; 

                const directions = [
                    { dr: -1, dc: 0, d: 1 }, // ìƒ
                    { dr: 1, dc: 0, d: 2 },  // í•˜
                    { dr: 0, dc: -1, d: 3 }, // ì¢Œ
                    { dr: 0, dc: 1, d: 4 }   // ìš°
                ];

                let endNode = null;

                while (queue.length > 0) {
                    const { i, t, d, p } = queue.shift();
                    if (i === vEndIndex) { endNode = { i, t, d, p }; break; }

                    for (const move of directions) {
                        const nextR = Math.floor(i / V_COLS) + move.dr;
                        const nextC = i % V_COLS + move.dc;
                        const nextIndex = nextR * V_COLS + nextC;

                        if (nextR < 0 || nextR >= V_ROWS || nextC < 0 || nextC >= V_COLS) continue;
                        if (virtualBoard[nextIndex] !== null && nextIndex !== vEndIndex) continue;

                        const nextTurns = (d !== 0 && d !== move.d) ? t + 1 : t;
                        if (nextTurns > 2) continue;

                        if (!visited[nextIndex] || visited[nextIndex].t >= nextTurns) {
                            visited[nextIndex] = { t: nextTurns, p: i };
                            queue.push({ i: nextIndex, t: nextTurns, d: move.d, p: i });
                        }
                    }
                }

                if (endNode) {
                    const path = [];
                    let currentIdx = endNode.i;
                    while (currentIdx !== -1 && visited[currentIdx]) {
                        path.push(currentIdx);
                        currentIdx = visited[currentIdx].p;
                    }
                    return path.reverse();
                }
                return null;
            }

            // --- [ìœ ì§€] ìº”ë²„ìŠ¤ ì¢Œí‘œ ë³€í™˜ í—¬í¼ ---
            function _getPathPixelCoords(path) {
                const pixelPath = [];
                for (let i = 0; i < path.length; i++) {
                    const virtualIndex = path[i];
                    const vR = Math.floor(virtualIndex / (BOARD_COLS + 2));
                    const vC = virtualIndex % (BOARD_COLS + 2);
                    const bR = vR - 1;
                    const bC = vC - 1;
                    
                    const x = bC * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    const y = bR * (currentTileSize + currentGapSize) + (currentTileSize / 2) + currentExtraMargin;
                    
                    pixelPath.push({ x, y });
                }
                return pixelPath;
            }

            // --- [ìœ ì§€] ìº”ë²„ìŠ¤ ê²½ë¡œ ê·¸ë¦¬ê¸° ì• ë‹ˆë©”ì´ì…˜ ---
            let currentAnimationId = null;
            function drawAnimatedPath(path) {
                if (!ctx || !path || path.length < 2) return;
                if (currentAnimationId) cancelAnimationFrame(currentAnimationId);

                const pixelPath = _getPathPixelCoords(path);
                const totalSegments = pixelPath.length - 1;
                if (totalSegments <= 0) return;

                const DURATION = 300;
                const startTime = performance.now();
                const segmentProgress = 1.0 / totalSegments;

                ctx.strokeStyle = "#4A8DFF";
                ctx.lineWidth = 6;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.shadowColor = "rgba(74, 141, 255, 0.7)";
                ctx.shadowBlur = 10;

                function animate(timestamp) {
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / DURATION, 1.0);

                    ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                    ctx.beginPath();
                    ctx.moveTo(pixelPath[0].x, pixelPath[0].y);

                    let currentProgress = 0.0;
                    for (let i = 1; i < pixelPath.length; i++) {
                        const segmentT = Math.min(Math.max(progress - currentProgress, 0) / segmentProgress, 1.0);
                        if (segmentT > 0) {
                            const prev = pixelPath[i - 1];
                            const curr = pixelPath[i];
                            const interpX = prev.x + (curr.x - prev.x) * segmentT;
                            const interpY = prev.y + (curr.y - prev.y) * segmentT;
                            ctx.lineTo(interpX, interpY);
                        }
                        currentProgress += segmentProgress;
                        if (segmentT < 1.0) break; 
                    }
                    ctx.stroke();

                    if (progress < 1.0) {
                        currentAnimationId = requestAnimationFrame(animate);
                    } else {
                        currentAnimationId = null;
                        setTimeout(() => {
                            if (ctx) {
                                ctx.shadowColor = "transparent"; 
                                ctx.shadowBlur = 0;
                                ctx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
                            }
                        }, 100); 
                    }
                }
                currentAnimationId = requestAnimationFrame(animate);
            }

            // [ì‚­ì œ] attemptTileRemoval() (íŠ¸ëœì­ì…˜ í•¨ìˆ˜) ì œê±°

            // --- [ì¶”ê°€] ê²Œì„ ì¢…ë£Œ í™•ì¸ í•¨ìˆ˜ ---
            function checkGameEnd() {
                // ë¡œì»¬ ë³´ë“œì— ë‚¨ì€ íƒ€ì¼ì´ ìˆëŠ”ì§€ í™•ì¸
                const remainingTiles = gameBoardArray.filter(tile => tile !== null).length;
                
                if (remainingTiles === 0) {
                    isGameLive = false;
                    gameOverFlag = true;
                    clearInterval(timerInterval); // íƒ€ì´ë¨¸ ì¤‘ì§€
                    playSound('win-sound-new');
                    
                    // 0.5ì´ˆ í›„ ê²Œì„ ì¢…ë£Œ í™”ë©´ í‘œì‹œ (íƒ€ì¼ ì‚¬ë¼ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„)
                    setTimeout(showGameOverScreen, 500); 
                }
            }

            // --- [ë³€ê²½] í—¤ë” UI ì—…ë°ì´íŠ¸ (í˜¼ìí•˜ê¸°ìš©) ---
            function updateHeaderUI() {
                if(scoreDisplay) scoreDisplay.textContent = `ì ìˆ˜: ${currentScore}`;
                
                if(timerDisplay) {
                    const minutes = Math.floor(gameTimer / 60).toString().padStart(2, '0');
                    const seconds = (gameTimer % 60).toString().padStart(2, '0');
                    timerDisplay.textContent = `ì‹œê°„: ${minutes}:${seconds}`;
                }
            }

            // --- [ë³€ê²½] ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬ (í˜¼ìí•˜ê¸°ìš©) ---
            function showGameOverScreen(forceLoss = false) { // [ìˆ˜ì •] forceLoss íŒŒë¼ë¯¸í„° ì¶”ê°€
                 const finalTime = timerDisplay.textContent; // "ì‹œê°„: MM:SS"

                 // [ìˆ˜ì •] ê°•ì œ íŒ¨ë°° ì—¬ë¶€ì— ë”°ë¼ ì œëª©ê³¼ ë‚´ìš© ë³€ê²½
                 const title = forceLoss ? "ğŸ˜¢ ê²Œì„ ì˜¤ë²„" : "ğŸ‰ í´ë¦¬ì–´!";
                 const bodyContent = forceLoss 
                    ? `<p style="font-size: 1.1em; margin-bottom: 10px;">ë” ì´ìƒ ë§ì¶œ ìˆ˜ ìˆëŠ”<br>íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                       <p style="font-size: 1.1em; margin-bottom: 25px;">${finalTime}</p>`
                    : `<h3 style="font-size: 1.4em; margin-bottom: 10px;">ìµœì¢… ì ìˆ˜: ${currentScore}</h3>
                       <p style="font-size: 1.1em; margin-bottom: 25px;">${finalTime}</p>`;

                 gameOverOverlay.innerHTML = `
                     <div class="modal-content">
                         <div class="modal-header"><h2>${title}</h2></div>
                         <div class="modal-body" style="text-align: center;">
                             ${bodyContent}
                             <div class="modal-buttons">
                                 <button id="restart-btn" class="menu-btn primary">ë‹¤ì‹œ í•˜ê¸°</button>
                             </div>
                         </div>
                     </div>`;
                 gameOverOverlay.style.display = 'flex';

                 // [ë³€ê²½] 'ë‹¤ì‹œ í•˜ê¸°' ë²„íŠ¼ (ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  initialize() í˜¸ì¶œ)
                 document.getElementById('restart-btn').addEventListener('click', () => {
                     gameOverOverlay.style.display = 'none';
                     initialize(); // ë¡œë”© ìŠ¤í”¼ë„ˆë¶€í„° ë‹¤ì‹œ ì‹œì‘
                 });
                 
                 // [ì‚­ì œ] 'ëŒ€ê¸°ì‹¤ë¡œ' ë²„íŠ¼ ë° ë¦¬ë§¤ì¹˜ ë¡œì§ ì œê±°
            }

  
            // --- ì´ˆê¸°í™” í•¨ìˆ˜ í˜¸ì¶œ ---
            initialize();
        });
    </script>
</body>
</html>
