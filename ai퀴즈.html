<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI ìŠ¤í”¼ë“œí€´ì¦ˆ</title>
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff') format('woff');
            font-weight: 500;
        }
        @font-face {
            font-family: 'GmarketSans';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
            font-weight: 700;
        }

        :root {
            --bg-color: #2c3e50;
            --board-bg: #34495e;
            --border-color: #2c3e50;
            --primary-color: #4a8dff;
            --accent-color: #ffc84a;
            --correct-color: #2ecc71;
            --incorrect-color: #e74c3c;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
        }
        #game-header {
            flex-shrink: 0; display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 10px; background-color: rgba(0,0,0,0.3);
            gap: 8px;
        }
        
        .player-info {
            display: flex; align-items: center; gap: 8px;
            background-color: rgba(255,255,255,0.1);
            padding: 8px; border-radius: 10px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .player-info.my-turn {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
        }
        .player-info .avatar { 
            font-size: 1.5em; 
            width: 32px; height: 32px;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0;
        }
        .player-info .avatar img {
            width: 100%; height: 100%;
            object-fit: contain; border-radius: 50%;
        }
        .player-info .details {
            display: flex; flex-direction: column;
            min-width: 0;
        }
        .player-info .nickname {
            font-weight: 700; font-size: 0.9em;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .player-info .score {
            font-weight: 700; font-size: 1em;
            color: var(--accent-color);
        }

        #game-container {
            width: 100%; flex-grow: 1;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            position: relative; overflow: hidden; padding: 20px;
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
        }

        #quiz-area {
            width: 100%;
            background-color: var(--board-bg);
            border: 8px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 25px;
            display: flex; flex-direction: column;
            gap: 20px;
            max-width: 500px;
        }

        #round-info {
            text-align: center;
            font-size: 1.2em;
            font-weight: 700;
            color: var(--accent-color);
        }

        #question-text {
            font-size: 1.5em;
            font-weight: 700;
            text-align: center;
            /* min-height: 100px; */ /* ë†’ì´ë¥¼ ì•„ë˜ descë¡œ ì´ë™ */
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 10px; /* ìƒë‹¨ ì—¬ë°± */
        }

        /* â–¼â–¼â–¼ [ì‹ ê·œ] ë¬¸ì œ ëœ»í’€ì´ ìŠ¤íƒ€ì¼ â–¼â–¼â–¼ */
        #question-desc {
            font-size: 0.9em; /* ë” ì‘ì€ í°íŠ¸ */
            font-weight: 500;
            color: var(--accent-color); /* ë…¸ë€ìƒ‰ */
            text-align: center;
            padding: 0 15px;
            min-height: 60px; /* ìµœì†Œ ë†’ì´ í™•ë³´ */
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
            justify-content: center;
            align-items: center;
        }
        /* â–²â–²â–² [ì‹ ê·œ] â–²â–²â–² */

        #round-timer-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }
        #round-timer-fill {
            width: 100%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.1s linear;
        }
        
        #options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        .option-btn {
            width: 100%;
            padding: 20px;
            font-size: 1.1em;
            font-weight: 700;
            font-family: 'GmarketSans', sans-serif;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            background-color: #ecf0f1;
            color: #34495e;
            transition: all 0.2s ease;
        }
        .option-btn:not(:disabled):hover {
            transform: scale(1.03);
        }
        .option-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .option-btn.selected {
            background-color: var(--primary-color);
            color: white;
        }
        .option-btn.correct {
            background-color: var(--correct-color);
            color: white;
            animation: pulse-correct 0.5s;
        }
        .option-btn.incorrect {
            background-color: var(--incorrect-color);
            color: white;
            opacity: 0.5;
        }
        @keyframes pulse-correct {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* ì˜¤ë²„ë ˆì´ ë° ëª¨ë‹¬ (ë¦¬ë²„ì‹œ.htmlì—ì„œ ê°€ì ¸ì˜´) */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; text-align: center; background-color: rgba(0,0,0,0.7); }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid white; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .modal-content { background: #2c3e50; color: white; padding: 0; border-radius: 20px; width: 90%; max-width: 400px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); overflow: hidden; }
        .modal-header { background-color: #34495e; padding: 15px; }
        .modal-header h2 { font-size: 1.8em; }
        .modal-body { padding: 25px; }
        .modal-buttons { display: flex; flex-direction: column; gap: 12px; align-items: center; margin-top: 25px; }
        .menu-btn { width: 100%; padding: 15px; font-size: 1.2em; font-weight: bold; border-radius: 12px; border: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; margin: 8px 0; }
        .menu-btn.primary { background-color: var(--primary-color); color: white; }
        .menu-btn.secondary { background-color: #e9eff8; color: #333; }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn:disabled { background-color: #ccc; color: #888; cursor: not-allowed; }
        
        #countdown-number { font-size: 8em; font-weight: 700; color: white; text-shadow: 0 0 30px rgba(255,255,255,0.8); animation: countdown-pop 1s; }
        @keyframes countdown-pop { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #score-board { margin: 20px 0; }
        .score-row { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-radius: 8px; font-size: 1.2em; font-weight: 700; margin: 8px auto; max-width: 300px; }
        .score-row.winner { background-color: var(--accent-color); color: #111; transform: scale(1.05); }
        .score-row.loser { background-color: #f0f3f4; color: #333; }
        
        .score-avatar { display: inline-flex; align-items: center; gap: 8px; }
        .score-avatar img { width: 28px; height: 28px; object-fit: contain; border-radius: 50%; }

        /* ì£¼ì œ ì„ íƒ ëª¨ë‹¬ìš© ë²„íŠ¼ */
        .topic-btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        /* â–¼â–¼â–¼ [ì‹ ê·œ] í”„ë¡œê·¸ë ˆìŠ¤ ë°” ìŠ¤íƒ€ì¼ â–¼â–¼â–¼ */
        #progress-bar-container {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
            width: 70%;    /* ë„ˆë¹„ ì¡°ì • */
            max-width: 300px; /* ìµœëŒ€ ë„ˆë¹„ */
            height: 12px;   /* ë†’ì´ ì¡°ì • */
            background-color: rgba(0, 0, 0, 0.4); /* ë°°ê²½ìƒ‰ ì•½ê°„ ì–´ë‘¡ê²Œ */
            border-radius: 6px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            overflow: hidden;
            margin-top: 20px; /* ìœ„ìª½ í…ìŠ¤íŠ¸ì™€ì˜ ê°„ê²© */
            margin-left: auto;  /* â–¼â–¼â–¼ [ì¶”ê°€] ê°€ìš´ë° ì •ë ¬ â–¼â–¼â–¼ */
            margin-right: auto; /* â–²â–²â–² [ì¶”ê°€] ê°€ìš´ë° ì •ë ¬ â–²â–²â–² */
        }
        #progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color); /* ì±„ì›Œì§€ëŠ” ìƒ‰ */
            border-radius: 6px;
            transition: width 0.3s ease-out; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ */
        }
        /* â–²â–²â–² [ì‹ ê·œ] â–²â–²â–² */
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-header"></div>
        <div id="game-container">
            <div id="quiz-area" style="display: none;">
                <div id="round-info">Round 1 / 30</div>
                <div id="round-timer-bar"><div id="round-timer-fill"></div></div>
                <div id="question-text">ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>
                <div id="question-desc"></div>
                                               <div id="options-grid">
                    <button class="option-btn" data-index="0"></button>
                    <button class="option-btn" data-index="1"></button>
                    <button class="option-btn" data-index="2"></button>
                    <button class="option-btn" data-index="3"></button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="game-over-overlay" class="overlay" style="display: none;"></div>
    
    <div id="info-overlay" class="overlay">
        <div class="modal-content" style="background: transparent; box-shadow: none;">
             <p id="info-text" style="color: white; font-size: 1.3em; margin-bottom: 20px;">ê²Œì„ì— ì°¸ê°€í•˜ëŠ” ì¤‘...</p>
            <div id="info-spinner" class="spinner"></div>
<div id="progress-bar-container">
                <div id="progress-bar-fill"></div>
            </div>
            <button id="host-retry-btn" class="menu-btn secondary" style="display: none;">API í˜¸ì¶œ ì¬ì‹œë„</button>
        </div>
    </div>
    
    <div id="topic-modal" class="overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header"><h2 id="topic-modal-title">ê²Œì„ ì£¼ì œ ì„ íƒ</h2></div>
            <div class="modal-body">
                <p id="topic-modal-desc">ë°©ì¥ì´ ì²« 10ë¼ìš´ë“œì˜ ì£¼ì œë¥¼ ì„ íƒí•©ë‹ˆë‹¤.</p>
                <div class="topic-btn-grid modal-buttons">
                    <button class="menu-btn primary" data-topic="english">ğŸ” ì˜ì–´ ë‹¨ì–´</button>
                    <button class="menu-btn primary" data-topic="proverb">ğŸ“œì†ë‹´</button>
                    <button class="menu-btn primary" data-topic="idiom">ğŸ“–ì‚¬ìì„±ì–´</button>
                    <button class="menu-btn primary" data-topic="capital">ğŸŒìˆ˜ë„</button>
                    <button class="menu-btn primary" data-topic="history">ğŸ‘‘í•œêµ­ì‚¬</button>
                    <button class="menu-btn primary" data-topic="easy_words">ğŸ“šë‚±ë§ í€´ì¦ˆ</button>
                    <button class="menu-btn primary" data-topic="random">ğŸ²ëœë¤</button>
                </div>
            </div>
        </div>
    </div>

   <audio id="click-sound" src="https://blog.kakaocdn.net/dna/dC0WAE/dJMb84DsZw6/AAAAAAAAAAAAAAAAAAAAAC8XpuPuNVEsdp6Ia-d35XR-m3FCZxObUR5uFI1tk2iv/%EB%B2%84%ED%8A%BC%EC%82%AC%EC%9A%B4%EB%93%9C.mp3?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=RdbjxdP75HLHSpBIhymVkYpUOA0%3D&attach=1&knm=tfile.mp3" preload="auto"></audio>
    <audio id="correct-sound" src="sound/í€´ì¦ˆì •ë‹µ.mp3" preload="auto"></audio>
    <audio id="win-sound" src="sound/ê²Œì„ìŠ¹ë¦¬.mp3" preload="auto"></audio>
    <audio id="loss-sound" src="sound/ê²Œì„íŒ¨ë°°.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sound/í€´ì¦ˆì˜¤ë‹µ.mp3" preload="auto"></audio>

    <script src="ì•„ë°”íƒ€.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    
    <script>
        // --- Gemini API ì„¤ì • ---
        const API_KEYS = [
            "AIzaSyD55Qjfm4u8vhmki6-6JE3qshThouFYFBQ", // 1ë²ˆ í‚¤
            "AIzaSyDKWwTVn6nl0YfoW7Anwx51plicNqWOhQw"  // 2ë²ˆ í‚¤
        ];

        // â–¼â–¼â–¼ TTS ê´€ë ¨ ë³€ìˆ˜ ë° ì´ˆê¸°í™” â–¼â–¼â–¼
        let synth = window.speechSynthesis;
        let voices = [];

        function populateVoiceList() {
            voices = synth.getVoices().sort(function (a, b) {
                const aname = a.name.toUpperCase();
                const bname = b.name.toUpperCase();
                if (aname < bname) return -1;
                else if (aname == bname) return 0;
                else return +1;
            });
            // console.log("Available voices:", voices); // ì‚¬ìš© ê°€ëŠ¥í•œ ìŒì„± ëª©ë¡ í™•ì¸ìš©
        }

        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }


        let currentKeyIndex = 0;
        const currentModel = "gemini-2.5-flash-lite"; // ì†ë„ê°€ ë¹ ë¥¸ Flash ëª¨ë¸ ì‚¬ìš©

        // â–¼â–¼â–¼ [ì‹ ê·œ] ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì¤„ ì£¼ì œëª… (UX ê°œì„ ìš©) â–¼â–¼â–¼
        const topicMapForDisplay = {
            "english": "ğŸ” ì˜ì–´ë‹¨ì–´",
            "proverb": "ğŸ“œì†ë‹´",
            "idiom": "ğŸ“–ì‚¬ìì„±ì–´",
            "capital": "ğŸŒìˆ˜ë„",
            "history": "ğŸ‘‘ì—­ì‚¬",
            "easy_words": "ğŸ“šë‚±ë§í€´ì¦ˆ"
        };
        // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²

        // API í‚¤ ìˆœí™˜ í•¨ìˆ˜
        function rotateKey() {
            currentKeyIndex = (currentKeyIndex + 1) % API_KEYS.length;
            console.warn(`API í‚¤ 429 ì˜¤ë¥˜. ë‹¤ìŒ í‚¤ë¡œ êµì²´í•©ë‹ˆë‹¤: (index ${currentKeyIndex})`);
            return API_KEYS[currentKeyIndex];
        }

        // Gemini API í˜¸ì¶œ í•¨ìˆ˜ (429 ì¬ì‹œë„ ë¡œì§ í¬í•¨)
        // Gemini API í˜¸ì¶œ í•¨ìˆ˜ (JSON íŒŒì‹± ê°•í™”)
        async function callGeminiAPI(prompt) {
    let key = API_KEYS[currentKeyIndex];
    let url = `https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${key}`;

    const requestBody = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
            temperature: 0.9,
            topK: 40,
            topP: 1,
            maxOutputTokens: 8192,
            // â–¼â–¼â–¼ [ì¤‘ìš”] JSON ëª¨ë“œ í•´ì œ (ì´ ì¤„ì„ ì‚­ì œí•˜ê±°ë‚˜ text/plainìœ¼ë¡œ ë³€ê²½) â–¼â–¼â–¼
            responseMimeType: "text/plain" 
        },
        safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
        ]
    };

    try {
        let response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (response.status === 429) {
            key = rotateKey();
            url = `https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${key}`;
            response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
        }

        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }

        const data = await response.json();
        
        if (!data.candidates || !data.candidates[0].content) {
            throw new Error("AIê°€ ì‘ë‹µí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        }

        let rawText = data.candidates[0].content.parts[0].text;
        
        // â–¼â–¼â–¼ [ìˆ˜ì •ë¨] í…ìŠ¤íŠ¸ íŒŒì‹± ë¡œì§ (JSON.parse ëŒ€ì‹  split ì‚¬ìš©) â–¼â–¼â–¼
        // ë§ˆí¬ë‹¤ìš´ ì œê±°
        rawText = rawText.replace(/```/g, "").trim();

        const quizList = [];
        const lines = rawText.split('\n'); // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¬¸ì œ ë‚˜ëˆ„ê¸°

        lines.forEach(line => {
            if (line.trim() === "") return; // ë¹ˆ ì¤„ ë¬´ì‹œ
            
            // íŒŒì´í”„(|)ë¡œ ë°ì´í„° ìª¼ê°œê¸°
            const parts = line.split('|').map(p => p.trim());
            
            // ë°ì´í„°ê°€ 5ê°œ(ë¬¸ì œ, ì •ë‹µ, ì˜¤ë‹µ3ê°œ) ë‹¤ ìˆëŠ”ì§€ í™•ì¸
            if (parts.length >= 5) {
                quizList.push({
                    question: parts[0],
                    correct: parts[1],
                    incorrect: [parts[2], parts[3], parts[4]]
                });
            }
        });

        if (quizList.length === 0) {
            throw new Error("íŒŒì‹±ëœ í€´ì¦ˆê°€ ì—†ìŠµë‹ˆë‹¤. í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }

        return quizList; 
        // â–²â–²â–² [ìˆ˜ì • ì™„ë£Œ] â–²â–²â–²

    } catch (error) {
        console.error("Gemini API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜:", error);
        throw error; 
    }
}

                                       // â–¼â–¼â–¼ [ìˆ˜ì •] í€´ì¦ˆ ìƒì„± í”„ë¡¬í”„íŠ¸ (ì˜ì–´ í€´ì¦ˆ: ì˜ë‹¨ì–´ -> í•œê¸€ ëœ» ë°©ì‹ìœ¼ë¡œ ë³µêµ¬) â–¼â–¼â–¼
       function getPromptForTopic(topic) {
    const topicInstructions = {
        "english": "questionì€ 'chair' ê°™ì€ ì´ˆ/ì¤‘ê¸‰ ì˜ì–´ ëª…ì‚¬, correctëŠ” í•œê¸€ ëœ»('ì˜ì'), incorrectëŠ” í—·ê°ˆë¦¬ëŠ” ë‹¤ë¥¸ í•œê¸€ ëª…ì‚¬ 3ê°œ.",
        "proverb": "questionì€ ì†ë‹´ì˜ ëœ»í’€ì´, correctëŠ” ì†ë‹´ ì›ë¬¸, incorrectëŠ” ë‹¤ë¥¸ ì†ë‹´ 3ê°œ.",
        "idiom": "questionì€ ì‚¬ìì„±ì–´ ëœ»í’€ì´, correctëŠ” ì‚¬ìì„±ì–´, incorrectëŠ” ë‹¤ë¥¸ ì‚¬ìì„±ì–´ 3ê°œ.",
        "capital": "questionì€ êµ­ê°€ ì´ë¦„(ì˜ˆ: 'í”„ë‘ìŠ¤'), correctëŠ” ìˆ˜ë„ ì´ë¦„, incorrectëŠ” ë‹¤ë¥¸ ë„ì‹œ ì´ë¦„ 3ê°œ.",
        "history": "questionì€ í•œêµ­ì‚¬ ë¬¸ì œ ì„¤ëª…, correctëŠ” ì •ë‹µ ë‹¨ì–´, incorrectëŠ” ì˜¤ë‹µ ë‹¨ì–´ 3ê°œ.",
        "easy_words": "questionì€ ì‰¬ìš´ ë‹¨ì–´ ì„¤ëª…, correctëŠ” ì •ë‹µ ë‹¨ì–´, incorrectëŠ” ë‹¤ë¥¸ ë‹¨ì–´ 3ê°œ."
    };

    let finalTopic = topic;
    if (topic === "random") {
        const topics = Object.keys(topicInstructions);
        finalTopic = topics[Math.floor(Math.random() * topics.length)];
    }

    const instruction = topicInstructions[finalTopic];

    // â–¼â–¼â–¼ [ìˆ˜ì •ë¨] JSON ê´€ë ¨ ë‚´ìš© ì œê±° ë° íŒŒì´í”„(|) í¬ë§· ì§€ì‹œ â–¼â–¼â–¼
    const promptHeader = `ë„ˆëŠ” ìŠ¤í”¼ë“œ í€´ì¦ˆ ì¶œì œìì…ë‹ˆë‹¤.
ë‹¤ìŒ ê·œì¹™ì— ë§ì¶° í€´ì¦ˆ 10ê°œë¥¼ ì‘ì„±í•´ì„œ ìˆœìˆ˜í•œ í…ìŠ¤íŠ¸ë¡œë§Œ ë‹µí•´ì£¼ì„¸ìš”. (JSON ê¸ˆì§€)

[ì¶œì œ ê·œì¹™]
1. ì£¼ì œ: ${instruction}
2. í˜•ì‹: ê° ì¤„ë§ˆë‹¤ "ë¬¸ì œ|ì •ë‹µ|ì˜¤ë‹µ1|ì˜¤ë‹µ2|ì˜¤ë‹µ3" í˜•íƒœë¡œ ì‘ì„±í•˜ì„¸ìš”. (êµ¬ë¶„ìëŠ” ìˆ˜ì§ì„  | ì‚¬ìš©)
3. ì˜¤ë‹µì€ ë°˜ë“œì‹œ 3ê°œì—¬ì•¼ í•©ë‹ˆë‹¤.
4. ì²« ì¤„ë¶€í„° ë°”ë¡œ ë¬¸ì œë¥¼ ì‘ì„±í•˜ê³ , ë‹¤ë¥¸ ì¸ì‚¬ë§ì´ë‚˜ ë§ˆí¬ë‹¤ìš´(\`\`\`)ì€ ì ˆëŒ€ ë„£ì§€ ë§ˆì„¸ìš”.

[ì‘ì„± ì˜ˆì‹œ]
ì‚¬ê³¼ì˜ ìƒ‰ê¹”ì€?|ë¹¨ê°•|íŒŒë‘|ë³´ë¼|ê²€ì •
ë°”ë‹¤ì— ì‚¬ëŠ” ë™ë¬¼ì€?|ê³ ë˜|ì‚¬ì|í˜¸ë‘ì´|ë…ìˆ˜ë¦¬
`;
    return { prompt: promptHeader, topicName: finalTopic };
}




            

        // --- Firebase ì„¤ì • ---
        // (ëŒ€ê¸°ì‹¤.html ë“±ì—ì„œ ê°€ì ¸ì˜¨ ì„¤ì •)
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
            authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
            projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.appspot.com",
            messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const auth = firebase.auth();
        const roomsRef = db.ref('rooms');
        const usersRef = db.ref('users');

        // --- HTML ìš”ì†Œ ---
        const gameHeader = document.getElementById('game-header');
        const quizArea = document.getElementById('quiz-area');
        const roundInfo = document.getElementById('round-info');
        const timerFill = document.getElementById('round-timer-fill');
        const questionText = document.getElementById('question-text');
        const optionsGrid = document.getElementById('options-grid');
        const optionBtns = optionsGrid.querySelectorAll('.option-btn');
        const questionDesc = document.getElementById('question-desc'); // â–¼â–¼â–¼ [ì‹ ê·œ] ëœ»í’€ì´ div
        
        const infoOverlay = document.getElementById('info-overlay');
        const infoText = document.getElementById('info-text');
        const infoSpinner = document.getElementById('info-spinner');
        const hostRetryBtn = document.getElementById('host-retry-btn');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const topicModal = document.getElementById('topic-modal');

        // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
        let myPlayerId, myNickname, myAvatar;
        let roomRef, currentRoomData, isHost;
        let isExiting = false, isGameLive = false, gameOverFlag = false;
        let isSoloMode = false; // âœ¨ í˜¼ì í•˜ê¸° ëª¨ë“œ í”Œë˜ê·¸
        
        const TOTAL_ROUNDS = 30;
        const ROUND_TIME_MS = 10000; // 7
        let roundEndTimeout;
        let currentRoundTimer;

        let progressInterval;
        let loadingDotsInterval; // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ìš©
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBarFill = document.getElementById('progress-bar-fill');
        
        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            const map = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#03G;'};
            return str.replace(/[&<>"']/g, m => map[m]);
        }
        function playSound(id) {
            const sound = document.getElementById(id);
            if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); }
        }


       // --- ì´ˆê¸°í™” ---
        document.addEventListener('DOMContentLoaded', () => {
            // (ë³´ì•ˆ ì½”ë“œ)
            document.addEventListener('contextmenu', event => event.preventDefault());
            document.addEventListener('keydown', event => {
                if (event.key === 'F12' ||
                    (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
                    (event.ctrlKey && event.key.toUpperCase() === 'U')) {
                    event.preventDefault();
                }
            });
            // setInterval(() => { try { debugger; } catch (e) {} }, 1000);

            // â–¼â–¼â–¼ [ìˆ˜ì •] Firebase Authë¡œ í”Œë ˆì´ì–´ IDë¥¼ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì • (ë©€í‹°í”Œë ˆì´ ë²„ê·¸) â–¼â–¼â–¼
            auth.onAuthStateChanged(user => {
                if (user) {
                    myPlayerId = user.uid; // âœ¨ í•µì‹¬: localStorage ëŒ€ì‹  auth.uid ì‚¬ìš©

                    // DBì—ì„œ ìµœì‹  ë‹‰ë„¤ì„/ì•„ë°”íƒ€ ê°€ì ¸ì˜¤ê¸° (localStorageëŠ” ì˜¤ë˜ëì„ ìˆ˜ ìˆìŒ)
                    usersRef.child(myPlayerId).child('profile').once('value', snapshot => {
                        if (snapshot.exists()) {
                            myNickname = snapshot.val().nickname || 'Player';
                            myAvatar = snapshot.val().avatar || 'ğŸ˜Š';
                        } else {
                            // DBì— í”„ë¡œí•„ì´ ì—†ëŠ” ë¹„ì •ìƒì  ìƒí™©
                            myNickname = 'Player';
                            myAvatar = 'ğŸ˜Š';
                        }

                        // URL íŒŒë¼ë¯¸í„° í™•ì¸ ë° ë°© ì…ì¥
                        const urlParams = new URLSearchParams(window.location.search);
                        const roomId = urlParams.get('roomId');
                        if (!roomId) {
                            alert("ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤.");
                            window.location.replace('ëŒ€ê¸°ì‹¤.html');
                            return;
                        }
                        joinRoom(roomId);

                    });

                } else {
                    // ë¡œê·¸ì¸ë˜ì§€ ì•Šì€ ì‚¬ìš©ì
                    alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
                    window.location.replace('index.html');
                }
            });
            // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
        });
        
        function joinRoom(roomId) {
            const urlParams = new URLSearchParams(window.location.search);
            isSoloMode = urlParams.get('mode') === 'solo'; // âœ¨ 'í˜¼ì í•˜ê¸°' ëª¨ë“œ í™•ì¸

            if (isSoloMode) {
                // âœ¨ í˜¼ì í•˜ê¸° ëª¨ë“œ ì´ˆê¸°í™” (DB í•„ìš” ì—†ìŒ)
                isHost = true; // í˜¼ì í•˜ê¸°ëŠ” í•­ìƒ í˜¸ìŠ¤íŠ¸ì²˜ëŸ¼ ë™ì‘
                currentRoomData = {
                    roomName: 'í˜¼ì í•˜ê¸°',
                    players: { [myPlayerId]: { nickname: myNickname, avatar: myAvatar, isHost: true } },
                    scores: { [myPlayerId]: 0 },
                    currentRound: 0,
                    status: 'preparing',
                    quizSet: null
                };
                
                // â–¼â–¼â–¼ [ìˆ˜ì •] ì†”ë¡œ ëª¨ë“œë„ 'processRoomState'ë¥¼ ì‚¬ìš©í•´ UI ë Œë”ë§
                processRoomState({});
                return;
            }

            // âœ¨ ë©€í‹° í”Œë ˆì´ ëª¨ë“œ (ê¸°ì¡´ ë¡œì§)
            roomRef = roomsRef.child(roomId);
            roomRef.once('value', snapshot => {
                if (!snapshot.exists()) {
                    alert("ë°©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    window.location.replace('ëŒ€ê¸°ì‹¤.html');
                    return;
                }
                currentRoomData = snapshot.val();
                isHost = currentRoomData.hostId === myPlayerId;

                // ì ‘ì† ì¢…ë£Œ ì‹œ ì²˜ë¦¬
                if (isHost) {
                    roomRef.onDisconnect().remove();
                } else {
                    roomRef.child('players/' + myPlayerId).onDisconnect().remove();
                }
                
                listenToRoomChanges(); // 1. ë¦¬ìŠ¤ë„ˆ ë¶€ì°©

                // 2. [í•µì‹¬] ê²ŒìŠ¤íŠ¸ê°€ í˜„ì¬ ë°© ìƒíƒœë¥¼ ì¦‰ì‹œ ì²˜ë¦¬í•˜ë„ë¡ í˜¸ì¶œ
                processRoomState({}); 

                // 3. í˜¸ìŠ¤íŠ¸ëŠ” ê²Œì„ì„ ì¤€ë¹„ì‹œí‚´
                if (isHost && currentRoomData.status !== 'preparing') { // (ì¤‘ë³µ ë°©ì§€)
                    // â–¼â–¼â–¼ [ìˆ˜ì •] playersê°€ nullì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ë°©ì–´ ì½”ë“œ â–¼â–¼â–¼
                    const players = currentRoomData.players || {}; // playersê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´ë¡œ
                    const initialScores = {};
                    Object.keys(players).forEach(pid => { // 'players' ë³€ìˆ˜ ì‚¬ìš©
                        initialScores[pid] = 0;
                    });
                    
                    roomRef.update({
                        status: 'preparing', // 'ì¤€ë¹„ ì¤‘' ìƒíƒœ
                        scores: initialScores,
                        currentRound: 0
                    });
                    // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
                }
            });
        }
        
        // --- Gemini API í˜¸ì¶œ (Host Only) ---
        async function fetchQuizSet(topic) {
            // â–¼â–¼â–¼ [ìˆ˜ì •] Fix 1 & 2: í”„ë¡¬í”„íŠ¸ ê°€ì ¸ì˜¤ê¸° ë° ê²ŒìŠ¤íŠ¸ ë¡œë”© ìƒíƒœ ì „íŒŒ â–¼â–¼â–¼
            // 1. ìœ„ì—ì„œ ìˆ˜ì •í•œ getPromptForTopic í•¨ìˆ˜ì—ì„œ í”„ë¡¬í”„íŠ¸ì™€ ì‹¤ì œ ì£¼ì œëª…(topicName)ì„ ë°›ì•„ì˜´
            const { prompt, topicName } = getPromptForTopic(topic);
            const topicDisplayName = topicMapForDisplay[topicName] || "ëœë¤";
            
            if (!isSoloMode && isHost) {
                // 2. (ë©€í‹°í”Œë ˆì´) API í˜¸ì¶œ ì „ì—, ê²ŒìŠ¤íŠ¸ì—ê²Œ "ìƒì„± ì¤‘" ìƒíƒœë¥¼ ë¨¼ì € ì•Œë¦¼
                roomRef.update({ 
                    status: 'generating_quiz',
                    currentTopicName: topicDisplayName // âœ¨ ê²ŒìŠ¤íŠ¸ì—ê²Œ ë³´ì—¬ì¤„ ì£¼ì œëª…
                });
            }
            // â–²â–²â–² [ìˆ˜ì •] Fix 1 & 2 â–²â–²â–²

  
            infoText.innerHTML = `${topicDisplayName} ë¬¸ì œë¥¼ ìƒì„±ì¤‘...<br>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.`; // ë”°ì˜´í‘œ ì œê±°, ì¤„ë°”ê¿ˆ ì¶”ê°€
            infoSpinner.style.display = 'none'; // ìŠ¤í”¼ë„ˆ ìˆ¨ê¸°ê¸°
            startProgressBarSimulation(); // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì‹œì‘
            startLoadingDotsAnimation(); // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            hostRetryBtn.style.display = 'none';
            infoOverlay.style.display = 'flex';
  

            try {
                // 4. API í˜¸ì¶œ
                const quizSet = await callGeminiAPI(prompt);

                if (!quizSet || quizSet.length < 10) {
                    throw new Error("APIê°€ 10ë¬¸ì œ ì„¸íŠ¸ë¥¼ ë°˜í™˜í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                }

                // 5. API í˜¸ì¶œ ì„±ê³µ!
                topicModal.style.display = 'none'; // ì£¼ì œ ì„ íƒ ëª¨ë‹¬ ë‹«ê¸°
                // infoOverlay.style.display = 'none'; // <-- ìˆ¨ê¸°ëŠ” ë¡œì§ì„ stopProgressBarSimulationìœ¼ë¡œ ì´ë™

                // â–¼â–¼â–¼ [ìˆ˜ì •] í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì™„ë£Œ í›„ ë‹¤ìŒ ë‹¨ê³„ ì‹¤í–‰ â–¼â–¼â–¼
                const nextStepCallback = () => {
                    if (isSoloMode) {
                        // âœ¨ ì†”ë¡œ ëª¨ë“œ: ë‚´ë¶€ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ í›„ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                        currentRoomData.quizSet = quizSet;
                        currentRoomData.currentTopic = topicName;
                        currentRoomData.currentRound = currentRoomData.currentRound || 0;
                        currentRoomData.status = 'starting';
                        // ì½œë°± ë‚´ë¶€ì—ì„œ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                        startRoundCountdown(3);
                    } else {
                        // âœ¨ ë©€í‹° ëª¨ë“œ: í€´ì¦ˆ ì„¸íŠ¸ë¥¼ DBì— ì €ì¥ -> ë¦¬ìŠ¤ë„ˆê°€ 'starting' ê°ì§€ í›„ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                        const baseRound = currentRoomData.currentRound || 0;
                        roomRef.update({
                            quizSet: quizSet,
                            currentTopic: topicName,
                            currentRound: baseRound,
                            status: 'starting'
                        });
                        // ë©€í‹° ëª¨ë“œëŠ” DB ì—…ë°ì´íŠ¸ í›„ ë¦¬ìŠ¤ë„ˆê°€ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¹´ìš´íŠ¸ë‹¤ìš´ X
                    }
                };

                // í”„ë¡œê·¸ë ˆìŠ¤ ë°”ë¥¼ 100%ë¡œ ì±„ìš°ê³  ì½œë°± ì‹¤í–‰
                stopProgressBarSimulation(true, nextStepCallback);
                // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
                
            } catch (error) {
                // 6. API í˜¸ì¶œ ì‹¤íŒ¨!
                console.error("fetchQuizSet ì˜¤ë¥˜:", error);
                infoText.textContent = "í€´ì¦ˆ ìƒì„± ì‹¤íŒ¨! (API ì˜¤ë¥˜)";
                infoSpinner.style.display = 'none';
                hostRetryBtn.style.display = 'block';
                // ì¬ì‹œë„ ë²„íŠ¼ì— í˜„ì¬ í† í”½ ì •ë³´ë¥¼ ì €ì¥ (e.g., 'random')
                hostRetryBtn.dataset.topic = topic;

                // â–¼â–¼â–¼ [ì‹ ê·œ] Fix 2: ìƒì„± ì‹¤íŒ¨ ì‹œ ë©€í‹°í”Œë ˆì´ ìƒíƒœ ë˜ëŒë¦¬ê¸° â–¼â–¼â–¼
                if (!isSoloMode && isHost) {
                    roomRef.update({ status: 'preparing' }); // í˜¸ìŠ¤íŠ¸ê°€ ë‹¤ì‹œ ì£¼ì œë¥¼ ì„ íƒí•˜ë„ë¡
                }
                // â–²â–²â–² [ì‹ ê·œ] Fix 2 â–²â–²â–²
            }
        }
        
        // ì¬ì‹œë„ ë²„íŠ¼ ì´ë²¤íŠ¸ (í˜¸ìŠ¤íŠ¸ì—ê²Œë§Œ ë³´ì„)
        hostRetryBtn.addEventListener('click', () => {
            const topic = hostRetryBtn.dataset.topic;
            if (topic) {
                fetchQuizSet(topic);
            }
        });

        // --- ì‹¤ì‹œê°„ ê²Œì„ ë¡œì§ (State Machine) ---
        function listenToRoomChanges() {
            roomRef.on('value', snapshot => {
                if (isExiting || !snapshot.exists()) {
                    if (isGameLive && !gameOverFlag) alert("ë°©ì¥ì´ ë‚˜ê°€ ë°©ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤.");
                    cleanupAndExit();
                    return;
                }
                
                const oldRoomData = currentRoomData || {};
                currentRoomData = snapshot.val();
                
                if (!currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                    if (isGameLive && !gameOverFlag) alert("ë°©ì—ì„œ í‡´ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
                    cleanupAndExit();
                    return;
                }
                
                // âœ¨ [í•µì‹¬] ìƒíƒœ ì²˜ë¦¬ í•¨ìˆ˜ í˜¸ì¶œ
                processRoomState(oldRoomData);
            });
        }

        // â–¼â–¼â–¼ [ì‹ ê·œ] (All) ë°© ìƒíƒœì— ë”°ë¥¸ UI/ë¡œì§ ì²˜ë¦¬ í•¨ìˆ˜ â–¼â–¼â–¼
        function processRoomState(oldRoomData = {}) {
            if (!currentRoomData) return; // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì¤‘ë‹¨

            isGameLive = true; 
            updateHeaderUI(); // ì ìˆ˜íŒ í•­ìƒ ì—…ë°ì´íŠ¸

            const oldStatus = oldRoomData.status;
            const newStatus = currentRoomData.status;

            // --- ìƒíƒœ(status)ì— ë”°ë¼ UI ë³€ê²½ ---

            // â–¼â–¼â–¼ [ì‹ ê·œ] 'playing' ìƒíƒœ (ì²« ì§„ì…) ì²˜ë¦¬ â–¼â–¼â–¼
            if (newStatus === 'playing') {
                if (isHost) {
                    infoText.textContent = "ê²Œì„ì„ ì´ˆê¸°í™” ì¤‘ì…ë‹ˆë‹¤...";
                } else {
                    infoText.textContent = "ê²Œì„ì— ì°¸ê°€í•˜ëŠ” ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...";
                }
                infoSpinner.style.display = 'block';
                hostRetryBtn.style.display = 'none';
                infoOverlay.style.display = 'flex';
            }
            // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
            
            // 1. ê²Œì„ ì¤€ë¹„
            if (newStatus === 'preparing') {
                if (isHost) {
                    if (oldStatus !== 'preparing') { 
                        infoOverlay.style.display = 'none'; 
                        showTopicModal("ì²« 10ë¼ìš´ë“œì˜ ì£¼ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.", false);
                    }
                } else {
                    // (Guest) ê²ŒìŠ¤íŠ¸(non-host)ëŠ” ëŒ€ê¸° ë©”ì‹œì§€ í‘œì‹œ
                    infoText.textContent = "ë°©ì¥ì´ ê²Œì„ ì£¼ì œë¥¼ ì„ íƒ ì¤‘ì…ë‹ˆë‹¤...";
                    infoSpinner.style.display = 'block';
                    hostRetryBtn.style.display = 'none';
                    infoOverlay.style.display = 'flex';
                }
            }
            
            // 2. í€´ì¦ˆ ìƒì„± ì¤‘
            if (newStatus === 'generating_quiz') {
                const topicName = currentRoomData.currentTopicName || 'ê²Œì„';
                infoText.innerHTML = `${topicName} ë¬¸ì œë¥¼ ìƒì„±ì¤‘...<br>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.`; // ë”°ì˜´í‘œ ì œê±°, ì¤„ë°”ê¿ˆ ì¶”ê°€
                infoSpinner.style.display = 'none'; // ìŠ¤í”¼ë„ˆ ìˆ¨ê¸°ê¸°
                if (oldStatus !== 'generating_quiz') { // ìƒíƒœê°€ ì²˜ìŒ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
                   startProgressBarSimulation();
                   startLoadingDotsAnimation(); // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                }
                hostRetryBtn.style.display = 'none';
                infoOverlay.style.display = 'flex';
                topicModal.style.display = 'none';
                // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
            } else {
                 stopProgressBarSimulation(false); // ì¦‰ì‹œ ìˆ¨ê¹€
                 stopLoadingDotsAnimation(); // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
            }
            
            // 3. ê²Œì„ ì‹œì‘ ì¤‘: ì¹´ìš´íŠ¸ë‹¤ìš´
            if (newStatus === 'starting' && oldStatus !== 'starting') {
                startRoundCountdown(3); 
            }
            
            // 4. ë¬¸ì œ í‘œì‹œ
            if (newStatus === 'showing_question') {
                if (oldStatus !== 'showing_question') {
                    displayQuiz();
                }
            }

            // â–¼â–¼â–¼ [ì‹ ê·œ] 4.5. (ë©€í‹°) ì²« ì •ë‹µì ê°ì§€ ì‹œ ì¦‰ì‹œ ë¼ìš´ë“œ ì¢…ë£Œ â–¼â–¼â–¼
            if (!isSoloMode && newStatus === 'showing_question' && 
                currentRoomData.roundFirstCorrect && 
                oldRoomData.roundFirstCorrect !== currentRoomData.roundFirstCorrect) 
            {
                if (isHost) {
                    // í˜¸ìŠ¤íŠ¸ëŠ” ì¦‰ì‹œ ë¼ìš´ë“œë¥¼ ì¢…ë£Œì‹œí‚´
                    console.log("ì²« ì •ë‹µì ê°ì§€! ë¼ìš´ë“œ ì¦‰ì‹œ ì¢…ë£Œ.");
                    clearTimeout(roundEndTimeout); // ê¸°ì¡´ íƒ€ì´ë¨¸ ì·¨ì†Œ
                    setTimeout(triggerResult, 100); // 0.1ì´ˆ í›„ ì¦‰ì‹œ ê²°ê³¼ ì§‘ê³„
                }
            }
            // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
            
            // 5. ê²°ê³¼ í‘œì‹œ
            if (newStatus === 'showing_result') {
                if (oldStatus !== 'showing_result') {
                    displayResult();
                }
            }

// â–¼â–¼â–¼ [ìˆ˜ì •] (Host Only) ê²ŒìŠ¤íŠ¸ì˜ ì£¼ì œ ì„ íƒ ê°ì§€ (ìƒíƒœ ë¬´ê´€í•˜ê²Œ ìµœìš°ì„  ì²˜ë¦¬) â–¼â–¼â–¼
            // preparing(ìµœì´ˆ) ë˜ëŠ” changing_topic(ê²Œì„ì¤‘) ìƒíƒœì—ì„œ ê²ŒìŠ¤íŠ¸ê°€ ì£¼ì œë¥¼ ê³ ë¥´ë©´ ê°ì§€
            if (isHost && currentRoomData.selectedNextTopic) {
                // ì´ë¯¸ ìƒì„± ì¤‘('generating_quiz')ì´ë©´ ë¬´ì‹œ
                if (newStatus !== 'generating_quiz') {
                    console.log("ê²ŒìŠ¤íŠ¸ì˜ ì£¼ì œ ì„ íƒ ê°ì§€:", currentRoomData.selectedNextTopic);
                    const topicToFetch = currentRoomData.selectedNextTopic; 
                    
                    // DBì—ì„œ ìš”ì²­ì„ ì§€ìš°ê³  ì¦‰ì‹œ ìƒì„± ì‹œì‘
                    roomRef.child('selectedNextTopic').remove().then(() => {
                        // ìƒíƒœ ë³€ê²½ ë° ìƒì„± (showTopicModalì˜ í˜¸ìŠ¤íŠ¸ ë¡œì§ê³¼ ë™ì¼)
                        const topicDisplayName = topicMapForDisplay[topicToFetch] || topicToFetch;
                        roomRef.update({ 
                            status: 'generating_quiz',
                            currentTopicName: topicDisplayName
                        }).then(() => {
                            fetchQuizSet(topicToFetch);
                        });
                    });
                    return; // ìƒì„± ì‹œì‘í–ˆìœ¼ë‹ˆ ë¦¬í„´
                }
            }
            // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²

            // 6. ì£¼ì œ ë³€ê²½ (UI ì²˜ë¦¬)
            if (newStatus === 'changing_topic') {
                const topicChangerId = currentRoomData.topicChanger;
                
                // (All) ê¼´ì°Œê°€ ì„ íƒ ì¤‘
                if (oldStatus !== 'changing_topic' || infoOverlay.style.display === 'none') { 
                    if (topicChangerId === myPlayerId) {
                        // ë‚´ê°€ ê¼´ì°Œ!
                        infoOverlay.style.display = 'none'; 
                        showTopicModal("ì—­ì „ì˜ ì‹œê°„! ë‹¤ìŒ ì£¼ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.", true);
                    } else {
                        // ë‹¤ë¥¸ ì‚¬ëŒì´ ê¼´ì°Œ
                        const changerNickname = currentRoomData.players[topicChangerId]?.nickname || 'í”Œë ˆì´ì–´';
                        infoText.textContent = `í˜„ì¬ ê¼´ì°Œ(${changerNickname})ê°€ ë‹¤ìŒ ì£¼ì œë¥¼ ì„ íƒ ì¤‘ì…ë‹ˆë‹¤...`;
                        infoSpinner.style.display = 'block';
                        hostRetryBtn.style.display = 'none'; 
                        infoOverlay.style.display = 'flex';
                    }
                }
            }
            
            // 7. ê²Œì„ ì¢…ë£Œ
            if (newStatus === 'gameOver' && !gameOverFlag) {
                gameOverFlag = true;
                showGameOverScreen();
            }
        }
        // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
        
        // --- í˜¸ìŠ¤íŠ¸ ì „ìš©: ê²Œì„ íë¦„ ì œì–´ ---
        
        // (Host) 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ë¼ìš´ë“œ ì‹œì‘
        function startRoundCountdown(seconds) {
            infoOverlay.style.display = 'flex';
            infoSpinner.style.display = 'none';
            hostRetryBtn.style.display = 'none';
            stopLoadingDotsAnimation(); // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
  
            
            let count = seconds;
            infoText.innerHTML = `<div id="countdown-number">${count}</div>`;
            
            const interval = setInterval(() => {
                count--;
                const el = document.getElementById('countdown-number');
                if (count > 0) {
                    if(el) {
                        el.style.animation = 'none';
                        el.offsetHeight; 
                        el.style.animation = 'countdown-pop 1s';
                        el.textContent = count;
                    }
                } else {
                    clearInterval(interval);
                    infoOverlay.style.display = 'none';
                    if (isHost) {
                        triggerQuestion(); // í˜¸ìŠ¤íŠ¸ê°€ ì‹¤ì œ ë¼ìš´ë“œ ì‹œì‘
                    }
                }
            }, 1000);
        }

// (Solo Only) ìƒíƒœ ë³€ê²½ ì²˜ë¦¬
        function handleSoloModeState() {
            if (!isSoloMode) return;
            updateHeaderUI();
            
            const status = currentRoomData.status;
            
            if (status === 'starting') {
                startRoundCountdown(3);
            } else if (status === 'showing_question') {
                displayQuiz();
            } else if (status === 'showing_result') {
                displayResult();
            } else if (status === 'changing_topic') {
                // ì†”ë¡œ ëª¨ë“œëŠ” ê¼´ì°Œ ìœ ì € ì—†ìŒ -> ë°”ë¡œ ëª¨ë‹¬ í‘œì‹œ
                showTopicModal("ë‹¤ìŒ 10ë¼ìš´ë“œì˜ ì£¼ì œë¥¼ ì„ íƒí•˜ì„¸ìš”.", true);
            } else if (status === 'gameOver') {
                showGameOverScreen();
            }
        }

        // (Host) ë¬¸ì œ ì¶œì œ ì‹ í˜¸ ë³´ë‚´ê¸°
        // (Host) ë¬¸ì œ ì¶œì œ ì‹ í˜¸ ë³´ë‚´ê¸°
        function triggerQuestion() {
            if (!isHost) return;
            
            const roundIndex = (currentRoomData.currentRound || 0);
            
            if (roundIndex >= TOTAL_ROUNDS) {
                triggerGameOver();
                return;
            }
            
            // 10ë¼ìš´ë“œê°€ ëë‚¬ìœ¼ë©´ ì£¼ì œ ë³€ê²½
            if (roundIndex > 0 && roundIndex % 10 === 0 && !currentRoomData.topicChanged) {
                triggerTopicChange();
                return;
            }
            
           if (isSoloMode) {
                // â–¼â–¼â–¼ [ìˆ˜ì •] ì†”ë¡œ ëª¨ë“œ: (ë²„ê·¸ ìˆ˜ì •) ë®ì–´ì“°ê¸° ëŒ€ì‹  ë°ì´í„° ë³‘í•© â–¼â–¼â–¼
                const newRoundData = { // ìƒˆ ë¡œì»¬ ë³€ìˆ˜ ì‚¬ìš©
                    status: 'showing_question',
                    currentRound: roundIndex + 1,
                    roundAnswers: null,
                    roundFirstCorrect: null,
                    roundStartTime: Date.now(),
                    topicChanged: false
                };
                Object.assign(currentRoomData, newRoundData); // ê¸°ì¡´ currentRoomDataì— ìƒˆ ì •ë³´ ë³‘í•©
                handleSoloModeState();
            } else {
                // âœ¨ ë©€í‹° ëª¨ë“œ: DB ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë¡œì§)
                roomRef.update({
                    status: 'showing_question',
                    currentRound: roundIndex + 1,
                    roundAnswers: null, // ë¼ìš´ë“œ ë‹µë³€ ì´ˆê¸°í™”
                    roundFirstCorrect: null, // 'ì²« ì •ë‹µì' ì´ˆê¸°í™”
                    roundStartTime: firebase.database.ServerValue.TIMESTAMP,
                    topicChanged: false // ì£¼ì œ ë³€ê²½ í”Œë˜ê·¸ ë¦¬ì…‹
                });
            }
        }
        

        // (Host) 10ì´ˆ í›„ ê²°ê³¼ ì§‘ê³„
        // â–¼â–¼â–¼ [ìˆ˜ì •] (Host) ê²°ê³¼ ì§‘ê³„ (setTimeout ë˜í¼ ì œê±°) â–¼â–¼â–¼
        function triggerResult() {
            clearTimeout(roundEndTimeout); // [ì‹ ê·œ] íƒ€ì´ë¨¸ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            
            // [ìˆ˜ì •] í˜¸ìŠ¤íŠ¸ê°€ ì•„ë‹ˆê±°ë‚˜, ìƒíƒœê°€ 'showing_question'ì´ ì•„ë‹ˆë©´ ì¦‰ì‹œ ì¤‘ë‹¨
            if (!isHost || currentRoomData.status !== 'showing_question') return; 

            // (ê¸°ì¡´ setTimeout ì•ˆì— ìˆë˜ ë¡œì§ì„ ë°–ìœ¼ë¡œ êº¼ëƒ„)
            const answers = currentRoomData.roundAnswers || {};
            const scores = { ...currentRoomData.scores };
            const firstCorrectId = currentRoomData.roundFirstCorrect;
            
            const quizSetIndex = (currentRoomData.currentRound - 1) % 10;
            const correct = currentRoomData.quizSet[quizSetIndex].correct;
            
            // ì ìˆ˜ ê³„ì‚°
            Object.keys(answers).forEach(pid => {
                if (answers[pid].answer === correct) {
                    if (pid === firstCorrectId) {
                        scores[pid] += 100; // ì²« ì •ë‹µì
                    } else {
                        scores[pid] += 20; // ì¼ë°˜ ì •ë‹µì
                    }
                }
            });

            if (isSoloMode) {
                // âœ¨ ì†”ë¡œ ëª¨ë“œ: ë‚´ë¶€ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ í›„ UI ì²˜ë¦¬
                currentRoomData.status = 'showing_result';
                currentRoomData.scores = scores;
                handleSoloModeState();
            } else {
                // âœ¨ ë©€í‹° ëª¨ë“œ: DB ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë¡œì§)
                roomRef.update({
                    status: 'showing_result',
                    scores: scores
                });
            }
        }
        // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
        
   
        // â–¼â–¼â–¼ [ìˆ˜ì •] 10/20 ë¼ìš´ë“œ ì£¼ì œ ë³€ê²½ (ì†”ë¡œ ëª¨ë“œ ë²„ê·¸ ìˆ˜ì •) â–¼â–¼â–¼
        function triggerTopicChange() {
            if (!isHost) return;

            if (isSoloMode) {
                // âœ¨ ì†”ë¡œ ëª¨ë“œ: ì¦‰ì‹œ 'changing_topic' ìƒíƒœë¡œ ë³€ê²½
                currentRoomData.status = 'changing_topic';
                currentRoomData.topicChanged = true; // (ì¤‘ìš”)
                handleSoloModeState();

            } else {
                // âœ¨ ë©€í‹° ëª¨ë“œ: ê¼´ì°Œ(topicChanger)ë¥¼ ì°¾ì•„ DB ì—…ë°ì´íŠ¸
                let loserId = null;
                let minScore = Infinity;
                const scores = currentRoomData.scores || {};
                
                // ê¼´ì°Œ ì°¾ê¸° (ì°¸ê°€ì ëª©ë¡ ê¸°ì¤€)
                Object.keys(currentRoomData.players).forEach(pid => {
                    const score = scores[pid] || 0;
                    if (score < minScore) {
                        minScore = score;
                        loserId = pid;
                    }
                });

                roomRef.update({
                    status: 'changing_topic',
                    topicChanger: loserId,
                    topicChanged: true // (ì¤‘ìš”) ë¬´í•œ ë£¨í”„ ë°©ì§€
                });
            }
        }
        // â–²â–²â–² [ìˆ˜ì •] 10/20 ë¼ìš´ë“œ ì£¼ì œ ë³€ê²½ â–²â–²â–²
        // â–¼â–¼â–¼ [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ (ì†”ë¡œ ëª¨ë“œ ì²˜ë¦¬) â–¼â–¼â–¼
        function triggerGameOver() {
            if (!isHost) return;
            
            if (isSoloMode) {
                // âœ¨ ì†”ë¡œ ëª¨ë“œ: ë‚´ë¶€ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ í›„ UI ì²˜ë¦¬
                currentRoomData.status = 'gameOver';
                updatePlayerStats();
                handleSoloModeState();
            } else {
                // âœ¨ ë©€í‹° ëª¨ë“œ: DB ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë¡œì§)
                roomRef.update({ status: 'gameOver' });
                updatePlayerStats(); // í˜¸ìŠ¤íŠ¸ê°€ ìŠ¹íŒ¨ ê¸°ë¡
            }
        }
        // â–²â–²â–² [ì‹ ê·œ] ê²Œì„ ì¢…ë£Œ â–²â–²â–²
        
        // --- í´ë¼ì´ì–¸íŠ¸ UI ë Œë”ë§ ---
        
        // (All) ì£¼ì œ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        function showTopicModal(desc, isTopicChange) {
            document.getElementById('topic-modal-title').textContent = isTopicChange ? "ì£¼ì œ ë³€ê²½!" : "ê²Œì„ ì£¼ì œ ì„ íƒ";
            document.getElementById('topic-modal-desc').textContent = desc;
            
            topicModal.querySelectorAll('.topic-btn-grid button').forEach(btn => {
               btn.onclick = () => {
                    playSound('click-sound');
                    const topic = btn.dataset.topic;
                    const topicDisplayName = topicMapForDisplay[topic] || topic;

                    // 1. ëª¨ë‹¬ ë‹«ê¸°
                    topicModal.style.display = 'none'; 
                    
                    // 2. ë¡œë”© í™”ë©´ ì¦‰ì‹œ í‘œì‹œ
                    infoText.innerHTML = `${topicDisplayName} ë¬¸ì œë¥¼ ìƒì„±ì¤‘...<br>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.`;
                    infoSpinner.style.display = 'none'; 
                    startProgressBarSimulation(); // ë°” ì‹œì‘
                    startLoadingDotsAnimation(); // ì  ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    infoOverlay.style.display = 'flex';
                    
                    // 3. ì‹¤í–‰ ë¡œì§
                    if (isSoloMode) {
                        // ì†”ë¡œ: ë°”ë¡œ ìƒì„±
                        fetchQuizSet(topic);
                    } else if (isHost) {
                        // í˜¸ìŠ¤íŠ¸: 'generating_quiz' ìƒíƒœë¡œ ë¨¼ì € ë³€ê²½ í›„ ìƒì„± (ê²ŒìŠ¤íŠ¸ì—ê²Œ ì•Œë¦¼)
                        roomRef.update({ 
                            status: 'generating_quiz',
                            currentTopicName: topicDisplayName
                        }).then(() => {
                            fetchQuizSet(topic);
                        });
                    } else {
                        // ê²ŒìŠ¤íŠ¸: DBì— ìš”ì²­ë§Œ ë³´ëƒ„ (í˜¸ìŠ¤íŠ¸ê°€ ê°ì§€í•´ì•¼ í•¨)
                        roomRef.update({ selectedNextTopic: topic });
                    }
                }
            });
            
            topicModal.style.display = 'flex';
        }

        // â–¼â–¼â–¼ [ì‹ ê·œ] (All) ì‹œë“œ ê¸°ë°˜ ë°°ì—´ ì…”í”Œ (ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ë™ì¼ ìˆœì„œ) â–¼â–¼â–¼
        function seededShuffle(array, seed) {
            let m = array.length, t, i;
            const pseudoRandom = () => {
                // ê°„ë‹¨í•œ LCG (ì„ í˜• í•©ë™ ìƒì„±ê¸°)
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };

            while (m) {
                i = Math.floor(pseudoRandom() * m--);
                t = array[m];
                array[m] = array[i];
                array[i] = t;
            }
            return array;
        }
        // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
        

                        // (All) í€´ì¦ˆ UI í‘œì‹œ
        function displayQuiz() {
            infoOverlay.style.display = 'none';
            quizArea.style.display = 'flex';

            const round = currentRoomData.currentRound;
            const topic = currentRoomData.currentTopic; // í˜„ì¬ ì£¼ì œ ê°€ì ¸ì˜¤ê¸°
            const quizSetIndex = (round - 1) % 10;
            const quiz = currentRoomData.quizSet[quizSetIndex];

            // AI ë°ì´í„° ì˜¤ë¥˜ ë°©ì–´ (ì˜¤ë‹µ ê°œìˆ˜ í¬í•¨)
            if (!quiz || !quiz.correct || !quiz.incorrect || quiz.incorrect.length < 3) {
                // â–¼â–¼â–¼ ì˜ì–´ í€´ì¦ˆì¼ ê²½ìš° TTS í˜¸ì¶œ â–¼â–¼â–¼
            if (topic === 'english' && quiz.question) {
                speakWord(quiz.question);
            }
            // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
                console.error("í€´ì¦ˆ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (ì˜¤ë‹µ ë¶€ì¡± í¬í•¨).", round, quizSetIndex, quiz);
                questionText.textContent = "í€´ì¦ˆ ë°ì´í„° ì˜¤ë¥˜ ë°œìƒ!";
                optionBtns.forEach(btn => { btn.style.display = 'none'; }); // ëª¨ë“  ë²„íŠ¼ ìˆ¨ê¹€
                if (isHost) { setTimeout(triggerQuestion, 3000); } // í˜¸ìŠ¤íŠ¸ëŠ” ê°•ì œ ì§„í–‰
                return;
            }

            roundInfo.textContent = `Round ${round} / ${TOTAL_ROUNDS}`;

            // ë¬¸ì œ/ì„¤ëª… ë¶„ë¦¬ (ì´ì œ ëª¨ë“  ì£¼ì œ ë™ì¼í•˜ê²Œ ì ìš© ê°€ëŠ¥)
            const fullQuestion = quiz.question;
            const splitIndex = fullQuestion.indexOf('. ');
            if (topic !== 'spelling' && splitIndex > -1 && fullQuestion.length > splitIndex + 2) { // ë§ì¶¤ë²• ì œì™¸
                questionText.textContent = fullQuestion.substring(0, splitIndex + 1);
                questionDesc.textContent = fullQuestion.substring(splitIndex + 2);
                questionDesc.style.display = 'flex';
            } else {
                questionText.textContent = fullQuestion; // ë§ì¶¤ë²• ë˜ëŠ” ì„¤ëª… ì—†ëŠ” ë¬¸ì œ
                questionDesc.textContent = '';
                questionDesc.style.display = 'none';
            }

            // â–¼â–¼â–¼ [í•µì‹¬ ìˆ˜ì •] ëª¨ë“  ì£¼ì œì— ëŒ€í•´ 4ê°œ ë²„íŠ¼ ë¡œì§ ì‚¬ìš© â–¼â–¼â–¼
            const correctOption = quiz.correct;
            const incorrectOptions = quiz.incorrect; // ì´ì œ í•­ìƒ 3ê°œì¼ ê²ƒìœ¼ë¡œ ê¸°ëŒ€
            const seed = currentRoomData.currentRound; // ì‹œë“œëŠ” ë¼ìš´ë“œ ë²ˆí˜¸

            let options = [...incorrectOptions, correctOption]; // ì˜¤ë‹µ 3ê°œ + ì •ë‹µ 1ê°œ
            options = seededShuffle(options, seed); // 4ê°œ ì…”í”Œ

            optionBtns.forEach((btn, i) => {
                // AIê°€ í˜¹ì‹œ 4ê°œ ë¯¸ë§Œ ì˜µì…˜ì„ ì£¼ë”ë¼ë„ ì˜¤ë¥˜ ë°©ì§€
                if (options[i]) {
                    btn.textContent = options[i];
                    btn.style.display = 'block'; // ë²„íŠ¼ ë³´ì´ê¸°
                    btn.disabled = false;
                    btn.className = 'option-btn';
                    btn.onclick = () => handleAnswerClick(options[i], correctOption);
                } else {
                    btn.style.display = 'none'; // ì˜µì…˜ ì—†ìœ¼ë©´ ìˆ¨ê¸°ê¸°
                }
            });
            // â–²â–²â–² [í•µì‹¬ ìˆ˜ì •] â–²â–²â–²

            // íƒ€ì´ë¨¸ ì„¤ì • (ê¸°ì¡´ê³¼ ë™ì¼)
            let currentRoundTime = ROUND_TIME_MS; // 10ì´ˆ
            if (topic === 'proverb' || topic === 'idiom') {
                currentRoundTime = 12000; // ì†ë‹´/ì‚¬ìì„±ì–´ëŠ” 12ì´ˆ
            }
            timerFill.style.transition = 'none';
            timerFill.style.width = '100%';
            setTimeout(() => {
                timerFill.style.transition = `width ${currentRoundTime}ms linear`;
                timerFill.style.width = '0%';
            }, 100);

            if (isHost) {
                clearTimeout(roundEndTimeout);
                roundEndTimeout = setTimeout(triggerResult, currentRoundTime + 500);
            }
        }

// â–¼â–¼â–¼ [ì‹ ê·œ] TTS ì‹¤í–‰ í•¨ìˆ˜ â–¼â–¼â–¼
        // â–¼â–¼â–¼ [ìˆ˜ì •] TTS ì‹¤í–‰ í•¨ìˆ˜ (ìŒì„± ë¡œë”© ì§€ì—° ì²˜ë¦¬ ê°•í™”) â–¼â–¼â–¼
        function speakWord(word) {
            // [ì¶”ê°€] ìŒì„± ëª©ë¡ì´ ë¹„ì–´ ìˆìœ¼ë©´ ë‹¤ì‹œ ë¡œë“œ ì‹œë„
            if (voices.length === 0) {
                console.log("ìŒì„± ëª©ë¡ ë¡œë”© ì¤‘... ì¬ì‹œë„.");
                populateVoiceList(); 
                // ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„ (ë¹„ë™ê¸° ë¡œë“œë¥¼ ìœ„í•œ ì•½ê°„ì˜ ì§€ì—°)
                setTimeout(() => speakWord(word), 200); 
                return;
            }

            if (synth.speaking) {
                // ì´ë¯¸ ë§í•˜ê³  ìˆìœ¼ë©´ ì·¨ì†Œí•˜ê³  ìƒˆë¡œ ì‹œì‘ (ì˜µì…˜)
                 synth.cancel(); 
                 // console.log('Previous speech cancelled.');
                 // ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„
                 setTimeout(() => speakWord(word), 50); 
                 return;
                // ì•„ë‹ˆë©´ ê·¸ëƒ¥ ë¬´ì‹œ:
                // console.warn('Synth is already speaking.'); return; 
            }
            
            if (word && typeof word === 'string' && word.trim() !== '') {
                const utterThis = new SpeechSynthesisUtterance(word.trim());
                
                utterThis.onend = function (event) {
                    // console.log('Speech finished.');
                }
                utterThis.onerror = function (event) {
                    console.error('SpeechSynthesisUtterance error:', event);
                }
                
                // ì˜ì–´ ìŒì„± ì°¾ê¸° (ë” ë‹¤ì–‘í•œ ê²½ìš° ê³ ë ¤)
                let selectedVoice = voices.find(voice => voice.lang === 'en-US' && voice.localService); // ë¡œì»¬ ë¯¸êµ­ ì˜ì–´ ìš°ì„ 
                if (!selectedVoice) selectedVoice = voices.find(voice => voice.lang === 'en-US'); // ì›ê²© ë¯¸êµ­ ì˜ì–´
                if (!selectedVoice) selectedVoice = voices.find(voice => voice.lang.startsWith('en-') && voice.localService); // ë¡œì»¬ ì˜ì–´
                if (!selectedVoice) selectedVoice = voices.find(voice => voice.lang.startsWith('en-')); // ì›ê²© ì˜ì–´

                if (selectedVoice) {
                    utterThis.voice = selectedVoice;
                     console.log("Using voice:", selectedVoice.name, selectedVoice.lang); // ì–´ë–¤ ìŒì„±ì´ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
                } else {
                    console.warn("English voice not found. Using default voice.");
                    // ê¸°ë³¸ ìŒì„±(ëŒ€ê°œ ì‹œìŠ¤í…œ ì–¸ì–´)ìœ¼ë¡œë¼ë„ ì‹œë„
                }
                
                // utterThis.pitch = 1; 
                // utterThis.rate = 1; 

                // [ì¶”ê°€] ì½ê¸° ì‹œì‘ ì „ ë¡œê·¸
                 console.log(`Attempting to speak: "${word}"`);
                synth.speak(utterThis);
            } else {
                console.warn("SpeakWord: Invalid word provided -", word);
            }
        }
        // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
        
        // (All) ë‹µë³€ í´ë¦­ ì²˜ë¦¬
        function handleAnswerClick(selectedAnswer, correctAnswer) {
            playSound('click-sound');
            // ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”
            optionBtns.forEach(btn => {
                btn.disabled = true;
                if (btn.textContent === selectedAnswer) {
                    btn.classList.add('selected'); // ë‚´ê°€ ì„ íƒí•œ ê²ƒ
                }
            });
            
            const isCorrect = (selectedAnswer === correctAnswer);
            
                       if (isSoloMode) {
                // â–¼â–¼â–¼ [ìˆ˜ì •] ì†”ë¡œ ëª¨ë“œ: ì •ë‹µ/ì˜¤ë‹µ ê´€ê³„ì—†ì´ ì¦‰ì‹œ ê²°ê³¼ ì²˜ë¦¬ (ì˜¤ë‹µ ì‚¬ìš´ë“œ ì¶”ê°€) â–¼â–¼â–¼
                currentRoomData.roundAnswers = { [myPlayerId]: { answer: selectedAnswer, time: Date.now() } };
                
                if (isCorrect) {
                    currentRoomData.roundFirstCorrect = myPlayerId;
                    console.log("ì†”ë¡œ ëª¨ë“œì—ì„œ ì •ë‹µ!");
                    playSound('correct-sound');
                } else {
                    playSound('incorrect-sound'); // [ì‹ ê·œ] ì˜¤ë‹µ ì‚¬ìš´ë“œ
                }
                
                // [ì´ë™] ì •ë‹µ/ì˜¤ë‹µ ëª¨ë‘ íƒ€ì´ë¨¸ë¥¼ ì·¨ì†Œí•˜ê³  ì¦‰ì‹œ ê²°ê³¼ ì§‘ê³„
                clearTimeout(roundEndTimeout); 
                setTimeout(triggerResult, 100); 
                // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
            } else {

                // âœ¨ ë©€í‹° ëª¨ë“œ: DB ê¸°ë¡ ë° íŠ¸ëœì­ì…˜ (ê¸°ì¡´ ë¡œì§)
                
                // 1. ë‚´ ë‹µë³€ì„ DBì— ê¸°ë¡
                roomRef.child('roundAnswers/' + myPlayerId).set({
                    answer: selectedAnswer,
                    time: firebase.database.ServerValue.TIMESTAMP
                });
                
                // 2. (Transaction) ë‚´ê°€ 'ì²« ë²ˆì§¸ ì •ë‹µì'ì¸ì§€ í™•ì¸
                if (isCorrect) {
                    roomRef.child('roundFirstCorrect').transaction(currentVal => {
                        if (currentVal === null) {
                            return myPlayerId; // ë‚´ê°€ ì²« ì •ë‹µì!
                        }
                        return; // ì´ë¯¸ ëˆ„ê°€ ì„ ì í•¨ (undefined ë°˜í™˜ = íŠ¸ëœì­ì…˜ ì·¨ì†Œ)
                    }).then(result => {
                        if (result.committed && result.snapshot.val() === myPlayerId) {
                            console.log("ë‚´ê°€ ì²« ë²ˆì§¸ ì •ë‹µì!");
                            playSound('correct-sound');
                        }
                    });
                } else { // â–¼â–¼â–¼ [ì‹ ê·œ] ì˜¤ë‹µì¼ ê²½ìš° â–¼â–¼â–¼
                    playSound('incorrect-sound'); 
                } // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
            }
        }
        
        // (All) ê²°ê³¼ í™”ë©´ í‘œì‹œ
        function displayResult() {
            if (currentRoomData.status !== 'showing_result') return;
            questionDesc.style.display = 'none'; 
            clearTimeout(roundEndTimeout); // â–¼â–¼â–¼ [ìˆ˜ì •] ê¸°ì¡´ íƒ€ì´ë¨¸ í™•ì‹¤íˆ ì œê±°
            clearInterval(currentRoundTimer); // (ì´ ì½”ë“œëŠ” ì‚¬ì‹¤ìƒ ì‘ë™ ì•ˆí•˜ì§€ë§Œ ìœ ì§€)
            // â–¼â–¼â–¼ [ì‹ ê·œ] CSS íƒ€ì´ë¨¸ ë°” ì¦‰ì‹œ ì •ì§€ (ë¬¸ì œ 4 ìˆ˜ì •) â–¼â–¼â–¼
            const currentWidth = timerFill.offsetWidth;
            timerFill.style.transition = 'none'; // ì• ë‹ˆë©”ì´ì…˜ ì¦‰ì‹œ ì¤‘ì§€
            // ë¶€ëª¨ ëŒ€ë¹„ í˜„ì¬ ë„ˆë¹„(%)ë¡œ ê³ ì •
            timerFill.style.width = (currentWidth / timerFill.parentElement.offsetWidth) * 100 + '%';
            // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
            quizArea.style.display = 'flex';

            const quizSetIndex = (currentRoomData.currentRound - 1) % 10;
            const correct = currentRoomData.quizSet[quizSetIndex].correct;
            const firstCorrectId = currentRoomData.roundFirstCorrect;
            const myAnswer = currentRoomData.roundAnswers?.[myPlayerId]?.answer;
            
            optionBtns.forEach(btn => {
                btn.disabled = true;
                const btnText = btn.textContent;
                
                if (btnText === correct) {
                    btn.classList.add('correct');
                } else if (btnText === myAnswer && myAnswer !== correct) {
                    btn.classList.add('incorrect');
                }
            });
            
            if (firstCorrectId) {
                const winnerNick = currentRoomData.players[firstCorrectId]?.nickname || 'ì •ë‹µì';
                questionText.textContent = `${winnerNick}ë‹˜ì´ ì²« ì •ë‹µ! (+100ì )`;
            } else {
                questionText.textContent = "ì •ë‹µ: " + correct;
            }
            
            // (Host) 3ì´ˆ ë’¤ ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
            if (isHost) {
                setTimeout(() => {
                    triggerQuestion(); // ë‹¤ìŒ ë¬¸ì œ ì¶œì œ
                }, 3000);
            }
        }
        
        // (All) í—¤ë” UI ì—…ë°ì´íŠ¸ (ì ìˆ˜íŒ)
        function updateHeaderUI() {
            if (!currentRoomData || !currentRoomData.players) return;
            gameHeader.innerHTML = '';
            
            const scores = currentRoomData.scores || {};
            
            Object.keys(currentRoomData.players).forEach(pid => {
                const player = currentRoomData.players[pid];
                if (!player) return; // AI í”Œë ˆì´ì–´ ë“± ì˜ˆì™¸ì²˜ë¦¬
                
                // âœ¨ [ìˆ˜ì •] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸(ID), ì´ë¯¸ì§€, ì´ëª¨ì§€ ìˆœìœ¼ë¡œ í™•ì¸
                const avatarSet = AVATAR_SETS[player.avatar];
                let avatarHTML = '';
                if (avatarSet) {
                    avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                } else if (player.avatar && (player.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(player.avatar))) {
                    avatarHTML = `<img src="${player.avatar}" alt="avatar">`;
                } else {
                    avatarHTML = escapeHTML(player.avatar); // ì´ëª¨ì§€
                }
                const avatar = avatarHTML; // ê¸°ì¡´ ë³€ìˆ˜ëª…(avatar)ì— í• ë‹¹
                
                const infoEl = document.createElement('div');
                infoEl.className = 'player-info';
                
                infoEl.innerHTML = `
                    <div class="avatar">${avatar}</div>
                    <div class="details">
                        <div class="nickname">${escapeHTML(player.nickname)}</div>
                        <div class="score">${scores[pid] || 0} ì </div>
                    </div>`;
                gameHeader.appendChild(infoEl);
            });
        }
        
        // (All) ê²Œì„ ì¢…ë£Œ í™”ë©´
        function showGameOverScreen() {
            const scores = currentRoomData.scores;
            const players = currentRoomData.players;
            
            let winnerId = null;
            let maxScore = -Infinity;
            
            Object.keys(scores).forEach(pid => {
                if (scores[pid] > maxScore) {
                    maxScore = scores[pid];
                    winnerId = pid;
                }
            });
            
            const iWon = (winnerId === myPlayerId);
            const message = iWon ? "ğŸ‰ ìŠ¹ë¦¬!" : "ğŸ˜¢ íŒ¨ë°°...";
            playSound(iWon ? 'win-sound' : 'loss-sound');

            const scoresHTML = Object.keys(players).map(pid => {
                const player = players[pid];

                // âœ¨ [ìˆ˜ì •] 4ë°©í–¥ ì•„ë°”íƒ€ ì„¸íŠ¸(ID), ì´ë¯¸ì§€, ì´ëª¨ì§€ ìˆœìœ¼ë¡œ í™•ì¸
                const avatarSet = AVATAR_SETS[player.avatar];
                let avatarHTML = '';
                if (avatarSet) {
                    avatarHTML = `<img src="${avatarSet.front}" alt="avatar">`;
                } else if (player.avatar && (player.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(player.avatar))) {
                    avatarHTML = `<img src="${player.avatar}" alt="avatar">`;
                } else {
                    avatarHTML = escapeHTML(player.avatar); // ì´ëª¨ì§€
                }
                const avatar = avatarHTML; // ê¸°ì¡´ ë³€ìˆ˜ëª…(avatar)ì— í• ë‹¹

                return `<div class="score-row ${pid === winnerId ? 'winner' : 'loser'}">
                            <span class="score-avatar">${avatar} ${escapeHTML(player.nickname)}</span>
                            <span>${scores[pid] || 0} ì </span>
                        </div>`;
            }).sort((a,b) => b.includes('winner') ? 1 : -1).join(''); // ìŠ¹ìê°€ ìœ„ë¡œ ì˜¤ê²Œ

            gameOverOverlay.innerHTML = `
                <div class="modal-content" style="background: #2c3e50;">
                    <div class="modal-header"><h2>${message}</h2></div>
                    <div class="modal-body" style="color:white;">
                        <div id="score-board">${scoresHTML}</div>
                        <button id="lobby-btn" class="menu-btn secondary">ëŒ€ê¸°ì‹¤ë¡œ</button>
                    </div>
                </div>`;
            gameOverOverlay.style.display = 'flex';
            document.getElementById('lobby-btn').addEventListener('click', cleanupAndExit);
            // (ì°¸ê³ ) ë¦¬ë§¤ì¹˜ ê¸°ëŠ¥ì€ ì´ í€´ì¦ˆ ê²Œì„ì—ì„œëŠ” ì œì™¸í–ˆìŠµë‹ˆë‹¤.
        }

        // (Host) ê²Œì„ í†µê³„ ì—…ë°ì´íŠ¸
        function updatePlayerStats() {
            if (!isHost) return; // í˜¸ìŠ¤íŠ¸ë§Œ í†µê³„ ì²˜ë¦¬
            
            const scores = currentRoomData.scores;
            let winnerId = null;
            let maxScore = -Infinity;
            Object.keys(scores).forEach(pid => {
                if (scores[pid] > maxScore) {
                    maxScore = scores[pid];
                    winnerId = pid;
                }
            });
            
            // ëª¨ë“  í”Œë ˆì´ì–´ì˜ ìŠ¹/íŒ¨ ê¸°ë¡
            Object.keys(currentRoomData.players).forEach(pid => {
                if (pid.startsWith('guest_') || pid === 'ai_player') return;
                
                const userRef = usersRef.child(pid);
                const won = (pid === winnerId);
                
                userRef.transaction(userData => {
                    if (userData) {
                        if (!userData.profile) userData.profile = {};
                        const profile = userData.profile;
                        profile.exp = (profile.exp || 0) + (won ? 120 : 30);
                        profile.points = (profile.points || 0) + (won ? 200 : 100);

                        if (!userData.gameStats) userData.gameStats = {};
                        // â–¼â–¼â–¼ [ìˆ˜ì •] quiz statsì— highscore í•„ë“œ ì¶”ê°€ â–¼â–¼â–¼
                        if (!userData.gameStats.quiz) userData.gameStats.quiz = { wins: 0, losses: 0, plays: 0, highscore: 0 };
                        
                        const stats = userData.gameStats.quiz;
                        if (won) stats.wins = (stats.wins || 0) + 1;
                        else stats.losses = (stats.losses || 0) + 1;
                        stats.plays = (stats.plays || 0) + 1;
                        
                        // [ì‹ ê·œ] ìµœê³  ì ìˆ˜ ì—…ë°ì´íŠ¸ ë¡œì§
                        const finalScore = scores[pid] || 0;
                        if (finalScore > (stats.highscore || 0)) {
                            stats.highscore = finalScore;
                        }
                        // â–²â–²â–² [ìˆ˜ì •] â–²â–²â–²
                    }
                    return userData;
                });
            });
        }
        
        // (All) ë°© ë‚˜ê°€ê¸°
        function cleanupAndExit() {
            isExiting = true;
            if (!isSoloMode && roomRef) { // âœ¨ ë©€í‹° ëª¨ë“œì—ì„œë§Œ DB ì •ë¦¬
                if (isHost) {
                    roomRef.remove();
                } else {
                    roomRef.child('players/' + myPlayerId).remove();
                }
                roomRef.off();
            }
            window.location.replace('ëŒ€ê¸°ì‹¤.html'); // ë’¤ë¡œê°€ê¸° ë°©ì§€
        }
        
        // â–¼â–¼â–¼ [ì‹ ê·œ] í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì‹œë®¬ë ˆì´ì…˜ í•¨ìˆ˜ â–¼â–¼â–¼
        function startProgressBarSimulation() {
            clearInterval(progressInterval); // ì´ì „ ì¸í„°ë²Œ í´ë¦¬ì–´
            progressBarFill.style.transition = 'width 0.3s ease-out'; // ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼
            progressBarFill.style.width = '0%'; // 0%ì—ì„œ ì‹œì‘
            progressBarContainer.style.display = 'block';

            let progress = 0;
            progressInterval = setInterval(() => {
                progress += 5; // 5%ì”© ì¦ê°€ (ì†ë„ ì¡°ì ˆ ê°€ëŠ¥)
                if (progress <= 95) { // 95%ê¹Œì§€ë§Œ ìë™ìœ¼ë¡œ ì¦ê°€
                    progressBarFill.style.width = progress + '%';
                } else {
                    clearInterval(progressInterval); // 95% ë„ë‹¬ ì‹œ ìë™ ì¦ê°€ ë©ˆì¶¤
                }
            }, 200); // 0.2ì´ˆë§ˆë‹¤ ì¦ê°€ (ì†ë„ ì¡°ì ˆ ê°€ëŠ¥)
        }

        function stopProgressBarSimulation(complete = true, callback = null) { // ì½œë°± íŒŒë¼ë¯¸í„° ì¶”ê°€
            clearInterval(progressInterval);
            stopLoadingDotsAnimation(); // ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ë„ ì—¬ê¸°ì„œ í™•ì‹¤íˆ ì¤‘ì§€

            if (complete) {
                // ì™„ë£Œ ì‹œ 100% ì±„ìš°ê³  ì ì‹œ í›„ ìˆ¨ê¸°ê³  ì½œë°± ì‹¤í–‰
                progressBarFill.style.transition = 'width 0.1s ease-out'; // ë¹ ë¥´ê²Œ 100%
                progressBarFill.style.width = '100%';
                setTimeout(() => {
                    progressBarContainer.style.display = 'none';
                    progressBarFill.style.width = '0%'; // ë‹¤ìŒì„ ìœ„í•´ ë¦¬ì…‹
                    
                    // â–¼â–¼â–¼ [ì¶”ê°€] ì½œë°± í•¨ìˆ˜ ì‹¤í–‰ â–¼â–¼â–¼
                    if (callback) {
                        callback();
                    } else {
                        // ì½œë°± ì—†ìœ¼ë©´ infoOverlay ìˆ¨ê¸°ê¸° (í˜¸ì¶œ ì‹¤íŒ¨ ë“±)
                         infoOverlay.style.display = 'none';
                    }
                    // â–²â–²â–² [ì¶”ê°€] â–²â–²â–²
                }, 300); // 0.3ì´ˆ í›„ ìˆ¨ê¹€ ë° ì½œë°± ì‹¤í–‰
            } else {
                // ì¤‘ë‹¨/ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ìˆ¨ê¹€
                progressBarContainer.style.display = 'none';
                progressBarFill.style.width = '0%'; // ë¦¬ì…‹
                infoOverlay.style.display = 'none'; // ì‹¤íŒ¨ ì‹œ ì˜¤ë²„ë ˆì´ë„ ìˆ¨ê¹€
            }
        }

        // â–¼â–¼â–¼ [ì‹ ê·œ] ë¡œë”© ì  ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜ â–¼â–¼â–¼
        function startLoadingDotsAnimation() {
            stopLoadingDotsAnimation(); // ì´ì „ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€
            let dotCount = 1;
            loadingDotsInterval = setInterval(() => {
                let dots = '.'.repeat(dotCount);
                // í˜„ì¬ infoText ë‚´ìš©ì„ ìœ ì§€í•˜ë©´ì„œ ì ë§Œ ì—…ë°ì´íŠ¸
                const baseText = infoText.innerHTML.split('<br>')[0]; // ì²« ì¤„ë§Œ ê°€ì ¸ì˜´
                infoText.innerHTML = `${baseText}<br>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”${dots}`;
                dotCount = (dotCount % 3) + 1; // 1 -> 2 -> 3 -> 1 ë°˜ë³µ
            }, 500); // 0.5ì´ˆë§ˆë‹¤ ì  ë³€ê²½
        }

        function stopLoadingDotsAnimation() {
            clearInterval(loadingDotsInterval);
        }
        // â–²â–²â–² [ì‹ ê·œ] â–²â–²â–²
    </script>
</body>
</html>