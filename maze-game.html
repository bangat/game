<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>캐릭터 미로찾기 게임 (랜덤 생성)</title>
    <style>
        /* 기본 스타일 */
        :root {
            --bg-color: #f0f2f5;
            --wall-color: #34495e;
            --path-color: #ecf0f1;
            --button-bg: #2c3e50;
            --button-text: #ffffff;
            --button-hover: #3e5771;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* 스크롤 방지 */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* 콘텐츠를 위아래로 분산 배치 */
            align-items: center;
            -webkit-user-select: none; /* 드래그 선택 방지 */
            user-select: none;
            touch-action: manipulation; /* 터치 지연 제거 */
        }
        /* 게임 컨테이너 */
        #game-container {
            width: 95%;
            max-width: 500px; /* 데스크탑/태블릿 최대 너비 */
            flex-grow: 1; /* 남은 세로 공간을 모두 차지하도록 설정 */
            margin: 2vh auto; /* 상하 여백 및 가로 중앙 정렬 */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--path-color);
            display: flex; /* 내부 미로 정렬을 위해 추가 */
        }
        
        /* 미로 */
        #maze {
            position: relative;
            width: 100%;
            height: 100%;
            display: grid;
        }
        
        /* 미로 구성 요소 (벽) */
        .wall {
            background-color: var(--wall-color);
        }
        /* 플레이어 캐릭터 & 목표 지점 */
        #player, #goal {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.1s linear;
        }
        #player {
            z-index: 10;
        }
        #goal {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        /* 터치 조작 버튼 */
        #controls {
            width: 100%;
            padding-block: 10px; /* 상하 패딩 */
            padding-bottom: max(15px, env(safe-area-inset-bottom)); /* 아이폰 하단 노치 대응 */
            flex-shrink: 0; /* 컨트롤러 크기가 줄어들지 않도록 */
        }
        #controls .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 5px; /* 버튼 행 간격 */
        }
        
        #controls .button-row-bottom {
            gap: 15px; /* 하단 버튼 3개 사이의 간격 */
        }
        #controls button {
            width: 60px; /* 버튼 크기 약간 줄임 */
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: var(--button-bg);
            color: var(--button-text);
            font-size: 24px; /* 아이콘 크기 조정 */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        #controls button:active {
             transform: scale(0.95);
             background-color: var(--button-hover);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="maze">
            <div id="player">🚀</div>
        </div>
    </div>
    <div id="controls">
        <div class="button-row">
            <button id="up">▲</button>
        </div>
        <div class="button-row button-row-bottom">
            <button id="left">◀</button>
            <button id="down">▼</button>
            <button id="right">▶</button>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // ✨ 여기에 랜덤으로 보여줄 동물 이모지 배열을 추가합니다.
        const animalEmojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦', '🐤', '🦄'];
// ✨ 여기에 랜덤으로 적용할 컬러 테마 배열을 추가합니다.
            const colorThemes = [
                { // 기본 테마
                    '--bg-color': '#f0f2f5',
                    '--wall-color': '#34495e',
                    '--path-color': '#ecf0f1',
                    '--button-bg': '#2c3e50',
                },
                { // 숲 테마
                    '--bg-color': '#e8f5e9',
                    '--wall-color': '#2e7d32',
                    '--path-color': '#c8e6c9',
                    '--button-bg': '#1b5e20',
                },
                { // 바다 테마
                    '--bg-color': '#e3f2fd',
                    '--wall-color': '#0d47a1',
                    '--path-color': '#bbdefb',
                    '--button-bg': '#1565c0',
                },
                { // 사막 테마
                    '--bg-color': '#fff3e0',
                    '--wall-color': '#d84315',
                    '--path-color': '#ffe0b2',
                    '--button-bg': '#bf360c',
                },
                { // 캔디 테마
                    '--bg-color': '#fce4ec',
                    '--wall-color': '#c2185b',
                    '--path-color': '#f8bbd0',
                    '--button-bg': '#880e4f',
                }
            ];
        const mazeContainer = document.getElementById('maze');
            const player = document.getElementById('player');

            // ✨ 게임 상태 관련 변수들을 상위 스코프로 이동
            let playerPos = { x: 0, y: 0 };
            let goalPos = { x: 0, y: 0 };
            let cellSize = 0;
            let mazeLayout = [];
            let mazeRows, mazeCols;

            // ✨ 미로 생성 함수 (Recursive Backtracker 알고리즘)
            function generateMaze(rows, cols) {
                // 미로 크기는 항상 홀수여야 벽 구조가 예쁘게 나옵니다.
                rows = rows % 2 === 0 ? rows + 1 : rows;
                cols = cols % 2 === 0 ? cols + 1 : cols;
                
                // 1. 모든 칸을 벽(1)으로 채운 미로판 생성
                const maze = Array(rows).fill(null).map(() => Array(cols).fill(1));
                
                const stack = [];
                // 2. 시작점 (1,1) 설정
                const startX = 1, startY = 1;
                maze[startY][startX] = 0; // 시작점을 길(0)으로 만듦
                stack.push([startX, startY]);

                while (stack.length > 0) {
                    const [cx, cy] = stack[stack.length - 1];
                    
                    // 3. 현재 위치에서 갈 수 있는 (방문 안 한) 방향 찾기
                    const directions = [];
                    // 위
                    if (cy - 2 >= 0 && maze[cy - 2][cx] === 1) directions.push('N');
                    // 아래
                    if (cy + 2 < rows && maze[cy + 2][cx] === 1) directions.push('S');
                    // 왼쪽
                    if (cx - 2 >= 0 && maze[cy][cx - 2] === 1) directions.push('W');
                    // 오른쪽
                    if (cx + 2 < cols && maze[cy][cx + 2] === 1) directions.push('E');

                    if (directions.length > 0) {
                        // 4. 갈 수 있는 방향 중 하나를 무작위로 선택
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        let nx = cx, ny = cy;

                        // 5. 선택한 방향으로 두 칸 이동하고, 그 사이 벽을 허뭄
                        switch (dir) {
                            case 'N': ny -= 2; maze[cy - 1][cx] = 0; break;
                            case 'S': ny += 2; maze[cy + 1][cx] = 0; break;
                            case 'W': nx -= 2; maze[cy][cx - 1] = 0; break;
                            case 'E': nx += 2; maze[cy][cx + 1] = 0; break;
                        }
                        
                        maze[ny][nx] = 0;
                        stack.push([nx, ny]);
                    } else {
                        // 6. 더 이상 갈 곳이 없으면 스택에서 꺼내 되돌아감 (Backtrack)
                        stack.pop();
                    }
                }
                return maze;
            }
            
            function initializeGame() {
 const randomEmoji = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
    player.textContent = randomEmoji;
 // ✨ 컬러 테마 배열에서 랜덤으로 하나를 선택합니다.
        const randomTheme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
        
        // ✨ 선택된 테마의 색상들을 실제 스타일에 적용합니다.
        for (const colorVar in randomTheme) {
            document.documentElement.style.setProperty(colorVar, randomTheme[colorVar]);
        }
                mazeContainer.innerHTML = '';
                
                // ✨ 미로 크기 설정 (세로로 긴 형태)
                mazeRows = 19;
                mazeCols = 13;

                // ✨ 게임 시작 시 새로운 미로 생성
                mazeLayout = generateMaze(mazeRows, mazeCols);

                // ✨ 시작점('S')과 도착점('G')을 미로에 배치
                // 시작점은 맨 위쪽 길 중 하나에 랜덤 배치
                let startX = 2 * Math.floor(Math.random() * Math.floor(mazeCols / 2)) + 1;
                mazeLayout[1][startX] = 'S';
                // 도착점은 맨 아래쪽 길 중 하나에 랜덤 배치
                let goalX = 2 * Math.floor(Math.random() * Math.floor(mazeCols / 2)) + 1;
                mazeLayout[mazeRows - 2][goalX] = 'G';
                
                // 셀 크기는 가로/세로 중 더 작은 쪽에 맞춰 계산하여 비율 유지
                cellSize = Math.min(mazeContainer.offsetWidth / mazeCols, mazeContainer.offsetHeight / mazeRows);
                
                mazeContainer.style.gridTemplateColumns = `repeat(${mazeCols}, ${cellSize}px)`;
                mazeContainer.style.gridTemplateRows = `repeat(${mazeRows}, ${cellSize}px)`;
                // 미로를 컨테이너 중앙에 배치
                mazeContainer.style.margin = 'auto';

                for (let y = 0; y < mazeRows; y++) {
                    for (let x = 0; x < mazeCols; x++) {
                        const cell = document.createElement('div');
                        cell.style.width = `${cellSize}px`;
                        cell.style.height = `${cellSize}px`;
                        
                        if (mazeLayout[y][x] === 1) {
                            cell.className = 'wall';
                        } else {
                            if (mazeLayout[y][x] === 'S') {
                                playerPos = { x, y };
                            } else if (mazeLayout[y][x] === 'G') {
                                goalPos = { x, y };
                                const goalElement = document.createElement('div');
                                goalElement.id = 'goal';
                                goalElement.textContent = '🏠';
                                goalElement.style.width = `${cellSize}px`;
                                goalElement.style.height = `${cellSize}px`;
                                goalElement.style.fontSize = `${cellSize * 0.8}px`;
                                goalElement.style.left = `${x * cellSize}px`;
                                goalElement.style.top = `${y * cellSize}px`;
                                mazeContainer.appendChild(goalElement);
                            }
                        }
                        mazeContainer.appendChild(cell);
                    }
                }
                
                mazeContainer.appendChild(player);
                updatePlayerPosition();
            }

            function updatePlayerPosition() {
                player.style.width = `${cellSize * 0.9}px`;
                player.style.height = `${cellSize * 0.9}px`;
                player.style.fontSize = `${cellSize * 0.7}px`;
                player.style.left = `${playerPos.x * cellSize + (cellSize * 0.05)}px`;
                player.style.top = `${playerPos.y * cellSize + (cellSize * 0.05)}px`;
            }

            function movePlayer(dx, dy) {
                const newX = playerPos.x + dx;
                const newY = playerPos.y + dy;
                if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                    playerPos.x = newX;
                    playerPos.y = newY;
                    updatePlayerPosition();
                    if (playerPos.x === goalPos.x && playerPos.y === goalPos.y) {
                        setTimeout(() => {
                            alert('🎉 도착! 미션을 완료했습니다! 🎉');
                            initializeGame(); // ✨ 클리어 후 새 게임 시작 (새 미로 생성)
                        }, 100);
                    }
                }
            }

            // 이벤트 리스너 설정
            document.getElementById('up').addEventListener('click', (e) => { e.preventDefault(); movePlayer(0, -1); });
            document.getElementById('down').addEventListener('click', (e) => { e.preventDefault(); movePlayer(0, 1); });
            document.getElementById('left').addEventListener('click', (e) => { e.preventDefault(); movePlayer(-1, 0); });
            document.getElementById('right').addEventListener('click', (e) => { e.preventDefault(); movePlayer(1, 0); });
            window.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowUp': movePlayer(0, -1); break;
                    case 'ArrowDown': movePlayer(0, 1); break;
                    case 'ArrowLeft': movePlayer(-1, 0); break;
                    case 'ArrowRight': movePlayer(1, 0); break;
                }
            });

            // 화면 크기 변경 시 미로 다시 그리기
            window.addEventListener('resize', initializeGame);

            // 게임 시작
            initializeGame();
        });
    </script>
</body>
</html>
