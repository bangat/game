<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ï∫êÎ¶≠ÌÑ∞ ÎØ∏Î°úÏ∞æÍ∏∞ Í≤åÏûÑ</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --wall-color: #34495e; --path-color: #ecf0f1;
            --button-bg: #2c3e50; --button-text: #ffffff; --button-hover: #3e5771;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        #game-container {
            width: 95%; max-width: 500px; flex-grow: 1; margin: 2vh auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); border-radius: 10px; overflow: hidden;
            background-color: var(--path-color); display: flex; position: relative;
        }
        #maze { position: relative; width: 100%; height: 100%; display: grid; }
        .wall { background-color: var(--wall-color); }
        #player, #opponent, #goal {
            position: absolute; display: flex; justify-content: center; align-items: center;
            transition: all 0.1s linear;
        }
        #player { z-index: 10; } #opponent { z-index: 9; }
        #goal { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        #controls { width: 100%; padding-block: 10px; padding-bottom: max(15px, env(safe-area-inset-bottom)); flex-shrink: 0; }
        #controls .button-row { display: flex; justify-content: center; align-items: center; margin-top: 5px; }
        #controls .button-row-bottom { gap: 15px; }
        #controls button {
            width: 60px; height: 60px; border-radius: 50%; border: none; background-color: var(--button-bg);
            color: var(--button-text); font-size: 24px; font-weight: bold; cursor: pointer; box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        #controls button:active { transform: scale(0.95); background-color: var(--button-hover); }
        #start-menu { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; padding: 20px; }
        #start-menu h1 { font-size: 3em; color: var(--wall-color); margin-bottom: 40px; }
        .menu-btn {
            width: 100%; max-width: 300px; padding: 15px; font-size: 1.2em; font-weight: bold;
            border-radius: 12px; border: none; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn.primary { background-color: var(--button-bg); color: var(--button-text); }
        #join-form { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 300px; margin-top: 20px; border-top: 2px solid #ddd; padding-top: 30px; }
        #room-code-input { width: 100%; padding: 15px; font-size: 1.2em; text-align: center; border: 2px solid #ccc; border-radius: 12px; margin-bottom: 15px; }
        #game-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; }
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            color: white; display: flex; justify-content: center; align-items: center; z-index: 100; text-align: center;
        }
        #waiting-overlay { background-color: rgba(0, 0, 0, 0.7); }
        .waiting-box, .result-box { padding: 20px; }
        #waiting-room-code {
            font-size: 3em; font-weight: bold; background-color: #fff; color: #333; padding: 10px 30px;
            border-radius: 10px; margin: 15px 0; display: inline-block;
        }
        #start-countdown { font-size: 2.5em; font-weight: bold; }
        .spinner { margin: 20px auto; border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #round-over-overlay, #game-over-overlay { background-color: rgba(0, 0, 0, 0.8); }
        .result-message { font-size: 3em; font-weight: bold; margin-bottom: 15px; }
        .score-info { font-size: 1.5em; }
        #game-over-message { font-size: 4em; font-weight: bold; margin-bottom: 30px; }
        #score-board {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0,0,0,0.5); color: white; padding: 5px 15px;
            border-radius: 10px; font-size: 1.2em; font-weight: bold; z-index: 20;
        }
    </style>
</head>
<body>
    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div class="result-box"> <h2 id="game-over-message"></h2> <button id="restart-btn" class="menu-btn primary">Î°úÎπÑÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button> </div>
    </div>
    <div id="round-over-overlay" class="overlay" style="display: none;">
        <div class="result-box"> <h2 class="result-message" id="round-result-message"></h2> <p class="score-info" id="round-score-info"></p> </div>
    </div>
    <div id="waiting-overlay" class="overlay" style="display: none;">
        <div class="waiting-box">
            <h2>ÏπúÍµ¨Î•º Í∏∞Îã§Î¶¨Îäî Ï§ë...</h2> <p>ÏπúÍµ¨ÏóêÍ≤å ÏïÑÎûò ÏΩîÎìúÎ•º ÏïåÎ†§Ï£ºÏÑ∏Ïöî!</p>
            <div id="waiting-room-code">1234</div> <div class="spinner"></div> <p id="start-countdown"></p>
        </div>
    </div>

    <div id="start-menu">
        <h1>üöÄ ÎØ∏Î°ú Ï∞æÍ∏∞</h1>
        <button id="play-solo-btn" class="menu-btn">ÌòºÏûê ÌïòÍ∏∞</button>
        <button id="create-room-btn" class="menu-btn primary">ÏπúÍµ¨ÏôÄ Í∞ôÏù¥ÌïòÍ∏∞ (Î∞© ÎßåÎì§Í∏∞)</button>
        <div id="join-form">
            <input type="number" id="room-code-input" placeholder="Í≤åÏûÑ ÏΩîÎìú ÏûÖÎ†•">
            <button id="join-room-btn" class="menu-btn">ÏΩîÎìúÎ°ú Ï∞∏Í∞ÄÌïòÍ∏∞</button>
        </div>
    </div>

    <div id="game-wrapper" style="display: none;">
        <div id="game-container">
            <div id="score-board" style="display: none;"></div>
            <div id="maze">
                <div id="player"></div>
                <div id="opponent" style="display: none;"></div>
            </div>
        </div>
        <div id="controls">
            <div class="button-row"> <button id="up">‚ñ≤</button> </div>
            <div class="button-row button-row-bottom">
                <button id="left">‚óÄ</button> <button id="down">‚ñº</button> <button id="right">‚ñ∂</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12", measurementId: "G-9K2BE1X5D6"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('gameRooms');

        const startMenu = document.getElementById('start-menu'), playSoloBtn = document.getElementById('play-solo-btn'),
              createRoomBtn = document.getElementById('create-room-btn'), roomCodeInput = document.getElementById('room-code-input'),
              joinRoomBtn = document.getElementById('join-room-btn'), gameWrapper = document.getElementById('game-wrapper'),
              mazeContainer = document.getElementById('maze'), player = document.getElementById('player'), opponent = document.getElementById('opponent'),
              waitingOverlay = document.getElementById('waiting-overlay'), waitingRoomCodeEl = document.getElementById('waiting-room-code'),
              startCountdownEl = document.getElementById('start-countdown'), gameOverOverlay = document.getElementById('game-over-overlay'),
              gameOverMessageEl = document.getElementById('game-over-message'), restartBtn = document.getElementById('restart-btn'),
              roundOverOverlay = document.getElementById('round-over-overlay'), roundResultMessageEl = document.getElementById('round-result-message'),
              roundScoreInfoEl = document.getElementById('round-score-info'), scoreBoard = document.getElementById('score-board');

        const animalEmojis = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ'];
        const colorThemes = [ { '--bg-color': '#f0f2f5', '--wall-color': '#34495e', '--path-color': '#ecf0f1', '--button-bg': '#2c3e50', }, { '--bg-color': '#e8f5e9', '--wall-color': '#2e7d32', '--path-color': '#c8e6c9', '--button-bg': '#1b5e20', }, { '--bg-color': '#e3f2fd', '--wall-color': '#0d47a1', '--path-color': '#bbdefb', '--button-bg': '#1565c0', }];
        
        let myPlayerId = getPlayerId(), opponentId;
        let currentRoomCode, roomRef, currentRoomData;
        let playerPos = { x: 0, y: 0 }, goalPos = { x: 0, y: 0 }, cellSize = 0, mazeLayout = [], mazeRows, mazeCols;
        let isHost = false;
        let moveInterval = null, isCountingDown = false;

        function getPlayerId() {
            let playerId = sessionStorage.getItem('mazePlayerId');
            if (!playerId) { playerId = Math.random().toString(36).substr(2, 9); sessionStorage.setItem('mazePlayerId', playerId); }
            return playerId;
        }

        playSoloBtn.addEventListener('click', () => {
            startMenu.style.display = 'none'; gameWrapper.style.display = 'flex';
            initializeGame();
        });

        createRoomBtn.addEventListener('click', () => {
            isHost = true; currentRoomCode = Math.floor(1000 + Math.random() * 9000).toString();
            roomRef = gameRoomsRef.child(currentRoomCode);
            mazeRows = 19; mazeCols = 13;
            const generatedMazeLayout = generateMaze(mazeRows, mazeCols);
            placeStartAndGoal(generatedMazeLayout);
            const myEmoji = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
            const newRoomData = {
                mazeLayout: generatedMazeLayout, players: { [myPlayerId]: { emoji: myEmoji, x: 0, y: 0, isHost: true } },
                scores: { [myPlayerId]: 0 }, gameState: 'waiting', createdAt: firebase.database.ServerValue.TIMESTAMP
            };
            roomRef.set(newRoomData).then(() => {
                showWaitingScreen(currentRoomCode);
                listenToRoomChanges();
            });
        });

        joinRoomBtn.addEventListener('click', () => {
            const enteredCode = roomCodeInput.value;
            if (!enteredCode || enteredCode.length !== 4) { alert('4ÏûêÎ¶¨ Í≤åÏûÑ ÏΩîÎìúÎ•º Ï†ïÌôïÌûà ÏûÖÎ†•ÌïòÏÑ∏Ïöî.'); return; }
            const potentialRoomRef = gameRoomsRef.child(enteredCode);
            potentialRoomRef.once('value', (snapshot) => {
                const roomData = snapshot.val();
                if (snapshot.exists() && roomData.gameState === 'waiting' && Object.keys(roomData.players).length < 2) {
                    currentRoomCode = enteredCode; roomRef = potentialRoomRef;
                    const myEmoji = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
                    roomRef.child('players/' + myPlayerId).set({ emoji: myEmoji, x: 0, y: 0 });
                    roomRef.child('scores/' + myPlayerId).set(0);
                    listenToRoomChanges();
                    showWaitingScreen(currentRoomCode);
                } else { alert('Ï°¥Ïû¨ÌïòÏßÄ ÏïäÍ±∞ÎÇò Ïù¥ÎØ∏ ÏãúÏûëÎêú Î∞©ÏûÖÎãàÎã§.'); }
            });
        });

        restartBtn.addEventListener('click', () => {
            if (isHost && roomRef) { roomRef.remove(); }
            window.location.reload();
        });

        function showWaitingScreen(code) {
            startMenu.style.display = 'none';
            waitingRoomCodeEl.textContent = code;
            waitingOverlay.style.display = 'flex';
        }

        function listenToRoomChanges() {
            roomRef.on('value', (snapshot) => {
                currentRoomData = snapshot.val(); // ‚ú® ÌòÑÏû¨ Î∞© Îç∞Ïù¥ÌÑ∞Î•º Ï†ÑÏó≠ Î≥ÄÏàòÏóê Ï†ÄÏû•
                if (!currentRoomData) return;
                const players = currentRoomData.players;
                const playerCount = Object.keys(players).length;
                opponentId = Object.keys(players).find(pid => pid !== myPlayerId);

                if (currentRoomData.scores && opponentId && scoreBoard.style.display === 'block') {
                    scoreBoard.textContent = `${players[myPlayerId]?.emoji || ''} ${currentRoomData.scores[myPlayerId] || 0} : ${currentRoomData.scores[opponentId] || 0} ${players[opponentId]?.emoji || ''}`;
                }

                switch(currentRoomData.gameState) {
                    case 'waiting': if (isHost && playerCount === 2) roomRef.child('gameState').set('ready'); break;
                    case 'ready': startCountdown(currentRoomData); break;
                    case 'playing': roundOverOverlay.style.display = 'none'; updateAllPlayerPositions(players); break;
                    case 'roundOver': showRoundResult(currentRoomData); break;
                    case 'gameOver': showGameOverScreen(currentRoomData.gameWinner === myPlayerId); roomRef.off(); break;
                }
            });
        }

        function startCountdown(roomData) {
            if (isCountingDown) return;
            isCountingDown = true;
            
            // ‚ú® Î≤ÑÍ∑∏ ÏàòÏ†ï: Ïó¨Í∏∞ÏÑú Î¶¨Ïä§ÎÑàÎ•º ÎÅÑÎ©¥ ÏïàÎê©ÎãàÎã§.
            // roomRef.off(); 

            waitingRoomCodeEl.style.display = 'none';
            const isFinal = (roomData.scores[myPlayerId] === 1 && roomData.scores[opponentId] === 1);
            let count = 3;
            startCountdownEl.innerHTML = isFinal ? "üî• ÎßàÏßÄÎßâ ÎùºÏö¥Îìú! üî•" : `Í≥ß ÏãúÏûëÌï©ÎãàÎã§!`;
            
            setTimeout(() => {
                const interval = setInterval(() => {
                    if (count > 0) {
                        startCountdownEl.textContent = count;
                    } else {
                        clearInterval(interval);
                        waitingOverlay.style.display = 'none';
                        gameWrapper.style.display = 'flex';
                        initializeGame(roomData, true);
                        isCountingDown = false;
                    }
                    count--;
                }, 1000);
            }, 1000);
        }

        function updateAllPlayerPositions(players) {
            for (const pid in players) {
                const pData = players[pid];
                const element = (pid === myPlayerId) ? player : opponent;
                if (!element) continue;
                element.style.display = 'flex'; element.textContent = pData.emoji;
                element.style.left = `${pData.x * cellSize + (cellSize * 0.05)}px`;
                element.style.top = `${pData.y * cellSize + (cellSize * 0.05)}px`;
            }
        }

        function showRoundResult(roomData) {
            const winnerId = roomData.roundWinner;
            if (!winnerId || !roomData.players[winnerId]) return;
            const winnerEmoji = roomData.players[winnerId].emoji;
            roundResultMessageEl.innerHTML = `${winnerEmoji}ÎãòÏù¥ Ïù¥Î≤à ÎùºÏö¥ÎìúÏóêÏÑú<br>ÏäπÎ¶¨ÌñàÏäµÎãàÎã§!`;
            roundScoreInfoEl.textContent = `ÌòÑÏû¨ Ï†êÏàò ${roomData.scores[myPlayerId] || 0} : ${roomData.scores[opponentId] || 0}`;
            roundOverOverlay.style.display = 'flex';

            if(isHost) {
                setTimeout(() => {
                    const scores = roomData.scores;
                    scores[winnerId]++;
                    if (scores[winnerId] >= 2) {
                        roomRef.update({ gameState: 'gameOver', gameWinner: winnerId });
                    } else {
                        const newMaze = generateMaze(mazeRows, mazeCols);
                        placeStartAndGoal(newMaze);
                        roomRef.update({ mazeLayout: newMaze, scores: scores, gameState: 'ready', roundWinner: null });
                    }
                }, 2000);
            }
        }
        
        function showGameOverScreen(didIWin) {
            gameOverMessageEl.textContent = didIWin ? "üéâ ÏµúÏ¢Ö ÏäπÎ¶¨! üéâ" : "üò≠ ÏµúÏ¢Ö Ìå®Î∞∞! üò≠";
            gameOverOverlay.style.display = 'flex';
        }

        // ‚ú® Î≤ÑÍ∑∏ ÏàòÏ†ï: ÌôîÎ©¥ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú ÏÉâÏÉÅ Î≥ÄÍ≤Ω Î∞©ÏßÄÎ•º ÏúÑÌïú ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä
        function initializeGame(roomDataOrNull = null, changeTheme = true) {
            roundOverOverlay.style.display = 'none';

            // ‚ú® Î≤ÑÍ∑∏ ÏàòÏ†ï: changeThemeÏù¥ trueÏùº ÎïåÎßå ÌÖåÎßàÏôÄ Ïù¥Î™®ÏßÄÎ•º Î≥ÄÍ≤Ω
            if (changeTheme) {
                const randomTheme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
                for (const colorVar in randomTheme) { document.documentElement.style.setProperty(colorVar, randomTheme[colorVar]); }
            }
            
            mazeContainer.innerHTML = '';

            if(roomDataOrNull) {
                mazeLayout = roomDataOrNull.mazeLayout; mazeRows = mazeLayout.length; mazeCols = mazeLayout[0].length;
                scoreBoard.style.display = 'block';
                opponent.style.display = 'flex';
            } else {
                mazeRows = 19; mazeCols = 13; mazeLayout = generateMaze(mazeRows, mazeCols); placeStartAndGoal(mazeLayout);
                scoreBoard.style.display = 'none'; opponent.style.display = 'none';
            }
            
            cellSize = Math.min(mazeContainer.offsetWidth / mazeCols, mazeContainer.offsetHeight / mazeRows);
            mazeContainer.style.gridTemplateColumns = `repeat(${mazeCols}, ${cellSize}px)`;
            mazeContainer.style.gridTemplateRows = `repeat(${mazeRows}, ${cellSize}px)`;
            mazeContainer.style.margin = 'auto';

            for (let y = 0; y < mazeRows; y++) {
                for (let x = 0; x < mazeCols; x++) {
                    const cell = document.createElement('div');
                    cell.style.width = `${cellSize}px`; cell.style.height = `${cellSize}px`;
                    if (mazeLayout[y][x] === 1) { cell.className = 'wall'; } 
                    else if (mazeLayout[y][x] === 'S') { playerPos = { x, y }; } 
                    else if (mazeLayout[y][x] === 'G') {
                        goalPos = { x, y };
                        const goalElement = document.createElement('div');
                        goalElement.id = 'goal'; goalElement.textContent = 'üè†';
                        mazeContainer.appendChild(goalElement);
                    }
                    mazeContainer.appendChild(cell);
                }
            }
            [player, opponent].forEach(el => mazeContainer.appendChild(el));
            
            // ‚ú® Î≤ÑÍ∑∏ ÏàòÏ†ï: ÌôîÎ©¥ Í∑∏Î¶¨Í∏∞ Î°úÏßÅÏùÑ initializeGameÏúºÎ°ú ÌÜµÌï©
            const goalEl = document.getElementById('goal');
            if(goalEl) {
                goalEl.style.cssText = `width:${cellSize}px; height:${cellSize}px; font-size:${cellSize*0.8}px; left:${goalPos.x*cellSize}px; top:${goalPos.y*cellSize}px;`;
            }
            [player, opponent].forEach(el => {
                 el.style.width = `${cellSize * 0.9}px`; el.style.height = `${cellSize * 0.9}px`;
                 el.style.fontSize = `${cellSize * 0.7}px`;
            });
            
            if (roomDataOrNull) {
                const players = roomDataOrNull.players;
                for(const pid in players) {
                    players[pid].x = playerPos.x; players[pid].y = playerPos.y;
                }
                updateAllPlayerPositions(players); // ‚ú® Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥Î•º Ï¶âÏãú Í∑∏Î¶º
                if(isHost) {
                    roomRef.update({ players: players, gameState: 'playing' });
                }
            } else {
                 player.textContent = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
                 updatePlayerPosition();
            }
        }
        
        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                roomRef.child('players/' + myPlayerId).update({ x: newX, y: newY });
                if (newX === goalPos.x && newY === goalPos.y) {
                    roomRef.child('gameState').once('value', (gameStateSnap) => {
                        if(gameStateSnap.val() === 'playing') {
                            roomRef.update({ gameState: 'roundOver', roundWinner: myPlayerId });
                        }
                    });
                }
            }
        }

        function soloMove(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                updatePlayerPosition();
                if (playerPos.x === goalPos.x && playerPos.y === goalPos.y) {
                    setTimeout(() => { alert('üéâ ÎèÑÏ∞©!'); initializeGame(); }, 100);
                }
            }
        }
        function updatePlayerPosition() { player.style.left = `${playerPos.x * cellSize + (cellSize * 0.05)}px`; player.style.top = `${playerPos.y * cellSize + (cellSize * 0.05)}px`; }
        
        function startMoving(dx, dy) {
            stopMoving();
            const moveFn = currentRoomCode ? movePlayer : soloMove;
            moveFn(dx, dy);
            moveInterval = setInterval(() => moveFn(dx, dy), 150);
        }
        function stopMoving() { clearInterval(moveInterval); }

        ['up', 'down', 'left', 'right'].forEach(dir => {
            const btn = document.getElementById(dir); let dx = 0, dy = 0;
            if (dir === 'up') dy = -1; if (dir === 'down') dy = 1;
            if (dir === 'left') dx = -1; if (dir === 'right') dx = 1;
            btn.addEventListener('mousedown', () => startMoving(dx, dy));
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); startMoving(dx, dy); });
        });
        document.addEventListener('mouseup', stopMoving); document.addEventListener('touchend', stopMoving);
        
        let keyHeld = {};
        window.addEventListener('keydown', (e) => {
            if (keyHeld[e.key] || !gameWrapper.style.display || gameWrapper.style.display === 'none') return;
            keyHeld[e.key] = true;
            switch (e.key) {
                case 'ArrowUp': startMoving(0, -1); break; case 'ArrowDown': startMoving(0, 1); break;
                case 'ArrowLeft': startMoving(-1, 0); break; case 'ArrowRight': startMoving(1, 0); break;
            }
        });
        window.addEventListener('keyup', (e) => {
            keyHeld[e.key] = false;
            stopMoving();
        });

        function placeStartAndGoal(layout) { const topRowPaths = []; for (let i = 0; i < layout[1].length; i++) { if (layout[1][i] === 0) topRowPaths.push(i); } const startX = topRowPaths[Math.floor(Math.random() * topRowPaths.length)]; layout[1][startX] = 'S'; const bottomRowPaths = []; const bottomRowIndex = layout.length - 2; for (let i = 0; i < layout[bottomRowIndex].length; i++) { if (layout[bottomRowIndex][i] === 0) bottomRowPaths.push(i); } const goalX = bottomRowPaths[Math.floor(Math.random() * bottomRowPaths.length)]; layout[bottomRowIndex][goalX] = 'G'; }
        function generateMaze(rows, cols) { rows = rows % 2 === 0 ? rows + 1 : rows; cols = cols % 2 === 0 ? cols + 1 : cols; const maze = Array(rows).fill(null).map(() => Array(cols).fill(1)); const stack = []; const startX = 1, startY = 1; maze[startY][startX] = 0; stack.push([startX, startY]); while (stack.length > 0) { const [cx, cy] = stack[stack.length - 1]; const directions = []; if (cy - 2 >= 0 && maze[cy - 2][cx] === 1) directions.push('N'); if (cy + 2 < rows && maze[cy + 2][cx] === 1) directions.push('S'); if (cx - 2 >= 0 && maze[cy][cx - 2] === 1) directions.push('W'); if (cx + 2 < cols && maze[cy][cx + 2] === 1) directions.push('E'); if (directions.length > 0) { const dir = directions[Math.floor(Math.random() * directions.length)]; let nx = cx, ny = cy; switch (dir) { case 'N': ny -= 2; maze[cy - 1][cx] = 0; break; case 'S': ny += 2; maze[cy + 1][cx] = 0; break; case 'W': nx -= 2; maze[cy][cx - 1] = 0; break; case 'E': nx += 2; maze[cy][cx + 1] = 0; break; } maze[ny][nx] = 0; stack.push([nx, ny]); } else { stack.pop(); } } return maze; }
        
        // ‚ú® Î≤ÑÍ∑∏ ÏàòÏ†ï: ÌôîÎ©¥ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú ÏÉâÏÉÅ Î≥ÄÍ≤Ω ÏóÜÏù¥ ÎßµÎßå Îã§Ïãú Í∑∏Î¶¨ÎèÑÎ°ù ÏàòÏ†ï
        window.addEventListener('resize', () => {
            if (gameWrapper.style.display === 'flex') {
                initializeGame(currentRoomData, false);
            }
        });
    });
    </script>
</body>
</html>
