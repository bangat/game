<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>캐릭터 미로찾기 게임</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --wall-color: #34495e; --path-color: #ecf0f1;
            --button-bg: #2c3e50; --button-text: #ffffff; --button-hover: #3e5771;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        #game-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; }
        #game-header {
            flex-shrink: 0; padding: 10px; display: flex;
            justify-content: center; align-items: center; width: 100%;
        }
        #score-board {
            background-color: rgba(0,0,0,0.6); color: white; padding: 8px 20px;
            border-radius: 20px; font-size: 1.4em; font-weight: bold; z-index: 20;
        }
        #game-container {
            width: 95%; max-width: 500px; flex-grow: 1; margin: 0 auto 2vh auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); border-radius: 10px; overflow: hidden;
            background-color: var(--path-color); display: flex; position: relative;
        }
        #maze { position: relative; width: 100%; height: 100%; display: grid; }
        .wall { background-color: var(--wall-color); }
        #player, #opponent, #goal {
    position: absolute; display: flex; justify-content: center; align-items: center;
    transition: all 0.12s linear;
}

        #player { z-index: 10; } #opponent { z-index: 9; }
        #player.me {
            animation: pulse-me 1.5s infinite;
        }
        @keyframes pulse-me {
            0% { box-shadow: 0 0 12px 3px rgba(66, 133, 244, 0.9); }
            50% { box-shadow: 0 0 18px 6px rgba(66, 133, 244, 0.5); }
            100% { box-shadow: 0 0 12px 3px rgba(66, 133, 244, 0.9); }
        }
        #goal { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        #controls { width: 100%; padding-block: 10px; padding-bottom: max(15px, env(safe-area-inset-bottom)); flex-shrink: 0; }
        #controls .button-row { display: flex; justify-content: center; align-items: center; margin-top: 5px; }
        #controls .button-row-bottom { gap: 15px; }
        #controls button {
            width: 60px; height: 60px; border-radius: 50%; border: none; background-color: var(--button-bg);
            color: var(--button-text); font-size: 24px; font-weight: bold; cursor: pointer; box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        #controls button:active { transform: scale(0.95); background-color: var(--button-hover); }
        #start-menu { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; padding: 20px; }
        #start-menu h1 { font-size: 3em; color: var(--wall-color); margin-bottom: 40px; }
        .menu-btn {
            width: 100%; max-width: 300px; padding: 15px; font-size: 1.2em; font-weight: bold;
            border-radius: 12px; border: none; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn.primary { background-color: var(--button-bg); color: var(--button-text); }
        #join-form { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 300px; margin-top: 20px; border-top: 2px solid #ddd; padding-top: 30px; }
        #room-code-input { width: 100%; padding: 15px; font-size: 1.2em; text-align: center; border: 2px solid #ccc; border-radius: 12px; margin-bottom: 15px; }
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center;
        }
        .overlay > div { padding: 20px; }
        #waiting-overlay { background-color: rgba(0, 0, 0, 0.7); }
        #waiting-room-code { font-size: 3em; font-weight: bold; background-color: #fff; color: #333; padding: 10px 30px; border-radius: 10px; margin: 15px 0; display: inline-block; }
        #start-countdown { font-size: 2.5em; font-weight: bold; }
        .spinner { margin: 20px auto; border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #round-over-overlay, #game-over-overlay { background-color: rgba(0, 0, 0, 0.8); }
        .result-message { font-size: 3em; font-weight: bold; margin-bottom: 15px; }
        .score-info { font-size: 1.5em; }
        #game-over-message { font-size: 4em; font-weight: bold; margin-bottom: 30px; }
        #game-over-buttons { display: flex; gap: 15px; }
    </style>
</head>
<body>
    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div>
            <h2 id="game-over-message"></h2>
            <div id="game-over-buttons">
                <button id="rematch-btn" class="menu-btn">다시 하기</button>
                <button id="lobby-btn" class="menu-btn primary">로비로</button>
            </div>
        </div>
    </div>
    <div id="round-over-overlay" class="overlay" style="display: none;">
        <div> <h2 class="result-message" id="round-result-message"></h2> <p class="score-info" id="round-score-info"></p> </div>
    </div>
    <div id="waiting-overlay" class="overlay" style="display: none;">
        <div>
            <h2 id="waiting-title">친구를 기다리는 중...</h2>
            <p id="waiting-subtitle">친구에게 아래 숫자를 알려주세요!</p>
            <div id="waiting-room-code">1234</div> <div class="spinner"></div> <p id="start-countdown"></p>
        </div>
    </div>

    <div id="start-menu">
        <h1>🚀 미로 찾기</h1>
        <button id="play-solo-btn" class="menu-btn">혼자 하기</button>
        <button id="create-room-btn" class="menu-btn primary">친구와 같이하기 (방 만들기)</button>
        <div id="join-form">
            <input type="number" id="room-code-input" placeholder="게임 코드 입력">
            <button id="join-room-btn" class="menu-btn">코드로 참가하기</button>
        </div>
    </div>

    <div id="game-wrapper" style="display: none;">
        <div id="game-header"> <div id="score-board" style="display: none;"></div> </div>
        <div id="game-container">
            <div id="maze">
                <div id="player"></div> <div id="opponent" style="display: none;"></div>
            </div>
        </div>
        <div id="controls">
            <div class="button-row"> <button id="up">▲</button> </div>
            <div class="button-row button-row-bottom">
                <button id="left">◀</button> <button id="down">▼</button> <button id="right">▶</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12", measurementId: "G-9K2BE1X5D6"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRoomsRef = database.ref('gameRooms');

        const startMenu = document.getElementById('start-menu'), playSoloBtn = document.getElementById('play-solo-btn'),
              createRoomBtn = document.getElementById('create-room-btn'), roomCodeInput = document.getElementById('room-code-input'),
              joinRoomBtn = document.getElementById('join-room-btn'), gameWrapper = document.getElementById('game-wrapper'),
              mazeContainer = document.getElementById('maze'), player = document.getElementById('player'), opponent = document.getElementById('opponent'),
              waitingOverlay = document.getElementById('waiting-overlay'), waitingRoomCodeEl = document.getElementById('waiting-room-code'),
              waitingTitleEl = document.getElementById('waiting-title'), waitingSubtitleEl = document.getElementById('waiting-subtitle'),
              startCountdownEl = document.getElementById('start-countdown'), gameOverOverlay = document.getElementById('game-over-overlay'),
              gameOverMessageEl = document.getElementById('game-over-message'), lobbyBtn = document.getElementById('lobby-btn'),
              rematchBtn = document.getElementById('rematch-btn'), roundOverOverlay = document.getElementById('round-over-overlay'),
              roundResultMessageEl = document.getElementById('round-result-message'), roundScoreInfoEl = document.getElementById('round-score-info'),
              scoreBoard = document.getElementById('score-board');

        const animalEmojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵'];
        const colorThemes = [ { '--bg-color': '#f0f2f5', '--wall-color': '#34495e', '--path-color': '#ecf0f1', '--button-bg': '#2c3e50', }, { '--bg-color': '#e8f5e9', '--wall-color': '#2e7d32', '--path-color': '#c8e6c9', '--button-bg': '#1b5e20', }, { '--bg-color': '#e3f2fd', '--wall-color': '#0d47a1', '--path-color': '#bbdefb', '--button-bg': '#1565c0', }];

        let myPlayerId = getPlayerId(), opponentId, currentRoomCode, roomRef, currentRoomData;
        let playerPos = { x: 0, y: 0 }, goalPos = { x: 0, y: 0 }, cellSize = 0, mazeLayout = [], mazeRows, mazeCols;
        let isHost = false, moveInterval = null, isCountingDown = false;

        function getPlayerId() {
            let playerId = sessionStorage.getItem('mazePlayerId');
            if (!playerId) { playerId = Math.random().toString(36).substr(2, 9); sessionStorage.setItem('mazePlayerId', playerId); }
            return playerId;
        }

        playSoloBtn.addEventListener('click', () => { startMenu.style.display = 'none'; gameWrapper.style.display = 'flex'; initializeGame(); });
        createRoomBtn.addEventListener('click', () => {
            isHost = true; currentRoomCode = Math.floor(1000 + Math.random() * 9000).toString();
            roomRef = gameRoomsRef.child(currentRoomCode);
            mazeRows = 31; mazeCols = 21; // ◀◀ 세로, 가로 크기 확장
            const generatedMazeLayout = generateMaze(mazeRows, mazeCols);
            placeStartAndGoal(generatedMazeLayout);
            const myEmoji = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
            const newRoomData = {
                mazeLayout: generatedMazeLayout, players: { [myPlayerId]: { emoji: myEmoji, x: 0, y: 0, isHost: true } },
                scores: { [myPlayerId]: 0 }, gameState: 'waiting', createdAt: firebase.database.ServerValue.TIMESTAMP
            };
            roomRef.set(newRoomData).then(() => { showWaitingScreen(currentRoomCode); listenToRoomChanges(); });
        });
        joinRoomBtn.addEventListener('click', () => {
            const enteredCode = roomCodeInput.value;
            if (!enteredCode || enteredCode.length !== 4) { alert('4자리 게임 코드를 정확히 입력하세요.'); return; }
            const potentialRoomRef = gameRoomsRef.child(enteredCode);
            potentialRoomRef.once('value', (snapshot) => {
                const roomData = snapshot.val();
                if (snapshot.exists() && roomData.gameState === 'waiting' && Object.keys(roomData.players).length < 2) {
                    currentRoomCode = enteredCode; roomRef = potentialRoomRef;
                    const myEmoji = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
                    roomRef.child('players/' + myPlayerId).set({ emoji: myEmoji, x: 0, y: 0 });
                    roomRef.child('scores/' + myPlayerId).set(0);
                    listenToRoomChanges(); showWaitingScreen(currentRoomCode);
                } else { alert('존재하지 않거나 이미 시작된 방입니다.'); }
            });
        });
        lobbyBtn.addEventListener('click', () => { if (isHost && roomRef) { roomRef.remove(); } window.location.reload(); });
        rematchBtn.addEventListener('click', () => {
            rematchBtn.textContent = '상대방 기다리는 중...';
            rematchBtn.disabled = true;
            roomRef.child('players/' + myPlayerId + '/wantsRematch').set(true);
        });

        function showWaitingScreen(code) {
            startMenu.style.display = 'none';
            waitingTitleEl.style.display = 'block'; waitingSubtitleEl.style.display = 'block';
            waitingRoomCodeEl.style.display = 'inline-block';
            document.querySelector('#waiting-overlay .spinner').style.display = 'block';
            waitingRoomCodeEl.textContent = code;
            waitingOverlay.style.display = 'flex';
        }

        function listenToRoomChanges() {
            roomRef.on('value', (snapshot) => {
                currentRoomData = snapshot.val();
                if (!currentRoomData) return;
                const players = currentRoomData.players;
                if (!players) return;
                const playerCount = Object.keys(players).length;
                opponentId = Object.keys(players).find(pid => pid !== myPlayerId);

                if (currentRoomData.scores && opponentId && players[myPlayerId] && players[opponentId] && scoreBoard.style.display === 'block') {
                    scoreBoard.textContent = `${players[myPlayerId].emoji} ${currentRoomData.scores[myPlayerId] || 0} : ${currentRoomData.scores[opponentId] || 0} ${players[opponentId].emoji}`;
                }

                switch(currentRoomData.gameState) {
                    case 'waiting': if (isHost && playerCount === 2) roomRef.child('gameState').set('ready'); break;
                    case 'ready': startCountdown(currentRoomData); break;
                    case 'playing': roundOverOverlay.style.display = 'none'; updateAllPlayerPositions(players); break;
                    case 'roundOver': showRoundResult(currentRoomData); break;
                    case 'gameOver':
                        showGameOverScreen(currentRoomData.gameWinner === myPlayerId);
                        if(isHost && players[myPlayerId]?.wantsRematch && players[opponentId]?.wantsRematch) {
                            roomRef.child('gameState').set('rematch');
                        }
                        break;
                    case 'rematch':
                        if(isHost) {
                            const newMaze = generateMaze(mazeRows, mazeCols); placeStartAndGoal(newMaze);
                            const newScores = {[myPlayerId]: 0, [opponentId]: 0};
                            const resetPlayers = players;
                            for(const pid in resetPlayers) { if(resetPlayers[pid]) resetPlayers[pid].wantsRematch = null; }
                            roomRef.update({ mazeLayout: newMaze, scores: newScores, players: resetPlayers, gameState: 'ready', roundWinner: null, gameWinner: null });
                        }
                        break;
                }
            });
        }

        function startCountdown(roomData) {
            if (isCountingDown) return;
            isCountingDown = true;
            gameOverOverlay.style.display = 'none';
            roundOverOverlay.style.display = 'none'; // ✨ 라운드 오버 창 숨기기 추가

            waitingTitleEl.style.display = 'none';
            waitingSubtitleEl.style.display = 'none';
            waitingRoomCodeEl.style.display = 'none';
            document.querySelector('#waiting-overlay .spinner').style.display = 'none';

            const isFinal = (roomData.scores[myPlayerId] === 1 && roomData.scores[opponentId] === 1);
            let count = 3;
            startCountdownEl.innerHTML = isFinal ? "🔥 마지막 라운드! 🔥" : `곧 시작합니다!`;
            waitingOverlay.style.display = 'flex';

            setTimeout(() => {
                const interval = setInterval(() => {
                    if (count > 0) { startCountdownEl.textContent = count; }
                    else {
                        clearInterval(interval);
                        waitingOverlay.style.display = 'none'; gameWrapper.style.display = 'flex';
                        initializeGame(roomData, true);
                        isCountingDown = false;
                    }
                    count--;
                }, 1000);
            }, 1000);
        }

        function updateAllPlayerPositions(players) {
            if(!players) return;
            for (const pid in players) {
                const pData = players[pid];
                const element = (pid === myPlayerId) ? player : opponent;
                if (!element || !pData) continue;
                element.style.display = 'flex'; element.textContent = pData.emoji;
                element.style.left = `${pData.x * cellSize + (cellSize * 0.05)}px`;
                element.style.top = `${pData.y * cellSize + (cellSize * 0.05)}px`;
            }
        }

        function showRoundResult(roomData) {
            const winnerId = roomData.roundWinner;
            if (!winnerId || !roomData.players || !roomData.players[winnerId]) return;
            const winnerEmoji = roomData.players[winnerId].emoji;
            roundResultMessageEl.innerHTML = `${winnerEmoji}님이<br>승리했습니다!`;
            roundScoreInfoEl.textContent = `현재 점수 ${roomData.scores[myPlayerId] || 0} : ${roomData.scores[opponentId] || 0}`;
            roundOverOverlay.style.display = 'flex';

            if(isHost) {
                setTimeout(() => {
                    const scores = roomData.scores;
                    scores[winnerId]++;
                    if (scores[winnerId] >= 2) {
                        roomRef.update({ gameState: 'gameOver', gameWinner: winnerId });
                    } else {
                        const newMaze = generateMaze(mazeRows, mazeCols);
                        placeStartAndGoal(newMaze);
                        roomRef.update({ mazeLayout: newMaze, scores: scores, gameState: 'ready', roundWinner: null });
                    }
                }, 1500);
            }
        }

        function showGameOverScreen(didIWin) {
            roundOverOverlay.style.display = 'none'; // ✨ 라운드 오버 창 숨기기 추가
            gameOverMessageEl.textContent = didIWin ? "🎉 최종 승리! 🎉" : "😭 최종 패배! 😭";
            rematchBtn.textContent = '다시 하기'; rematchBtn.disabled = false;
            gameOverOverlay.style.display = 'flex';
        }

        function initializeGame(roomDataOrNull = null, changeTheme = true) {
            roundOverOverlay.style.display = 'none';
            player.classList.remove('me');

            if (changeTheme) {
                const randomTheme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
                for (const colorVar in randomTheme) { document.documentElement.style.setProperty(colorVar, randomTheme[colorVar]); }
            }

            if(roomDataOrNull) {
                mazeLayout = roomDataOrNull.mazeLayout; mazeRows = mazeLayout.length; mazeCols = mazeLayout[0].length;
                scoreBoard.style.display = 'block'; opponent.style.display = 'flex'; player.classList.add('me');
            } else {
                mazeRows = 31; mazeCols = 21; mazeLayout = generateMaze(mazeRows, mazeCols); placeStartAndGoal(mazeLayout); // ◀◀ 세로, 가로 크기 확장
                scoreBoard.style.display = 'none'; opponent.style.display = 'none';
            }

            for (let y = 0; y < mazeRows; y++) {
                for (let x = 0; x < mazeCols; x++) {
                    if (mazeLayout[y][x] === 'S') { playerPos = { x, y }; }
                    else if (mazeLayout[y][x] === 'G') { goalPos = { x, y }; }
                }
            }

            drawMapAndPlayers();

            if (roomDataOrNull) {
                const players = roomDataOrNull.players;
                // ✨ 캐릭터가 겹쳐보이는 버그 수정: 호스트만 시작 위치를 업데이트
                if(isHost) {
                    for(const pid in players) {
                        if(players[pid]) {
                            players[pid].x = playerPos.x; players[pid].y = playerPos.y;
                        }
                    }
                    if (currentRoomData.gameState !== 'playing') {
                        roomRef.update({ players: players, gameState: 'playing' });
                    }
                }
            } else {
                 if (changeTheme) player.textContent = animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
                 updatePlayerPosition();
            }
        }

        function drawMapAndPlayers() {
            mazeContainer.innerHTML = '';
            cellSize = Math.min(mazeContainer.offsetWidth / mazeCols, mazeContainer.offsetHeight / mazeRows);
            mazeContainer.style.gridTemplateColumns = `repeat(${mazeCols}, ${cellSize}px)`;
            mazeContainer.style.gridTemplateRows = `repeat(${mazeRows}, ${cellSize}px)`;
            mazeContainer.style.margin = 'auto';

            for (let y = 0; y < mazeRows; y++) {
                for (let x = 0; x < mazeCols; x++) {
                    const cell = document.createElement('div');
                    cell.style.cssText = `grid-column: ${x + 1}; grid-row: ${y + 1};`;
                    if (mazeLayout[y][x] === 1) cell.className = 'wall';
                    mazeContainer.appendChild(cell);
                }
            }
            const goalElement = document.createElement('div');
            goalElement.id = 'goal'; goalElement.textContent = '🏠';
            goalElement.style.cssText = `width:${cellSize}px; height:${cellSize}px; font-size:${cellSize*0.8}px; left:${goalPos.x*cellSize}px; top:${goalPos.y*cellSize}px;`;
            mazeContainer.appendChild(goalElement);

            [player, opponent].forEach(el => {
                mazeContainer.appendChild(el);
                el.style.width = `${cellSize * 0.9}px`; el.style.height = `${cellSize * 0.9}px`;
                el.style.fontSize = `${cellSize * 0.7}px`;
            });
            if (currentRoomData && currentRoomData.players) { updateAllPlayerPositions(currentRoomData.players); }
            else { updatePlayerPosition(); }
        }

        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                roomRef.child('players/' + myPlayerId).update({ x: newX, y: newY });
                if (newX === goalPos.x && newY === goalPos.y) {
                    roomRef.child('gameState').once('value', (gs) => { if(gs.val() === 'playing') roomRef.update({ gameState: 'roundOver', roundWinner: myPlayerId }); });
                }
            }
        }
        function soloMove(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                updatePlayerPosition();
                if (newX === goalPos.x && newY === goalPos.y) { setTimeout(() => { alert('🎉 도착!'); initializeGame(); }, 100); }
            }
        }
        function updatePlayerPosition() { player.style.left = `${playerPos.x * cellSize + (cellSize * 0.05)}px`; player.style.top = `${playerPos.y * cellSize + (cellSize * 0.05)}px`; }

        function startMoving(dx, dy) {
    stopMoving(); const moveFn = currentRoomCode ? movePlayer : soloMove;
    moveFn(dx, dy); moveInterval = setInterval(() => moveFn(dx, dy), 120);
}

        function stopMoving() { clearInterval(moveInterval); }

        ['up', 'down', 'left', 'right'].forEach(dir => {
            const btn = document.getElementById(dir); let dx = 0, dy = 0;
            if (dir === 'up') dy = -1; if (dir === 'down') dy = 1;
            if (dir === 'left') dx = -1; if (dir === 'right') dx = 1;
            btn.addEventListener('mousedown', () => startMoving(dx, dy));
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); startMoving(dx, dy); });
        });
        document.addEventListener('mouseup', stopMoving); document.addEventListener('touchend', stopMoving);

        let keyHeld = {};
        window.addEventListener('keydown', (e) => {
            if (keyHeld[e.key] || !gameWrapper.style.display || gameWrapper.style.display === 'none') return;
            keyHeld[e.key] = true;
            switch (e.key) {
                case 'ArrowUp': startMoving(0, -1); break; case 'ArrowDown': startMoving(0, 1); break;
                case 'ArrowLeft': startMoving(-1, 0); break; case 'ArrowRight': startMoving(1, 0); break;
            }
        });
        window.addEventListener('keyup', (e) => { keyHeld[e.key] = false; stopMoving(); });

        function placeStartAndGoal(layout) { const topRowPaths = []; for (let i = 0; i < layout[1].length; i++) { if (layout[1][i] === 0) topRowPaths.push(i); } const startX = topRowPaths[Math.floor(Math.random() * topRowPaths.length)]; layout[1][startX] = 'S'; const bottomRowPaths = []; const bottomRowIndex = layout.length - 2; for (let i = 0; i < layout[bottomRowIndex].length; i++) { if (layout[bottomRowIndex][i] === 0) bottomRowPaths.push(i); } const goalX = bottomRowPaths[Math.floor(Math.random() * bottomRowPaths.length)]; layout[bottomRowIndex][goalX] = 'G'; }
        
        function generateMaze(rows, cols) {
            rows = rows % 2 === 0 ? rows + 1 : rows;
            cols = cols % 2 === 0 ? cols + 1 : cols;
            const maze = Array(rows).fill(null).map(() => Array(cols).fill(1));
            const stack = [];
            const startX = 1, startY = 1;
            maze[startY][startX] = 0;
            stack.push([startX, startY]);

            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1];
                const directions = [];
                if (cy - 2 >= 1 && maze[cy - 2][cx] === 1) directions.push('N');
                if (cy + 2 < rows - 1 && maze[cy + 2][cx] === 1) directions.push('S');
                if (cx - 2 >= 1 && maze[cy][cx - 2] === 1) directions.push('W');
                if (cx + 2 < cols - 1 && maze[cy][cx + 2] === 1) directions.push('E');

                if (directions.length > 0) {
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    let nx = cx, ny = cy;
                    switch (dir) {
                        case 'N': ny -= 2; maze[cy - 1][cx] = 0; break;
                        case 'S': ny += 2; maze[cy + 1][cx] = 0; break;
                        case 'W': nx -= 2; maze[cy][cx - 1] = 0; break;
                        case 'E': nx += 2; maze[cy][cx + 1] = 0; break;
                    }
                    maze[ny][nx] = 0;
                    stack.push([nx, ny]);
                } else {
                    stack.pop();
                }
            }
            
            // --- ✨ 난이도 상승: 막다른 길 추가 로직 ---
            const removalCount = Math.floor(rows * cols * 0.05); // 전체 셀의 5%만큼 벽을 추가로 제거
            for (let i = 0; i < removalCount; i++) {
                const rx = Math.floor(Math.random() * (cols - 2)) + 1;
                const ry = Math.floor(Math.random() * (rows - 2)) + 1;
                if (maze[ry][rx] === 1) { // 임의의 위치가 벽일 경우 길로 만듦
                     maze[ry][rx] = 0;
                }
            }

            return maze;
        }

        window.addEventListener('resize', () => { if (gameWrapper.style.display === 'flex') { drawMapAndPlayers(); } });
    });
    </script>
</body>
</html>
