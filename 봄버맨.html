<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>크레이지 봄버</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        :root {
            --bg-color: #2c3e50;
             /* 이미지 URL 변수 */
            /* --board-bg-url 은 JS에서 직접 설정 */
            /* ✨ --wall-image-url: url('./봄버맨이미지/파괴불가.png');  <-- 이 줄을 삭제합니다. */

            --crate-color: #a0522d; /* 나무상자 색상 */
            --path-color: transparent; /* 길은 투명 (배경 보이도록) */
            --wall-color: #7f8c8d; /* 이미지 로딩 실패 시 보일 색상 */

            --player1-color: #3498db;
            --player2-color: #e74c3c;
            --explosion-color: rgba(255, 165, 0, 0.8);
            --item-bomb-color: #9b59b6;
            --item-range-color: #f1c40f;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
        }

        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-around; align-items: center;
            padding: 10px; background-color: rgba(0,0,0,0.2);
            width: 100%;
        }
        .player-info { display: flex; align-items: center; gap: 8px; }
        .player-avatar { font-size: 1.5em; }
        .player-avatar img { width: 32px; height: 32px; border-radius: 50%; }
        .player-stats { 
            font-size: 0.8em; 
            display: flex; 
            gap: 8px; /* ✨ 간격 살짝 조정 */
            margin-left: 5px;
            align-items: center; /* ✨ [신규] 아이콘/텍스트 세로 중앙 정렬 */
        }

        #game-container {
            width: 100%;
            flex-grow: 1; /* 남은 세로 공간 모두 차지 */
            display: flex; justify-content: center; align-items: center; /* 가운데 정렬 */
            position: relative; overflow: hidden;
            padding: 0; /* ✨ 10px -> 0으로 변경 (또는 이 라인 삭제) */
        }

        #game-board {
            position: relative;
            /* background-image 는 JS에서 설정 */
            /* ✨ 맵 배경 이미지 관련 CSS 모두 삭제 (JS가 backgroundColor로 제어) */
            background-size: cover; /* 삭제 */
            background-repeat: no-repeat; /* 삭제 */
            background-position: center; /* 중앙 정렬 */
            aspect-ratio: 11 / 15; /* 게임 보드 비율 */
            /* 높이/너비 중 작은 쪽에 맞춰 크기 조절 */
            width: auto; /* 너비 자동 */
            height: 100%; /* 컨테이너 높이에 맞춤 */
            max-height: calc(100vh - 70px); /* 헤더 높이 제외 최대 높이 */
            max-width: 100%; /* 컨테이너 너비 제한 */
            overflow: hidden;
            background-color: #333; /* 이미지 로딩 전 배경색 */
        }

        .grid-cell {
            position: absolute;
            width: calc(100% / 11);
            height: calc(100% / 15);
            /* 배경 관련 속도는 각 타일 클래스에서 설정 */
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            will-change: opacity, transform;
            top: 0; left: 0;
        }
        .wall { /* 파괴 불가 벽 */
            /* ✨ 이미지 관련 속성 모두 삭제 */
            background-color: var(--wall-color); /* #7f8c8d */
            border: 1px solid rgba(0,0,0,0.4);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2);
            z-index: 2;
        }
        .path { /* 이동 가능 길 */
             background-color: var(--path-color); /* 투명 */
             z-index: 1;
        }
        .crate { /* 파괴 가능 나무상자 */
            background-color: var(--crate-color); /* 갈색 */
            border: 1px solid rgba(0,0,0,0.3);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2);
            z-index: 2;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .crate.destroyed {
            opacity: 0;
            transform: scale(0.5);
        }

        .explosion { /* 폭발 효과 */
            position: absolute;
            top: 0; left: 0;
            background-color: var(--explosion-color);
            z-index: 20; /* 가장 위에 보이도록 */
            animation: fade-out-explosion 0.4s forwards;
            pointer-events: none;
            border-radius: 20%;
        }
        @keyframes fade-out-explosion {
            0% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(0.7); }
        }

        .bomb { /* 설치된 폭탄 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            z-index: 5; /* 길(1) < 폭탄(5) < 아이템(6) */
            
            display: block; /* ✨ [신규] 이미지가 보이도록 display 속성 추가 */

            /* ✨ [수정] 이미지를 배경으로 설정 */
            background-image: url('./봄버맨사운드/물풍선.png');
            background-size: 100% 100%; /* 타일 크기에 꽉 채우기 */
            background-repeat: no-repeat;
            background-position: center;

            /* ✨ [삭제] 텍스트/이모지 관련 속성 제거 */
            /* display: flex; justify-content: center; align-items: center; */
            /* font-size: calc(100vh / 25); */

            transition: left 0.1s linear, top 0.1s linear;
            will-change: left, top;
            animation: pulse-bomb 1s infinite;
            pointer-events: none;
        }

        @keyframes pulse-bomb {
            0% { transform: scale(1.0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1.0); }
        }


        .item { /* 아이템 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            z-index: 6; /* 폭탄(5) < 아이템(6) < 플레이어(10) */
            /* ✨ [삭제] display: flex; justify-content: center; align-items: center; */
            /* ✨ [삭제] font-size: calc(100vh / 28); */
            border-radius: 50%;
            opacity: 0; /* 기본 숨김 */
            transition: opacity 0.3s ease-in;
            pointer-events: none;
        }
        .item.visible {
            opacity: 0.9;
        }
        /* ✨ [수정] 아래 두 줄의 background-color를 삭제(주석 처리)합니다 */
        /* .item-bomb { background-color: var(--item-bomb-color); } */
        /* .item-range { background-color: var(--item-range-color); } */
        .item-balloon {
             animation: float 2s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }

        .player { /* 플레이어 캐릭터 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            border-radius: 50%;
            z-index: 10; /* 아이템(6) < 플레이어(10) < 화살표(11) */
            display: flex; justify-content: center; align-items: center;
            font-size: 0.8em;
            transition: left 0.2s linear, top 0.2s linear, opacity 0.3s ease; 
            will-change: left, top, opacity;
        }
        .player-avatar-img {
            width: 90%; height: 90%;
            object-fit: contain; border-radius: 50%;
        }
        .player.dead { /* 사망 시 효과 */
            opacity: 0.5;
            pointer-events: none; /* 조작 불가 */
        }

        .player-indicator { /* 내 캐릭터 위 화살표 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            z-index: 11; /* 플레이어(10)보다 위 */
            text-align: center;
            font-size: 1.2em;
            color: yellow;
            text-shadow: 0 0 3px black;
            pointer-events: none;
            transition: left 0.1s linear, top 0.1s linear;
            will-change: left, top;
            animation: bounce 1s infinite ease-in-out;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

         /* --- 컨트롤러, 모달 CSS (변경 없음) --- */
        #controls-container { position: fixed; bottom: 30px; left: 30px; z-index: 100;}
         #d-pad { position: relative; width: 120px; height: 120px; }
         .d-pad-btn { 
            position: absolute; 
            width: 40px; 
            height: 40px; 
            background-color: rgba(255, 255, 255, 0.3); /* ✨ 원래 색으로 */
            border: 1px solid rgba(255, 255, 255, 0.5); /* ✨ 원래 테두리 */
            border-radius: 8px; /* ✨ 둥근 사각형으로 변경 */
            display: flex; justify-content: center; align-items: center; 
            font-size: 1.5em; 
            color: white; 
            cursor: pointer; 
         }
         .d-pad-btn.active { background-color: rgba(255, 255, 255, 0.6); } /* ✨ 원래 활성 색으로 */
         #btn-up { top: 0; left: 40px; }
         #btn-left { top: 40px; left: 0; }
         #btn-right { top: 40px; left: 80px; }
         #btn-down { top: 80px; left: 40px; }
         /* ✨ [신규] 오른쪽 컨트롤러 컨테이너 */
         #action-controls-container {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 100;
            display: flex;
            flex-direction: column; /* 아이템 버튼이 위로 쌓이도록 */
            align-items: center; /* 가운데 정렬 */
         }

         /* ✨ [신규] 아이템 버튼 슬롯 */
         #item-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px; /* 폭탄 버튼과의 간격 */
         }

         /* ✨ [신규] 개별 아이템 버튼 (디자인만) */
         .item-slot-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5em;
            cursor: not-allowed; /* 아직 기능이 없으므로 */
         }

         /* CSS (변경코드) - #bomb-btn 스타일 전체를 교체하세요 */
         #bomb-btn { 
            position: fixed; 
            bottom: 40px; 
            right: 40px; /* ✨ 중앙이 아닌 오른쪽으로 위치 고정 */
            width: 80px; 
            height: 80px; 
            
            background-color: rgba(20, 150, 255, 0.7);  /* ✨ 파란색으로 변경 (스크린샷 참조) */
            border: 3px solid rgba(255, 255, 255, 0.5); /* ✨ 테두리 변경 */
            border-radius: 50%; 
            z-index: 100; 
            cursor: pointer; 
            
            background-image: url('./봄버맨사운드/물풍선.png');
            background-size: 80% 80%; 
            background-repeat: no-repeat;
            background-position: center;

             /* ✨ [신규] 유리알 질감 효과 */
            box-shadow: inset 0 3px 5px rgba(255,255,255,0.5), 0 4px 6px rgba(0,0,0,0.3);
         }
         #bomb-btn:active { 
            background-color: rgba(50, 170, 255, 0.9); /* ✨ 눌렀을 때 파란색 */
            transform: scale(0.95); 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); /* ✨ 누르면 안으로 그림자 */
         }
         .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.7); z-index: 1000; }
         .overlay.active { display: flex; }
         .modal-content { background: #ecf0f1; color: #333; padding: 30px; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
         .modal-content h2 { font-size: 2em; margin-bottom: 20px; color: var(--primary-color); }
         .modal-btn { padding: 12px 25px; font-size: 1.1em; font-weight: 700; border-radius: 10px; border: none; cursor: pointer; margin: 10px; }
         .modal-btn.primary { background-color: var(--primary-color); color: white; }
         .modal-btn.secondary { background-color: #bdc3c7; color: #333; }

/* --- 3분 타이머 스타일 --- */
        #game-timer {
            position: absolute; /* header 바로 아래 중앙에 */
            top: 60px; /* 헤더 높이(52px) + 여백 */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1.5em;
            font-weight: 700;
            padding: 5px 15px;
            border-radius: 10px;
            z-index: 50;
            width: 100px;
            text-align: center;
        }

        /* --- 3, 2, 1 카운트다운 오버레이 --- */
        #countdown-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000; /* 최상위 */
            color: white;
            font-weight: 700;
            font-size: 15vw; /* 화면 크기에 비례 */
            display: none; /* JS로 제어 */
        }
        #countdown-overlay .number {
            animation: countdown-zoom 1s forwards;
        }
        @keyframes countdown-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            90% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(1); opacity: 0; } /* 1초 뒤 사라짐 */
        }

    </style>
</head>
<body>
    <audio id="sound-background" src="./봄버맨사운드/배경음악1.mp3" loop></audio>
    <audio id="sound-place-bomb" src="./봄버맨사운드/폭탄놓는소리.mp3"></audio>
    <audio id="sound-explosion" src="./봄버맨사운드/물풍선터지는소리.mp3"></audio>
    <audio id="sound-item-get" src="./봄버맨사운드/드랍.mp3"></audio>
    <audio id="sound-win" src="./봄버맨사운드/win.mp3"></audio>
    <audio id="sound-lose" src="./봄버맨사운드/패배.mp3"></audio>

    <div id="game-wrapper">
        <div id="game-header"></div>
        <div id="game-timer">03:00</div> 
        <div id="game-container">
            <div id="game-board"></div>
        </div>
    </div>

    <div id="controls-container">
        <div id="d-pad">
            <button class="d-pad-btn" id="btn-up">↑</button>
            <button class="d-pad-btn" id="btn-left">←</button>
            <button class="d-pad-btn" id="btn-right">→</button>
            <button class="d-pad-btn" id="btn-down">↓</button>
        </div>
    </div>

    <button id="bomb-btn"></button>

    <div id="game-over-modal" class="overlay">
        <div class="modal-content">
            <h2 id="game-over-message"></h2>
            <button id="lobby-btn" class="modal-btn secondary">대기실로</button>
        </div>
    </div>

    <div id="countdown-overlay">
        <span id="countdown-number" class="number">3</span>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script>
        // 개발자 도구 F12 방지 (엄격하지 않음)
        document.addEventListener('contextmenu', event => event.preventDefault());
        /*
        document.addEventListener('keydown', event => {
             if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) || (event.ctrlKey && event.key.toUpperCase() === 'U')) {
               event.preventDefault();
             }
        });
        // setInterval(() => { try { debugger; } catch (e) {} }, 1000); // 디버거 방지 (개발 중에는 주석 처리)
        */

        document.addEventListener('DOMContentLoaded', () => {
            // Firebase 앱 초기화
            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.appspot.com",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database(); // Firebase Realtime Database 인스턴스
            const auth = firebase.auth(); // Firebase Authentication 인스턴스
            const roomsRef = db.ref('rooms'); // 'rooms' 경로 참조
            const usersRef = db.ref('users'); // 'users' 경로 참조

            // HTML 요소 가져오기
            const gameBoard = document.getElementById('game-board');
            const gameHeader = document.getElementById('game-header');
            const gameOverModal = document.getElementById('game-over-modal');
            const gameOverMessage = document.getElementById('game-over-message');
            // 로비 버튼은 게임오버 모달 내부에 있으므로 showGameOver에서 처리

            // 게임 상태 변수
            let myPlayerId, myNickname, myAvatar, roomRef, isHost;
            let currentRoomData = {}; // 현재 방 데이터 (Firebase에서 받아옴)
            let playerElements = {}; // 플레이어 DOM 요소 저장 객체 {'playerId': element}
            let myIndicatorElement = null; // 내 플레이어 위 화살표 DOM 요소
            let bombElements = {}; // 폭탄 DOM 요소 저장 객체 {'bombId': element}
            let itemElements = {}; // 아이템 DOM 요소 저장 객체 {'itemId': element}
            let mapGrid = []; // 로컬 맵 데이터 (0: 길, 1: 벽, 2: 상자)
            let mapElements = []; // 맵 타일 DOM 요소 저장 배열 [[cell, cell], ...]
           let TILE_WIDTH = 0; // 타일 가로 크기
            let TILE_HEIGHT = 0; // 타일 세로 크기

            // ✨ [신규] 게임 타이머 및 카운트다운 요소
            const countdownOverlayEl = document.getElementById('countdown-overlay');
            const countdownNumberEl = document.getElementById('countdown-number');
            const gameTimerEl = document.getElementById('game-timer');
            const GAME_TIME_LIMIT = 180; // 3분
            let gameTimerInterval = null; // 게임 타이머 setInterval ID
            let ghostSpawned = false; // 유령 스폰 여부 (미래 기능용)
            // ✨ [신규] 사운드 스로틀링
            let lastExplosionSoundTime = 0;

            const GRID_COLS = 11; // 맵 가로 칸 수
            const GRID_ROWS = 15; // 맵 세로 칸 수

            let moveDirection = { x: 0, y: 0, current: null }; // 현재 이동 방향 정보
            let moveInterval = null; // 연속 이동 인터벌 ID
            const BASE_MOVE_SPEED = 210;
// ✨ [신규] 속도 레벨 (기본, +1, +2)
            const speedLevels = [BASE_MOVE_SPEED, 180, 150]; 

            let serverTimeOffset = 0; // 클라이언트-서버 시간 차이
            let bombTimerInterval = null; // 폭탄 타이머 체크 인터벌 ID
            let explodingBombs = new Set(); // 현재 폭발 중인 폭탄 ID 저장 Set

            // 아이템 타입 정의
            const ITEM_TYPES = { BOMB_COUNT: 'bomb', BOMB_RANGE: 'range', SPEED: 'speed' };
           // 아이템 아이콘 정의
             const ITEM_ICONS = { [ITEM_TYPES.BOMB_COUNT]: '💣', [ITEM_TYPES.BOMB_RANGE]: '🔥' };

             // ✨ [신규] 사운드 재생 함수 (오류 방지 포함)
             function playSound(id) {
                try {
                    const sound = document.getElementById(id);
                    if (sound) {
                        sound.currentTime = 0; // 처음부터 재생
                        sound.play();
                    }
                } catch (e) {
                    console.warn(`사운드(${id}) 재생 오류:`, e);
                }
             }
             
             // ✨ 맵 배경색 목록 (초원, 설원, 사막, 석재)
             const mapBackgroundColors = [
                 '#a7d38c', // 초원
                 '#f0f8ff', // 설원 (AliceBlue)
                 '#e6c891', // 사막
                 '#bdc3c7'  // 석재
             ];
             let selectedMapBackground = ''; // 현재 게임에서 사용할 배경 이미지 URL

            // 초기화 함수: 서버 시간 오프셋 가져오고, 사용자 인증 상태 확인
            function initialize() {
                // 서버 시간과의 차이를 가져와 동기화에 사용
                const offsetRef = db.ref(".info/serverTimeOffset");
                offsetRef.on("value", (snap) => {
                    serverTimeOffset = snap.val();
                });

                // 사용자 로그인 상태 변경 감지
                auth.onAuthStateChanged(user => {
                    if (user) { // 로그인 되어 있으면
                        myPlayerId = user.uid; // 내 ID 저장
                        myNickname = localStorage.getItem('userNickname'); // 로컬 저장소에서 닉네임 가져오기
                        myAvatar = localStorage.getItem('userAvatar'); // 로컬 저장소에서 아바타 가져오기

                        // URL에서 방 ID 가져오기
                        const urlParams = new URLSearchParams(window.location.search);
                        const roomId = urlParams.get('roomId');

                        // 방 ID나 닉네임 없으면 잘못된 접근 처리
                        if (!roomId || !myNickname) {
                            alert("잘못된 접근입니다.");
                            window.location.href = '대기실.html';
                            return;
                        }
                        joinRoom(roomId); // 방 참가 함수 호출
                    } else { // 로그인 안 되어 있으면
                        window.location.href = 'index.html'; // 로그인 페이지로 이동
                    }
                });
            }

            // 방 참가 함수: 방 정보 가져오고, 방장/게스트 설정, 리스너 시작
            function joinRoom(roomId) {
                roomRef = roomsRef.child(roomId); // 해당 방 경로 참조

                // 방 정보 한 번만 가져오기
                roomRef.once('value', snapshot => {
                    if (!snapshot.exists()) { // 방이 없으면
                        alert("방을 찾을 수 없습니다.");
                        window.location.href = '대기실.html';
                        return;
                    }

                    currentRoomData = snapshot.val(); // 현재 방 데이터 저장
                    isHost = currentRoomData.hostId === myPlayerId; // 내가 방장인지 확인

                    if (isHost) { // 방장이면
                        roomRef.onDisconnect().remove(); // 연결 끊기면 방 자동 삭제 설정
                        // 방장만 폭탄 타이머 시작
                        if (!bombTimerInterval) {
                            bombTimerInterval = setInterval(checkBombTimers, 100); // 0.1초마다 타이머 체크
                        }
                    } else { // 게스트면
                        // 연결 끊기면 내 플레이어 정보만 삭제 설정
                        roomRef.child('players/' + myPlayerId).onDisconnect().remove();
                    }

                    
listenToRoomChanges(); // Firebase 데이터 변경 감지 시작
                    setupControls(); // 조작 버튼 설정
                });
            }

            // 게임 레이아웃 설정 함수: 타일 크기 계산, 맵 생성 또는 렌더링
            function setupGameLayout() {
                // 브라우저가 화면을 그릴 준비가 되면 실행 (정확한 크기 계산 위함)
                requestAnimationFrame(() => {
                     // 게임 보드 요소가 없으면 중단 (예: 페이지 이동 중)
                    if (!document.body.contains(gameBoard)) {
                        console.log("게임 보드 없음, 레이아웃 설정 중단");
                        return;
                    }

                    // 타일 크기 계산
                    TILE_WIDTH = gameBoard.clientWidth / GRID_COLS;
                    TILE_HEIGHT = gameBoard.clientHeight / GRID_ROWS;

                    // 타일 크기가 유효하지 않으면 재시도
                    if (isNaN(TILE_WIDTH) || TILE_WIDTH <= 0 || isNaN(TILE_HEIGHT) || TILE_HEIGHT <= 0) {
                        console.warn("타일 크기 계산 오류, 재시도...");
                        setTimeout(setupGameLayout, 100); // 0.1초 후 재시도
                        return;
                    }

                    console.log(`[레이아웃 설정] 타일 크기: W=${TILE_WIDTH.toFixed(1)}, H=${TILE_HEIGHT.toFixed(1)}`);

                    // 호스트이고 아직 맵 데이터가 없으면 맵 생성
                    if (isHost && !currentRoomData.map) {
                        console.log("[레이아웃 설정] 호스트가 맵 생성 중...");
                        generateMap(); // 맵 데이터 생성 및 Firebase 업데이트
                        // 맵 렌더링은 listenToRoomChanges가 Firebase 업데이트 감지 후 처리
                    }
                    // 맵 데이터가 있으면 (게스트 또는 호스트가 재접속/화면크기변경 등) 맵/요소 렌더링
                    else if (currentRoomData.map) {
                         console.log("[레이아웃 설정] 기존 맵 및 요소 렌더링 중...");
                         // 로컬 맵 데이터 없으면 Firebase 데이터로 채움
                         if(mapGrid.length === 0) mapGrid = currentRoomData.map;
                         renderMap(); // 맵 타일 렌더링
                         renderGameElements(); // 플레이어, 폭탄, 아이템 렌더링
                    } else {
                         console.log("[레이아웃 설정] 맵 데이터 기다리는 중...");
                         // 아직 맵 데이터 못 받음, listenToRoomChanges가 처리할 때까지 대기
                    }
                });
            }


            // 맵 생성 함수 (방장 전용): 맵 구조, 플레이어 위치, 아이템 등 생성 후 Firebase 업데이트
            function generateMap() {
                // 1. 맵 배경색 랜덤 선택
                const mapIndex = Math.floor(Math.random() * mapBackgroundColors.length);
                
                 // ✨ 호스트는 자기 화면 배경색 즉시 설정
                 const newColor = mapBackgroundColors[mapIndex];
                 gameBoard.style.backgroundColor = newColor;
                 console.log("호스트 맵 배경색 즉시 설정:", newColor);

                // 2. 맵 데이터 초기화 (모든 칸 길(0)로)
                mapGrid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(0));

                // 3. 플레이어 시작 위치 정의
                let player1Pos = { r: GRID_ROWS - 2, c: Math.floor(GRID_COLS / 2) }; // 아래 중앙
                let player2Pos = { r: 1, c: Math.floor(GRID_COLS / 2) }; // 위 중앙

                // 4. 파괴 불가 벽(1) 랜덤 배치 (4~6개)
                let wallCount = 0;
                const maxWalls = Math.floor(Math.random() * 3) + 4;
                while (wallCount < maxWalls) {
                    const r = Math.floor(Math.random() * (GRID_ROWS - 2)) + 1; // 테두리 제외
                    const c = Math.floor(Math.random() * (GRID_COLS - 2)) + 1; // 테두리 제외
                    // 시작 지점 주변(2칸 이내) 및 이미 벽/상자가 있는 곳 제외
                    const isNearP1 = Math.abs(r - player1Pos.r) <= 2 && Math.abs(c - player1Pos.c) <= 2;
                    const isNearP2 = Math.abs(r - player2Pos.r) <= 2 && Math.abs(c - player2Pos.c) <= 2;
                    if (mapGrid[r][c] === 0 && !isNearP1 && !isNearP2) {
                        mapGrid[r][c] = 1; // 벽(1) 배치
                        wallCount++;
                    }
                }

                // 5. 파괴 가능 나무상자(2) 랜덤 배치 (빈 공간의 60% 정도)
                for (let r = 0; r < GRID_ROWS; r++) {
                     for (let c = 0; c < GRID_COLS; c++) {
                        // 길이(0)이고, 시작 지점 바로 옆(1칸 이내) 아니면 확률적 배치
                        if (mapGrid[r][c] === 0) {
                             const isNearP1 = Math.abs(r - player1Pos.r) <= 1 && Math.abs(c - player1Pos.c) <= 1;
                             const isNearP2 = Math.abs(r - player2Pos.r) <= 1 && Math.abs(c - player2Pos.c) <= 1;
                             if (!isNearP1 && !isNearP2 && Math.random() < 0.6) {
                                mapGrid[r][c] = 2; // 나무상자(2) 배치
                             }
                        }
                     }
                }

                // 6. 시작 지점 주변 강제로 길(0) 만들기 (벽/상자 덮어쓰기)
                const startPoints = [
                    player1Pos, {r: player1Pos.r - 1, c: player1Pos.c}, {r: player1Pos.r, c: player1Pos.c - 1}, {r: player1Pos.r, c: player1Pos.c + 1},
                    player2Pos, {r: player2Pos.r + 1, c: player2Pos.c}, {r: player2Pos.r, c: player2Pos.c - 1}, {r: player2Pos.r, c: player2Pos.c + 1}
                ];
                startPoints.forEach(pos => {
                    // 맵 범위 안인지 확인 후 길(0)로 변경
                    if (pos.r >= 0 && pos.r < GRID_ROWS && pos.c >= 0 && pos.c < GRID_COLS) {
                        mapGrid[pos.r][pos.c] = 0;
                    }
                });

                // 7. 플레이어 데이터 준비 (위치, 기본 스탯)
                const playerIds = Object.keys(currentRoomData.players);
                const hostId = currentRoomData.hostId;
                const guestId = playerIds.find(id => id !== hostId);
                let playersData = { ...currentRoomData.players }; // 기존 아바타 등 정보 유지
                // 호스트(P1) 데이터 설정
                playersData[hostId] = { ...playersData[hostId], r: player1Pos.r, c: player1Pos.c, stats: { maxBombs: 1, bombRange: 1, speed: 1, isAlive: true } };
                // 게스트(P2) 데이터 설정 (존재하면)
                if (guestId && playersData[guestId]) {
                    playersData[guestId] = { ...playersData[guestId], r: player2Pos.r, c: player2Pos.c, stats: { maxBombs: 1, bombRange: 1, speed: 1, isAlive: true } };
                }

                // 8. 시작 아이템 풍선 위치 선정 (시작점 근처 나무상자 아래)
                let initialItems = {};
                const itemTypes = [ITEM_TYPES.BOMB_COUNT, ITEM_TYPES.BOMB_RANGE]; // 가능한 아이템 종류

                // 주변 나무상자 찾는 함수
                const findCrateSpot = (startPos) => {
                    // 상하좌우 후보 위치
                    const candidates = [
                        {r: startPos.r, c: startPos.c - 1}, {r: startPos.r, c: startPos.c + 1}, // 좌우
                        {r: startPos.r - 1, c: startPos.c}, {r: startPos.r + 1, c: startPos.c}  // 상하
                    ];
                    // 후보 위치 랜덤 섞기
                    candidates.sort(() => Math.random() - 0.5);
                    // 섞인 순서대로 나무상자(2)인지 확인 후 반환
                    for (let p of candidates) {
                        // 맵 범위 안이고 나무상자(2)이면 해당 위치 반환
                        if (p.r >= 0 && p.r < GRID_ROWS && p.c >= 0 && p.c < GRID_COLS && mapGrid[p.r]?.[p.c] === 2) {
                            return p;
                        }
                    }
                     // 주변 1칸에 없으면, 2칸 범위에서 다시 찾기 (비상용)
                     for (let dr = -2; dr <= 2; dr++){
                        for (let dc = -2; dc <= 2; dc++){
                            // 대각선 포함 2칸 이내, 시작점 제외
                            if(Math.abs(dr) + Math.abs(dc) > 2 || (dr === 0 && dc === 0)) continue;
                            const r = startPos.r + dr;
                            const c = startPos.c + dc;
                             // 맵 범위 안이고 나무상자(2)이면 반환
                             if (r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS && mapGrid[r]?.[c] === 2) {
                                return {r, c};
                             }
                        }
                    }
                    return null; // 못 찾으면 null 반환
                };

                // P1 아이템 위치 찾고 데이터 생성
                const p1ItemPos = findCrateSpot(player1Pos);
                if (p1ItemPos) {
                     const itemKey = roomRef.child('items').push().key; // Firebase 키 생성
                     initialItems[itemKey] = {
                        r: p1ItemPos.r, c: p1ItemPos.c, type: itemTypes[0], // P1은 폭탄 개수
                        isVisible: false, isBalloon: true // 처음엔 안 보임
                    };
                     mapGrid[p1ItemPos.r][p1ItemPos.c] = 2; // 확실히 상자로 덮기
                     console.log(`P1 시작 아이템 위치: ${p1ItemPos.r}, ${p1ItemPos.c}`);
                } else {
                     console.warn("P1 시작 아이템 놓을 상자 못 찾음");
                }

                 // P2 아이템 위치 찾고 데이터 생성
                 const p2ItemPos = findCrateSpot(player2Pos);
                 if (p2ItemPos) {
                      const itemKey = roomRef.child('items').push().key; // Firebase 키 생성
                     initialItems[itemKey] = {
                        r: p2ItemPos.r, c: p2ItemPos.c, type: itemTypes[1], // P2는 사거리
                        isVisible: false, isBalloon: true // 처음엔 안 보임
                    };
                      mapGrid[p2ItemPos.r][p2ItemPos.c] = 2; // 확실히 상자로 덮기
                      console.log(`P2 시작 아이템 위치: ${p2ItemPos.r}, ${p2ItemPos.c}`);
                 } else {
                      console.warn("P2 시작 아이템 놓을 상자 못 찾음");
                 }

               // 9. Firebase에 모든 데이터 업데이트
               console.log("[맵 생성] Firebase 업데이트 실행...");
               
               // ✨ [핵심 수정] players 객체 전체 덮어쓰기 대신 개별 업데이트
                const updates = {};
                updates['mapIndex'] = mapIndex;
                updates['map'] = mapGrid;
                updates['items'] = initialItems;
                updates['status'] = 'playing';
                updates['gameStartTime'] = firebase.database.ServerValue.TIMESTAMP;

                // ✨ 각 플레이어의 r, c, stats만 업데이트
                updates['players'] = playersData;
                
                roomRef.update(updates);
            }


            // Firebase 데이터 변경 감지 함수
            function listenToRoomChanges() {
                // 방 데이터 변경될 때마다 실행
                roomRef.on('value', snapshot => {
                    // 방이 삭제되었는지 확인
                    if (!snapshot.exists()) {
                         // 게임 오버 모달이 안 떠있으면 (정상 종료 아니면)
                         if (!gameOverModal.classList.contains('active')) {
                            alert("방장이 나갔습니다.");
                            clearInterval(bombTimerInterval); // 타이머 정리
                            bombTimerInterval = null;
                            window.location.href = '대기실.html'; // 대기실로 이동
                        }
                        return; // 함수 종료
                    }

                    

                  const oldStatus = currentRoomData.status; // 이전 게임 상태 저장
                    const oldMapDataString = JSON.stringify(currentRoomData.map); // 이전 맵 데이터 문자열로 저장
                    currentRoomData = snapshot.val(); // 최신 방 데이터 저장

                    // ✨ [신규] 게임 시작 감지 (카운트다운 시작)
                    if (currentRoomData.status === 'playing' && oldStatus !== 'playing') {
                        startCountdown(); // 카운트다운 시작
                        return; // 맵 렌더링 등은 카운트다운 완료 후
                    }
                    
                    // ✨ [신규] 이미 게임 중일 때 (재접속 등)
                    if (currentRoomData.status === 'playing' && oldStatus === 'playing') {
                        // 카운트다운 없이 바로 게임 타이머 시작
                        startGameTimer(); 
                    }
                    const newMapDataString = JSON.stringify(currentRoomData.map); // 새 맵 데이터 문자열로 저장

                     // ✨ 맵 배경색 설정 (데이터에 있고, 유효한 인덱스면)
                     if (currentRoomData.mapIndex !== undefined && mapBackgroundColors[currentRoomData.mapIndex]) {
                         const newColor = mapBackgroundColors[currentRoomData.mapIndex];
                         // ✨ 현재 배경색과 다를 경우에만 변경
                         if (gameBoard.style.backgroundColor !== newColor) { 
                             gameBoard.style.backgroundColor = newColor;
                             console.log("맵 배경색 설정:", newColor);
                         }
                     }

                    // 타일 크기 계산 및 맵/요소 렌더링 순서 관리
                    if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) { // 타일 크기 계산 안됐으면
                        console.log("[데이터 수신] 타일 크기 미계산, 레이아웃 재설정 예약");
                        setTimeout(setupGameLayout, 50); // 잠시 후 재계산 및 렌더링 시도
                    } else { // 타일 크기 계산 됐으면
                        // ▼▼▼ [수정] 맵 렌더링 로직 변경 ▼▼▼
                        
                        // 1. 맵이 아예 없었으면 (초기 로딩)
                        if (currentRoomData.map && mapElements.length === 0) {
                             console.log("[데이터 수신] 초기 로드, 맵 및 요소 렌더링");
                             mapGrid = currentRoomData.map;
                             renderMap(); // 맵 타일 생성
                             renderGameElements(); // 요소 렌더링
                        } 
                        // 2. 맵 데이터가 변경되었으면 (예: 상자 파괴)
                        else if (currentRoomData.map && oldMapDataString !== newMapDataString) {
                             console.log("[데이터 수신] 맵 변경, 맵 시각 효과 업데이트 및 요소 렌더링");
                             updateMapVisuals(currentRoomData.map); // ✨ 맵 타일 시각 효과만 업데이트
                             renderGameElements(); // ✨ 요소는 따로 렌더링 (플레이어, 아이템 등)
                        } 
                        // 3. 맵 변경 없으면 (플레이어 이동 등)
                        else {
                             // console.log("[데이터 수신] 동적 요소만 렌더링");
                             renderGameElements();
                        }
                        // ▲▲▲ [수정] ▲▲▲
                    }

                    // 헤더 업데이트 (플레이어 정보 표시)
                    if (currentRoomData.players) {
                        updateHeader(currentRoomData.players);
                    }

                    // 게임 상태가 'gameOver'로 변경되었으면 종료 처리
                    if (currentRoomData.status === 'gameOver' && oldStatus !== 'gameOver') {
                        clearInterval(bombTimerInterval); // 타이머 정리
                        bombTimerInterval = null;
                        showGameOver(currentRoomData.winner); // 게임 오버 화면 표시
                    }
                });
               roomRef.child('rematchRequests').on('value', snapshot => {
                    if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;

                    const requests = snapshot.val();
                    const requestCount = Object.keys(requests).length;
                    const playerCount = Object.keys(currentRoomData.players).length;

                    // 모든 플레이어가 재시작을 요청했다면
                    if (requestCount === playerCount) {
                        // 방장(Host)만 게임 재시작을 처리합니다.
                        if (isHost) {
                            // 게임 상태를 초기화하고 재시작 신호를 보냅니다.
                            roomRef.update({
                                gameState: 'restarting', // 재시작 트리거
                                rematchRequests: null,   // 요청 기록 삭제
                                winner: null,            // 게임오버 상태 삭제
                                status: 'waiting',       // 대기 상태로 변경 (맵 재생성 유도)
                                map: null,               // 맵 삭제
                                items: null,             // 아이템 삭제
                                bombs: null,             // 폭탄 삭제
                                gameStartTime: null,     // 시간 삭제
                                players: currentRoomData.players // ✨ 플레이어 정보는 유지
                            });
                        }
                    }
                });

                // ✨ [신규] '재시작' 신호 감지 리스너 (알까기.html 참조)
                roomRef.child('gameState').on('value', snapshot => {
                    if (snapshot.val() === 'restarting') {
                        // 재시작 신호를 받으면 0.5초 후 새로고침하여 게임을 다시 시작합니다.
                        setTimeout(() => {
                            location.reload();
                        }, 500);
                    }
                }); 
  
            }

            


            // 게임 요소들 렌더링 함수 (플레이어, 아이템, 폭탄 순서 중요)
            function renderGameElements() {
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;
                 // 렌더링 순서: 아이템 -> 폭탄 -> 플레이어 (z-index 순서 고려)
                 renderItems(currentRoomData.items);
                 renderBombs(currentRoomData.bombs);
                 renderPlayers(currentRoomData.players);
            }


            // 맵 타일 렌더링 함수
            function renderMap() {
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) {
                      console.warn("[맵 렌더링] 타일 크기 미계산, 렌더링 중단");
                      return;
                 }

                gameBoard.innerHTML = ''; // 기존 맵 요소 모두 제거
                 // 내 화살표 요소 먼저 생성 및 추가
                 if (!myIndicatorElement && myPlayerId) {
                    myIndicatorElement = document.createElement('div');
                    myIndicatorElement.className = 'player-indicator';
                    myIndicatorElement.textContent = '🔽';
                    gameBoard.appendChild(myIndicatorElement);
                }

                mapElements = []; // 맵 요소 배열 초기화
                // 맵 데이터 기반으로 타일 요소 생성
                (currentRoomData.map || []).forEach((row, r) => { // currentRoomData.map 사용 보장
                    const rowElements = [];
                    row.forEach((tileType, c) => {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell'; // 기본 클래스
                        cell.dataset.r = r; // 행 좌표 저장
                        cell.dataset.c = c; // 열 좌표 저장

                        // 타일 타입에 맞는 클래스 추가
                        if (tileType === 1) cell.classList.add('wall');
                        else if (tileType === 2) cell.classList.add('crate');
                        else cell.classList.add('path');

                        // top, left로 위치 설정
                        cell.style.left = `${c * TILE_WIDTH}px`;
                        cell.style.top = `${r * TILE_HEIGHT}px`;

                        gameBoard.appendChild(cell); // 게임 보드에 추가
                        rowElements.push(cell); // 행 배열에 추가
                    });
                    mapElements.push(rowElements); // 전체 맵 요소 배열에 행 추가
                });
                 // 로컬 mapGrid도 업데이트
                 mapGrid = currentRoomData.map || [];
            }


            // 맵 시각 효과 업데이트 함수 (예: 상자 파괴 시)
            function updateMapVisuals(newMapData) {
                // 맵 요소 배열 없거나 타일 크기 계산 안됐으면 중단
                if (!mapElements.length || TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;

                // 모든 칸 순회
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        // 해당 위치 요소 없으면 건너뜀
                        if (!mapElements[r] || !mapElements[r][c]) continue;
                        const cellEl = mapElements[r][c]; // 현재 칸 DOM 요소
                        const oldType = mapGrid[r]?.[c]; // 이전 로컬 맵 데이터
                        const newType = newMapData[r]?.[c]; // 새 Firebase 맵 데이터

                        // 타입이 변경되었을 때만 처리
                        if (oldType !== newType) {
                            // 나무상자(2) -> 길(0) 변경 시
                            if (oldType === 2 && newType === 0) {
                                cellEl.classList.add('destroyed'); // 파괴 애니메이션 클래스 추가
                                 // 애니메이션 시간(0.3초) 후 실제 스타일 변경
                                 setTimeout(() => {
                                    // 요소가 아직 존재하고, 데이터가 다시 바뀌지 않았는지 확인
                                    // currentRoomData.map 직접 비교
                                    if (mapElements[r]?.[c] === cellEl && currentRoomData?.map?.[r]?.[c] === 0) {
                                        cellEl.classList.remove('crate', 'destroyed'); // 상자 클래스 제거
                                        cellEl.classList.add('path'); // 길 클래스 추가
                                        cellEl.style.backgroundImage = 'none'; // 이미지 제거
                                        cellEl.style.backgroundColor = 'var(--path-color)'; // 투명 배경
                                        cellEl.style.border = 'none'; // 테두리 제거
                                        cellEl.style.boxShadow = 'none'; // 그림자 제거
                                    }
                                 }, 300);
                            } else { // 그 외 타입 변경 시 (즉시 변경)
                                cellEl.classList.remove('wall', 'crate', 'path', 'destroyed'); // 모든 타입 클래스 제거
                                // 새 타입에 맞는 클래스 추가
                                if (newType === 1) cellEl.classList.add('wall');
                                else if (newType === 2) cellEl.classList.add('crate');
                                else cellEl.classList.add('path');

                                // 새 타입에 맞는 스타일 적용
                                if (newType === 1) { // 벽
                                     // ✨ 클래스(.wall)가 스타일을 적용하므로 
                                     // ✨ 인라인 스타일은 모두 제거 (상자 스타일만 복사)
                                     cellEl.style.backgroundImage = 'none';
                                     cellEl.style.backgroundColor = 'var(--wall-color)';
                                     cellEl.style.border = '1px solid rgba(0,0,0,0.4)';
                                     cellEl.style.boxShadow = 'inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2)';
                                } else if (newType === 2) { // 상자
                                     cellEl.style.backgroundImage = 'none'; // 이미지 대신 색상 사용
                                     cellEl.style.backgroundColor = 'var(--crate-color)';
                                     cellEl.style.border = '1px solid rgba(0,0,0,0.3)';
                                     cellEl.style.boxShadow = 'inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2)';
                                } else { // 길
                                    cellEl.style.backgroundImage = 'none';
                                    cellEl.style.backgroundColor = 'var(--path-color)'; // 투명
                                    cellEl.style.border = 'none';
                                    cellEl.style.boxShadow = 'none';
                                }
                            }
                        }
                    }
                }
                mapGrid = newMapData; // 로컬 맵 데이터 업데이트
            }


           function renderPlayers(players) {
                // 타일 크기 계산 안됐으면 중단
                if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;

                // 내 화살표 요소 없으면 생성 (보드 존재 확인 추가)
                if (!myIndicatorElement && myPlayerId && document.body.contains(gameBoard)) {
                    myIndicatorElement = document.createElement('div');
                    myIndicatorElement.className = 'player-indicator';
                    myIndicatorElement.textContent = '🔽';
                    gameBoard.appendChild(myIndicatorElement);
                }

                const playerIds = Object.keys(players || {}); // 플레이어 ID 목록
                const currentOnScreen = {}; // 현재 화면에 있는 플레이어 추적용

                // 모든 플레이어 데이터 순회
                playerIds.forEach(playerId => {
                    currentOnScreen[playerId] = true; // 화면에 있다고 표시
                    const pData = players[playerId]; // 현재 플레이어 데이터
                    // 데이터 유효성 검사 (위치, 스탯 정보 없으면 건너뜀)
                    if (!pData || pData.r === undefined || pData.c === undefined || !pData.stats) return;

                    let playerEl = playerElements[playerId]; // 기존 DOM 요소 가져오기
                    
                    // ✨ [수정] DOM 요소 생성 로직 변경
                    if (!playerEl && document.body.contains(gameBoard)) {
                        playerEl = document.createElement('div');
                        playerEl.className = 'player';
                        playerEl.id = `player-${playerId}`;
                        
                        // --- ✨ [신규] (0,0) 스폰 버그 수정 ---
                        // 생성 시점에 즉시 초기 위치를 설정합니다.
                        const x = pData.c * TILE_WIDTH;
                        const y = pData.r * TILE_HEIGHT;
                        playerEl.style.left = `${x}px`;
                        playerEl.style.top = `${y}px`;
                        // --- ✨ [신규] 끝 ---

                        // ✨ 1. 아바타 이미지용 <img> 태그 생성
                        const avatarImg = document.createElement('img');
                        avatarImg.className = 'player-avatar-img';
                        avatarImg.style.display = 'none'; // 기본 숨김
                        
                        // ✨ 2. 아바타 이모지용 <span> 태그 생성
                        const avatarEmoji = document.createElement('span');
                        avatarEmoji.className = 'player-avatar-emoji';
                        avatarEmoji.style.display = 'none'; // 기본 숨김

                        playerEl.appendChild(avatarImg); 
                        playerEl.appendChild(avatarEmoji); // ✨ span 태그 추가
                        
                        gameBoard.appendChild(playerEl);
                        playerElements[playerId] = playerEl;
                    } else if (!playerEl) {
                        return; // 보드 없으면 생성 불가
                    }

                    // ✨ [수정] 아바타/이모지 렌더링 로직 (textContent로 인한 <img> 파괴 버그 수정)
                    const avatarImgEl = playerEl.querySelector('.player-avatar-img');
                    const avatarEmojiEl = playerEl.querySelector('.player-avatar-emoji');

                    // ✨ <img>나 <span>이 없는 비정상적인 경우 (예: 이전 버그로 인해)
                    if (!avatarImgEl || !avatarEmojiEl) {
                        // DOM 요소를 강제로 재생성하기 위해 제거
                        if (playerEl) playerEl.remove();
                        delete playerElements[playerId];
                        // 다음 렌더링 프레임에서 다시 생성되도록 함
                        return; 
                    }

                    if (pData.avatar && pData.avatar.startsWith('http')) {
                        // 이미지 아바타
                        if (avatarImgEl.src !== pData.avatar) {
                           avatarImgEl.src = pData.avatar;
                        }
                        avatarImgEl.style.display = 'block';
                        avatarEmojiEl.style.display = 'none';
                    } else if (pData.avatar) {
                        // 이모지 아바타
                        avatarEmojiEl.textContent = pData.avatar;
                        avatarEmojiEl.style.fontSize = `${TILE_HEIGHT * 0.7}px`;
                        avatarEmojiEl.style.display = 'block';
                        avatarImgEl.style.display = 'none';
                        avatarImgEl.src = ''; // 이미지 흔적 제거
                    } else {
                        // 아바타 정보 없음 (둘 다 숨김)
                         avatarImgEl.style.display = 'none';
                         avatarEmojiEl.style.display = 'none';
                    }
                    
                    // ✨ [기존] 플레이어 배경색 설정
                    playerEl.style.backgroundColor = (playerId === currentRoomData?.hostId) ?
                        'var(--player1-color)' : 'var(--player2-color)';

                    if (playerId !== myPlayerId) {
                        // 위치 계산 및 적용 (top, left) - 다른 플레이어만
                        const x = pData.c * TILE_WIDTH;
                        const y = pData.r * TILE_HEIGHT;
                        playerEl.style.left = `${x}px`;
                        playerEl.style.top = `${y}px`;
                    }

                    // 사망 상태 반영 (이건 내 플레이어에게도 적용되어야 함)
                    const isAlive = pData.stats.isAlive;
                    playerEl.classList.toggle('dead', !isAlive);

                   
                    if (playerId === myPlayerId && myIndicatorElement) {

                         myIndicatorElement.style.display = isAlive ? 'block' : 'none'; // '사망' 상태만 반영
                    }
                });

                // Firebase 데이터에는 없는데 화면에 남아있는 플레이어 요소 제거
                for(const pid in playerElements){
                    if(!currentOnScreen[pid]){ // 데이터에 없는 ID면
                        if(playerElements[pid]) playerElements[pid].remove(); // DOM에서 제거
                        delete playerElements[pid]; // 추적 객체에서 제거
                        // 내 플레이어가 제거되면 화살표도 제거
                        if(pid === myPlayerId && myIndicatorElement){
                            myIndicatorElement.remove();
                            myIndicatorElement = null;
                        }
                    }
                }
            }


            // 아이템 렌더링 함수
            function renderItems(itemsData) {
                // 데이터 없거나 타일 크기 계산 안됐으면 중단
                if (!itemsData) itemsData = {};
                if (TILE_WIDTH <= 0) return;

                const itemsOnScreen = {}; // 현재 화면 아이템 추적용
                // 모든 아이템 데이터 순회
                for (const itemId in itemsData) {
                    const iData = itemsData[itemId];
                    // 데이터 유효성 검사
                    if(!iData || iData.r === undefined || iData.c === undefined || iData.isVisible === undefined || !iData.type) continue;

                    itemsOnScreen[itemId] = true; // 화면에 있다고 표시

                    let itemEl = itemElements[itemId]; // 기존 DOM 요소 가져오기
                    // DOM 요소 없으면 새로 생성 (보드 존재 확인 추가)
                    if (!itemEl && document.body.contains(gameBoard)) {
                        itemEl = document.createElement('div');
                        itemEl.id = itemId;
                        itemEl.className = 'item'; // 기본 클래스

                        // ✨ [수정] 아이템 아이콘 설정
                        if (iData.type === ITEM_TYPES.BOMB_COUNT) {
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/물풍선아이템.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            
                            // ✨ [수정] 이미지 아이템 스타일
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                            
                        } else if (iData.type === ITEM_TYPES.BOMB_RANGE) {
                            // ✨ [수정] 물줄기강화.png 이미지로 변경
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/물줄기강화.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            
                           itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                        
                        // ✨ [신규] 속도업 아이템 렌더링
                        } else if (iData.type === ITEM_TYPES.SPEED) {
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/속도업.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                        
                        } else {
                            itemEl.textContent = '?';
                        }
                        
                        itemEl.classList.add(`item-${iData.type}`); // 타입별 클래스 추가
                        if (iData.isBalloon) itemEl.classList.add('item-balloon'); // 풍선 클래스 추가
                        gameBoard.appendChild(itemEl); // 게임 보드에 추가
                        itemElements[itemId] = itemEl; // 추적 객체에 저장
                    } else if (!itemEl) {
                        continue; // 보드 없으면 생성 불가
                    }


                    // isVisible 상태에 따라 'visible' 클래스 토글
                    itemEl.classList.toggle('visible', iData.isVisible);

                    // 위치 계산 및 적용 (top, left)
                    const itemX = iData.c * TILE_WIDTH;
                    const itemY = iData.r * TILE_HEIGHT;
                    itemEl.style.left = `${itemX}px`;
                    itemEl.style.top = `${itemY}px`;
                }
                // Firebase 데이터에는 없는데 화면에 남아있는 아이템 요소 제거
                for (const itemId in itemElements) {
                    if (!itemsOnScreen[itemId]) {
                         if (itemElements[itemId]) { // 요소 존재 확인 후 제거
                            itemElements[itemId].remove();
                            delete itemElements[itemId]; // 추적 객체에서 제거
                         }
                    }
                }
            }


            // 폭탄 렌더링 함수
            function renderBombs(bombsData) {
                // 타일 크기 계산 안됐으면 중단
                if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;
                if (!bombsData) bombsData = {}; // 데이터 없으면 빈 객체로

                const bombsOnScreen = {}; // 현재 화면 폭탄 추적용
                // 모든 폭탄 데이터 순회
                for (const bombId in bombsData) {
                    const bData = bombsData[bombId];
                    // 데이터 유효성 검사
                    if (!bData || typeof bData.r !== 'number' || typeof bData.c !== 'number' || typeof bData.placedAt !== 'number') continue;
                    bombsOnScreen[bombId] = true; // 화면에 있다고 표시

                    let bombEl = bombElements[bombId]; // 기존 DOM 요소 가져오기
                    // DOM 요소 없으면 새로 생성 (보드 존재 확인 추가)
if (!bombEl && document.body.contains(gameBoard)) {
                        bombEl = document.createElement('div');
                        bombEl.id = bombId;
                        bombEl.className = 'bomb'; // 기본 클래스
                        
                        /* ✨ [수정] 아래 2줄을 반드시 삭제해야 합니다 */
                        // bombEl.textContent = '💧';
                        // bombEl.style.fontSize = `${TILE_HEIGHT * 0.8}px`; 

                        gameBoard.appendChild(bombEl); // 게임 보드에 추가
                        bombElements[bombId] = bombEl; // 추적 객체에 저장
                    } else if (!bombEl) {
                         continue; // 보드 없으면 생성 불가
                    }


                    // 위치 계산 및 적용 (top, left)
                    const bombX = bData.c * TILE_WIDTH;
                    const bombY = bData.r * TILE_HEIGHT;
                    bombEl.style.left = `${bombX}px`;
                    bombEl.style.top = `${bombY}px`;
                }

                // Firebase 데이터에는 없는데 화면에 남아있는 폭탄 요소 제거
                for (const bombId in bombElements) {
                    if (!bombsOnScreen[bombId]) { // 데이터에 없는 ID면
                        if (bombElements[bombId]) { // 요소 존재 확인 후 제거
                            bombElements[bombId].remove();
                            delete bombElements[bombId]; // 추적 객체에서 제거
                        }
                    }
                }
            }


            // 폭탄 타이머 체크 함수 (방장 전용)
            function checkBombTimers() {
                // 방장이 아니거나 폭탄 데이터 없으면 중단
                if (!isHost || !currentRoomData?.bombs) return;
                const now = Date.now() + serverTimeOffset; // 현재 서버 시간
                const bombs = currentRoomData.bombs;
                // 모든 폭탄 순회
                for (const bombId in bombs) {
                    // 이미 터지는 중이면 건너뜀
                    if (explodingBombs.has(bombId)) continue;
                    const bData = bombs[bombId];
                    // 데이터 유효성 검사 (설치 시간 있는지)
                    if (bData && typeof bData.placedAt === 'number') {
                        // 설치 시간 + 3초 < 현재 시간이면 폭발
                        if (bData.placedAt + 3000 < now) {
                            explodeBomb(bombId, bData); // 폭발 함수 호출
                        }
                    }
                }
            }


            // 폭탄 설치 함수 (클라이언트 요청)
            function placeBomb() {
                // 내 플레이어 데이터, 스탯 없으면 중단
                if (!currentRoomData?.players?.[myPlayerId]?.stats) return;
                const myStats = currentRoomData.players[myPlayerId].stats;
                const myPos = currentRoomData.players[myPlayerId];
                // 위치 없거나 죽었으면 중단
                if (myPos.r === undefined || myPos.c === undefined || !myStats.isAlive) return;
                // 현재 설치된 내 폭탄 개수 세기
                const myBombs = Object.values(currentRoomData.bombs || {}).filter(b => b.owner === myPlayerId).length;
                // 최대 설치 개수 넘으면 중단
                if (myBombs >= myStats.maxBombs) return;
                
                // ✨ [신규] 이미 해당 위치에 폭탄이 있는지 확인
                const bombs = currentRoomData.bombs || {};
                for (const bombId in bombs) {
                    if (bombs[bombId].r === myPos.r && bombs[bombId].c === myPos.c) {
                        return; // 이미 폭탄이 있으므로 설치 불가
                    }
                }
                
                // 새 폭탄 ID 생성
                const bombId = roomRef.child('bombs').push().key;
                // 폭탄 데이터 생성 (위치, 설치 시간)
                const bombData = {
                    owner: myPlayerId,
                    r: myPos.r,
                    c: myPos.c,
                    placedAt: firebase.database.ServerValue.TIMESTAMP // 서버 시간 기록
                };
                // Firebase에 폭탄 데이터 저장 요청
                roomRef.child('bombs/' + bombId).set(bombData);
                playSound('sound-place-bomb');
            }


            // 폭발 처리 함수 (방장 전용)
            function explodeBomb(bombId, bData) {
                 // 방장 아니거나, 이미 터지는 중이거나, 데이터 없거나, 맵 없으면 중단
                if (!isHost || explodingBombs.has(bombId) || !bData || !currentRoomData?.map) return;
                
                // ✨ 1. 이 폭발로 인해 터질 모든 폭탄과 타일을 재귀적으로 찾는다.
                // "r,c" => {r, c}, 최종 폭발 범위 (중복 없음)
                const allAffectedTiles = new Map(); 
                // bombId, 연쇄 폭발에 포함된 모든 폭탄 ID (중복 없음)
                const allBombsInChain = new Set(); 
                
                // 재귀 함수: 연쇄 폭발 탐색
                function findExplosionChain(currentBombId, currentBombData) {
                    // 이미 처리했거나(무한 루프 방지), 데이터 없으면 중단
                    if (allBombsInChain.has(currentBombId) || !currentBombData) return;
                    
                    allBombsInChain.add(currentBombId); // 이 폭탄을 체인에 추가
                    // ✨ 다른 타이머가 중복 실행 않도록 전역 set에도 즉시 추가
                    explodingBombs.add(currentBombId); 

                    const ownerStats = currentRoomData.players?.[currentBombData.owner]?.stats;
                    const range = ownerStats ? Math.min(3, ownerStats.bombRange) : 1; // ✨ 최대 3개로 변경
                    // ✨ [0,0] 센터 타일 포함
                    const directions = [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]]; 
                    
                    const currentBombTiles = []; // 이 폭탄 *하나*의 범위 (다른 폭탄 찾기용)

                    directions.forEach(([dr, dc]) => {
                        const isCenter = dr === 0 && dc === 0;
                        // isCenter가 참이면 0~0 (1번), 거짓이면 1~range
                        for (let i = (isCenter ? 0 : 1); i <= (isCenter ? 0 : range); i++) {
                            const r = currentBombData.r + dr * i;
                            const c = currentBombData.c + dc * i;

                            // 맵 밖 체크
                            if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) break;
                            
                            const tileType = currentRoomData.map?.[r]?.[c];
                            if (tileType === undefined) break; // 맵 데이터 오류

                            // 1. 최종 폭발 범위(allAffectedTiles)에 추가
                            const tileKey = `${r},${c}`;
                            if (!allAffectedTiles.has(tileKey)) { // 중복 타일은 추가 안함
                                allAffectedTiles.set(tileKey, { r, c });
                            }
                            // 2. 이 폭탄의 개별 범위(currentBombTiles)에도 추가
                            currentBombTiles.push({r, c}); 

                            if (tileType === 1) break; // 파괴불가 벽
                            if (tileType === 2) break; // 파괴가능 상자 (여기까지 불길이 닿음)
                        }
                    });

                    // ✨ 3. 이 폭탄의 범위(currentBombTiles)에 걸친 '다른' 폭탄을 찾는다.
                    for (const tile of currentBombTiles) {
                        for (const otherBombId in currentRoomData.bombs) {
                            // 이미 체인에 포함된 폭탄은 다시 체크 안 함
                            if (allBombsInChain.has(otherBombId)) continue; 
                            
                            const otherBombData = currentRoomData.bombs[otherBombId];
                            // 다른 폭탄이 해당 타일에 존재하면
                            if (otherBombData && otherBombData.r === tile.r && otherBombData.c === tile.c) {
                                // ✨ 연쇄 폭발! 재귀 호출
                                findExplosionChain(otherBombId, otherBombData);
                            }
                        }
                    }
                } // --- 재귀 함수 끝 ---

                // ✨ 2. 재귀 탐색 시작 (최초 폭탄 A로 시작)
                findExplosionChain(bombId, bData);

                // ✨ 3. 모든 체인이 탐색 완료됨.
                // allAffectedTiles에 모든 고유 타일이 모임.
                const updates = {}; // Firebase 업데이트 내용 객체

                allAffectedTiles.forEach(tile => {
                    // ✨ 4. 시각 효과를 한 번에 표시 (중복 없이)
                    showExplosionEffect(tile.r, tile.c);

                    // --- 이하 방장만 처리 ---
                    if (isHost) {
                        const currentTileType = currentRoomData.map?.[tile.r]?.[tile.c];
                        // 나무상자(2)면 파괴 처리
                        if (currentTileType === 2) {
                            updates[`map/${tile.r}/${tile.c}`] = 0; // 맵 데이터 길(0)로 변경
                            
                            // 아이템 드롭/공개 처리
                            let revealedItem = false; 
                            for(const itemId in currentRoomData.items) {
                                const item = currentRoomData.items[itemId];
                                if (item?.isBalloon && !item.isVisible && item.r === tile.r && item.c === tile.c) {
                                    updates[`items/${itemId}/isVisible`] = true;
                                    revealedItem = true;
                                    break; 
                                }
                            }
                            if (!revealedItem && Math.random() < 0.3) {
                                // ✨ [신규] 아이템 드랍 풀 정의 (33% 확률로 섞임)
                                const itemDropPool = [ITEM_TYPES.BOMB_COUNT, ITEM_TYPES.BOMB_RANGE, ITEM_TYPES.SPEED];
                                const randomType = itemDropPool[Math.floor(Math.random() * itemDropPool.length)];

                                const newItemKey = roomRef.child('items').push().key;
                                updates[`items/${newItemKey}`] = {
                                    r: tile.r, c: tile.c,
                                    type: randomType, // ✨ 랜덤 타입 적용
                                    isVisible: true, isBalloon: true
                                };
                            }
                        }

                        // 플레이어 피격 처리
                        for (const playerId in currentRoomData.players) {
                            const pData = currentRoomData.players[playerId];
                            if (pData?.stats?.isAlive === true && pData.r === tile.r && pData.c === tile.c) {
                                updates[`players/${playerId}/stats/isAlive`] = false;
                            }
                        }
                        
                        // ✨ [신규] 아이템 파괴 처리
                        for (const itemId in currentRoomData.items) {
                            const item = currentRoomData.items[itemId];
                            // 보이는 아이템(풍선 아님)이 폭발 범위에 있으면
                            if (item && item.isVisible && !item.isBalloon && item.r === tile.r && item.c === tile.c) {
                                updates[`items/${itemId}`] = null; // 아이템 삭제
                            }
                        }

                    } // --- 방장 처리 끝 ---
                }); // --- 최종 폭발 범위 순회 끝 ---

                // ✨ 5. Firebase 업데이트 및 승리 조건 확인 (방장만)
                if (isHost) {
                    // 체인에 포함된 모든 폭탄 삭제
                    allBombsInChain.forEach(id => {
                        updates[`bombs/${id}`] = null; // null로 설정하여 삭제
                    });

                    const performUpdatesAndCheckWin = () => {
                        checkWinCondition(); // 승리 조건 확인
                        
                        // 전역 Set에서 폭탄 ID들 제거 (0.2초 후)
                        // (폭발 애니메이션 시간(0.4초)보다 짧게)
                        setTimeout(() => {
                            allBombsInChain.forEach(id => explodingBombs.delete(id));
                        }, 200); 
                    };

                    // 업데이트할 내용이 있으면 Firebase에 한 번에 전송
                    if (Object.keys(updates).length > 0) {
                        roomRef.update(updates).then(performUpdatesAndCheckWin).catch(error => {
                            console.error("Firebase 업데이트 실패:", error);
                            performUpdatesAndCheckWin(); // 실패해도 체크는 시도
                        });
                    } else {
                        performUpdatesAndCheckWin(); // 업데이트 없어도 체크
                    }
                }
            }


          // 폭발 시각 효과 함수
            function showExplosionEffect(r, c) {
                 // ✨ [신규] 폭발 사운드 (스로틀링)
                 const now = Date.now();
                 if (now - lastExplosionSoundTime > 100) { // 0.1초 이내 중복 재생 방지
                    playSound('sound-explosion');
                    lastExplosionSoundTime = now;
                 }
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0 || !document.body.contains(gameBoard)) return;

                // 고유 ID를 (r, c) 좌표 기반으로 고정
                const effectId = `exp-${r}-${c}`;
                
                let explosionEl = document.getElementById(effectId); // 기존 효과 요소 찾기

                if (explosionEl) {
                    // ✨ 1. 이미 효과가 존재하면? -> 제거 타이머만 초기화
                    if (explosionEl.removeTimer) {
                        clearTimeout(explosionEl.removeTimer);
                    }
                    // ✨ 2. [핵심] CSS 애니메이션 강제 재시작 (깜빡임 해결)
                    explosionEl.style.animation = 'none'; // 애니메이션 끄기
                    explosionEl.offsetHeight; // 브라우저가 DOM 변경을 감지하도록 함 (reflow)
                    explosionEl.style.animation = ''; // 애니메이션 다시 켜기 (CSS 기본값으로)

                } else {
                    // ✨ 3. 효과가 없으면? -> 새로 생성
                    explosionEl = document.createElement('div');
                    explosionEl.id = effectId;
                    explosionEl.className = 'explosion'; // CSS 클래스 적용
                    explosionEl.style.width = `${TILE_WIDTH}px`; // 타일 크기 적용
                    explosionEl.style.height = `${TILE_HEIGHT}px`;
                    explosionEl.style.left = `${c * TILE_WIDTH}px`; // 위치 적용 (left)
                    explosionEl.style.top = `${r * TILE_HEIGHT}px`; // 위치 적용 (top)
                    gameBoard.appendChild(explosionEl); // 게임 보드에 추가
                }

                // ✨ 4. 0.4초 후 제거 타이머 설정 (요소에 타이머 ID 저장)
                explosionEl.removeTimer = setTimeout(() => {
                    // setTimeout 시점에 요소가 아직 존재하는지 한 번 더 확인
                    const elToRemove = document.getElementById(effectId);
                    if (elToRemove) {
                        elToRemove.remove();
                    }
                }, 400); // CSS 애니메이션 시간과 일치
            }


           // 승리 조건 확인 함수 (방장 전용)
            function checkWinCondition(isTimeUp = false) { // ✨ isTimeUp 파라미터 추가
                // 방장 아니거나 플레이어 데이터 없으면 중단
                if (!isHost || !currentRoomData?.players) return;

                let winnerId = null;

                // ✨ [신규] 시간 종료로 인한 판정
                if (isTimeUp && currentRoomData.status === 'playing') {
                    console.log("시간 종료! 스탯으로 승패 판정.");
                    const playerIds = Object.keys(currentRoomData.players);
                    const p1Id = playerIds[0];
                    const p2Id = playerIds[1];
                    const p1Stats = currentRoomData.players[p1Id]?.stats;
                    const p2Stats = currentRoomData.players[p2Id]?.stats;

                    // 둘 다 살아있을 때만 스탯 비교
                    if (p1Stats?.isAlive && p2Stats?.isAlive) {
                        const p1Score = (p1Stats.maxBombs || 1) + (p1Stats.bombRange || 1);
                        const p2Score = (p2Stats.maxBombs || 1) + (p2Stats.bombRange || 1);

                        if (p1Score > p2Score) winnerId = p1Id;
                        else if (p2Score > p1Score) winnerId = p2Id;
                        else winnerId = null; // 스탯 같으면 무승부
                    } else {
                        // 시간 종료 시점에 한 명만 살아있으면 그 사람이 승자
                        const alivePlayers = playerIds.filter(id => currentRoomData.players[id]?.stats?.isAlive);
                        if (alivePlayers.length === 1) winnerId = alivePlayers[0];
                        else winnerId = null; // 둘 다 죽었으면 무승부
                    }
                    
                    roomRef.update({ status: 'gameOver', winner: winnerId });
                    return; // 시간 종료 판정 끝
                }

                // ✨ [기존] 일반 사망으로 인한 판정
                const alivePlayers = Object.entries(currentRoomData.players)
                                         .filter(([id, pData]) => pData?.stats?.isAlive); // 데이터 유효성 검사 추가
                // 살아있는 플레이어가 1명 이하이고, 아직 게임 종료 상태가 아니면
                if (alivePlayers.length <= 1 && currentRoomData.status === 'playing') {
                    // 승자 ID 결정 (1명이면 그 ID, 0명이면 null(무승부))
                    winnerId = alivePlayers.length === 1 ? alivePlayers[0][0] : null;
                    console.log(`게임 종료! 승자: ${winnerId || '무승부'}`);
                    // Firebase에 게임 상태 및 승자 업데이트
                    roomRef.update({ status: 'gameOver', winner: winnerId });
                }
            }

// ✨ [신규] 카운트다운 시작 함수
            function startCountdown() {
                if (!countdownOverlayEl || !countdownNumberEl) return;
                
                countdownOverlayEl.style.display = 'flex';
                let count = 3;
                
                function runCount() {
                    countdownNumberEl.textContent = count;
                    countdownNumberEl.style.animation = 'none';
                    countdownNumberEl.offsetHeight; // Reflow
                    countdownNumberEl.style.animation = 'countdown-zoom 1s forwards';
                    
                    if (count > 0) {
                        count--;
                        setTimeout(runCount, 1000); // 1초마다 반복
                    } else {
                        // 카운트다운 종료
                        setTimeout(() => {
                            countdownOverlayEl.style.display = 'none';
                            playSound('sound-background'); // 배경음악 시작
                            setupGameLayout(); // 맵/요소 렌더링 시작
                            startGameTimer(); // 게임 타이머 시작
                        }, 1000); // "0" (또는 "Start")가 사라지는 시간
                    }
                }
                runCount(); // 카운트 시작
            }

            // ✨ [신규] 게임 타이머 시작 함수 (모든 클라이언트)
            function startGameTimer() {
                if (gameTimerInterval) clearInterval(gameTimerInterval); // 중복 방지

                const startTime = currentRoomData.gameStartTime || (Date.now() + serverTimeOffset);
                
                gameTimerInterval = setInterval(() => {
                    const now = Date.now() + serverTimeOffset;
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const remaining = Math.max(0, GAME_TIME_LIMIT - elapsed);
                    
                    updateTimerDisplay(remaining);

                    // --- 유령 AI 스폰 로직 (미래 기능) ---
                    if (remaining <= 90 && !ghostSpawned) { 
                        // spawnGhost(); // TODO: 유령 AI 스폰 함수 호출
                        console.log("유령 스폰 시간!");
                        ghostSpawned = true; // 중복 스폰 방지
                    }

                    // --- 시간 종료 처리 (방장만) ---
                    if (remaining <= 0 && isHost) {
                        stopGameTimer();
                        checkWinCondition(true); // '시간 종료'로 승패 판정
                    }
                }, 1000);
            }

            // ✨ [신규] 게임 타이머 중지 함수
            function stopGameTimer() {
                if (gameTimerInterval) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
            }

            // ✨ [신규] 타이머 UI 업데이트 함수
            function updateTimerDisplay(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                if(gameTimerEl) {
                    gameTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }

            // 게임 오버 화면 표시 함수
           // 게임 오버 화면 표시 함수
            function showGameOver(winnerId) {
                // ✨ [신규] 타이머, 배경음악 정지
                stopGameTimer(); 
                try { document.getElementById('sound-background').pause(); } catch(e) {}

                let message = "무승부!"; // 기본 메시지
                if (winnerId) { // 승자가 있으면
                    const winnerData = currentRoomData?.players?.[winnerId]; // 승자 데이터 가져오기
                    // 승자 이름 결정 (데이터 없으면 기본값 사용)
                    const winnerName = winnerData?.nickname || (winnerId === myPlayerId ? myNickname : '상대방');
                    message = `🎉 ${winnerName} 승리! 🎉`; // 승리 메시지

                    // ✨ [신규] 승/패 사운드 재생
                    playSound(winnerId === myPlayerId ? 'sound-win' : 'sound-lose');
                } else {
                    // ✨ [신규] 무승부 사운드 (패배 사운드 재활용)
                    playSound('sound-lose');
                }
                gameOverMessage.textContent = message; // 모달 메시지 설정

                // ✨ [신규] '다시 하기' 버튼 HTML 추가 (알까기.html 참조)
                const modalContent = gameOverModal.querySelector('.modal-content');
                modalContent.innerHTML = `
                    <h2 id="game-over-message">${message}</h2>
                    <button id="rematch-btn" class="modal-btn primary">다시 하기</button>
                    <button id="lobby-btn" class="modal-btn secondary">대기실로</button>
                `;
                gameOverModal.classList.add('active'); // 모달 보이게

                // ✨ [수정] 로비 버튼 이벤트 리스너 (새 HTML 구조에 맞게 수정)
                const lobbyBtnGameOver = modalContent.querySelector('#lobby-btn');
                if(lobbyBtnGameOver) {
                    lobbyBtnGameOver.onclick = () => { window.location.href = '대기실.html'; };
                }

                // ✨ [신규] '다시 하기' 버튼 이벤트 리스너 (알까기.html 참조)
                const rematchBtn = modalContent.querySelector('#rematch-btn');
                if (rematchBtn) {
                    rematchBtn.addEventListener('click', () => {
                        if (roomRef) {
                            rematchBtn.disabled = true;
                            rematchBtn.textContent = '상대방 기다리는 중...';
                            // Firebase에 재시작 요청
                            roomRef.child('rematchRequests').child(myPlayerId).set(true);
                        }
                    });
                }
            }


            // 헤더 업데이트 함수 (플레이어 정보 표시)
            function updateHeader(players) {
                gameHeader.innerHTML = ''; // 헤더 초기화
                // 모든 플레이어 데이터 순회 (데이터 없으면 빈 객체로)
                Object.keys(players || {}).forEach(playerId => {
                    const pData = players[playerId];
                    // 플레이어 데이터 유효성 검사
                    if(!pData || !pData.avatar) return;

                    // 플레이어 정보 표시 영역 생성
                    const pInfo = document.createElement('div');
                    pInfo.className = 'player-info';
                    // 아바타 영역 생성
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'player-avatar';
                    // 아바타 설정 (URL 또는 이모지)
                    if (pData.avatar.startsWith('http')) {
                        avatarEl.innerHTML = `<img src="${pData.avatar}" alt="av">`;
                    } else {
                        avatarEl.textContent = pData.avatar;
                    }
                    // 스탯 표시 영역 생성
                    const statsEl = document.createElement('div');
                    statsEl.className = 'player-stats';
                    if (pData.stats) {
                        // ✨ [수정] 폭탄 및 물줄기 아이콘을 <img> 태그로 변경
                        statsEl.innerHTML = `
                            <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/물풍선아이템.png" alt="bomb" style="width: 1.2em; height: 1.2em; object-fit: contain;">
                                ${pData.stats.maxBombs ?? 1}
                            </span>
                           <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/물줄기강화.png" alt="range" style="width: 1.1em; height: 1.1em; object-fit: contain;">
                                ${pData.stats.bombRange ?? 1}
                            </span>
                            <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/속도업.png" alt="speed" style="width: 1.1em; height: 1.1em; object-fit: contain;">
                                ${pData.stats.speed ?? 1}
                            </span>
                        `;
                    }
                    pInfo.appendChild(avatarEl);
                    pInfo.appendChild(statsEl);
                    gameHeader.appendChild(pInfo); // 헤더에 플레이어 정보 추가
                });
            }


            // 조작 버튼/키 설정 함수
            function setupControls() {
                // D-Pad 버튼 정보 객체
                const dPadButtons = {
                    'btn-up': { dir: 'up', x: 0, y: -1, el: document.getElementById('btn-up') },
                    'btn-down': { dir: 'down', x: 0, y: 1, el: document.getElementById('btn-down') },
                    'btn-left': { dir: 'left', x: -1, y: 0, el: document.getElementById('btn-left') },
                    'btn-right': { dir: 'right', x: 1, y: 0, el: document.getElementById('btn-right') },
                };

                // 각 D-Pad 버튼에 이벤트 리스너 추가
                Object.values(dPadButtons).forEach(btn => {
                     // 버튼 요소 없으면 중단
                     if(!btn.el) return;
                     // 터치 시작 또는 마우스 누르기 시작 이벤트
                    const start = (e) => {
                        e.preventDefault(); // 기본 동작 방지 (스크롤 등)
                        // 죽었으면 조작 불가
                        if (currentRoomData?.players?.[myPlayerId]?.stats?.isAlive === false) return;
                        // 모든 버튼 비활성 스타일 제거
                        Object.values(dPadButtons).forEach(b => { if(b.el) b.el.classList.remove('active'); });
                        btn.el.classList.add('active'); // 현재 버튼 활성 스타일 추가
                        startContinuousMove(btn.dir, btn.x, btn.y); // 연속 이동 시작
                    };
                    // 터치 종료 또는 마우스 떼기 이벤트
                    const end = (e) => {
                        e.preventDefault();
                         if(btn.el) btn.el.classList.remove('active'); // 활성 스타일 제거
                        // 현재 이동 방향과 같으면 이동 중지
                        if (moveDirection.current === btn.dir) {
                            stopContinuousMove();
                        }
                    };
                    // 이벤트 리스너 등록
                    btn.el.addEventListener('mousedown', start);
                    btn.el.addEventListener('touchstart', start, { passive: false });
                    btn.el.addEventListener('mouseup', end);
                    btn.el.addEventListener('touchend', end);
                    btn.el.addEventListener('mouseleave', end); // 버튼 영역 벗어나도 중지
                });

                 // 폭탄 버튼 설정
                 const bombButton = document.getElementById('bomb-btn');
                 if (bombButton) { // 버튼 존재하면 클릭 이벤트 추가
                    bombButton.addEventListener('click', placeBomb);
                 }

                // PC 키보드 누르기 이벤트
                document.addEventListener('keydown', (e) => {
                     // 죽었으면 조작 불가
                     if (currentRoomData?.players?.[myPlayerId]?.stats?.isAlive === false) return;
                     // 키에 따른 동작 분기
                    switch(e.key) {
                        case 'ArrowUp': e.preventDefault(); startContinuousMove('up', 0, -1); break;
                        case 'ArrowDown': e.preventDefault(); startContinuousMove('down', 0, 1); break;
                        case 'ArrowLeft': e.preventDefault(); startContinuousMove('left', -1, 0); break;
                        case 'ArrowRight': e.preventDefault(); startContinuousMove('right', 1, 0); break;
                        case ' ': e.preventDefault(); placeBomb(); break; // 스페이스바 = 폭탄
                    }
                });

                // PC 키보드 떼기 이벤트
                document.addEventListener('keyup', (e) => {
                    // 키와 방향 매핑
                    const keyMap = {'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right'};
                    // 현재 이동 방향과 뗀 키가 같으면 이동 중지
                    if (moveDirection.current === keyMap[e.key]) {
                        stopContinuousMove();
                    }
                });
            }


            function startContinuousMove(dir, x, y) {
              // 이미 해당 방향으로 이동 중이면 중단
                if (moveDirection.current === dir) return;
                stopContinuousMove(); // 기존 이동 중지
                moveDirection = { x, y, current: dir }; // 새 이동 방향 설정

                // ✨ 재귀적으로 움직임을 처리할 함수
                const moveLoop = () => {
                    // 1. 이동이 중지되었는지 확인
                    if (moveDirection.current !== dir) return; 

                    // 2. 생존 상태 확인
                    if (currentRoomData?.players?.[myPlayerId]?.stats?.isAlive === false) {
                        stopContinuousMove();
                        return;
                    }
                    
                    // 3. 이동 시도
                    tryMove(moveDirection.x, moveDirection.y);

                    // 4. ✨ 다음 이동 속도를 '최신' 데이터로 다시 계산
                    const myStats = currentRoomData?.players?.[myPlayerId]?.stats || { speed: 1 };
                    const speedLevel = Math.max(0, (myStats.speed || 1) - 1);
                    const currentInterval = speedLevels[Math.min(speedLevel, speedLevels.length - 1)];

                    // 5. 다음 이동 예약 (setInterval 대신 setTimeout 사용)
                    moveInterval = setTimeout(moveLoop, currentInterval);
                };
                
                // ✨ 최초 1회 즉시 실행 (즉시 이동 시도)
                // tryMove(x, y)를 호출하는 대신 moveLoop()를 바로 호출하여 
                // 이동 -> 속도계산 -> 다음 이동 예약을 한 사이클로 묶습니다.
                moveLoop();
            }


           function stopContinuousMove() {
                clearTimeout(moveInterval); // ✨ clearInterval -> clearTimeout
                moveInterval = null; // ID 초기화
                moveDirection.current = null; // 현재 방향 초기화
                 // D-Pad 버튼 시각 효과 초기화
                 const dPadButtons = {
                    'btn-up': { el: document.getElementById('btn-up') },
                    'btn-down': { el: document.getElementById('btn-down') },
                    'btn-left': { el: document.getElementById('btn-left') },
                    'btn-right': { el: document.getElementById('btn-right') },
                };
                 Object.values(dPadButtons).forEach(btn => {
                      if(btn?.el) btn.el.classList.remove('active');
                 });
            }


            // 이동 시도 함수 (아이템 획득 처리 포함)
            function tryMove(dc, dr) {
                // 내 플레이어 데이터, 스탯 없거나 죽었으면 중단
                if (!currentRoomData?.players?.[myPlayerId]?.stats?.isAlive) return;
                const myPos = currentRoomData.players[myPlayerId];
                // 위치 정보 없으면 중단
                if (myPos.r === undefined || myPos.c === undefined) return;
                // 새 위치 계산
                const newR = myPos.r + dr;
                const newC = myPos.c + dc;

                // 이동 가능한 위치인지 확인
                if (isWalkable(newR, newC)) {
                    // Firebase 업데이트 내용 객체 (기본: 새 위치)
                    const updates = { r: newR, c: newC };
                    const items = currentRoomData.items || {}; // 현재 아이템 목록
                    let collectedItemId = null; // 획득한 아이템 ID
                    let collectedItemType = null; // 획득한 아이템 타입

                    // 새 위치에 아이템 있는지 확인
                    for (const itemId in items) {
                        const itemData = items[itemId];
                        // 아이템 존재하고, 보이고, 새 위치에 있으면
                        if (itemData && itemData.isVisible && itemData.r === newR && itemData.c === newC) {
                            collectedItemId = itemId;
                            collectedItemType = itemData.type;
                            break; // 하나만 획득
                        }
                    }

                    // 아이템 획득 시 스탯 업데이트 내용 추가
                    if (collectedItemId && collectedItemType) {
                        playSound('sound-item-get'); // ✨ [신규] 아이템 획득 사운드
                        // 현재 스탯 복사 (없으면 기본값 사용)
                        const myStats = { ...(myPos.stats || { maxBombs: 1, bombRange: 1, speed: 1, isAlive: true }) };
                        if (collectedItemType === ITEM_TYPES.BOMB_COUNT) {
                            myStats.maxBombs = Math.min(5, (myStats.maxBombs || 1) + 1); 
                        } else if (collectedItemType === ITEM_TYPES.BOMB_RANGE) {
                            myStats.bombRange = Math.min(3, (myStats.bombRange || 1) + 1);
                        // ✨ [신규] 속도업 아이템 획득 (최대 3레벨)
                        } else if (collectedItemType === ITEM_TYPES.SPEED) {
                            myStats.speed = Math.min(3, (myStats.speed || 1) + 1);
                        }
                        updates.stats = myStats; // 업데이트할 스탯 추가

                        // Firebase에서 아이템 삭제 요청
                        roomRef.child('items/' + collectedItemId).remove()
                            .catch(error => console.error("아이템 제거 오류:", error)); // 에러 로깅
                    }

                    // Firebase에 플레이어 위치 (및 스탯) 업데이트 요청
                    // --- ✨ [신규] 클라이언트 즉시 예측 이동 (렉 제거) ---
                    // 1. 로컬 데이터 즉시 수정
                    currentRoomData.players[myPlayerId].r = newR;
                    currentRoomData.players[myPlayerId].c = newC;
                    if (updates.stats) { // 스탯 업데이트가 있으면 로컬에도 반영
                        currentRoomData.players[myPlayerId].stats = updates.stats;
                        updateHeader(currentRoomData.players); // 헤더 즉시 업데이트
                    }
                    
                    // 2. 로컬 렌더링 즉시 실행 (내 플레이어만)
                    const myPlayerEl = playerElements[myPlayerId];
                    // 타일 크기가 계산된 상태인지 확인
                    if (myPlayerEl && TILE_WIDTH > 0 && TILE_HEIGHT > 0) {
                        const x = newC * TILE_WIDTH;
                        const y = newR * TILE_HEIGHT;
                        myPlayerEl.style.left = `${x}px`;
                        myPlayerEl.style.top = `${y}px`;

                        // 내 화살표도 즉시 이동
                        if (myIndicatorElement) {
                             const indicatorY = y - TILE_HEIGHT * 0.6; 
                             myIndicatorElement.style.left = `${x}px`;
                             myIndicatorElement.style.top = `${indicatorY}px`;
                        }
                    }
                    // --- ✨ 예측 이동 끝 ---

                    // 3. Firebase에 업데이트 전송 (기존 로직)
                    roomRef.child('players/' + myPlayerId).update(updates)
                        .catch(error => console.error("플레이어 업데이트 오류:", error)); // 에러 로깅
                }
            }


            // 이동 가능 여부 확인 함수
            function isWalkable(r, c) {
                 // 1. 맵 범위 체크
                if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) {
                     return false; // 맵 밖
                }
                 // 2. 타일 타입 체크 (Firebase 데이터 기준)
                 // 데이터 없으면 이동 불가 처리
                const tileType = currentRoomData?.map?.[r]?.[c];
                // 벽(1) 또는 상자(2)면 이동 불가
                if (tileType === 1 || tileType === 2) {
                    return false;
                }
                 // 맵 데이터 자체가 없으면 이동 불가
                 if (tileType === undefined) return false;

                 // 3. 폭탄 위치 체크
                const bombs = currentRoomData.bombs || {};
                // 모든 폭탄 순회
                for (const bombId in bombs) {
                     const bombData = bombs[bombId];
                    // 폭탄 데이터 있고, 터지는 중 아니고, 해당 위치에 있으면 이동 불가
                    if (bombData && !explodingBombs.has(bombId) && bombData.r === r && bombData.c === c) {
                        return false;
                    }
                }
                // 모든 조건 통과 시 이동 가능 (길 0)
                return true;
            }

            // --- 게임 시작 ---
            initialize();

            // 페이지 벗어나기 전 처리 (타이머 정리)
             window.addEventListener('beforeunload', () => {
                 clearInterval(bombTimerInterval);
                 clearInterval(gameTimerInterval); // ✨ [신규] 게임 타이머도 정리
                 bombTimerInterval = null;
                 gameTimerInterval = null;
             });

             // 화면 크기 변경 시 처리 (레이아웃 재계산)
             window.addEventListener('resize', () => {
                 // 리사이즈 멈춘 후 잠시 뒤 실행 (성능 최적화)
                 clearTimeout(window.resizeTimeout);
                 window.resizeTimeout = setTimeout(setupGameLayout, 150);
             });
        });
    </script>
</body>
</html>