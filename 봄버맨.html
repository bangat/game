<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>크레이지 봄버</title>
    <link rel="manifest" href="manifest.json">
    <link href="https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansMedium.woff" as="font" type="font/woff" crossorigin>
    <style>
        :root {
            --bg-color: #2c3e50;
             /* 이미지 URL 변수 */
            /* --board-bg-url 은 JS에서 직접 설정 */
            /* ✨ --wall-image-url: url('./봄버맨이미지/파괴불가.png');  <-- 이 줄을 삭제합니다. */

            --crate-color: #a0522d; /* 나무상자 색상 */
            --path-color: transparent; /* 길은 투명 (배경 보이도록) */
            --wall-color: #7f8c8d; /* 이미지 로딩 실패 시 보일 색상 */

            --player1-color: #3498db;
            --player2-color: #e74c3c;
            --explosion-color: rgba(52, 152, 219, 0.7);
            --item-bomb-color: #9b59b6;
            --item-range-color: #f1c40f;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'GmarketSans', sans-serif;
            background-color: var(--bg-color); color: white;
            display: flex; flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            -webkit-user-select: none; user-select: none;
            touch-action: none;
        }

        #game-wrapper {
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
        }

        #game-header {
            flex-shrink: 0; display: flex;
            justify-content: space-around; align-items: center;
            padding: 10px; background-color: rgba(0,0,0,0.2);
            width: 100%;
        }
        .player-info { display: flex; align-items: center; gap: 8px; }
        .player-avatar { font-size: 1.5em; }
        .player-avatar img { width: 32px; height: 32px; border-radius: 50%; }
        .player-stats { 
            font-size: 0.8em; 
            display: flex; 
            gap: 8px; /* ✨ 간격 살짝 조정 */
            margin-left: 5px;
            align-items: center; /* ✨ [신규] 아이콘/텍스트 세로 중앙 정렬 */
        }

        #game-container {
            width: 100%;
            flex-grow: 1; /* 남은 세로 공간 모두 차지 */
            display: flex; justify-content: center; align-items: center; /* 가운데 정렬 */
            position: relative; overflow: hidden;
            padding: 0; /* ✨ 10px -> 0으로 변경 (또는 이 라인 삭제) */
        }

        #game-board {
            position: relative;
            /* background-image 는 JS에서 설정 */
            /* ✨ 맵 배경 이미지 관련 CSS 모두 삭제 (JS가 backgroundColor로 제어) */
            background-size: cover; /* 삭제 */
            background-repeat: no-repeat; /* 삭제 */
            background-position: center; /* 중앙 정렬 */
            aspect-ratio: 11 / 15; /* 게임 보드 비율 */
            /* 높이/너비 중 작은 쪽에 맞춰 크기 조절 */
            width: auto; /* 너비 자동 */
            height: 100%; /* 컨테이너 높이에 맞춤 */
            max-height: calc(100vh - 70px); /* 헤더 높이 제외 최대 높이 */
            max-width: 100%; /* 컨테이너 너비 제한 */
            overflow: hidden;
            background-color: #333; /* 이미지 로딩 전 배경색 */
        }

        .grid-cell {
            position: absolute;
            width: calc(100% / 11);
            height: calc(100% / 15);
            /* 배경 관련 속도는 각 타일 클래스에서 설정 */
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            will-change: opacity, transform;
            top: 0; left: 0;
        }
        .wall { /* 파괴 불가 벽 */
            /* ✨ 이미지 관련 속성 모두 삭제 */
            background-color: var(--wall-color); /* #7f8c8d */
            border: 1px solid rgba(0,0,0,0.4);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2);
            z-index: 2;
        }
        .path { /* 이동 가능 길 */
             background-color: var(--path-color); /* 투명 */
             z-index: 1;
        }
        .crate { /* 파괴 가능 나무상자 */
            background-color: var(--crate-color); /* 갈색 */
            border: 1px solid rgba(0,0,0,0.3);
            box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2);
            z-index: 2;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .crate.destroyed {
            opacity: 0;
            transform: scale(0.5);
        }

        .explosion { /* 폭발 효과 */
            position: absolute;
            top: 0; left: 0;
            background-color: var(--explosion-color);
            z-index: 20; /* 가장 위에 보이도록 */
            animation: fade-out-explosion 0.4s forwards;
            pointer-events: none;
            border-radius: 50%;
        }
        @keyframes fade-out-explosion {
            0% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(0.7); }
        }

        .bomb { /* 설치된 폭탄 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            z-index: 5; /* 길(1) < 폭탄(5) < 아이템(6) */
            
            display: block; /* ✨ 이미지가 보이도록 display 속성 추가 */

            /* ✨ [수정] 이미지를 배경으로 설정 (원복) */
            background-image: url('./봄버맨사운드/물풍선.png');
            background-size: 100% 100%; /* 타일 크기에 꽉 채우기 */
            background-repeat: no-repeat;
            background-position: center;

            /* ✨ [삭제] CSS 물방울 스타일 제거 */
            
            transition: left 0.1s linear, top 0.1s linear;
            will-change: left, top;
            animation: pulse-bomb 1s infinite;
            pointer-events: none;
        }

        @keyframes pulse-bomb {
            0% { transform: scale(1.0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1.0); }
        }


        .item { /* 아이템 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            z-index: 6; /* 폭탄(5) < 아이템(6) < 플레이어(10) */
            /* ✨ [삭제] display: flex; justify-content: center; align-items: center; */
            /* ✨ [삭제] font-size: calc(100vh / 28); */
            border-radius: 50%;
            opacity: 0; /* 기본 숨김 */
            transition: opacity 0.3s ease-in;
            pointer-events: none;
        }
        .item.visible {
            opacity: 0.9;
        }
        /* ✨ [수정] 아래 두 줄의 background-color를 삭제(주석 처리)합니다 */
        /* .item-bomb { background-color: var(--item-bomb-color); } */
        /* .item-range { background-color: var(--item-range-color); } */
        .item-balloon {
             animation: float 2s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }

        .player { /* 플레이어 캐릭터 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            height: calc(100% / 15);
            /* border-radius: 50%; */ /* ✨ [삭제] 원형 배경 제거 */
            z-index: 10; /* 아이템(6) < 플레이어(10) < 화살표(11) */
            font-size: 0.8em;
            transition: left 0.2s linear, top 0.2s linear, opacity 0.3s ease; 
            will-change: left, top, opacity;
        }
        .player-avatar-img {
            width: 120%; height: 120%;
            object-fit: contain; border-radius: 50%;
        }
        .player.dead { /* 사망 시 효과 */
            opacity: 0.5;
            pointer-events: none; /* 조작 불가 */
        }

        .player-indicator { /* 내 캐릭터 위 화살표 */
            position: absolute;
            top: 0; left: 0;
            width: calc(100% / 11);
            z-index: 11; /* 플레이어(10)보다 위 */
            text-align: center;
            font-size: 1.2em;
            color: yellow;
            text-shadow: 0 0 3px black;
            pointer-events: none;
            transition: left 0.1s linear, top 0.1s linear;
            will-change: left, top;
            animation: bounce 1s infinite ease-in-out;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

         /* --- 컨트롤러, 모달 CSS (변경 없음) --- */
        #controls-container { position: fixed; bottom: 30px; left: 30px; z-index: 100;}
         #d-pad { position: relative; width: 120px; height: 120px; }
         .d-pad-btn { 
            position: absolute; 
            width: 40px; 
            height: 40px; 
            background-color: rgba(255, 255, 255, 0.3); /* ✨ 원래 색으로 */
            border: 1px solid rgba(255, 255, 255, 0.5); /* ✨ 원래 테두리 */
            border-radius: 8px; /* ✨ 둥근 사각형으로 변경 */
            display: flex; justify-content: center; align-items: center; 
            font-size: 1.5em; 
            color: white; 
            cursor: pointer; 
         }
         .d-pad-btn.active { background-color: rgba(255, 255, 255, 0.6); } /* ✨ 원래 활성 색으로 */
         #btn-up { top: 0; left: 40px; }
         #btn-left { top: 40px; left: 0; }
         #btn-right { top: 40px; left: 80px; }
         #btn-down { top: 80px; left: 40px; }
         /* ✨ [신규] 오른쪽 컨트롤러 컨테이너 */
         #action-controls-container {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 100;
            display: flex;
            flex-direction: column; /* 아이템 버튼이 위로 쌓이도록 */
            align-items: center; /* 가운데 정렬 */
         }

         /* ✨ [신규] 아이템 버튼 슬롯 */
         #item-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px; /* 폭탄 버튼과의 간격 */
         }

/* ✨ [신규] 폭탄/아이템 UI 전체 래퍼 */
        #action-ui-wrapper {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 200px; /* (폭탄 80 + 아이템 60 + 여백) */
            height: 200px; /* (폭탄 80 + 아이템 60 + 여백) */
            z-index: 100;
            pointer-events: none; /* 래퍼는 클릭x, 버튼만 클릭o */
        }

         /* CSS (변경코드) - #bomb-btn 스타일 전체를 교체하세요 */
         #bomb-btn { 
            position: absolute; /* ✨ [수정] fixed -> absolute */
            bottom: 0; /* ✨ [수정] 래퍼 기준 0 */
            right: 0; /* ✨ [수정] 래퍼 기준 0 */
            width: 80px; 
            height: 80px; 
            
            background-color: rgba(20, 150, 255, 0.7);  
            border: 3px solid rgba(255, 255, 255, 0.5); 
            border-radius: 50%; 
            z-index: 102; /* ✨ [수정] 100 -> 102 (아이템보다 위) */
            cursor: pointer; 
            
            /* ✨ [수정] 물풍선.png 이미지로 원복 */
            background-image: url('./봄버맨사운드/물풍선.png');
            background-size: 80% 80%; 
            background-repeat: no-repeat;
            background-position: center;

             /* ✨ [신규] 유리알 질감 효과 */
            box-shadow: inset 0 3px 5px rgba(255,255,255,0.5), 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto; /* ✨ [신규] 클릭 활성화 */
         }
         #bomb-btn:active { 
            background-color: rgba(50, 170, 255, 0.9); /* ✨ 눌렀을 때 파란색 */
            transform: scale(0.95); 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); /* ✨ 누르면 안으로 그림자 */
         }
         .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.7); z-index: 1000; }
         .overlay.active { display: flex; }
         .modal-content { background: #ecf0f1; color: #333; padding: 30px; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
         .modal-content h2 { font-size: 2em; margin-bottom: 20px; color: var(--primary-color); }
         .modal-btn { padding: 12px 25px; font-size: 1.1em; font-weight: 700; border-radius: 10px; border: none; cursor: pointer; margin: 10px; }
        /* 약 324행 */
         .modal-btn.primary { background-color: var(--primary-color); color: white; }
          .modal-btn.secondary { background-color: #bdc3c7; color: #333; }

/* --- 3분 타이머 스타일 --- */
        #game-timer {
            position: absolute; /* header 바로 아래 중앙에 */
            top: 60px; /* 헤더 높이(52px) + 여백 */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1.5em;
            font-weight: 700;
            padding: 5px 15px;
            border-radius: 10px;
            z-index: 50;
            width: 100px;
            text-align: center;
        }

        /* --- 3, 2, 1 카운트다운 오버레이 --- */
        #countdown-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000; /* 최상위 */
            color: white;
            font-weight: 700;
            font-size: 15vw; /* 화면 크기에 비례 */
            display: none; /* JS로 제어 */
        }
        #countdown-overlay .number {
            animation: countdown-zoom 1s forwards;
        }
        @keyframes countdown-zoom {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            90% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(1); opacity: 0; } /* 1초 뒤 사라짐 */
        }

        .player-bubble {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140%; /* 플레이어보다 크게 */
            height: 140%;
            z-index: 1; /* 플레이어 아바타(z-index: 2)보다 뒤에 */
            display: none; /* 기본 숨김 */
            opacity: 0.9;

            /* --- ✨ [신규] CSS 물방울 스타일 (from .bomb) --- */
            background-color: rgba(52, 152, 219, 0.7);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.4), 
                        inset 0 -5px 10px rgba(0, 0, 0, 0.3), 
                        0 2px 5px rgba(0, 0, 0, 0.2);
            position: relative; 
            overflow: hidden; 
            /* --- ✨ [삭제] 이미지 속성 제거 --- */
            /* background-image: url('./봄버맨사운드/물풍선.png'); */
        }

        /* ✨ [신규] .bomb와 .player-bubble의 공통 광택 효과 */
       
        /* ✨ [신규] 쉴드 활성화 시각 효과 */
        .player-shield-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150%; /* 플레이어보다 크게 */
            height: 150%;
            z-index: 1; /* 플레이어 아바타(2)보다 뒤 */
            display: none; /* 기본 숨김 */
            opacity: 0;
            border-radius: 50%;
            
            /* 쉴드예시.png 참고한 물방울/보호막 스타일 */
            border: 3px solid rgba(120, 200, 255, 0.7);
            background-color: rgba(100, 180, 255, 0.2);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.8), 
                        inset 0 0 10px rgba(150, 220, 255, 0.5);

            animation: shield-pulse 1.5s infinite ease-in-out, shield-fade-in 0.3s forwards;
        }

        /* 쉴드 활성화/비활성화 애니메이션 */
        @keyframes shield-fade-in {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* 쉴드 펄스 애니메이션 */
        @keyframes shield-pulse {
            0% { box-shadow: 0 0 15px rgba(100, 200, 255, 0.8), inset 0 0 10px rgba(150, 220, 255, 0.5); }
            50% { box-shadow: 0 0 25px rgba(150, 220, 255, 1), inset 0 0 15px rgba(150, 220, 255, 0.7); }
            100% { box-shadow: 0 0 15px rgba(100, 200, 255, 0.8), inset 0 0 10px rgba(150, 220, 255, 0.5); }
        }
        
        /* ✨ [신규] 다트 발사체 스타일 */
        .dart-projectile {
            position: absolute;
            z-index: 15; /* 플레이어(10)보다 위 */
            background-image: url('./봄버맨사운드/다트.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: left 0.3s linear, top 0.3s linear;
            pointer-events: none;
        }

        /* ✨ [신규] 갇혔을 때 둥둥 떠다니는 애니메이션 (기존 .item-balloon의 @keyframes float 사용) */
        .player.trapped {
             animation: float 2s ease-in-out infinite;
        }

       #item-slots-container {
            position: absolute; /* ✨ [수정] fixed -> absolute */
            bottom: 0; /* ✨ [수정] 래퍼 기준 0 */
            right: 0; /* ✨ [수정] 래퍼 기준 0 */
            width: 100%; /* 래퍼 크기 100% */
            height: 100%; /* 래퍼 크기 100% */
            z-index: 101; /* ✨ [수정] 100 -> 101 */
            pointer-events: none; /* ✨ [신규] 컨테이너는 클릭x, 버튼만 클릭o */
        
        }
        .item-slot-btn {
            width: 60px; /* ✨ [수정] 레이아웃에 맞게 크기 조정 */
            height: 60px; /* ✨ [수정] 레이아웃에 맞게 크기 조정 */
            border-radius: 50%;
            background-color: #007bff; /* ✨ [수정] 진한 파란색 배경 */
            border: 3px solid #66b0ff; /* ✨ [수정] 밝은 파란색 테두리 */
            cursor: pointer;
            padding: 5px; /* 내부 여백 */
            display: flex;
            flex-direction: column; /* 아이콘과 개수를 세로로 */
            justify-content: center;
            align-items: center;
            color: white;
            position: absolute; /* ✨ [수정] relative -> absolute */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.2s ease-out, background-color 0.1s ease;
            pointer-events: auto; /* ✨ [신규] 클릭 활성화 */
        }
        .item-slot-btn:active {
            transform: scale(0.95);
            background-color: #0056b3; /* ✨ [수정] 클릭 시 더 진한 파란색 */
        }

        /* ✨ [신규] 아이템 슬롯 개별 위치 (레이아웃.png 스타일) */
        #item-slot-1 { /* 바늘 (왼쪽 하단 - 레이아웃.png의 다트 위치) */
            right: 90px; /* (폭탄 80px + 갭 10px) */
            bottom: 10px; /* ( (폭탄 80px - 아이템 60px) / 2 ) */
        }
        #item-slot-2 { /* 쉴드 (왼쪽 상단 - 레이아웃.png의 얼음 위치) */
            right: 90px;
            bottom: 80px; /* (아이템1 10px + 아이템1 60px + 갭 10px) */
        }
        #item-slot-3 { /* 다트 (중앙 상단 - 레이아웃.png의 타이머 위치) */
            right: 10px; /* ( (폭탄 80px - 아이템 60px) / 2 ) */
            bottom: 90px; /* (폭탄 80px + 갭 10px) */
        }

 
        #item-slot-2 { /* slot 2 (Shield) */

        }
        #item-slot-3 { /* slot 3 (Dart) */

        }
        .item-slot-btn .item-icon {
            font-size: 2em; /* 아이콘 크기 */
            line-height: 1;
        }
        .item-slot-btn .item-count {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 0.9em;
            font-weight: 700;
            background-color: rgba(255, 0, 0, 0.8); /* 빨간 배경 */
            border-radius: 50%;
            padding: 2px 6px;
            line-height: 1;
            min-width: 18px; /* 최소 너비 */
            text-align: center;
        }
        /* 개수가 0이면 숨김 */
        .item-slot-btn .item-count[data-count="0"] {
            display: none;
        }

    </style>
</head>
<body>
    <audio id="sound-background" src="./봄버맨사운드/배경음악1.mp3" loop></audio>
    <audio id="sound-place-bomb" src="./봄버맨사운드/폭탄놓는소리.mp3"></audio>
    <audio id="sound-explosion" src="./봄버맨사운드/물풍선터지는소리.mp3"></audio>
    <audio id="sound-item-get" src="./봄버맨사운드/드랍.mp3"></audio>
    <audio id="sound-win" src="./봄버맨사운드/win.mp3"></audio>
    <audio id="sound-lose" src="./봄버맨사운드/패배.mp3"></audio>

    <div id="game-wrapper">
        <div id="game-header"></div>
        <div id="game-timer">05:00</div>
        <div id="game-container">
            <div id="game-board"></div>
        </div>
    </div>

    <div id="controls-container">
        <div id="d-pad">
            <button class="d-pad-btn" id="btn-up">↑</button>
            <button class="d-pad-btn" id="btn-left">←</button>
            <button class="d-pad-btn" id="btn-right">→</button>
            <button class="d-pad-btn" id="btn-down">↓</button>
        </div>
    </div>

</div> 
    <div id="action-ui-wrapper">
        <div id="item-slots-container">
            <button id="item-slot-1" class="item-slot-btn" data-item-type="needle">
                <span class="item-icon"></span> <span class="item-count" data-count="0">0</span> </button>
            <button id="item-slot-2" class="item-slot-btn" data-item-type="shield">
                <span class="item-icon"></span> <span class="item-count" data-count="0">0</span> </button>
            <button id="item-slot-3" class="item-slot-btn" data-item-type="dart">
                <span class="item-icon"></span> <span class="item-count" data-count="0">0</span> </button>
        </div>

        <button id="bomb-btn"></button>
    </div>

    <div id="game-over-modal" class="overlay">
        <div class="modal-content">
            <h2 id="game-over-message"></h2>
            <button id="lobby-btn" class="modal-btn secondary">대기실로</button>
        </div>
    </div>

    <div id="countdown-overlay">
        <span id="countdown-number" class="number">3</span>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>

    <script>
        // 개발자 도구 F12 방지 (엄격하지 않음)
        document.addEventListener('contextmenu', event => event.preventDefault());
        /*
        document.addEventListener('keydown', event => {
             if (event.key === 'F12' || (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) || (event.ctrlKey && event.key.toUpperCase() === 'U')) {
               event.preventDefault();
             }
        });
        // setInterval(() => { try { debugger; } catch (e) {} }, 1000); // 디버거 방지 (개발 중에는 주석 처리)
        */

        document.addEventListener('DOMContentLoaded', () => {
            // Firebase 앱 초기화
            const firebaseConfig = {
                apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw",
                authDomain: "goodluck-7c14b.firebaseapp.com",
                databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com",
                projectId: "goodluck-7c14b",
                storageBucket: "goodluck-7c14b.appspot.com",
                messagingSenderId: "858281658455",
                appId: "1:858281658455:web:9131280a459be983933b12"
            };
            firebase.initializeApp(firebaseConfig);
            const db = firebase.database(); // Firebase Realtime Database 인스턴스
            const auth = firebase.auth(); // Firebase Authentication 인스턴스
            const roomsRef = db.ref('rooms'); // 'rooms' 경로 참조
            const usersRef = db.ref('users'); // 'users' 경로 참조

            // HTML 요소 가져오기
            const gameBoard = document.getElementById('game-board');
            const gameHeader = document.getElementById('game-header');
            const gameOverModal = document.getElementById('game-over-modal');
            const gameOverMessage = document.getElementById('game-over-message');
            // 로비 버튼은 게임오버 모달 내부에 있으므로 showGameOver에서 처리

            // 게임 상태 변수
            let myPlayerId, myNickname, myAvatar, roomRef, isHost;
            let currentRoomData = {}; // 현재 방 데이터 (Firebase에서 받아옴)
            let playerElements = {}; // 플레이어 DOM 요소 저장 객체 {'playerId': element}
            let myIndicatorElement = null; // 내 플레이어 위 화살표 DOM 요소
            let bombElements = {}; // 폭탄 DOM 요소 저장 객체 {'bombId': element}
            let itemElements = {}; // 아이템 DOM 요소 저장 객체 {'itemId': element}
            let mapGrid = []; // 로컬 맵 데이터 (0: 길, 1: 벽, 2: 상자)
            let mapElements = []; // 맵 타일 DOM 요소 저장 배열 [[cell, cell], ...]
           let TILE_WIDTH = 0; // 타일 가로 크기
            let TILE_HEIGHT = 0; // 타일 세로 크기

            // ✨ [신규] 게임 타이머 및 카운트다운 요소
            const countdownOverlayEl = document.getElementById('countdown-overlay');
            const countdownNumberEl = document.getElementById('countdown-number');
            const gameTimerEl = document.getElementById('game-timer');
            const GAME_TIME_LIMIT = 300; // 5분
            let gameTimerInterval = null; // 게임 타이머 setInterval ID
            let ghostSpawned = false; // 유령 스폰 여부 (미래 기능용)
            // ✨ [신규] 사운드 스로틀링
            let lastExplosionSoundTime = 0;

            const GRID_COLS = 11; // 맵 가로 칸 수
            const GRID_ROWS = 15; // 맵 세로 칸 수

            let moveDirection = { x: 0, y: 0, current: null }; // 현재 이동 방향 정보
            let moveInterval = null; // 연속 이동 인터벌 ID
            const BASE_MOVE_SPEED = 210;
// ✨ [신규] 속도 레벨 (기본, +1, +2)
            const speedLevels = [BASE_MOVE_SPEED, 180, 150]; 

            let serverTimeOffset = 0; // 클라이언트-서버 시간 차이
            let bombTimerInterval = null; // 폭탄 타이머 체크 인터벌 ID
            let explodingBombs = new Set(); // 현재 폭발 중인 폭탄 ID 저장 Set

          const ITEM_TYPES = { BOMB_COUNT: 'bomb', BOMB_RANGE: 'range', SPEED: 'speed', NEEDLE: 'needle', SHIELD: 'shield', DART: 'dart' }; // ✨ 쉴드, 다트 추가

const ITEM_ICONS = {
                 [ITEM_TYPES.BOMB_COUNT]: './봄버맨사운드/물풍선아이템.png',
                 [ITEM_TYPES.BOMB_RANGE]: './봄버맨사운드/물줄기강화.png',
                 [ITEM_TYPES.SPEED]: './봄버맨사운드/속도업.png',
                 [ITEM_TYPES.NEEDLE]: './봄버맨사운드/바늘.png',
                 [ITEM_TYPES.SHIELD]: './봄버맨사운드/쉴드.png',
                 [ITEM_TYPES.DART]: './봄버맨사운드/다트.png', 
             };
             // ✨ [신규] 사운드 재생 함수 (오류 방지 포함)
             function playSound(id) {
                try {
                    const sound = document.getElementById(id);
                    if (sound) {
                        sound.currentTime = 0; // 처음부터 재생
                        sound.play();
                    }
                } catch (e) {
                    console.warn(`사운드(${id}) 재생 오류:`, e);
                }
             }
             
             // ✨ 맵 배경색 목록 (초원, 설원, 사막, 석재)
             const mapBackgroundColors = [
                 '#a7d38c', // 초원
                 '#f0f8ff', // 설원 (AliceBlue)
                 '#e6c891', // 사막
                 '#bdc3c7'  // 석재
             ];
             let selectedMapBackground = ''; // 현재 게임에서 사용할 배경 이미지 URL

            // 초기화 함수: 서버 시간 오프셋 가져오고, 사용자 인증 상태 확인
            function initialize() {
                // 서버 시간과의 차이를 가져와 동기화에 사용
                const offsetRef = db.ref(".info/serverTimeOffset");
                offsetRef.on("value", (snap) => {
                    serverTimeOffset = snap.val();
                });

                // 사용자 로그인 상태 변경 감지
                auth.onAuthStateChanged(user => {
                    if (user) { // 로그인 되어 있으면
                        myPlayerId = user.uid; // 내 ID 저장
                        myNickname = localStorage.getItem('userNickname'); // 로컬 저장소에서 닉네임 가져오기
                        myAvatar = localStorage.getItem('userAvatar'); // 로컬 저장소에서 아바타 가져오기

                        // URL에서 방 ID 가져오기
                        const urlParams = new URLSearchParams(window.location.search);
                        const roomId = urlParams.get('roomId');

                        // 방 ID나 닉네임 없으면 잘못된 접근 처리
                        if (!roomId || !myNickname) {
                            alert("잘못된 접근입니다.");
                            window.location.href = '대기실.html';
                            return;
                        }
                        joinRoom(roomId); // 방 참가 함수 호출
                    } else { // 로그인 안 되어 있으면
                        window.location.href = 'index.html'; // 로그인 페이지로 이동
                    }
                });
            }

            // 방 참가 함수: 방 정보 가져오고, 방장/게스트 설정, 리스너 시작
            function joinRoom(roomId) {
                roomRef = roomsRef.child(roomId); // 해당 방 경로 참조

                // ✨ [수정] roomRef.once()를 제거하고 listenToRoomChanges가
                // 첫 로딩을 포함한 모든 데이터 처리를 하도록 변경합니다. (카운트다운 버그 수정)
                listenToRoomChanges(); // Firebase 데이터 변경 감지 시작
                setupControls(); // 조작 버튼 설정
            }

            // 게임 레이아웃 설정 함수: 타일 크기 계산, 맵 생성 또는 렌더링
            // 게임 레이아웃 설정 함수: 타일 크기 계산, 맵 생성 또는 렌더링
            function setupGameLayout() {
                // 브라우저가 화면을 그릴 준비가 되면 실행 (정확한 크기 계산 위함)
                requestAnimationFrame(() => {
                     // 게임 보드 요소가 없으면 중단 (예: 페이지 이동 중)
                    if (!document.body.contains(gameBoard)) {
                        console.log("게임 보드 없음, 레이아웃 설정 중단");
                        return;
                    }

                    // ✨ [신규] '다시하기' 무한 루프 버그 수정
                    // 방장이 새로고침 후, 'restarting' 플래그를 여기서 제거합니다.
                    if (isHost && currentRoomData.status === 'waiting' && currentRoomData.gameState === 'restarting') {
                        roomRef.child('gameState').set(null); // 플래그 제거
                    }

                    // 타일 크기 계산
                    TILE_WIDTH = gameBoard.clientWidth / GRID_COLS;
                    TILE_HEIGHT = gameBoard.clientHeight / GRID_ROWS;

                    // 타일 크기가 유효하지 않으면 재시도
                    if (isNaN(TILE_WIDTH) || TILE_WIDTH <= 0 || isNaN(TILE_HEIGHT) || TILE_HEIGHT <= 0) {
                        console.warn("타일 크기 계산 오류, 재시도...");
                        setTimeout(setupGameLayout, 100); // 0.1초 후 재시도
                        return;
                    }

                    console.log(`[레이아웃 설정] 타일 크기: W=${TILE_WIDTH.toFixed(1)}, H=${TILE_HEIGHT.toFixed(1)}`);

                    // 호스트이고 아직 맵 데이터가 없으면 맵 생성
                    if (isHost && !currentRoomData.map) {
                        console.log("[레이아웃 설정] 호스트가 맵 생성 중...");
                        generateMap(); // 맵 데이터 생성 및 Firebase 업데이트
                        // 맵 렌더링은 listenToRoomChanges가 Firebase 업데이트 감지 후 처리
                    }
                    // 맵 데이터가 있으면 (게스트 또는 호스트가 재접속/화면크기변경 등) 맵/요소 렌더링
                    else if (currentRoomData.map) {
                         console.log("[레이아웃 설정] 기존 맵 및 요소 렌더링 중...");
                         // 로컬 맵 데이터 없으면 Firebase 데이터로 채움
                         if(mapGrid.length === 0) mapGrid = currentRoomData.map;
                         renderMap(); // 맵 타일 렌더링
                         renderGameElements(); // 플레이어, 폭탄, 아이템 렌더링
                    } else {
                         console.log("[레이아웃 설정] 맵 데이터 기다리는 중...");
                         // 아직 맵 데이터 못 받음, listenToRoomChanges가 처리할 때까지 대기
                    }
                });
            }


            // 맵 생성 함수 (방장 전용): 맵 구조, 플레이어 위치, 아이템 등 생성 후 Firebase 업데이트
            // 맵 생성 함수 (방장 전용): 맵 구조, 플레이어 위치, 아이템 등 생성 후 Firebase 업데이트
            // 맵 생성 함수 (방장 전용): 맵 구조, 플레이어 위치, 아이템 등 생성 후 Firebase 업데이트
            function generateMap() {
                // --- 1. 플레이어 수 및 순서 결정 ---
                const playerIds = Object.keys(currentRoomData.players);
                const playerCount = playerIds.length;
                const hostId = currentRoomData.hostId;
                // 호스트를 제외한 게스트들을 UID 기준으로 정렬 (순서 고정)
                const guestIds = playerIds.filter(id => id !== hostId).sort();
                // 최종 플레이어 순서 (P1=호스트, P2=게스트1, P3=게스트2, ...)
                const orderedPlayerIds = [hostId, ...guestIds];

                // --- 2. 맵 배경색 랜덤 선택 ---
                const mapIndex = Math.floor(Math.random() * mapBackgroundColors.length);
                const newColor = mapBackgroundColors[mapIndex];
                gameBoard.style.backgroundColor = newColor; // 호스트 화면 즉시 적용

                // --- 3. 맵 데이터 초기화 및 규칙적인 벽(1) 배치 ---
                mapGrid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(0));
                
                console.log(`[맵 생성] ${playerCount}인용 맵 생성 시작...`);

                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        // (홀수, 홀수) 좌표에 파괴 불가 벽(1) 배치 (예: 1,1 / 1,3 / 3,1 ...)
                        if (r % 2 !== 0 && c % 2 !== 0) {
                            mapGrid[r][c] = 1; // Wall
                        } else {
                            mapGrid[r][c] = 0; // Path
                        }
                    }
                }

                // --- 4. 플레이어 수에 따른 시작 위치 정의 ---
                let playerPositions = []; // 플레이어 시작 위치 배열
                const midC = Math.floor(GRID_COLS / 2);
                const midR = Math.floor(GRID_ROWS / 2);

                if (playerCount <= 2) { // 2인 (기존 요청대로)
                    playerPositions.push({ r: 1, c: midC }); // 위 중앙
                    playerPositions.push({ r: GRID_ROWS - 2, c: midC }); // 아래 중앙
                } else if (playerCount === 3) { // 3인 (요청 기반)
                    playerPositions.push({ r: 1, c: 1 }); // 10시 (좌상단)
                    playerPositions.push({ r: midR, c: GRID_COLS - 2 }); // 3시 (우중단)
                    playerPositions.push({ r: GRID_ROWS - 2, c: 1 }); // 8시 (좌하단)
                } else { // 4인 (요청 기반)
                    playerPositions.push({ r: 1, c: 1 }); // 11시 (좌상단)
                    playerPositions.push({ r: 1, c: GRID_COLS - 2 }); // 1시 (우상단)
                    playerPositions.push({ r: GRID_ROWS - 2, c: GRID_COLS - 2 }); // 5시 (우하단)
                    playerPositions.push({ r: GRID_ROWS - 2, c: 1 }); // 7시 (좌하단)
                }
                
                // --- 5. 시작 지점 주변 안전지대(길) 확보 ---
                const safeZones = new Set();
                playerPositions.forEach(pos => {
                    // (r, c) 좌표를 "r,c" 문자열 키로 사용
                    safeZones.add(`${pos.r},${pos.c}`); // 시작 위치
                    // 맵 범위 체크하며 상하좌우 1칸 추가
                    if (pos.r > 0) safeZones.add(`${pos.r - 1},${pos.c}`);
                    if (pos.r < GRID_ROWS - 1) safeZones.add(`${pos.r + 1},${pos.c}`);
                    if (pos.c > 0) safeZones.add(`${pos.r},${pos.c - 1}`);
                    if (pos.c < GRID_COLS - 1) safeZones.add(`${pos.r},${pos.c + 1}`);
                });

                // --- 6. 파괴 가능 나무상자(2) 랜덤 배치 ---
                for (let r = 0; r < GRID_ROWS; r++) {
                     for (let c = 0; c < GRID_COLS; c++) {
                         // 파괴불가 벽(1)이 아니고, 안전지대가 아니면
                        if (mapGrid[r][c] === 0 && !safeZones.has(`${r},${c}`)) {
                             if (Math.random() < 0.7) { // 70% 확률로 나무상자(2) 배치
                                mapGrid[r][c] = 2; 
                             }
                        }
                     }
                }
                
                // --- 7. 안전지대 강제로 길(0) 만들기 (혹시 모를 상자 덮어쓰기) ---
                safeZones.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    // 맵 범위 안인지 확인 후 길(0)로 변경
                    if (r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS) {
                        mapGrid[r][c] = 0;
                    }
                });


                // --- 8. 시작 아이템 풍선 위치 선정 ---
                let initialItems = {};
                // 4인 기준 아이템 풀 (순서대로 배정됨)
                const itemTypes = [ITEM_TYPES.BOMB_COUNT, ITEM_TYPES.BOMB_RANGE, ITEM_TYPES.SHIELD, ITEM_TYPES.SPEED]; // ✨ P3 쉴드, P4 스피드로 변경
                // 주변 나무상자 찾는 함수 (기존 함수 재사용)
                const findCrateSpot = (startPos) => {
                    const candidates = [
                        {r: startPos.r, c: startPos.c - 1}, {r: startPos.r, c: startPos.c + 1}, 
                        {r: startPos.r - 1, c: startPos.c}, {r: startPos.r + 1, c: startPos.c}
                    ];
                    candidates.sort(() => Math.random() - 0.5);
                    for (let p of candidates) {
                        if (p.r >= 0 && p.r < GRID_ROWS && p.c >= 0 && p.c < GRID_COLS && mapGrid[p.r]?.[p.c] === 2) {
                            return p;
                        }
                    }
                     // 1칸 주변에 없으면 2칸 범위에서 다시 찾기
                     for (let dr = -2; dr <= 2; dr++){
                        for (let dc = -2; dc <= 2; dc++){
                            if(Math.abs(dr) + Math.abs(dc) > 2 || (dr === 0 && dc === 0) || (Math.abs(dr) <= 1 && Math.abs(dc) <= 1)) continue; // 1칸 반경 제외
                            const r = startPos.r + dr;
                            const c = startPos.c + dc;
                             if (r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS && mapGrid[r]?.[c] === 2) {
                                return {r, c};
                             }
                        }
                    }
                    return null; 
                };

                // 모든 플레이어에게 아이템 배정
                playerPositions.forEach((pos, index) => {
                    const itemPos = findCrateSpot(pos);
                    if (itemPos) {
                         const itemKey = roomRef.child('items').push().key; 
                         initialItems[itemKey] = {
                            r: itemPos.r, c: itemPos.c, 
                            type: itemTypes[index % itemTypes.length], // 아이템 풀에서 순환 선택
                            isVisible: false, isBalloon: true 
                        };
                         mapGrid[itemPos.r][itemPos.c] = 2; // 확실히 상자로 덮기
                         console.log(`P${index+1} 시작 아이템 위치: ${itemPos.r}, ${itemPos.c}`);
                    } else {
                         console.warn(`P${index+1} 시작 아이템 놓을 상자 못 찾음`);
                    }
                });

                // --- 9. Firebase에 업데이트할 데이터 준비 ---
                const updates = {};
                updates['mapIndex'] = mapIndex;
                updates['map'] = mapGrid;
                updates['items'] = initialItems;

                // 모든 플레이어 위치 및 초기 스탯 설정
                orderedPlayerIds.forEach((playerId, index) => {
                    // 정의된 시작 위치가 있는 플레이어만 (최대 4명)
                    if (index < playerPositions.length) {
                        const pos = playerPositions[index];
                        updates[`players/${playerId}/r`] = pos.r;
                        updates[`players/${playerId}/c`] = pos.c;
                        updates[`players/${playerId}/stats`] = { maxBombs: 1, bombRange: 1, speed: 1, isAlive: true, needles: 0, shields: 0, darts: 0, shieldActiveUntil: null }; // ✨ 쉴드, 다트 스탯 + 쉴드 활성 시간
                    }
                });
                
                // --- 10. Firebase에 모든 데이터 일괄 업데이트 ---
                console.log("[맵 생성] Firebase 업데이트 실행...");
                roomRef.update(updates);
            }


            // Firebase 데이터 변경 감지 함수
            // Firebase 데이터 변경 감지 함수
            function listenToRoomChanges() {
                // 방 데이터 변경될 때마다 실행
                roomRef.on('value', snapshot => {
                    // 방이 삭제되었는지 확인
                    if (!snapshot.exists()) {
                         // 게임 오버 모달이 안 떠있으면 (정상 종료 아니면)
                         if (!gameOverModal.classList.contains('active')) {
                            alert("방장이 나갔습니다.");
                            clearInterval(bombTimerInterval); // 타이머 정리
                            bombTimerInterval = null;
                            window.location.href = '대기실.html'; // 대기실로 이동
                        }
                        return; // 함수 종료
                    }

                    
                  // ✨ [신규] 첫 로드인지 확인 (카운트다운 버그 수정)
                    const isFirstLoad = Object.keys(currentRoomData).length === 0;

                    const oldStatus = currentRoomData.status; // 이전 게임 상태 저장
                    const oldMapDataString = JSON.stringify(currentRoomData.map); // 이전 맵 데이터 문자열로 저장
                    currentRoomData = snapshot.val(); // 최신 방 데이터 저장

                    // ✨ [신규] 첫 로드일 때만 실행 (기존 roomRef.once 로직)
                    if (isFirstLoad) {
                        isHost = currentRoomData.hostId === myPlayerId;
                        if (isHost) { // 방장이면
                            roomRef.onDisconnect().remove(); // 연결 끊기면 방 자동 삭제 설정
                            // 방장만 폭탄 타이머 시작
                            if (!bombTimerInterval) {
                                bombTimerInterval = setInterval(checkBombTimers, 100); // 0.1초마다 타이머 체크
                            }
                        } else { // 게스트면
                            // 연결 끊기면 내 플레이어 정보만 삭제 설정
                            roomRef.child('players/' + myPlayerId).onDisconnect().remove();
                        }
                        // ✨ [신규] 다트 요청 리스너 (방장 전용)
                        if (isHost) {
                            roomRef.child('dartRequests').on('child_added', snapshot => {
                                const request = snapshot.val();
                                if (!request) return;
                                
                                const playerId = request.playerId;
                                const targetBombId = request.targetBombId;
                                
                                // DB에서 최신 데이터 다시 확인 (중요)
                                const player = currentRoomData.players?.[playerId];
                                const bomb = currentRoomData.bombs?.[targetBombId];

                                // 1. 유효성 검사 (플레이어, 다트 개수, 폭탄 존재)
                                if (player && (player.stats?.darts || 0) > 0 && bomb) {
                                    // 2. 다트 1개 소모
                                    roomRef.child(`players/${playerId}/stats/darts`).set(player.stats.darts - 1);
                                    
                                    // ✨ [신규] 3. 시각 효과 요청 생성
                                    const visualKey = roomRef.child('dartVisuals').push().key;
                                    roomRef.child('dartVisuals/' + visualKey).set({
                                        startR: player.r,
                                        startC: player.c,
                                        endR: bomb.r,
                                        endC: bomb.c
                                    });
                                    
                                    // 4. 폭탄 즉시 폭발 (폭발 중이 아닌지 확인)
                                    if (currentRoomData.bombs?.[targetBombId] && !explodingBombs.has(targetBombId)) {
                                        console.log(`[방장] ${playerId}의 다트 사용 -> ${targetBombId} 폭발`);
                                        explodeBomb(targetBombId, bomb);
                                    }
                                }
                                
                                // 5. 요청 삭제
                                snapshot.ref.remove();
                            });
                        }
                        
                        // ✨ [신규] 다트 시각 효과 리스너 (모든 클라이언트)
                        roomRef.child('dartVisuals').on('child_added', snapshot => {
                            const data = snapshot.val();
                            if (data) {
                                // playSound('sound-dart-throw'); // (TODO: 사운드 추가)
                                spawnDartVisual(data.startR, data.startC, data.endR, data.endC);
                            }
                            // 호스트만 시각 효과 데이터를 삭제
                            if (isHost) {
                                snapshot.ref.remove();
                            }
                        });
                    }

                    // ✨ [신규] 게임 시작 감지 (카운트다운 시작)
                    // (oldStatus가 undefined일 때도 정상 작동)
                    if (currentRoomData.status === 'playing' && oldStatus !== 'playing') {
                        // ✨ [수정] 호스트는 gameStartTime이 없으면 설정하고,
                        // 모든 클라이언트는 gameStartTime이 설정될 때까지 대기
                        if (isHost && !currentRoomData.gameStartTime) {
                            roomRef.child('gameStartTime').set(firebase.database.ServerValue.TIMESTAMP);
                            return; // gameStartTime이 설정되면 on('value')가 다시 호출됨
                        }
                        
                        // gameStartTime이 설정되었다면 카운트다운 시작
                        if (currentRoomData.gameStartTime) {
                            startCountdown(); // 카운트다운 시작
                        }
                        return; // 맵 렌더링 등은 카운트다운 완료 후
                    }

                    // ✨ [신규] 이미 게임 중일 때 (재접속 등)
                    if (currentRoomData.status === 'playing' && oldStatus === 'playing') {
                        // ✨ [수정] 카운트다운 없이, 그리고 타이머가 아직 안 돌고 있을 때만
                        if (!gameTimerInterval) {
                            startGameTimer(); 
                        }
                    }
                    const newMapDataString = JSON.stringify(currentRoomData.map); // 새 맵 데이터 문자열로 저장

                     // ✨ 맵 배경색 설정 (데이터에 있고, 유효한 인덱스면)
                     if (currentRoomData.mapIndex !== undefined && mapBackgroundColors[currentRoomData.mapIndex]) {
                         const newColor = mapBackgroundColors[currentRoomData.mapIndex];
                         // ✨ 현재 배경색과 다를 경우에만 변경
                         if (gameBoard.style.backgroundColor !== newColor) { 
                             gameBoard.style.backgroundColor = newColor;
                             console.log("맵 배경색 설정:", newColor);
                         }
                     }

                    // 타일 크기 계산 및 맵/요소 렌더링 순서 관리
                    if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) { // 타일 크기 계산 안됐으면
                        console.log("[데이터 수신] 타일 크기 미계산, 레이아웃 재설정 예약");
                        setTimeout(setupGameLayout, 50); // 잠시 후 재계산 및 렌더링 시도
                    } else { // 타일 크기 계산 됐으면
                        // ▼▼▼ [수정] 맵 렌더링 로직 변경 ▼▼▼
                        
                        // 1. 맵이 아예 없었으면 (초기 로딩)
                        if (currentRoomData.map && mapElements.length === 0) {
                             console.log("[데이터 수신] 초기 로드, 맵 및 요소 렌더링");
                             mapGrid = currentRoomData.map;
                             renderMap(); // 맵 타일 생성
                             renderGameElements(); // 요소 렌더링
                        } 
                        // 2. 맵 데이터가 변경되었으면 (예: 상자 파괴)
                        else if (currentRoomData.map && oldMapDataString !== newMapDataString) {
                             console.log("[데이터 수신] 맵 변경, 맵 시각 효과 업데이트 및 요소 렌더링");
                             updateMapVisuals(currentRoomData.map); // ✨ 맵 타일 시각 효과만 업데이트
                             renderGameElements(); // ✨ 요소는 따로 렌더링 (플레이어, 아이템 등)
                        } 
                        // 3. 맵 변경 없으면 (플레이어 이동 등)
                        else {
                             // console.log("[데이터 수신] 동적 요소만 렌더링");
                             renderGameElements();
                        }
                        // ▲▲▲ [수정] ▲▲▲
                    }

                    // 헤더 업데이트 (플레이어 정보 표시)
                    if (currentRoomData.players) {
                        updateHeader(currentRoomData.players);
                    }

                    // 게임 상태가 'gameOver'로 변경되었으면 종료 처리
                    if (currentRoomData.status === 'gameOver' && oldStatus !== 'gameOver') {
                        clearInterval(bombTimerInterval); // 타이머 정리
                        bombTimerInterval = null;
                        showGameOver(currentRoomData.winner); // 게임 오버 화면 표시
                    }
                });
               roomRef.child('rematchRequests').on('value', snapshot => {
                    if (!snapshot.exists() || !currentRoomData || !currentRoomData.players) return;

                    const requests = snapshot.val();
                    const requestCount = Object.keys(requests).length;
                    const playerCount = Object.keys(currentRoomData.players).length;

                    // 모든 플레이어가 재시작을 요청했다면
                  if (requestCount === playerCount) {
                        // 방장(Host)만 게임 재시작을 처리합니다.
                        if (isHost) {
                            
                            // ✨ [신규] 방 삭제 방지: 재시작 전 onDisconnect 핸들러를 취소합니다.
                            roomRef.onDisconnect().cancel(); 

                            // 게임 상태를 초기화하고 재시작 신호를 보냅니다.
                            roomRef.update({
                                gameState: 'restarting', // 재시작 트리거
                                rematchRequests: null,   // 요청 기록 삭제
                                winner: null,            // 게임오버 상태 삭제
                                status: 'playing',       // ✨ [수정] 'waiting' -> 'playing'
                                map: null,               // 맵 삭제
                                items: null,             // 아이템 삭제
                                bombs: null,             // 폭탄 삭제
                                gameStartTime: firebase.database.ServerValue.TIMESTAMP,     // ✨ [수정] gameStartTime 설정
                                players: currentRoomData.players // ✨ 플레이어 정보는 유지
                            });
                        }
                    }
                });

                // ✨ [신규] '재시작' 신호 감지 리스너 (알까기.html 참조)
                roomRef.child('gameState').on('value', snapshot => {
                    if (snapshot.val() === 'restarting') {
                        // 재시작 신호를 받으면 0.5초 후 새로고침하여 게임을 다시 시작합니다.
                        setTimeout(() => {
                            location.reload();
                        }, 500);
                    }
                }); 
  
            }

            


            // 게임 요소들 렌더링 함수 (플레이어, 아이템, 폭탄 순서 중요)
            function renderGameElements() {
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;
                 // 렌더링 순서: 아이템 -> 폭탄 -> 플레이어 (z-index 순서 고려)
                 renderItems(currentRoomData.items);
                 renderBombs(currentRoomData.bombs);
                 renderPlayers(currentRoomData.players);
            }


            // 맵 타일 렌더링 함수
            function renderMap() {
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) {
                      console.warn("[맵 렌더링] 타일 크기 미계산, 렌더링 중단");
                      return;
                 }

                gameBoard.innerHTML = ''; // 기존 맵 요소 모두 제거
                 // 내 화살표 요소 먼저 생성 및 추가
                 if (!myIndicatorElement && myPlayerId) {
                    myIndicatorElement = document.createElement('div');
                    myIndicatorElement.className = 'player-indicator';
                    myIndicatorElement.textContent = '🔽';
                    gameBoard.appendChild(myIndicatorElement);
                }

                mapElements = []; // 맵 요소 배열 초기화
                // 맵 데이터 기반으로 타일 요소 생성
                (currentRoomData.map || []).forEach((row, r) => { // currentRoomData.map 사용 보장
                    const rowElements = [];
                    row.forEach((tileType, c) => {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell'; // 기본 클래스
                        cell.dataset.r = r; // 행 좌표 저장
                        cell.dataset.c = c; // 열 좌표 저장

                        // 타일 타입에 맞는 클래스 추가
                        if (tileType === 1) cell.classList.add('wall');
                        else if (tileType === 2) cell.classList.add('crate');
                        else cell.classList.add('path');

                        // top, left로 위치 설정
                        cell.style.left = `${c * TILE_WIDTH}px`;
                        cell.style.top = `${r * TILE_HEIGHT}px`;

                        gameBoard.appendChild(cell); // 게임 보드에 추가
                        rowElements.push(cell); // 행 배열에 추가
                    });
                    mapElements.push(rowElements); // 전체 맵 요소 배열에 행 추가
                });
                 // 로컬 mapGrid도 업데이트
                 mapGrid = currentRoomData.map || [];
            }


            // 맵 시각 효과 업데이트 함수 (예: 상자 파괴 시)
            function updateMapVisuals(newMapData) {
                // 맵 요소 배열 없거나 타일 크기 계산 안됐으면 중단
                if (!mapElements.length || TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;

                // 모든 칸 순회
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        // 해당 위치 요소 없으면 건너뜀
                        if (!mapElements[r] || !mapElements[r][c]) continue;
                        const cellEl = mapElements[r][c]; // 현재 칸 DOM 요소
                        const oldType = mapGrid[r]?.[c]; // 이전 로컬 맵 데이터
                        const newType = newMapData[r]?.[c]; // 새 Firebase 맵 데이터

                        // 타입이 변경되었을 때만 처리
                        if (oldType !== newType) {
                            // 나무상자(2) -> 길(0) 변경 시
                            if (oldType === 2 && newType === 0) {
                                cellEl.classList.add('destroyed'); // 파괴 애니메이션 클래스 추가
                                 // 애니메이션 시간(0.3초) 후 실제 스타일 변경
                                 setTimeout(() => {
                                    // 요소가 아직 존재하고, 데이터가 다시 바뀌지 않았는지 확인
                                    // currentRoomData.map 직접 비교
                                    if (mapElements[r]?.[c] === cellEl && currentRoomData?.map?.[r]?.[c] === 0) {
                                        cellEl.classList.remove('crate', 'destroyed'); // 상자 클래스 제거
                                        cellEl.classList.add('path'); // 길 클래스 추가
                                        cellEl.style.backgroundImage = 'none'; // 이미지 제거
                                        cellEl.style.backgroundColor = 'var(--path-color)'; // 투명 배경
                                        cellEl.style.border = 'none'; // 테두리 제거
                                        cellEl.style.boxShadow = 'none'; // 그림자 제거
                                    }
                                 }, 300);
                            } else { // 그 외 타입 변경 시 (즉시 변경)
                                cellEl.classList.remove('wall', 'crate', 'path', 'destroyed'); // 모든 타입 클래스 제거
                                // 새 타입에 맞는 클래스 추가
                                if (newType === 1) cellEl.classList.add('wall');
                                else if (newType === 2) cellEl.classList.add('crate');
                                else cellEl.classList.add('path');

                                // 새 타입에 맞는 스타일 적용
                                if (newType === 1) { // 벽
                                     // ✨ 클래스(.wall)가 스타일을 적용하므로 
                                     // ✨ 인라인 스타일은 모두 제거 (상자 스타일만 복사)
                                     cellEl.style.backgroundImage = 'none';
                                     cellEl.style.backgroundColor = 'var(--wall-color)';
                                     cellEl.style.border = '1px solid rgba(0,0,0,0.4)';
                                     cellEl.style.boxShadow = 'inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2)';
                                } else if (newType === 2) { // 상자
                                     cellEl.style.backgroundImage = 'none'; // 이미지 대신 색상 사용
                                     cellEl.style.backgroundColor = 'var(--crate-color)';
                                     cellEl.style.border = '1px solid rgba(0,0,0,0.3)';
                                     cellEl.style.boxShadow = 'inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.2)';
                                } else { // 길
                                    cellEl.style.backgroundImage = 'none';
                                    cellEl.style.backgroundColor = 'var(--path-color)'; // 투명
                                    cellEl.style.border = 'none';
                                    cellEl.style.boxShadow = 'none';
                                }
                            }
                        }
                    }
                }
                mapGrid = newMapData; // 로컬 맵 데이터 업데이트
            }


          function renderPlayers(players) {
                if (!players) {
                    return;
                }
                if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;

                if (!myIndicatorElement && myPlayerId && document.body.contains(gameBoard)) {
                    myIndicatorElement = document.createElement('div');
                    myIndicatorElement.className = 'player-indicator';
                    myIndicatorElement.textContent = '🔽';
                    gameBoard.appendChild(myIndicatorElement);
                }

                const playerIds = Object.keys(players || {}); 
                const currentOnScreen = {}; 

                playerIds.forEach(playerId => {
                    currentOnScreen[playerId] = true; 
                    const pData = players[playerId]; 
                    if (!pData || pData.r === undefined || pData.c === undefined || !pData.stats) return;

                    let playerEl = playerElements[playerId]; 
                    
                    // ✨ [수정] 플레이어 생성 시, 자식 요소를 모두 absolute로 변경
                    if (!playerEl && document.body.contains(gameBoard)) {
                        playerEl = document.createElement('div');
                        playerEl.className = 'player';
                        playerEl.id = `player-${playerId}`;
                        
                        const x = pData.c * TILE_WIDTH;
                        const y = pData.r * TILE_HEIGHT;
                        playerEl.style.left = `${x}px`;
                        playerEl.style.top = `${y}px`;

                        // ✨ 1. 아바타 이미지
                        const avatarImg = document.createElement('img');
                        avatarImg.className = 'player-avatar-img';
                        avatarImg.style.display = 'none'; 
                        avatarImg.style.position = 'absolute'; // ✨ 추가
                        avatarImg.style.top = '50%'; // ✨ 추가
                        avatarImg.style.left = '50%'; // ✨ 추가
                        avatarImg.style.transform = 'translate(-50%, -50%)'; // ✨ 추가
                        avatarImg.style.zIndex = '2'; // ✨ 추가 (물풍선보다 위)
                        
                        // ✨ 2. 아바타 이모지
                        const avatarEmoji = document.createElement('span');
                        avatarEmoji.className = 'player-avatar-emoji';
                        avatarEmoji.style.display = 'none';
                        avatarEmoji.style.position = 'absolute'; // ✨ 추가
                        avatarEmoji.style.top = '50%'; // ✨ 추가
                        avatarEmoji.style.left = '50%'; // ✨ 추가
                        avatarEmoji.style.transform = 'translate(-50%, -50%)'; // ✨ 추가
                        avatarEmoji.style.zIndex = '2'; // ✨ 추가 (물풍선보다 위)

                        // ✨ 3. 물풍선 (CSS에 z-index: 1이 이미 설정됨)
                        const bubbleEl = document.createElement('div');
                        bubbleEl.className = 'player-bubble';
                        // ✨ (bubbleEl의 position/transform/z-index는 CSS에 설정됨)
                        
                        // ✨ 4. 쉴드 효과 (신규 추가)
                        const shieldEl = document.createElement('div');
                        shieldEl.className = 'player-shield-effect';
                        // (스타일은 CSS 파일에 정의되어 있음)

                        playerEl.appendChild(avatarImg); 
                        playerEl.appendChild(avatarEmoji); 
                        playerEl.appendChild(bubbleEl); // ✨ 물풍선 요소 추가
                        playerEl.appendChild(shieldEl); // ✨ [신규] 쉴드 요소 추가
                        
                        gameBoard.appendChild(playerEl);
                        playerElements[playerId] = playerEl;
                    } else if (!playerEl) {
                        return; 
                    }

                    const avatarImgEl = playerEl.querySelector('.player-avatar-img');
                    const avatarEmojiEl = playerEl.querySelector('.player-avatar-emoji');
                    const bubbleEl = playerEl.querySelector('.player-bubble'); 
                    const shieldEl = playerEl.querySelector('.player-shield-effect'); // ✨ [신규] 쉴드 요소 가져오기

                    if (!avatarImgEl || !avatarEmojiEl || !bubbleEl || !shieldEl) {  // ✨ [수정] 쉴드 요소 null 체크
                        if (playerEl) playerEl.remove();
                        delete playerElements[playerId];
                        return; 
                    }

                    const isImage = pData.avatar && (pData.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(pData.avatar));

                    if (isImage) {
                        if (avatarImgEl.src !== pData.avatar) {
                           avatarImgEl.src = pData.avatar;
                        }
                        avatarImgEl.style.display = 'block';
                        avatarEmojiEl.style.display = 'none';
                    } else if (pData.avatar) {
                        avatarEmojiEl.textContent = pData.avatar;
                        avatarEmojiEl.style.fontSize = `${TILE_HEIGHT * 0.7}px`;
                        avatarEmojiEl.style.display = 'block';
                        avatarImgEl.style.display = 'none';
                        avatarImgEl.src = ''; 
                    } else {
                         avatarImgEl.style.display = 'none';
                         avatarEmojiEl.style.display = 'none';
                    }
                    
                    playerEl.style.backgroundColor = 'transparent';

                    if (playerId !== myPlayerId) {
                        const x = pData.c * TILE_WIDTH;
                        const y = pData.r * TILE_HEIGHT;
                        playerEl.style.left = `${x}px`;
                        playerEl.style.top = `${y}px`;
                    }

                    const isAlive = pData.stats.isAlive;
                    const isTrapped = pData.stats.isTrapped === true;
                    
                    // ✨ [신규] 쉴드 활성화 상태 체크
                    const now = Date.now() + serverTimeOffset;
                    const isShieldActive = pData.stats.shieldActiveUntil && pData.stats.shieldActiveUntil > now;

                    playerEl.classList.toggle('dead', !isAlive); 
                    playerEl.classList.toggle('trapped', isTrapped && isAlive); 
                    bubbleEl.style.display = (isTrapped && isAlive) ? 'block' : 'none'; 
                    shieldEl.style.display = (isShieldActive && isAlive) ? 'block' : 'none'; // ✨ [신규] 쉴드 시각 효과 토글
                   
                    if (playerId === myPlayerId && myIndicatorElement) {
                         if (!myIndicatorElement.style.left || myIndicatorElement.style.left === '0px') {
                            const x = pData.c * TILE_WIDTH;
                            const y = pData.r * TILE_HEIGHT;
                            const indicatorY = y - TILE_HEIGHT * 0.6; 
                            myIndicatorElement.style.left = `${x}px`;
                            myIndicatorElement.style.top = `${indicatorY}px`;
                         }
                         
                         myIndicatorElement.style.display = (isAlive && !isTrapped) ? 'block' : 'none';
                    }

                    // ✨ [신규] 내 플레이어면 아이템 슬롯(바늘 개수) 업데이트
                    // ✨ [수정] 내 플레이어면 모든 아이템 슬롯 업데이트
                    if (playerId === myPlayerId) {
                        const myStats = pData.stats || {};
                        const needleCount = myStats.needles || 0;
                        const shieldCount = myStats.shields || 0;
                        const dartCount = myStats.darts || 0;

                        // 헬퍼 함수: 슬롯 UI 업데이트
                        const updateSlot = (slotId, itemType, count) => {
                            const slotEl = document.getElementById(slotId);
                            if (!slotEl) return;

                            const countEl = slotEl.querySelector('.item-count');
                            const iconEl = slotEl.querySelector('.item-icon');
                            const iconUrl = ITEM_ICONS[itemType];

                            // 아이콘 이미지 업데이트
                            if (iconEl && iconUrl) {
                                iconEl.innerHTML = `<img src="${iconUrl}" alt="${itemType}" style="width: 100%; height: 100%; object-fit: contain;">`;
                            }
                            
                            // 개수 업데이트
                            if (countEl) {
                                countEl.textContent = count;
                                countEl.dataset.count = count;
                            }

                            // 버튼 활성화/비활성화 로직
                            if (itemType === ITEM_TYPES.NEEDLE) {
                                slotEl.disabled = !(isTrapped && count > 0);
                            } else if (itemType === ITEM_TYPES.DART) {
                                slotEl.disabled = !(isAlive && !isTrapped && count > 0);
                            } else if (itemType === ITEM_TYPES.SHIELD) {
                                // ✨ [수정] 쉴드가 활성화(isShieldActive)되지 않았을 때만 사용 가능
                                slotEl.disabled = !(isAlive && !isTrapped && count > 0 && !isShieldActive);
                            }
                        };
                        
                        // 3개 슬롯 모두 업데이트
                        updateSlot('item-slot-1', ITEM_TYPES.NEEDLE, needleCount);
                        updateSlot('item-slot-2', ITEM_TYPES.SHIELD, shieldCount);
                        updateSlot('item-slot-3', ITEM_TYPES.DART, dartCount);
                    }
                }); // <-- playerIds.forEach 끝

                for(const pid in playerElements){
                    if(!currentOnScreen[pid]){ 
                        if(playerElements[pid]) playerElements[pid].remove(); 
                        delete playerElements[pid]; 
                        if(pid === myPlayerId && myIndicatorElement){
                            myIndicatorElement.remove();
                            myIndicatorElement = null;
                        }
                    }
                }
            }


            // 아이템 렌더링 함수
            function renderItems(itemsData) {
                // 데이터 없거나 타일 크기 계산 안됐으면 중단
                if (!itemsData) itemsData = {};
                if (TILE_WIDTH <= 0) return;

                const itemsOnScreen = {}; // 현재 화면 아이템 추적용
                // 모든 아이템 데이터 순회
                for (const itemId in itemsData) {
                    const iData = itemsData[itemId];
                    // 데이터 유효성 검사
                    if(!iData || iData.r === undefined || iData.c === undefined || iData.isVisible === undefined || !iData.type) continue;

                    itemsOnScreen[itemId] = true; // 화면에 있다고 표시

                    let itemEl = itemElements[itemId]; // 기존 DOM 요소 가져오기
                    // DOM 요소 없으면 새로 생성 (보드 존재 확인 추가)
                    if (!itemEl && document.body.contains(gameBoard)) {
                        itemEl = document.createElement('div');
                        itemEl.id = itemId;
                        itemEl.className = 'item'; // 기본 클래스

                        // ✨ [수정] 아이템 아이콘 설정
                        if (iData.type === ITEM_TYPES.BOMB_COUNT) {
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/물풍선아이템.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            
                            // ✨ [수정] 이미지 아이템 스타일
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                            
                        } else if (iData.type === ITEM_TYPES.BOMB_RANGE) {
                            // ✨ [수정] 물줄기강화.png 이미지로 변경
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/물줄기강화.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            
                           itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                        
                        // ✨ [신규] 속도업 아이템 렌더링
                        } else if (iData.type === ITEM_TYPES.SPEED) {
                            itemEl.style.backgroundImage = "url('./봄버맨사운드/속도업.png')";
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%';
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 
                        
                        // ✨ [신규] 바늘 아이템 렌더링 로직 추가

                        // ✨ [신규] 쉴드 아이템 렌더링
                        } else if (iData.type === ITEM_TYPES.SHIELD) {
                            itemEl.style.backgroundImage = `url('${ITEM_ICONS[ITEM_TYPES.SHIELD]}')`; 
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%'; 
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 

                        // ✨ [신규] 다트 아이템 렌더링
                        } else if (iData.type === ITEM_TYPES.DART) {
                            itemEl.style.backgroundImage = `url('${ITEM_ICONS[ITEM_TYPES.DART]}')`; 
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%'; 
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0';

                        } else if (iData.type === ITEM_TYPES.NEEDLE) {
                            itemEl.style.backgroundImage = `url('${ITEM_ICONS[ITEM_TYPES.NEEDLE]}')`; // 정의된 아이콘 사용
                            itemEl.style.backgroundColor = 'transparent';
                            itemEl.textContent = '';
                            itemEl.style.backgroundSize = '100% 100%'; // 크기 맞춤
                            itemEl.style.backgroundPosition = 'center';
                            itemEl.style.backgroundRepeat = 'no-repeat';
                            itemEl.style.display = 'block'; 
                            itemEl.style.fontSize = '0'; 

                        } else {
                            itemEl.textContent = '?'; // 알 수 없는 아이템
                        }
                        
                        itemEl.classList.add(`item-${iData.type}`); // 타입별 클래스 추가
                        if (iData.isBalloon) itemEl.classList.add('item-balloon'); // 풍선 클래스 추가
                        gameBoard.appendChild(itemEl); // 게임 보드에 추가
                        itemElements[itemId] = itemEl; // 추적 객체에 저장
                    } else if (!itemEl) {
                        continue; // 보드 없으면 생성 불가
                    }


                    // isVisible 상태에 따라 'visible' 클래스 토글
                    itemEl.classList.toggle('visible', iData.isVisible);

                    // 위치 계산 및 적용 (top, left)
                    const itemX = iData.c * TILE_WIDTH;
                    const itemY = iData.r * TILE_HEIGHT;
                    itemEl.style.left = `${itemX}px`;
                    itemEl.style.top = `${itemY}px`;
                }
                // Firebase 데이터에는 없는데 화면에 남아있는 아이템 요소 제거
                for (const itemId in itemElements) {
                    if (!itemsOnScreen[itemId]) {
                         if (itemElements[itemId]) { // 요소 존재 확인 후 제거
                            itemElements[itemId].remove();
                            delete itemElements[itemId]; // 추적 객체에서 제거
                         }
                    }
                }
            }


            // 폭탄 렌더링 함수
            function renderBombs(bombsData) {
                // 타일 크기 계산 안됐으면 중단
                if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0) return;
                if (!bombsData) bombsData = {}; // 데이터 없으면 빈 객체로

                const bombsOnScreen = {}; // 현재 화면 폭탄 추적용
                // 모든 폭탄 데이터 순회
                for (const bombId in bombsData) {
                    const bData = bombsData[bombId];
                    // 데이터 유효성 검사
                    if (!bData || typeof bData.r !== 'number' || typeof bData.c !== 'number' || typeof bData.placedAt !== 'number') continue;
                    bombsOnScreen[bombId] = true; // 화면에 있다고 표시

                    let bombEl = bombElements[bombId]; // 기존 DOM 요소 가져오기
                    // DOM 요소 없으면 새로 생성 (보드 존재 확인 추가)
if (!bombEl && document.body.contains(gameBoard)) {
                        bombEl = document.createElement('div');
                        bombEl.id = bombId;
                        bombEl.className = 'bomb'; // 기본 클래스
                        
                        /* ✨ [수정] 아래 2줄을 반드시 삭제해야 합니다 */
                        // bombEl.textContent = '💧';
                        // bombEl.style.fontSize = `${TILE_HEIGHT * 0.8}px`; 

                        gameBoard.appendChild(bombEl); // 게임 보드에 추가
                        bombElements[bombId] = bombEl; // 추적 객체에 저장
                    } else if (!bombEl) {
                         continue; // 보드 없으면 생성 불가
                    }


                    // 위치 계산 및 적용 (top, left)
                    const bombX = bData.c * TILE_WIDTH;
                    const bombY = bData.r * TILE_HEIGHT;
                    bombEl.style.left = `${bombX}px`;
                    bombEl.style.top = `${bombY}px`;
                }

                // Firebase 데이터에는 없는데 화면에 남아있는 폭탄 요소 제거
                for (const bombId in bombElements) {
                    if (!bombsOnScreen[bombId]) { // 데이터에 없는 ID면
                        if (bombElements[bombId]) { // 요소 존재 확인 후 제거
                            bombElements[bombId].remove();
                            delete bombElements[bombId]; // 추적 객체에서 제거
                        }
                    }
                }
            }

function checkBombTimers() {
                // 방장이 아니거나 맵/플레이어 데이터 없으면 중단
                if (!isHost || !currentRoomData?.map || !currentRoomData?.players) return;
                
                const now = Date.now() + serverTimeOffset; // 현재 서버 시간
                const bombs = currentRoomData.bombs || {};
                const players = currentRoomData.players;
                const updates = {}; // Firebase 일괄 업데이트용 객체

                // --- 1. 폭탄 타이머 체크 ---
                for (const bombId in bombs) {
                    // 이미 터지는 중이면 건너뜀
                    if (explodingBombs.has(bombId)) continue;
                    const bData = bombs[bombId];
                    // 데이터 유효성 검사 (설치 시간 있는지)
                    if (bData && typeof bData.placedAt === 'number') {
                        // 설치 시간 + 3초 < 현재 시간이면 폭발
                        if (bData.placedAt + 3000 < now) {
                            explodeBomb(bombId, bData); // 폭발 함수 호출 (이 함수는 비동기 아님)
                        }
                    }
                }

                // --- 2. ✨ [수정] 물풍선 갇힘 타이머 / 쉴드 만료 체크 ---
                let didPlayerDie = false; // ✨ [신규] 플레이어가 죽었는지 확인하는 플래그
                for (const playerId in players) {
                    const pData = players[playerId];
                    
                    // 2-1. 갇힘 타이머 체크
                    if (pData?.stats?.isAlive === true && pData?.stats?.isTrapped === true && typeof pData.stats.trapTime === 'number') {
                        // 2. 3초가 지났는지 확인
                        if (pData.stats.trapTime + 3000 < now) {
                            // 3. 3초 지났으면 사망 처리
                            updates[`players/${playerId}/stats/isAlive`] = false;
                            updates[`players/${playerId}/stats/isTrapped`] = false; // 갇힘 상태도 해제
                            didPlayerDie = true; // ✨ [신규] 플래그 설정
                        }
                    }

                    // ✨ [신규] 2-2. 쉴드 만료 타이머 체크
                    if (pData?.stats?.shieldActiveUntil && pData.stats.shieldActiveUntil < now) {
                        updates[`players/${playerId}/stats/shieldActiveUntil`] = null; // 쉴드 버프 시간 만료
                    }
                }

                // --- 3. ✨ [수정] 일괄 업데이트 실행 및 승리 조건 확인 ---
                if (Object.keys(updates).length > 0) {
                    roomRef.update(updates)
                        .then(() => {
                            // ✨ [신규] 플레이어가 방금 물풍선으로 죽었다면,
                            // 즉시 승리 조건을 확인합니다.
                            if (didPlayerDie) {
                                checkWinCondition(); 
                            }
                        })
                        .catch(error => {
                            console.error("물풍선 타이머 업데이트 오류:", error);
                        });
                }
            }


            // 폭탄 설치 함수 (클라이언트 요청)
            function placeBomb() {
                // 내 플레이어 데이터, 스탯 없으면 중단
                if (!currentRoomData?.players?.[myPlayerId]?.stats) return;
                const myStats = currentRoomData.players[myPlayerId].stats;
                const myPos = currentRoomData.players[myPlayerId];
                // 위치 없거나 죽었으면 중단
                // ✨ [수정] 살아있어도 '갇혔으면(isTrapped)' 설치 불가
                if (myPos.r === undefined || myPos.c === undefined || !myStats.isAlive || myStats.isTrapped) return;
                // 현재 설치된 내 폭탄 개수 세기
                const myBombs = Object.values(currentRoomData.bombs || {}).filter(b => b.owner === myPlayerId).length;
                // 최대 설치 개수 넘으면 중단
                if (myBombs >= myStats.maxBombs) return;
                
                // ✨ [신규] 이미 해당 위치에 폭탄이 있는지 확인
                const bombs = currentRoomData.bombs || {};
                for (const bombId in bombs) {
                    if (bombs[bombId].r === myPos.r && bombs[bombId].c === myPos.c) {
                        return; // 이미 폭탄이 있으므로 설치 불가
                    }
                }
                
                // 새 폭탄 ID 생성
                const bombId = roomRef.child('bombs').push().key;
                // 폭탄 데이터 생성 (위치, 설치 시간)
                const bombData = {
                    owner: myPlayerId,
                    r: myPos.r,
                    c: myPos.c,
                    placedAt: firebase.database.ServerValue.TIMESTAMP // 서버 시간 기록
                };
                // Firebase에 폭탄 데이터 저장 요청
                roomRef.child('bombs/' + bombId).set(bombData);
                playSound('sound-place-bomb');
            }


            // 폭발 처리 함수 (방장 전용)
            function explodeBomb(bombId, bData) {
                 // 방장 아니거나, 이미 터지는 중이거나, 데이터 없거나, 맵 없으면 중단
                if (!isHost || explodingBombs.has(bombId) || !bData || !currentRoomData?.map) return;
                
                // ✨ 1. 이 폭발로 인해 터질 모든 폭탄과 타일을 재귀적으로 찾는다.
                // "r,c" => {r, c}, 최종 폭발 범위 (중복 없음)
                const allAffectedTiles = new Map(); 
                // bombId, 연쇄 폭발에 포함된 모든 폭탄 ID (중복 없음)
                const allBombsInChain = new Set(); 
                
                // 재귀 함수: 연쇄 폭발 탐색
                function findExplosionChain(currentBombId, currentBombData) {
                    // 이미 처리했거나(무한 루프 방지), 데이터 없으면 중단
                    if (allBombsInChain.has(currentBombId) || !currentBombData) return;
                    
                    allBombsInChain.add(currentBombId); // 이 폭탄을 체인에 추가
                    // ✨ 다른 타이머가 중복 실행 않도록 전역 set에도 즉시 추가
                    explodingBombs.add(currentBombId); 

                    const ownerStats = currentRoomData.players?.[currentBombData.owner]?.stats;
                    const range = ownerStats ? Math.min(3, ownerStats.bombRange) : 1; // ✨ 최대 3개로 변경
                    // ✨ [0,0] 센터 타일 포함
                    const directions = [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]]; 
                    
                    const currentBombTiles = []; // 이 폭탄 *하나*의 범위 (다른 폭탄 찾기용)

                    directions.forEach(([dr, dc]) => {
                        const isCenter = dr === 0 && dc === 0;
                        // isCenter가 참이면 0~0 (1번), 거짓이면 1~range
                        for (let i = (isCenter ? 0 : 1); i <= (isCenter ? 0 : range); i++) {
                            const r = currentBombData.r + dr * i;
                            const c = currentBombData.c + dc * i;

                            // 맵 밖 체크
                            if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) break;
                            
                            const tileType = currentRoomData.map?.[r]?.[c];
                            if (tileType === undefined) break; // 맵 데이터 오류

                            // 1. 최종 폭발 범위(allAffectedTiles)에 추가
                            const tileKey = `${r},${c}`;
                            if (!allAffectedTiles.has(tileKey)) { // 중복 타일은 추가 안함
                                allAffectedTiles.set(tileKey, { r, c });
                            }
                            // 2. 이 폭탄의 개별 범위(currentBombTiles)에도 추가
                            currentBombTiles.push({r, c}); 

                            if (tileType === 1) break; // 파괴불가 벽
                            if (tileType === 2) break; // 파괴가능 상자 (여기까지 불길이 닿음)
                        }
                    });

                    // ✨ 3. 이 폭탄의 범위(currentBombTiles)에 걸친 '다른' 폭탄을 찾는다.
                    for (const tile of currentBombTiles) {
                        for (const otherBombId in currentRoomData.bombs) {
                            // 이미 체인에 포함된 폭탄은 다시 체크 안 함
                            if (allBombsInChain.has(otherBombId)) continue; 
                            
                            const otherBombData = currentRoomData.bombs[otherBombId];
                            // 다른 폭탄이 해당 타일에 존재하면
                            if (otherBombData && otherBombData.r === tile.r && otherBombData.c === tile.c) {
                                // ✨ 연쇄 폭발! 재귀 호출
                                findExplosionChain(otherBombId, otherBombData);
                            }
                        }
                    }
                } // --- 재귀 함수 끝 ---

                // ✨ 2. 재귀 탐색 시작 (최초 폭탄 A로 시작)
                findExplosionChain(bombId, bData);

                // ✨ 3. 모든 체인이 탐색 완료됨.
                // allAffectedTiles에 모든 고유 타일이 모임.
                const updates = {}; // Firebase 업데이트 내용 객체

                allAffectedTiles.forEach(tile => {
                    // ✨ 4. 시각 효과를 한 번에 표시 (중복 없이)
                    showExplosionEffect(tile.r, tile.c);

                    // --- 이하 방장만 처리 ---
                    if (isHost) {
                        const currentTileType = currentRoomData.map?.[tile.r]?.[tile.c];
                        // 나무상자(2)면 파괴 처리
                        if (currentTileType === 2) {
                            updates[`map/${tile.r}/${tile.c}`] = 0; // 맵 데이터 길(0)로 변경
                            
                            // 아이템 드롭/공개 처리
                            let revealedItem = false; 
                            for(const itemId in currentRoomData.items) {
                                const item = currentRoomData.items[itemId];
                                if (item?.isBalloon && !item.isVisible && item.r === tile.r && item.c === tile.c) {
                                    updates[`items/${itemId}/isVisible`] = true;
                                    revealedItem = true;
                                    break; 
                                }
                            }
                            if (!revealedItem && Math.random() < 0.3) { // 30% 확률로 아이템 드랍
                                // ✨ [수정] 아이템 드랍 풀에 쉴드, 다트 추가
                                const itemDropPool = [ITEM_TYPES.BOMB_COUNT, ITEM_TYPES.BOMB_RANGE, ITEM_TYPES.SPEED, ITEM_TYPES.NEEDLE, ITEM_TYPES.SHIELD, ITEM_TYPES.DART];
                                const randomType = itemDropPool[Math.floor(Math.random() * itemDropPool.length)];

                                const newItemKey = roomRef.child('items').push().key;
                                updates[`items/${newItemKey}`] = {
                                    r: tile.r, c: tile.c,
                                    type: randomType, // ✨ 랜덤 타입 적용
                                    isVisible: true, isBalloon: true
                                };
                            }
                        }

                        // 플레이어 피격 처리
                        const nowForExplosion = Date.now() + serverTimeOffset; // ✨ [신규] 폭발 시점의 현재 시간
                        for (const playerId in currentRoomData.players) {
                            const pData = currentRoomData.players[playerId];
                            // ✨ [수정] 살아있고, 아직 안 갇힌 플레이어가 맞았을 때
                            if (pData?.stats?.isAlive === true && pData?.stats?.isTrapped !== true && pData.r === tile.r && pData.c === tile.c) {
                                
                                // ✨ [수정] 활성화된 쉴드(shieldActiveUntil)가 있는지 체크
                                if (pData.stats.shieldActiveUntil && pData.stats.shieldActiveUntil > nowForExplosion) {
                                    // 쉴드가 활성화되어 있으면 1회 방어하고 버프 즉시 제거
                                    updates[`players/${playerId}/stats/shieldActiveUntil`] = null;
                                    // (TODO: 쉴드 파괴 사운드/효과)
                                    // playSound('sound-shield-break');
                                } else {
                                    // 쉴드가 없으면 갇힘 상태로 변경
                                    updates[`players/${playerId}/stats/isTrapped`] = true;
                                    updates[`players/${playerId}/stats/trapTime`] = firebase.database.ServerValue.TIMESTAMP;
                                }
                            }
                        }
                        
                        // ✨ [신규] 아이템 파괴 처리
                        for (const itemId in currentRoomData.items) {
                            const item = currentRoomData.items[itemId];
                            // 보이는 아이템(풍선 아님)이 폭발 범위에 있으면
                            if (item && item.isVisible && !item.isBalloon && item.r === tile.r && item.c === tile.c) {
                                updates[`items/${itemId}`] = null; // 아이템 삭제
                            }
                        }

                    } // --- 방장 처리 끝 ---
                }); // --- 최종 폭발 범위 순회 끝 ---

                // ✨ 5. Firebase 업데이트 및 승리 조건 확인 (방장만)
                if (isHost) {
                    // 체인에 포함된 모든 폭탄 삭제
                    allBombsInChain.forEach(id => {
                        updates[`bombs/${id}`] = null; // null로 설정하여 삭제
                    });

                    const performUpdatesAndCheckWin = () => {
                        checkWinCondition(); // 승리 조건 확인
                        
                        // 전역 Set에서 폭탄 ID들 제거 (0.2초 후)
                        // (폭발 애니메이션 시간(0.4초)보다 짧게)
                        setTimeout(() => {
                            allBombsInChain.forEach(id => explodingBombs.delete(id));
                        }, 200); 
                    };

                    // 업데이트할 내용이 있으면 Firebase에 한 번에 전송
                    if (Object.keys(updates).length > 0) {
                        roomRef.update(updates).then(performUpdatesAndCheckWin).catch(error => {
                            console.error("Firebase 업데이트 실패:", error);
                            performUpdatesAndCheckWin(); // 실패해도 체크는 시도
                        });
                    } else {
                        performUpdatesAndCheckWin(); // 업데이트 없어도 체크
                    }
                }
            }


          // 폭발 시각 효과 함수
            function showExplosionEffect(r, c) {
                 // ✨ [신규] 폭발 사운드 (스로틀링)
                 const now = Date.now();
                 if (now - lastExplosionSoundTime > 100) { // 0.1초 이내 중복 재생 방지
                    playSound('sound-explosion');
                    lastExplosionSoundTime = now;
                 }
                 // 타일 크기 계산 안됐으면 중단
                 if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0 || !document.body.contains(gameBoard)) return;

                // 고유 ID를 (r, c) 좌표 기반으로 고정
                const effectId = `exp-${r}-${c}`;
                
                let explosionEl = document.getElementById(effectId); // 기존 효과 요소 찾기

                if (explosionEl) {
                    // ✨ 1. 이미 효과가 존재하면? -> 제거 타이머만 초기화
                    if (explosionEl.removeTimer) {
                        clearTimeout(explosionEl.removeTimer);
                    }
                    // ✨ 2. [핵심] CSS 애니메이션 강제 재시작 (깜빡임 해결)
                    explosionEl.style.animation = 'none'; // 애니메이션 끄기
                    explosionEl.offsetHeight; // 브라우저가 DOM 변경을 감지하도록 함 (reflow)
                    explosionEl.style.animation = ''; // 애니메이션 다시 켜기 (CSS 기본값으로)

                } else {
                    // ✨ 3. 효과가 없으면? -> 새로 생성
                    explosionEl = document.createElement('div');
                    explosionEl.id = effectId;
                    explosionEl.className = 'explosion'; // CSS 클래스 적용
                    explosionEl.style.width = `${TILE_WIDTH}px`; // 타일 크기 적용
                    explosionEl.style.height = `${TILE_HEIGHT}px`;
                    explosionEl.style.left = `${c * TILE_WIDTH}px`; // 위치 적용 (left)
                    explosionEl.style.top = `${r * TILE_HEIGHT}px`; // 위치 적용 (top)
                    gameBoard.appendChild(explosionEl); // 게임 보드에 추가
                }

                // ✨ 4. 0.4초 후 제거 타이머 설정 (요소에 타이머 ID 저장)
                explosionEl.removeTimer = setTimeout(() => {
                    // setTimeout 시점에 요소가 아직 존재하는지 한 번 더 확인
                    const elToRemove = document.getElementById(effectId);
                    if (elToRemove) {
                        elToRemove.remove();
                    }
                }, 400); // CSS 애니메이션 시간과 일치
            }


// ✨ [신규] 다트 발사 시각 효과 함수 (모든 클라이언트)
            function spawnDartVisual(startR, startC, endR, endC) {
                if (TILE_WIDTH <= 0 || TILE_HEIGHT <= 0 || !document.body.contains(gameBoard)) return;

                const startX = startC * TILE_WIDTH + (TILE_WIDTH / 2); // 중앙
                const startY = startR * TILE_HEIGHT + (TILE_HEIGHT / 2); // 중앙
                const endX = endC * TILE_WIDTH + (TILE_WIDTH / 2);
                const endY = endR * TILE_HEIGHT + (TILE_HEIGHT / 2);
                
                // 1. 각도 계산
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                const angleDeg = Math.atan2(deltaY, deltaX) * 180 / Math.PI; // 각도 (도)

                // 2. 다트 요소 생성
                const dartEl = document.createElement('div');
                dartEl.className = 'dart-projectile';
                
                // 크기 설정 (예: 타일의 60%)
                const dartSizeW = TILE_WIDTH * 0.6;
                const dartSizeH = TILE_HEIGHT * 0.6;
                dartEl.style.width = `${dartSizeW}px`;
                dartEl.style.height = `${dartSizeH}px`;
                
                // 3. 시작 위치 설정 (중앙에서 시작하도록 보정)
                dartEl.style.left = `${startX - dartSizeW / 2}px`;
                dartEl.style.top = `${startY - dartSizeH / 2}px`;
                dartEl.style.transform = `rotate(${angleDeg}deg)`; // 방향 회전

                gameBoard.appendChild(dartEl);

                // 4. 1프레임 뒤, 목표 위치로 transition 시작
                requestAnimationFrame(() => {
                    dartEl.style.left = `${endX - dartSizeW / 2}px`;
                    dartEl.style.top = `${endY - dartSizeH / 2}px`;
                });

                // 5. CSS transition 시간(0.3s) 후 요소 제거
                setTimeout(() => {
                    if (dartEl) dartEl.remove();
                }, 300); 
            }

     
            // 승리 조건 확인 함수 (방장 전용)
            function checkWinCondition(isTimeUp = false) { // isTimeUp 파라미터
                // 방장 아니거나 플레이어 데이터 없으면 중단
                if (!isHost || !currentRoomData?.players) return;

                let winnerId = null;

                // --- 1. 시간 종료로 인한 판정 (isTimeUp = true) ---
                if (isTimeUp && currentRoomData.status === 'playing') {
                    console.log("시간 종료! 스탯으로 승패 판정.");
                    
                    const playerIds = Object.keys(currentRoomData.players);
                    const alivePlayerIds = playerIds.filter(id => currentRoomData.players[id]?.stats?.isAlive === true);

                    // 1-1. 살아남은 플레이어가 1명 초과일 때 (스탯 비교)
                    if (alivePlayerIds.length > 1) {
                        let bestScore = -1;
                        let winners = []; // 최고 스탯 플레이어 목록 (동점자 처리)

                        alivePlayerIds.forEach(id => {
                            const stats = currentRoomData.players[id].stats;
                            // 스탯 합산 (폭탄 + 사거리 + 속도)
                            const score = (stats?.maxBombs || 1) + (stats?.bombRange || 1) + (stats?.speed || 1);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                winners = [id]; // 새 최고 점수자
                            } else if (score === bestScore) {
                                winners.push(id); // 동점자 추가
                            }
                        });

                        // 최고 스탯 보유자가 1명이면 그 사람이 승자, 동점이면 무승부
                        winnerId = (winners.length === 1) ? winners[0] : null;

                    // 1-2. 살아남은 플레이어가 1명일 때
                    } else if (alivePlayerIds.length === 1) {
                        winnerId = alivePlayerIds[0]; // 그 1명이 승자

                    // 1-3. 살아남은 플레이어가 0명일 때
                    } else {
                        winnerId = null; // 무승부
                    }

                    // Firebase에 게임 상태 및 승자 업데이트
                    roomRef.update({ status: 'gameOver', winner: winnerId });
                    return; // 시간 종료 판정 끝
                }

                // --- 2. 일반 사망으로 인한 판정 (isTimeUp = false) ---
                const alivePlayers = Object.entries(currentRoomData.players)
                                         .filter(([id, pData]) => pData?.stats?.isAlive === true);
                
                // 살아있는 플레이어가 1명 이하이고, 아직 게임 종료 상태가 아니면
                if (alivePlayers.length <= 1 && currentRoomData.status === 'playing') {
                    // 승자 ID 결정 (1명이면 그 ID, 0명이면 null(무승부))
                    winnerId = alivePlayers.length === 1 ? alivePlayers[0][0] : null;
                    console.log(`게임 종료! 승자: ${winnerId || '무승부'}`);
                    // Firebase에 게임 상태 및 승자 업데이트
                    roomRef.update({ status: 'gameOver', winner: winnerId });
                }
            }

// ✨ [신규] 카운트다운 시작 함수
            // 약 1052행 'startCountdown' 함수 (전체 교체)
            function startCountdown() {
                if (!countdownOverlayEl || !countdownNumberEl) return;
                
                countdownOverlayEl.style.display = 'flex';
                let count = 3;
                
                function runCount() {
                    countdownNumberEl.textContent = count;
                    countdownNumberEl.style.animation = 'none';
                    countdownNumberEl.offsetHeight; // Reflow
                    countdownNumberEl.style.animation = 'countdown-zoom 1s forwards';
                    
                    // ✨ [수정] 3, 2, 1 까지만 표시하도록 count > 1 로 변경
                    if (count > 1) { 
                        count--;
                        setTimeout(runCount, 1000); // 1초마다 반복
                    } else {
                        // "1"이 표시된 후 1초 뒤에 게임 시작
                        setTimeout(() => {
                            countdownOverlayEl.style.display = 'none';
                            playSound('sound-background'); // 배경음악 시작
                            setupGameLayout(); // 맵/요소 렌더링 시작
                            startGameTimer(); // 게임 타이머 시작
                        }, 1000); // "1"이 사라지는 시간
                    }
                }
                runCount(); // 카운트 시작
            }

            // ✨ [신규] 게임 타이머 시작 함수 (모든 클라이언트)
            function startGameTimer() {
                // ✨ [수정] 타이머가 이미 실행 중이면 중복 실행 방지
                if (gameTimerInterval) return;

                // ✨ [수정] gameStartTime이 없으면(드문 경우), 시작 불가.
                // listenToRoomChanges가 설정할 때까지 기다려야 함.
                if (!currentRoomData.gameStartTime) {
                    console.warn("gameStartTime 없이 타이머 시작 시도. 대기...");
                    return; 
                }

                const startTime = currentRoomData.gameStartTime; // 이제 null이 아님

                gameTimerInterval = setInterval(() => {
                    const now = Date.now() + serverTimeOffset;
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const remaining = Math.max(0, GAME_TIME_LIMIT - elapsed);
                    
                    updateTimerDisplay(remaining);

                    // --- 유령 AI 스폰 로직 (미래 기능) ---
                    if (remaining <= 90 && !ghostSpawned) { 
                        // spawnGhost(); // TODO: 유령 AI 스폰 함수 호출
                        console.log("유령 스폰 시간!");
                        ghostSpawned = true; // 중복 스폰 방지
                    }

                    // --- 시간 종료 처리 (방장만) ---
                    if (remaining <= 0 && isHost) {
                        stopGameTimer();
                        checkWinCondition(true); // '시간 종료'로 승패 판정
                    }
                }, 1000);
            }

            // ✨ [신규] 게임 타이머 중지 함수
            function stopGameTimer() {
                if (gameTimerInterval) {
                    clearInterval(gameTimerInterval);
                    gameTimerInterval = null;
                }
            }

            // ✨ [신규] 타이머 UI 업데이트 함수
            function updateTimerDisplay(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                if(gameTimerEl) {
                    gameTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }

            // 게임 오버 화면 표시 함수
           // 게임 오버 화면 표시 함수
            function showGameOver(winnerId) {
                // ✨ [신규] 타이머, 배경음악 정지
                stopGameTimer(); 
                try { document.getElementById('sound-background').pause(); } catch(e) {}

                let message = "무승부!"; // 기본 메시지
                if (winnerId) { // 승자가 있으면
                    const winnerData = currentRoomData?.players?.[winnerId]; // 승자 데이터 가져오기
                    // 승자 이름 결정 (데이터 없으면 기본값 사용)
                    const winnerName = winnerData?.nickname || (winnerId === myPlayerId ? myNickname : '상대방');
                    message = `🎉 ${winnerName} 승리! 🎉`; // 승리 메시지

                    // ✨ [신규] 승/패 사운드 재생
                    playSound(winnerId === myPlayerId ? 'sound-win' : 'sound-lose');
                } else {
                    // ✨ [신규] 무승부 사운드 (패배 사운드 재활용)
                    playSound('sound-lose');
                }
                gameOverMessage.textContent = message; // 모달 메시지 설정

                // ✨ [신규] '다시 하기' 버튼 HTML 추가 (알까기.html 참조)
                const modalContent = gameOverModal.querySelector('.modal-content');
                modalContent.innerHTML = `
                    <h2 id="game-over-message">${message}</h2>
                    <button id="rematch-btn" class="modal-btn primary">다시 하기</button>
                    <button id="lobby-btn" class="modal-btn secondary">대기실로</button>
                `;
                gameOverModal.classList.add('active'); // 모달 보이게

                // ✨ [수정] 로비 버튼 이벤트 리스너 (새 HTML 구조에 맞게 수정)
                const lobbyBtnGameOver = modalContent.querySelector('#lobby-btn');
                if(lobbyBtnGameOver) {
                    lobbyBtnGameOver.onclick = () => { window.location.href = '대기실.html'; };
                }

                // ✨ [신규] '다시 하기' 버튼 이벤트 리스너 (알까기.html 참조)
                const rematchBtn = modalContent.querySelector('#rematch-btn');
                if (rematchBtn) {
                    rematchBtn.addEventListener('click', () => {
                        if (roomRef) {
                            rematchBtn.disabled = true;
                            rematchBtn.textContent = '상대방 기다리는 중...';
                            // Firebase에 재시작 요청
                            roomRef.child('rematchRequests').child(myPlayerId).set(true);
                        }
                    });
                }
            }


            // 헤더 업데이트 함수 (플레이어 정보 표시)
            // 약 1083행 'updateHeader' 함수 (전체 교체)
            function updateHeader(players) {
                gameHeader.innerHTML = ''; // 헤더 초기화
                // 모든 플레이어 데이터 순회 (데이터 없으면 빈 객체로)
                Object.keys(players || {}).forEach(playerId => {
                    const pData = players[playerId];
                    // 플레이어 데이터 유효성 검사
                    if(!pData || !pData.avatar) return;

                    // 플레이어 정보 표시 영역 생성
                    const pInfo = document.createElement('div');
                    pInfo.className = 'player-info';
                    // 아바타 영역 생성
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'player-avatar';
                    
                    // ✨ [수정] http 또는 로컬 이미지(.png 등)를 모두 <img>로 처리
                    const isImage = pData.avatar && (pData.avatar.startsWith('http') || /\.(png|jpg|jpeg|gif|webp)$/i.test(pData.avatar));
                    if (isImage) {
                        avatarEl.innerHTML = `<img src="${pData.avatar}" alt="av">`;
                    } else {
                        avatarEl.textContent = pData.avatar;
                    }

                    // 스탯 표시 영역 생성
                    const statsEl = document.createElement('div');
                    statsEl.className = 'player-stats';
                    if (pData.stats) {
                        // ✨ [수정] 폭탄 및 물줄기 아이콘을 <img> 태그로 변경
                        statsEl.innerHTML = `
                            <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/물풍선아이템.png" alt="bomb" style="width: 1.2em; height: 1.2em; object-fit: contain;">
                                ${pData.stats.maxBombs ?? 1}
                            </span>
                           <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/물줄기강화.png" alt="range" style="width: 1.1em; height: 1.1em; object-fit: contain;">
                                ${pData.stats.bombRange ?? 1}
                            </span>
                            <span style="display: flex; align-items: center; gap: 3px;">
                                <img src="./봄버맨사운드/속도업.png" alt="speed" style="width: 1.1em; height: 1.1em; object-fit: contain;">
                                ${pData.stats.speed ?? 1}
                            </span>
                        `;
                    }
                    pInfo.appendChild(avatarEl);
                    pInfo.appendChild(statsEl);
                    gameHeader.appendChild(pInfo); // 헤더에 플레이어 정보 추가
                });
            }

function useNeedle() {
                // 내 플레이어 데이터, 스탯 없으면 중단
                const myStats = currentRoomData?.players?.[myPlayerId]?.stats;
                if (!myStats) return;

                // 살아있고, 갇혀있고, 바늘이 1개 이상 있을 때만 사용 가능
                if (myStats.isAlive === true && myStats.isTrapped === true && (myStats.needles || 0) > 0) {
                    const updates = {};
                    updates[`players/${myPlayerId}/stats/isTrapped`] = false; // 갇힘 상태 해제
                    updates[`players/${myPlayerId}/stats/trapTime`] = null; // 갇힌 시간 제거
                    updates[`players/${myPlayerId}/stats/needles`] = (myStats.needles || 0) - 1; // 바늘 개수 감소

                    // Firebase 업데이트 요청
                    roomRef.update(updates).catch(error => console.error("바늘 사용 오류:", error));
                    // TODO: 바늘 사용 사운드 추가?
                }
            }

            function useShield() {
                // 내 플레이어 데이터, 스탯 없으면 중단
                const myStats = currentRoomData?.players?.[myPlayerId]?.stats;
                if (!myStats) return;

                // 현재 시간
                const now = Date.now() + serverTimeOffset;
                const isShieldActive = myStats.shieldActiveUntil && myStats.shieldActiveUntil > now;

                // 살아있고, 안 갇혔고, 쉴드 아이템이 1개 이상이고, 쉴드가 비활성화 상태일 때
                if (myStats.isAlive === true && myStats.isTrapped !== true && (myStats.shields || 0) > 0 && !isShieldActive) {
                    
                    // playSound('sound-shield-activate'); // (TODO: 쉴드 활성화 사운드)

                    // Firebase 업데이트 요청
                    roomRef.update({
                        [`players/${myPlayerId}/stats/shields`]: (myStats.shields || 0) - 1, // 쉴드 1개 소모
                        [`players/${myPlayerId}/stats/shieldActiveUntil`]: (Date.now() + serverTimeOffset) + 3000 // ✨ 3초 뒤 만료 시간 설정
                    }).catch(error => console.error("쉴드 사용 오류:", error));
                }
            }

            function useDart() {
                // 내 플레이어 데이터, 스탯 없으면 중단
                const myStats = currentRoomData?.players?.[myPlayerId]?.stats;
                if (!myStats) return;

                // 살아있고, 안 갇혔고, 다트가 1개 이상 있을 때
                if (myStats.isAlive === true && myStats.isTrapped !== true && (myStats.darts || 0) > 0) {
                    
                    // 1. 맵에서 가장 오래된 폭탄 찾기
                    const bombs = currentRoomData.bombs || {};
                    let oldestBombId = null;
                    let oldestTime = Infinity;

                    for (const bombId in bombs) {
                        // 터지는 중인 폭탄 제외
                        if (bombs[bombId].placedAt < oldestTime && !explodingBombs.has(bombId)) {
                            oldestTime = bombs[bombId].placedAt;
                            oldestBombId = bombId;
                        }
                    }

                    // 2. 터트릴 폭탄이 있으면 방장에게 요청
                    if (oldestBombId) {
                        // (사운드)
                        // playSound('sound-dart-throw'); 
                        
                        // 3. Firebase에 요청 생성
                        const reqId = roomRef.child('dartRequests').push().key;
                        roomRef.child('dartRequests/' + reqId).set({
                            playerId: myPlayerId,
                            targetBombId: oldestBombId
                        });

                        // 4. (선택적) 로컬에서 즉시 다트 개수 1개 차감 (UI 반응속도)
                        // 어차피 renderPlayers가 서버 데이터 기준으로 다시 그림
                        const dartSlot = document.getElementById('item-slot-3');
                        if (dartSlot) {
                             dartSlot.disabled = true; // 중복 클릭 방지
                             const countEl = dartSlot.querySelector('.item-count');
                             if(countEl) countEl.textContent = myStats.darts - 1;
                        }

                    }
                }
            }

            // 조작 버튼/키 설정 함수
            function setupControls() {
                // D-Pad 버튼 정보 객체
                const dPadButtons = {
                    'btn-up': { dir: 'up', x: 0, y: -1, el: document.getElementById('btn-up') },
                    'btn-down': { dir: 'down', x: 0, y: 1, el: document.getElementById('btn-down') },
                    'btn-left': { dir: 'left', x: -1, y: 0, el: document.getElementById('btn-left') },
                    'btn-right': { dir: 'right', x: 1, y: 0, el: document.getElementById('btn-right') },
                };

                // 각 D-Pad 버튼에 이벤트 리스너 추가
                Object.values(dPadButtons).forEach(btn => {
                     // 버튼 요소 없으면 중단
                     if(!btn.el) return;
                     // 터치 시작 또는 마우스 누르기 시작 이벤트
                    const start = (e) => {
                        e.preventDefault(); // 기본 동작 방지 (스크롤 등)
                        
                        // ✨ [수정] 죽었거나 '갇혔으면' 조작 불가
                        const myStats = currentRoomData?.players?.[myPlayerId]?.stats;
                        if (myStats?.isAlive === false || myStats?.isTrapped === true) return;
                        // 모든 버튼 비활성 스타일 제거
                        Object.values(dPadButtons).forEach(b => { if(b.el) b.el.classList.remove('active'); });
                        btn.el.classList.add('active'); // 현재 버튼 활성 스타일 추가
                        startContinuousMove(btn.dir, btn.x, btn.y); // 연속 이동 시작
                    };
                    // 터치 종료 또는 마우스 떼기 이벤트
                    const end = (e) => {
                        e.preventDefault();
                         if(btn.el) btn.el.classList.remove('active'); // 활성 스타일 제거
                        // 현재 이동 방향과 같으면 이동 중지
                        if (moveDirection.current === btn.dir) {
                            stopContinuousMove();
                        }
                    };
                    // 이벤트 리스너 등록
                    btn.el.addEventListener('mousedown', start);
                    btn.el.addEventListener('touchstart', start, { passive: false });
                    btn.el.addEventListener('mouseup', end);
                    btn.el.addEventListener('touchend', end);
                    btn.el.addEventListener('mouseleave', end); // 버튼 영역 벗어나도 중지
                    
                    // ✨ [신규] 멀티터치 버그 수정을 위해 touchcancel 이벤트 추가
                    btn.el.addEventListener('touchcancel', end); 
                });

                 // 폭탄 버튼 설정
                 const bombButton = document.getElementById('bomb-btn');
                 if (bombButton) { // 버튼 존재하면
                    // ✨ [수정] 'click' 대신 'touchstart'를 사용 (즉시 반응 및 멀티터치 개선)
                    bombButton.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // 'click' 이벤트 및 화면 확대/이동 방지
                        placeBomb();
                    }, { passive: false });
                 }

const needleSlotButton = document.getElementById('item-slot-1');
                 if (needleSlotButton) {
                     // 터치 시작 이벤트 (클릭 대신 사용)
                     needleSlotButton.addEventListener('touchstart', (e) => {
                         e.preventDefault(); // 기본 동작 방지
                         // 버튼이 활성화 상태일 때만 사용
                         if (!needleSlotButton.disabled) {
                             useNeedle();
                         }
                     }, { passive: false });

                     // 마우스 클릭 이벤트 (PC용)
                     needleSlotButton.addEventListener('click', (e) => {
                         if (!needleSlotButton.disabled) {
                             useNeedle();
                         }
                     });
                 }
                 
                 // ✨ [신규] 쉴드 버튼 설정
                 const shieldSlotButton = document.getElementById('item-slot-2');
                 if (shieldSlotButton) {
                     // 터치 시작 이벤트
                     shieldSlotButton.addEventListener('touchstart', (e) => {
                         e.preventDefault(); 
                         if (!shieldSlotButton.disabled) {
                             useShield();
                         }
                     }, { passive: false });

                     // 마우스 클릭 이벤트
                     shieldSlotButton.addEventListener('click', (e) => {
                         if (!shieldSlotButton.disabled) {
                             useShield();
                         }
                     });
                 }

                 }

                 // ✨ [신규] 다트 버튼 설정
                 const dartSlotButton = document.getElementById('item-slot-3');
                 if (dartSlotButton) {
                     // 터치 시작 이벤트
                     dartSlotButton.addEventListener('touchstart', (e) => {
                         e.preventDefault(); 
                         if (!dartSlotButton.disabled) {
                             useDart();
                         }
                     }, { passive: false });

                     // 마우스 클릭 이벤트
                     dartSlotButton.addEventListener('click', (e) => {
                         if (!dartSlotButton.disabled) {
                             useDart();
                         }
                     });

                // PC 키보드 누르기 이벤트
                document.addEventListener('keydown', (e) => {

                     // ✨ [수정] 죽었거나 '갇혔으면' 조작 불가
                     const myStats = currentRoomData?.players?.[myPlayerId]?.stats;
                     if (myStats?.isAlive === false || myStats?.isTrapped === true) return;
                     // 키에 따른 동작 분기
                    switch(e.key) {
                        case 'ArrowUp': e.preventDefault(); startContinuousMove('up', 0, -1); break;
                        case 'ArrowDown': e.preventDefault(); startContinuousMove('down', 0, 1); break;
                        case 'ArrowLeft': e.preventDefault(); startContinuousMove('left', -1, 0); break;
                        case 'ArrowRight': e.preventDefault(); startContinuousMove('right', 1, 0); break;
                        case ' ': e.preventDefault(); placeBomb(); break; // 스페이스바 = 폭탄
                    }
                });

                // PC 키보드 떼기 이벤트
                document.addEventListener('keyup', (e) => {
                    // 키와 방향 매핑
                    const keyMap = {'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right'};
                    // 현재 이동 방향과 뗀 키가 같으면 이동 중지
                    if (moveDirection.current === keyMap[e.key]) {
                        stopContinuousMove();
                    }
                });
            }


            function startContinuousMove(dir, x, y) {
              // 이미 해당 방향으로 이동 중이면 중단
                if (moveDirection.current === dir) return;
                stopContinuousMove(); // 기존 이동 중지
                moveDirection = { x, y, current: dir }; // 새 이동 방향 설정

                // ✨ 재귀적으로 움직임을 처리할 함수
                const moveLoop = () => {
                    // 1. 이동이 중지되었는지 확인
                    if (moveDirection.current !== dir) return; 

                    // 2. 생존 상태 확인
                    if (currentRoomData?.players?.[myPlayerId]?.stats?.isAlive === false) {
                        stopContinuousMove();
                        return;
                    }
                    
                    // 3. 이동 시도
                    tryMove(moveDirection.x, moveDirection.y);

                    // 4. ✨ 다음 이동 속도를 '최신' 데이터로 다시 계산
                    const myStats = currentRoomData?.players?.[myPlayerId]?.stats || { speed: 1 };
                    const speedLevel = Math.max(0, (myStats.speed || 1) - 1);
                    const currentInterval = speedLevels[Math.min(speedLevel, speedLevels.length - 1)];

                    // 5. 다음 이동 예약 (setInterval 대신 setTimeout 사용)
                    moveInterval = setTimeout(moveLoop, currentInterval);
                };
                
                // ✨ 최초 1회 즉시 실행 (즉시 이동 시도)
                // tryMove(x, y)를 호출하는 대신 moveLoop()를 바로 호출하여 
                // 이동 -> 속도계산 -> 다음 이동 예약을 한 사이클로 묶습니다.
                moveLoop();
            }


           function stopContinuousMove() {
                clearTimeout(moveInterval); // ✨ clearInterval -> clearTimeout
                moveInterval = null; // ID 초기화
                moveDirection.current = null; // 현재 방향 초기화
                 // D-Pad 버튼 시각 효과 초기화
                 const dPadButtons = {
                    'btn-up': { el: document.getElementById('btn-up') },
                    'btn-down': { el: document.getElementById('btn-down') },
                    'btn-left': { el: document.getElementById('btn-left') },
                    'btn-right': { el: document.getElementById('btn-right') },
                };
                 Object.values(dPadButtons).forEach(btn => {
                      if(btn?.el) btn.el.classList.remove('active');
                 });
            }


            // 이동 시도 함수 (아이템 획득 처리 포함)
            function tryMove(dc, dr) {
                // 내 플레이어 데이터, 스탯 없거나 죽었으면 중단
                if (!currentRoomData?.players?.[myPlayerId]?.stats?.isAlive) return;
                const myPos = currentRoomData.players[myPlayerId];
                // 위치 정보 없으면 중단
                if (myPos.r === undefined || myPos.c === undefined) return;
                // 새 위치 계산
                const newR = myPos.r + dr;
                const newC = myPos.c + dc;

                // 이동 가능한 위치인지 확인
                if (isWalkable(newR, newC)) {
                    // Firebase 업데이트 내용 객체 (기본: 새 위치)
                    const updates = { r: newR, c: newC };
                    const items = currentRoomData.items || {}; // 현재 아이템 목록
                    let collectedItemId = null; // 획득한 아이템 ID
                    let collectedItemType = null; // 획득한 아이템 타입

                    // 새 위치에 아이템 있는지 확인
                    for (const itemId in items) {
                        const itemData = items[itemId];
                        // 아이템 존재하고, 보이고, 새 위치에 있으면
                        if (itemData && itemData.isVisible && itemData.r === newR && itemData.c === newC) {
                            collectedItemId = itemId;
                            collectedItemType = itemData.type;
                            break; // 하나만 획득
                        }
                    }

                    // 아이템 획득 시 스탯 업데이트 내용 추가
                    if (collectedItemId && collectedItemType) {
                        playSound('sound-item-get'); // ✨ [신규] 아이템 획득 사운드
                        // 현재 스탯 복사 (없으면 기본값 사용)
                        const myStats = { ...(myPos.stats || { maxBombs: 1, bombRange: 1, speed: 1, isAlive: true }) };
                        if (collectedItemType === ITEM_TYPES.BOMB_COUNT) {
                            myStats.maxBombs = Math.min(5, (myStats.maxBombs || 1) + 1); 
                        } else if (collectedItemType === ITEM_TYPES.BOMB_RANGE) {
                            myStats.bombRange = Math.min(3, (myStats.bombRange || 1) + 1);
                        // ✨ [신규] 속도업 아이템 획득 (최대 3레벨)
                        } else if (collectedItemType === ITEM_TYPES.SPEED) {
                            myStats.speed = Math.min(3, (myStats.speed || 1) + 1);
                        // ✨ [신규] 바늘 아이템 획득 (최대 3개)
                        } else if (collectedItemType === ITEM_TYPES.SHIELD) {
                            myStats.shields = Math.min(3, (myStats.shields || 0) + 1);
                        } else if (collectedItemType === ITEM_TYPES.DART) {
                            myStats.darts = Math.min(3, (myStats.darts || 0) + 1);
                        } else if (collectedItemType === ITEM_TYPES.NEEDLE) {
                            myStats.needles = Math.min(3, (myStats.needles || 0) + 1);
                        }
                        updates.stats = myStats; // 업데이트할 스탯 추가

                        // Firebase에서 아이템 삭제 요청
                        roomRef.child('items/' + collectedItemId).remove()
                            .catch(error => console.error("아이템 제거 오류:", error)); // 에러 로깅
                    }

                    // Firebase에 플레이어 위치 (및 스탯) 업데이트 요청
                    // --- ✨ [신규] 클라이언트 즉시 예측 이동 (렉 제거) ---
                    // 1. 로컬 데이터 즉시 수정
                    currentRoomData.players[myPlayerId].r = newR;
                    currentRoomData.players[myPlayerId].c = newC;
                    if (updates.stats) { // 스탯 업데이트가 있으면 로컬에도 반영
                        currentRoomData.players[myPlayerId].stats = updates.stats;
                        updateHeader(currentRoomData.players); // 헤더 즉시 업데이트
                    }
                    
                    // 2. 로컬 렌더링 즉시 실행 (내 플레이어만)
                    const myPlayerEl = playerElements[myPlayerId];
                    // 타일 크기가 계산된 상태인지 확인
                    if (myPlayerEl && TILE_WIDTH > 0 && TILE_HEIGHT > 0) {
                        const x = newC * TILE_WIDTH;
                        const y = newR * TILE_HEIGHT;
                        myPlayerEl.style.left = `${x}px`;
                        myPlayerEl.style.top = `${y}px`;

                        // 내 화살표도 즉시 이동
                        if (myIndicatorElement) {
                             const indicatorY = y - TILE_HEIGHT * 0.6; 
                             myIndicatorElement.style.left = `${x}px`;
                             myIndicatorElement.style.top = `${indicatorY}px`;
                        }
                    }
                    // --- ✨ 예측 이동 끝 ---

                    // 3. Firebase에 업데이트 전송 (기존 로직)
                    roomRef.child('players/' + myPlayerId).update(updates)
                        .catch(error => console.error("플레이어 업데이트 오류:", error)); // 에러 로깅
                }
            }


            // 이동 가능 여부 확인 함수
            function isWalkable(r, c) {
                 // 1. 맵 범위 체크
                if (r < 0 || r >= GRID_ROWS || c < 0 || c >= GRID_COLS) {
                     return false; // 맵 밖
                }
                 // 2. 타일 타입 체크 (Firebase 데이터 기준)
                 // 데이터 없으면 이동 불가 처리
                const tileType = currentRoomData?.map?.[r]?.[c];
                // 벽(1) 또는 상자(2)면 이동 불가
                if (tileType === 1 || tileType === 2) {
                    return false;
                }
                 // 맵 데이터 자체가 없으면 이동 불가
                 if (tileType === undefined) return false;

                 // 3. 폭탄 위치 체크
                const bombs = currentRoomData.bombs || {};
                // 모든 폭탄 순회
                for (const bombId in bombs) {
                     const bombData = bombs[bombId];
                    // 폭탄 데이터 있고, 터지는 중 아니고, 해당 위치에 있으면 이동 불가
                    if (bombData && !explodingBombs.has(bombId) && bombData.r === r && bombData.c === c) {
                        return false;
                    }
                }
                // 모든 조건 통과 시 이동 가능 (길 0)
                return true;
            }

            // --- 게임 시작 ---
            initialize();

            // 페이지 벗어나기 전 처리 (타이머 정리)
             window.addEventListener('beforeunload', () => {
                 clearInterval(bombTimerInterval);
                 clearInterval(gameTimerInterval); // ✨ [신규] 게임 타이머도 정리
                 bombTimerInterval = null;
                 gameTimerInterval = null;
             });

             // 화면 크기 변경 시 처리 (레이아웃 재계산)
             window.addEventListener('resize', () => {
                 // 리사이즈 멈춘 후 잠시 뒤 실행 (성능 최적화)
                 clearTimeout(window.resizeTimeout);
                 window.resizeTimeout = setTimeout(setupGameLayout, 150);
             });
        });
    </script>
</body>
</html>
