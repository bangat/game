<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>미로찾기 게임</title>
    <style>
        :root {
            --bg-color: #f0f2f5; --wall-color: #34495e; --path-color: #ecf0f1;
            --button-bg: #2c3e50; --button-text: #ffffff; --button-hover: #3e5771;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; -webkit-user-select: none; user-select: none; touch-action: manipulation;
        }
        #game-wrapper { width: 100%; height: 100%; display: none; flex-direction: column; }
        #game-header {
            flex-shrink: 0; padding: 10px; display: flex;
            justify-content: center; align-items: center; width: 100%;
        }
        #score-board {
            background-color: rgba(0,0,0,0.6); color: white; padding: 8px 20px;
            border-radius: 20px; font-size: 1.4em; font-weight: bold; z-index: 20;
        }
        #game-container {
            width: 95%; max-width: 500px; flex-grow: 1; margin: 0 auto 2vh auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); border-radius: 10px; overflow: hidden;
            background-color: var(--path-color); display: flex; position: relative;
        }
        #maze { position: relative; width: 100%; height: 100%; display: grid; }
        .wall { background-color: var(--wall-color); }
        #player, #opponent, #goal {
            position: absolute; display: flex; justify-content: center; align-items: center;
            transition: all 0.12s linear;
        }
        #player { z-index: 10; } #opponent { z-index: 9; }
        #player.me { animation: pulse-me 1.5s infinite; }
        @keyframes pulse-me {
            0% { box-shadow: 0 0 12px 3px rgba(66, 133, 244, 0.9); }
            50% { box-shadow: 0 0 18px 6px rgba(66, 133, 244, 0.5); }
            100% { box-shadow: 0 0 12px 3px rgba(66, 133, 244, 0.9); }
        }
        #goal { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        #controls { width: 100%; padding-block: 10px; padding-bottom: max(15px, env(safe-area-inset-bottom)); flex-shrink: 0; }
        #controls .button-row { display: flex; justify-content: center; align-items: center; margin-top: 5px; }
        #controls .button-row-bottom { gap: 15px; }
        #controls button {
            width: 60px; height: 60px; border-radius: 50%; border: none; background-color: var(--button-bg);
            color: var(--button-text); font-size: 24px; font-weight: bold; cursor: pointer; box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        #controls button:active { transform: scale(0.95); background-color: var(--button-hover); }
        .menu-btn {
            width: 100%; max-width: 300px; padding: 15px; font-size: 1.2em; font-weight: bold;
            border-radius: 12px; border: none; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        .menu-btn:active { transform: scale(0.98); }
        .menu-btn.primary { background-color: var(--button-bg); color: var(--button-text); }
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center;
        }
        .overlay > div { padding: 20px; }
        #waiting-overlay { background-color: rgba(0, 0, 0, 0.7); }
        #start-countdown { font-size: 2.5em; font-weight: bold; }
        .spinner { margin: 20px auto; border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #round-over-overlay, #game-over-overlay { background-color: rgba(0, 0, 0, 0.8); }
        .result-message { font-size: 3em; font-weight: bold; margin-bottom: 15px; }
        .score-info { font-size: 1.5em; }
        #game-over-message { font-size: 4em; font-weight: bold; margin-bottom: 30px; }
        #game-over-buttons { display: flex; gap: 15px; }
    </style>
</head>
<body>
    <div id="game-over-overlay" class="overlay" style="display: none;">
        <div>
            <h2 id="game-over-message"></h2>
            <div id="game-over-buttons">
                <button id="rematch-btn" class="menu-btn">다시 하기</button>
                <button id="lobby-btn" class="menu-btn primary">로비로</button>
            </div>
        </div>
    </div>
    <div id="round-over-overlay" class="overlay" style="display: none;">
        <div> <h2 class="result-message" id="round-result-message"></h2> <p class="score-info" id="round-score-info"></p> </div>
    </div>
    <div id="waiting-overlay" class="overlay" style="display: none;">
        <div>
            <h2><div class="spinner"></div></h2>
            <p id="start-countdown">잠시만 기다려주세요...</p>
        </div>
    </div>
   
    <div id="game-wrapper">
        <div id="game-header"> <div id="score-board" style="display: none;"></div> </div>
        <div id="game-container">
            <div id="maze">
                <div id="player"></div> <div id="opponent" style="display: none;"></div>
            </div>
        </div>
        <div id="controls">
            <div class="button-row"> <button id="up">▲</button> </div>
            <div class="button-row button-row-bottom">
                <button id="left">◀</button> <button id="down">▼</button> <button id="right">▶</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const firebaseConfig = {
            apiKey: "AIzaSyCmNAKmgF_L3o0QyOGh_oFAq_rMRtUyklw", authDomain: "goodluck-7c14b.firebaseapp.com",
            databaseURL: "https://goodluck-7c14b-default-rtdb.firebaseio.com", projectId: "goodluck-7c14b",
            storageBucket: "goodluck-7c14b.firebasestorage.app", messagingSenderId: "858281658455",
            appId: "1:858281658455:web:9131280a459be983933b12"
        };
        firebase.initializeApp(firebaseConfig);

        const database = firebase.database();
        // ▼ 데이터 경로를 'memoryGameRooms'에서 'mazeGameRooms'로 변경하는 것이 좋지만,
        //    우선은 통합 로비를 사용하므로 그대로 둡니다.
        const gameRoomsRef = database.ref('memoryGameRooms');
        const playersRef = database.ref('users');

        async function updatePlayerStats(playerId, isWinner) {
            const playerStatRef = playersRef.child(playerId);
            try {
                await playerStatRef.transaction(currentData => {
                    if (currentData) {
                        if (!currentData.stats) currentData.stats = {};
                        if (!currentData.stats.mazeGame) currentData.stats.mazeGame = { wins: 0, losses: 0 };
                        
                        if (isWinner) {
                            currentData.stats.mazeGame.wins++;
                            currentData.exp = (currentData.exp || 0) + 70; // 미로찾기 승리 경험치
                        } else {
                            currentData.stats.mazeGame.losses++;
                            currentData.exp = (currentData.exp || 0) + 20; // 미로찾기 패배 경험치
                        }
                        
                        let expForNextLevel = (currentData.level || 1) * 100;
                        while (currentData.exp >= expForNextLevel) {
                            currentData.level++;
                            currentData.exp -= expForNextLevel;
                            expForNextLevel = currentData.level * 100;
                        }
                    }
                    return currentData;
                });
            } catch (error) { console.error("전적 업데이트 실패:", error); }
        }

        const gameWrapper = document.getElementById('game-wrapper'),
              mazeContainer = document.getElementById('maze'), 
              player = document.getElementById('player'), 
              opponent = document.getElementById('opponent'),
              waitingOverlay = document.getElementById('waiting-overlay'),
              startCountdownEl = document.getElementById('start-countdown'), 
              gameOverOverlay = document.getElementById('game-over-overlay'),
              gameOverMessageEl = document.getElementById('game-over-message'), 
              lobbyBtn = document.getElementById('lobby-btn'),
              rematchBtn = document.getElementById('rematch-btn'), 
              roundOverOverlay = document.getElementById('round-over-overlay'),
              roundResultMessageEl = document.getElementById('round-result-message'), 
              roundScoreInfoEl = document.getElementById('round-score-info'),
              scoreBoard = document.getElementById('score-board');

        const animalEmojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵'];
        const colorThemes = [
            { '--bg-color': '#f0f2f5', '--wall-color': '#34495e', '--path-color': '#ecf0f1', '--button-bg': '#2c3e50' },
            { '--bg-color': '#e8f5e9', '--wall-color': '#2e7d32', '--path-color': '#c8e6c9', '--button-bg': '#1b5e20' },
            { '--bg-color': '#e3f2fd', '--wall-color': '#0d47a1', '--path-color': '#bbdefb', '--button-bg': '#1565c0' }
        ];

        let myPlayerId, opponentId, roomRef, currentRoomData, myAvatar;
        let playerPos = { x: 0, y: 0 }, goalPos = { x: 0, y: 0 }, cellSize = 0, mazeLayout = [], mazeRows, mazeCols;
        let isHost = false, moveInterval = null, isCountingDown = false;

        function getPlayerId() {
            let id = localStorage.getItem('myPlayerId');
            if (!id) {
                alert("플레이어 정보가 없습니다. 메인 메뉴로 돌아갑니다.");
                window.location.href = 'index.html';
                return null;
            }
            myAvatar = localStorage.getItem('userAvatar'); // 아바타 정보도 가져옵니다.
            return id;
        }

        // --- ▼▼▼ 스크립트 시작 로직 수정 ▼▼▼ ---
        myPlayerId = getPlayerId();
        if (myPlayerId) {
            const startMode = localStorage.getItem('startMode');
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('roomId');
            
            localStorage.removeItem('startMode'); // 확인 후 바로 삭제

            if (startMode === 'single') {
                // 혼자 하기 모드
                startSinglePlayerCountdown();
            } else if (roomId) {
                // 같이 하기 모드
                roomRef = gameRoomsRef.child(roomId);
                roomRef.child('hostId').once('value', (snapshot) => {
                    isHost = snapshot.val() === myPlayerId;
                    listenToRoomChanges();
                });
            } else {
                // 비정상 접근 시 index로
                window.location.href = 'index.html';
            }
        }
        
        // --- ▼▼▼ 혼자 하기 관련 함수 추가 ▼▼▼ ---
        function startSinglePlayerCountdown() {
            gameWrapper.style.display = 'none';
            waitingOverlay.style.display = 'flex';
            let count = 3;
            startCountdownEl.textContent = count;
            
            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    startCountdownEl.textContent = count;
                } else {
                    clearInterval(interval);
                    waitingOverlay.style.display = 'none';
                    startSinglePlayerGame();
                }
            }, 1000);
        }

        function startSinglePlayerGame() {
            gameWrapper.style.display = 'flex';
            initializeGame(); // 인자 없이 호출하여 솔로 플레이 게임 생성
        }
        // --- ▲▲▲ 혼자 하기 관련 함수 추가 끝 ▲▲▲ ---

        lobbyBtn.addEventListener('click', () => { 
            if (isHost && roomRef) { roomRef.remove(); }
            window.location.href = '메모리게임.html';
        });
        
        rematchBtn.addEventListener('click', () => {
            if(roomRef) roomRef.child('players/' + myPlayerId).update({ wantsRematch: true });
            rematchBtn.textContent = "상대방 기다리는 중...";
            rematchBtn.disabled = true;
        });

        function listenToRoomChanges() {
            // (이하 멀티플레이 로직은 기존과 동일)
            roomRef.on('value', (snapshot) => {
                currentRoomData = snapshot.val();
                if (!currentRoomData || !currentRoomData.players || !currentRoomData.players[myPlayerId]) {
                    alert("방과의 연결이 끊겼습니다. 로비로 돌아갑니다.");
                    window.location.href = '메모리게임.html';
                    return;
                }
                const players = currentRoomData.players;
                const playerCount = Object.keys(players).length;
                opponentId = Object.keys(players).find(pid => pid !== myPlayerId);

                if (currentRoomData.scores && opponentId && players[myPlayerId] && players[opponentId] && scoreBoard.style.display === 'block') {
                    const myAvatar = players[myPlayerId].avatar;
                    const opponentAvatar = players[opponentId].avatar;
                    scoreBoard.textContent = `${myAvatar} ${currentRoomData.scores[myPlayerId] || 0} : ${currentRoomData.scores[opponentId] || 0} ${opponentAvatar}`;
                }

                switch(currentRoomData.gameState) {
                    case 'waiting':
                        waitingOverlay.style.display = 'flex';
                        gameWrapper.style.display = 'none';
                        break;
                    case 'ready': 
                        startCountdown(currentRoomData); 
                        break;
                    case 'playing': 
                        roundOverOverlay.style.display = 'none'; 
                        updateAllPlayerPositions(players); 
                        break;
                    case 'roundOver': 
                        showRoundResult(currentRoomData); 
                        break;
                    case 'gameOver':
                        if (isHost && currentRoomData.gameWinner) {
                            const winnerId = currentRoomData.gameWinner;
                            const loserId = Object.keys(players).find(pId => pId !== winnerId);
                            if (loserId) {
                                updatePlayerStats(winnerId, true);
                                updatePlayerStats(loserId, false);
                            }
                        }
                        showGameOverScreen(currentRoomData.gameWinner === myPlayerId);
                        break;
                    case 'rematch':
                        if(isHost) {
                            const newMaze = generateMaze(mazeRows, mazeCols); placeStartAndGoal(newMaze);
                            const newScores = {[myPlayerId]: 0, [opponentId]: 0};
                            const resetPlayers = players;
                            for(const pid in resetPlayers) { if(resetPlayers[pid]) resetPlayers[pid].wantsRematch = null; }
                            roomRef.update({ mazeLayout: newMaze, scores: newScores, players: resetPlayers, gameState: 'ready', roundWinner: null, gameWinner: null });
                        }
                        break;
                }
            });
        }

        function startCountdown(roomData) {
            if (isCountingDown) return;
            isCountingDown = true;
            gameOverOverlay.style.display = 'none';
            roundOverOverlay.style.display = 'none';

            const isFinal = (roomData.scores[myPlayerId] === 1 && roomData.scores[opponentId] === 1);
            let count = 3;
            startCountdownEl.innerHTML = isFinal ? "🔥 마지막 라운드! 🔥" : `곧 시작합니다!`;
            waitingOverlay.style.display = 'flex';

            setTimeout(() => {
                const interval = setInterval(() => {
                    if (count > 0) { startCountdownEl.textContent = count; }
                    else {
                        clearInterval(interval);
                        waitingOverlay.style.display = 'none'; gameWrapper.style.display = 'flex';
                        initializeGame(roomData, true);
                        isCountingDown = false;
                    }
                    count--;
                }, 1000);
            }, 1000);
        }

        function updateAllPlayerPositions(players) {
            if(!players) return;
            for (const pid in players) {
                const pData = players[pid];
                const element = (pid === myPlayerId) ? player : opponent;
                if (!element || !pData) continue;
                element.style.display = 'flex'; element.textContent = pData.avatar;
                element.style.left = `${pData.x * cellSize + (cellSize * 0.05)}px`;
                element.style.top = `${pData.y * cellSize + (cellSize * 0.05)}px`;
            }
        }

        function showRoundResult(roomData) {
            const winnerId = roomData.roundWinner;
            if (!winnerId || !roomData.players || !roomData.players[winnerId]) return;
            const winnerAvatar = roomData.players[winnerId].avatar;
            roundResultMessageEl.innerHTML = `${winnerAvatar}님이<br>승리했습니다!`;
            roundScoreInfoEl.textContent = `현재 점수 ${roomData.scores[myPlayerId] || 0} : ${roomData.scores[opponentId] || 0}`;
            roundOverOverlay.style.display = 'flex';

            if(isHost) {
                setTimeout(() => {
                    const scores = { ...roomData.scores };
                    scores[winnerId] = (scores[winnerId] || 0) + 1;
                    if (scores[winnerId] >= 2) {
                        roomRef.update({ gameState: 'gameOver', gameWinner: winnerId });
                    } else {
                        const newMaze = generateMaze(mazeRows, mazeCols);
                        placeStartAndGoal(newMaze);
                        roomRef.update({ mazeLayout: newMaze, scores: scores, gameState: 'ready', roundWinner: null });
                    }
                }, 1500);
            }
        }
        
        function showGameOverScreen(didIWin) {
            roundOverOverlay.style.display = 'none';
            gameOverMessageEl.textContent = didIWin ? "🎉 최종 승리! 🎉" : "😭 최종 패배! 😭";
            rematchBtn.textContent = '다시 하기'; rematchBtn.disabled = false;
            gameOverOverlay.style.display = 'flex';
        }

        function initializeGame(roomDataOrNull = null, changeTheme = true) {
            roundOverOverlay.style.display = 'none';
            player.classList.remove('me');

            if (changeTheme) {
                const randomTheme = colorThemes[Math.floor(Math.random() * colorThemes.length)];
                for (const colorVar in randomTheme) { document.documentElement.style.setProperty(colorVar, randomTheme[colorVar]); }
            }

            if(roomDataOrNull) {
                mazeLayout = roomDataOrNull.mazeLayout; mazeRows = mazeLayout.length; mazeCols = mazeLayout[0].length;
                scoreBoard.style.display = 'block'; opponent.style.display = 'flex'; player.classList.add('me');
            } else {
                mazeRows = 21; mazeCols = 15;
                mazeLayout = generateMaze(mazeRows, mazeCols); placeStartAndGoal(mazeLayout);
                scoreBoard.style.display = 'none'; opponent.style.display = 'none';
            }

            for (let y = 0; y < mazeRows; y++) {
                for (let x = 0; x < mazeCols; x++) {
                    if (mazeLayout[y][x] === 'S') { playerPos = { x, y }; }
                    else if (mazeLayout[y][x] === 'G') { goalPos = { x, y }; }
                }
            }

            drawMapAndPlayers();

            if (roomDataOrNull) {
                const players = roomDataOrNull.players;
                if(isHost) {
                    const updatedPlayers = { ...players };
                    for(const pid in updatedPlayers) {
                        if(updatedPlayers[pid]) {
                            updatedPlayers[pid].x = playerPos.x; updatedPlayers[pid].y = playerPos.y;
                        }
                    }
                    if (currentRoomData.gameState !== 'playing') {
                        roomRef.update({ players: updatedPlayers, gameState: 'playing' });
                    }
                }
            } else {
                 player.textContent = myAvatar || animalEmojis[Math.floor(Math.random() * animalEmojis.length)];
                 updatePlayerPosition();
            }
        }
        
        function drawMapAndPlayers() {
            mazeContainer.innerHTML = '';
            cellSize = Math.min(mazeContainer.offsetWidth / mazeCols, mazeContainer.offsetHeight / mazeRows);
            mazeContainer.style.gridTemplateColumns = `repeat(${mazeCols}, ${cellSize}px)`;
            mazeContainer.style.gridTemplateRows = `repeat(${mazeRows}, ${cellSize}px)`;
            mazeContainer.style.margin = 'auto';

            for (let y = 0; y < mazeRows; y++) {
                for (let x = 0; x < mazeCols; x++) {
                    const cell = document.createElement('div');
                    cell.style.cssText = `grid-column: ${x + 1}; grid-row: ${y + 1};`;
                    if (mazeLayout[y][x] === 1) cell.className = 'wall';
                    mazeContainer.appendChild(cell);
                }
            }
            const goalElement = document.createElement('div');
            goalElement.id = 'goal'; goalElement.textContent = '🏠';
            goalElement.style.cssText = `width:${cellSize}px; height:${cellSize}px; font-size:${cellSize*0.8}px; left:${goalPos.x*cellSize}px; top:${goalPos.y*cellSize}px;`;
            mazeContainer.appendChild(goalElement);

            [player, opponent].forEach(el => {
                mazeContainer.appendChild(el);
                el.style.width = `${cellSize * 0.9}px`; el.style.height = `${cellSize * 0.9}px`;
                el.style.fontSize = `${cellSize * 0.7}px`;
            });
            if (currentRoomData && currentRoomData.players) { updateAllPlayerPositions(currentRoomData.players); }
            else { updatePlayerPosition(); }
        }

        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                if (roomRef && roomRef.child('players/' + myPlayerId)) {
                    roomRef.child('players/' + myPlayerId).update({ x: newX, y: newY });
                }
                if (newX === goalPos.x && newY === goalPos.y) {
                    if (roomRef) {
                        roomRef.child('gameState').once('value', (gs) => { if(gs.val() === 'playing') roomRef.update({ gameState: 'roundOver', roundWinner: myPlayerId }); });
                    }
                }
            }
        }

        function soloMove(dx, dy) {
            const newX = playerPos.x + dx; const newY = playerPos.y + dy;
            if (newY >= 0 && newY < mazeRows && newX >= 0 && newX < mazeCols && mazeLayout[newY][newX] !== 1) {
                playerPos.x = newX; playerPos.y = newY;
                updatePlayerPosition();
                if (newX === goalPos.x && newY === goalPos.y) {

                    gameOverMessageEl.textContent = '도착!';
                    
                    // '다시 하기' 버튼을 보이게 하고 기능 설정
                    rematchBtn.style.display = 'block';
                    rematchBtn.textContent = '다시하기';
                    rematchBtn.onclick = () => {
                        gameOverOverlay.style.display = 'none';
                        startSinglePlayerGame(); // 새 게임 시작 함수 호출
                    };

lobbyBtn.textContent = '메인으로';
                    lobbyBtn.onclick = () => { 
                        // 👇 index.html로 돌아가기 전, 세션에 기록을 남깁니다.
                        sessionStorage.setItem('returnFromGame', 'true');
                        window.location.href = 'index.html'; 
                    };
                    
                    gameOverOverlay.style.display = 'flex';
                }
            }
        }

        function updatePlayerPosition() { player.style.left = `${playerPos.x * cellSize + (cellSize * 0.05)}px`; player.style.top = `${playerPos.y * cellSize + (cellSize * 0.05)}px`; }
        
        function startMoving(dx, dy) {
            stopMoving(); 
            // ▼ roomId가 있는지 여부로 솔로/멀티 구분
            const moveFn = new URLSearchParams(window.location.search).get('roomId') ? movePlayer : soloMove;
            moveFn(dx, dy); 
            moveInterval = setInterval(() => moveFn(dx, dy), 120);
        }

        function stopMoving() { clearInterval(moveInterval); }

        ['up', 'down', 'left', 'right'].forEach(dir => {
            const btn = document.getElementById(dir); let dx = 0, dy = 0;
            if (dir === 'up') dy = -1; if (dir === 'down') dy = 1;
            if (dir === 'left') dx = -1; if (dir === 'right') dx = 1;
            btn.addEventListener('mousedown', () => startMoving(dx, dy));
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); startMoving(dx, dy); });
        });
        document.addEventListener('mouseup', stopMoving); document.addEventListener('touchend', stopMoving);

        let keyHeld = {};
        window.addEventListener('keydown', (e) => {
            if (keyHeld[e.key] || !gameWrapper.style.display || gameWrapper.style.display === 'none') return;
            keyHeld[e.key] = true;
            switch (e.key) {
                case 'ArrowUp': startMoving(0, -1); break; case 'ArrowDown': startMoving(0, 1); break;
                case 'ArrowLeft': startMoving(-1, 0); break; case 'ArrowRight': startMoving(1, 0); break;
            }
        });
        window.addEventListener('keyup', (e) => { keyHeld[e.key] = false; stopMoving(); });

        function placeStartAndGoal(layout) { const topRowPaths = []; for (let i = 0; i < layout[1].length; i++) { if (layout[1][i] === 0) topRowPaths.push(i); } const startX = topRowPaths[Math.floor(Math.random() * topRowPaths.length)]; layout[1][startX] = 'S'; const bottomRowPaths = []; const bottomRowIndex = layout.length - 2; for (let i = 0; i < layout[bottomRowIndex].length; i++) { if (layout[bottomRowIndex][i] === 0) bottomRowPaths.push(i); } const goalX = bottomRowPaths[Math.floor(Math.random() * bottomRowPaths.length)]; layout[bottomRowIndex][goalX] = 'G'; }
        
        function generateMaze(rows, cols) {
            rows = rows % 2 === 0 ? rows + 1 : rows; cols = cols % 2 === 0 ? cols + 1 : cols;
            const maze = Array(rows).fill(null).map(() => Array(cols).fill(1));
            const stack = []; const startX = 1, startY = 1;
            maze[startY][startX] = 0; stack.push([startX, startY]);
            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1]; const directions = [];
                if (cy - 2 >= 1 && maze[cy - 2][cx] === 1) directions.push('N');
                if (cy + 2 < rows - 1 && maze[cy + 2][cx] === 1) directions.push('S');
                if (cx - 2 >= 1 && maze[cy][cx - 2] === 1) directions.push('W');
                if (cx + 2 < cols - 1 && maze[cy][cx + 2] === 1) directions.push('E');
                if (directions.length > 0) {
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    let nx = cx, ny = cy;
                    switch (dir) {
                        case 'N': ny -= 2; maze[cy - 1][cx] = 0; break;
                        case 'S': ny += 2; maze[cy + 1][cx] = 0; break;
                        case 'W': nx -= 2; maze[cy][cx - 1] = 0; break;
                        case 'E': nx += 2; maze[cy][cx + 1] = 0; break;
                    }
                    maze[ny][nx] = 0; stack.push([nx, ny]);
                } else { stack.pop(); }
            }
            const removalCount = Math.floor(rows * cols * 0.05);
            for (let i = 0; i < removalCount; i++) {
                const rx = Math.floor(Math.random() * (cols - 2)) + 1;
                const ry = Math.floor(Math.random() * (rows - 2)) + 1;
                if (maze[ry][rx] === 1) { maze[ry][rx] = 0; }
            }
            return maze;
        }

        window.addEventListener('resize', () => { if (gameWrapper.style.display === 'flex') { drawMapAndPlayers(); } });
    });
</script>
</body>
</html>